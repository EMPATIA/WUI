/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b="length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){
return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ba=/<([\w:]+)/,ca=/<|&#?\w+;/,da=/<(?:script|style|link)/i,ea=/checked\s*(?:[^=]|=\s*.checked.)/i,fa=/^$|\/(?:java|ecma)script/i,ga=/^true\/(.*)/,ha=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ia={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function ka(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,"script"),g.length>0&&ma(g,!i&&oa(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement("div")),g=(ba.exec(e)||["",""])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),"script"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(aa,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,"script"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),"none"!==c&&c||(qa=(qa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp("^("+Q+")(.*)$","i"),Ba=new RegExp("^([+-])=("+Q+")","i"),Ca={position:"absolute",visibility:"hidden",display:"block"},Da={letterSpacing:"0",fontWeight:"400"},Ea=["Webkit","O","Moz","ms"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Ha(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ia(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?"border":"content"),d,f)+"px"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",ta(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),"normal"===e&&b in Da&&(e=Da[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pa=/queueHooks$/,Qa=[Va],Ra={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||ta(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?ta(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta("show"),slideUp:Ta("hide"),slideToggle:Ta("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),
void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ab," ").indexOf(b)>=0)return!0;return!1}});var bb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cb=n.now(),db=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \t]*([^\r\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\/\//,kb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lb={},mb={},nb="*/".concat("*"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:"GET",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+"").replace(eb,"").replace(jb,pb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pb[3]||("http:"===pb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,"$1_="+cb++):d+(db.test(d)?"&":"?")+"_="+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nb+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&").replace(vb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&"withCredentials"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cb[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fb.pop()||n.expando+"_"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,"$1"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});

/*!
 DataTables 1.10.15
 ©2008-2017 SpryMedia Ltd - datatables.net/license
*/
(function(h){"function"===typeof define&&define.amd?define(["jquery"],function(E){return h(E,window,document)}):"object"===typeof exports?module.exports=function(E,H){E||(E=window);H||(H="undefined"!==typeof window?require("jquery"):require("jquery")(E));return h(H,E,E.document)}:h(jQuery,window,document)})(function(h,E,H,k){function Y(a){var b,c,d={};h.each(a,function(e){if((b=e.match(/^([^A-Z]+?)([A-Z])/))&&-1!=="a aa ai ao as b fn i m o s ".indexOf(b[1]+" "))c=e.replace(b[0],b[2].toLowerCase()),
d[c]=e,"o"===b[1]&&Y(a[e])});a._hungarianMap=d}function J(a,b,c){a._hungarianMap||Y(a);var d;h.each(b,function(e){d=a._hungarianMap[e];if(d!==k&&(c||b[d]===k))"o"===d.charAt(0)?(b[d]||(b[d]={}),h.extend(!0,b[d],b[e]),J(a[d],b[d],c)):b[d]=b[e]})}function Fa(a){var b=m.defaults.oLanguage,c=a.sZeroRecords;!a.sEmptyTable&&(c&&"No data available in table"===b.sEmptyTable)&&F(a,a,"sZeroRecords","sEmptyTable");!a.sLoadingRecords&&(c&&"Loading..."===b.sLoadingRecords)&&F(a,a,"sZeroRecords","sLoadingRecords");
a.sInfoThousands&&(a.sThousands=a.sInfoThousands);(a=a.sDecimal)&&fb(a)}function gb(a){A(a,"ordering","bSort");A(a,"orderMulti","bSortMulti");A(a,"orderClasses","bSortClasses");A(a,"orderCellsTop","bSortCellsTop");A(a,"order","aaSorting");A(a,"orderFixed","aaSortingFixed");A(a,"paging","bPaginate");A(a,"pagingType","sPaginationType");A(a,"pageLength","iDisplayLength");A(a,"searching","bFilter");"boolean"===typeof a.sScrollX&&(a.sScrollX=a.sScrollX?"100%":"");"boolean"===typeof a.scrollX&&(a.scrollX=
a.scrollX?"100%":"");if(a=a.aoSearchCols)for(var b=0,c=a.length;b<c;b++)a[b]&&J(m.models.oSearch,a[b])}function hb(a){A(a,"orderable","bSortable");A(a,"orderData","aDataSort");A(a,"orderSequence","asSorting");A(a,"orderDataType","sortDataType");var b=a.aDataSort;"number"===typeof b&&!h.isArray(b)&&(a.aDataSort=[b])}function ib(a){if(!m.__browser){var b={};m.__browser=b;var c=h("<div/>").css({position:"fixed",top:0,left:-1*h(E).scrollLeft(),height:1,width:1,overflow:"hidden"}).append(h("<div/>").css({position:"absolute",
top:1,left:1,width:100,overflow:"scroll"}).append(h("<div/>").css({width:"100%",height:10}))).appendTo("body"),d=c.children(),e=d.children();b.barWidth=d[0].offsetWidth-d[0].clientWidth;b.bScrollOversize=100===e[0].offsetWidth&&100!==d[0].clientWidth;b.bScrollbarLeft=1!==Math.round(e.offset().left);b.bBounding=c[0].getBoundingClientRect().width?!0:!1;c.remove()}h.extend(a.oBrowser,m.__browser);a.oScroll.iBarWidth=m.__browser.barWidth}function jb(a,b,c,d,e,f){var g,j=!1;c!==k&&(g=c,j=!0);for(;d!==
e;)a.hasOwnProperty(d)&&(g=j?b(g,a[d],d,a):a[d],j=!0,d+=f);return g}function Ga(a,b){var c=m.defaults.column,d=a.aoColumns.length,c=h.extend({},m.models.oColumn,c,{nTh:b?b:H.createElement("th"),sTitle:c.sTitle?c.sTitle:b?b.innerHTML:"",aDataSort:c.aDataSort?c.aDataSort:[d],mData:c.mData?c.mData:d,idx:d});a.aoColumns.push(c);c=a.aoPreSearchCols;c[d]=h.extend({},m.models.oSearch,c[d]);la(a,d,h(b).data())}function la(a,b,c){var b=a.aoColumns[b],d=a.oClasses,e=h(b.nTh);if(!b.sWidthOrig){b.sWidthOrig=
e.attr("width")||null;var f=(e.attr("style")||"").match(/width:\s*(\d+[pxem%]+)/);f&&(b.sWidthOrig=f[1])}c!==k&&null!==c&&(hb(c),J(m.defaults.column,c),c.mDataProp!==k&&!c.mData&&(c.mData=c.mDataProp),c.sType&&(b._sManualType=c.sType),c.className&&!c.sClass&&(c.sClass=c.className),h.extend(b,c),F(b,c,"sWidth","sWidthOrig"),c.iDataSort!==k&&(b.aDataSort=[c.iDataSort]),F(b,c,"aDataSort"));var g=b.mData,j=R(g),i=b.mRender?R(b.mRender):null,c=function(a){return"string"===typeof a&&-1!==a.indexOf("@")};
b._bAttrSrc=h.isPlainObject(g)&&(c(g.sort)||c(g.type)||c(g.filter));b._setter=null;b.fnGetData=function(a,b,c){var d=j(a,b,k,c);return i&&b?i(d,b,a,c):d};b.fnSetData=function(a,b,c){return S(g)(a,b,c)};"number"!==typeof g&&(a._rowReadObject=!0);a.oFeatures.bSort||(b.bSortable=!1,e.addClass(d.sSortableNone));a=-1!==h.inArray("asc",b.asSorting);c=-1!==h.inArray("desc",b.asSorting);!b.bSortable||!a&&!c?(b.sSortingClass=d.sSortableNone,b.sSortingClassJUI=""):a&&!c?(b.sSortingClass=d.sSortableAsc,b.sSortingClassJUI=
d.sSortJUIAscAllowed):!a&&c?(b.sSortingClass=d.sSortableDesc,b.sSortingClassJUI=d.sSortJUIDescAllowed):(b.sSortingClass=d.sSortable,b.sSortingClassJUI=d.sSortJUI)}function Z(a){if(!1!==a.oFeatures.bAutoWidth){var b=a.aoColumns;Ha(a);for(var c=0,d=b.length;c<d;c++)b[c].nTh.style.width=b[c].sWidth}b=a.oScroll;(""!==b.sY||""!==b.sX)&&ma(a);s(a,null,"column-sizing",[a])}function $(a,b){var c=na(a,"bVisible");return"number"===typeof c[b]?c[b]:null}function aa(a,b){var c=na(a,"bVisible"),c=h.inArray(b,
c);return-1!==c?c:null}function ba(a){var b=0;h.each(a.aoColumns,function(a,d){d.bVisible&&"none"!==h(d.nTh).css("display")&&b++});return b}function na(a,b){var c=[];h.map(a.aoColumns,function(a,e){a[b]&&c.push(e)});return c}function Ia(a){var b=a.aoColumns,c=a.aoData,d=m.ext.type.detect,e,f,g,j,i,h,l,q,r;e=0;for(f=b.length;e<f;e++)if(l=b[e],r=[],!l.sType&&l._sManualType)l.sType=l._sManualType;else if(!l.sType){g=0;for(j=d.length;g<j;g++){i=0;for(h=c.length;i<h;i++){r[i]===k&&(r[i]=B(a,i,e,"type"));
q=d[g](r[i],a);if(!q&&g!==d.length-1)break;if("html"===q)break}if(q){l.sType=q;break}}l.sType||(l.sType="string")}}function kb(a,b,c,d){var e,f,g,j,i,n,l=a.aoColumns;if(b)for(e=b.length-1;0<=e;e--){n=b[e];var q=n.targets!==k?n.targets:n.aTargets;h.isArray(q)||(q=[q]);f=0;for(g=q.length;f<g;f++)if("number"===typeof q[f]&&0<=q[f]){for(;l.length<=q[f];)Ga(a);d(q[f],n)}else if("number"===typeof q[f]&&0>q[f])d(l.length+q[f],n);else if("string"===typeof q[f]){j=0;for(i=l.length;j<i;j++)("_all"==q[f]||h(l[j].nTh).hasClass(q[f]))&&
d(j,n)}}if(c){e=0;for(a=c.length;e<a;e++)d(e,c[e])}}function N(a,b,c,d){var e=a.aoData.length,f=h.extend(!0,{},m.models.oRow,{src:c?"dom":"data",idx:e});f._aData=b;a.aoData.push(f);for(var g=a.aoColumns,j=0,i=g.length;j<i;j++)g[j].sType=null;a.aiDisplayMaster.push(e);b=a.rowIdFn(b);b!==k&&(a.aIds[b]=f);(c||!a.oFeatures.bDeferRender)&&Ja(a,e,c,d);return e}function oa(a,b){var c;b instanceof h||(b=h(b));return b.map(function(b,e){c=Ka(a,e);return N(a,c.data,e,c.cells)})}function B(a,b,c,d){var e=a.iDraw,
f=a.aoColumns[c],g=a.aoData[b]._aData,j=f.sDefaultContent,i=f.fnGetData(g,d,{settings:a,row:b,col:c});if(i===k)return a.iDrawError!=e&&null===j&&(K(a,0,"Requested unknown parameter "+("function"==typeof f.mData?"{function}":"'"+f.mData+"'")+" for row "+b+", column "+c,4),a.iDrawError=e),j;if((i===g||null===i)&&null!==j&&d!==k)i=j;else if("function"===typeof i)return i.call(g);return null===i&&"display"==d?"":i}function lb(a,b,c,d){a.aoColumns[c].fnSetData(a.aoData[b]._aData,d,{settings:a,row:b,col:c})}
function La(a){return h.map(a.match(/(\\.|[^\.])+/g)||[""],function(a){return a.replace(/\\\./g,".")})}function R(a){if(h.isPlainObject(a)){var b={};h.each(a,function(a,c){c&&(b[a]=R(c))});return function(a,c,f,g){var j=b[c]||b._;return j!==k?j(a,c,f,g):a}}if(null===a)return function(a){return a};if("function"===typeof a)return function(b,c,f,g){return a(b,c,f,g)};if("string"===typeof a&&(-1!==a.indexOf(".")||-1!==a.indexOf("[")||-1!==a.indexOf("("))){var c=function(a,b,f){var g,j;if(""!==f){j=La(f);
for(var i=0,n=j.length;i<n;i++){f=j[i].match(ca);g=j[i].match(V);if(f){j[i]=j[i].replace(ca,"");""!==j[i]&&(a=a[j[i]]);g=[];j.splice(0,i+1);j=j.join(".");if(h.isArray(a)){i=0;for(n=a.length;i<n;i++)g.push(c(a[i],b,j))}a=f[0].substring(1,f[0].length-1);a=""===a?g:g.join(a);break}else if(g){j[i]=j[i].replace(V,"");a=a[j[i]]();continue}if(null===a||a[j[i]]===k)return k;a=a[j[i]]}}return a};return function(b,e){return c(b,e,a)}}return function(b){return b[a]}}function S(a){if(h.isPlainObject(a))return S(a._);
if(null===a)return function(){};if("function"===typeof a)return function(b,d,e){a(b,"set",d,e)};if("string"===typeof a&&(-1!==a.indexOf(".")||-1!==a.indexOf("[")||-1!==a.indexOf("("))){var b=function(a,d,e){var e=La(e),f;f=e[e.length-1];for(var g,j,i=0,n=e.length-1;i<n;i++){g=e[i].match(ca);j=e[i].match(V);if(g){e[i]=e[i].replace(ca,"");a[e[i]]=[];f=e.slice();f.splice(0,i+1);g=f.join(".");if(h.isArray(d)){j=0;for(n=d.length;j<n;j++)f={},b(f,d[j],g),a[e[i]].push(f)}else a[e[i]]=d;return}j&&(e[i]=e[i].replace(V,
""),a=a[e[i]](d));if(null===a[e[i]]||a[e[i]]===k)a[e[i]]={};a=a[e[i]]}if(f.match(V))a[f.replace(V,"")](d);else a[f.replace(ca,"")]=d};return function(c,d){return b(c,d,a)}}return function(b,d){b[a]=d}}function Ma(a){return D(a.aoData,"_aData")}function pa(a){a.aoData.length=0;a.aiDisplayMaster.length=0;a.aiDisplay.length=0;a.aIds={}}function qa(a,b,c){for(var d=-1,e=0,f=a.length;e<f;e++)a[e]==b?d=e:a[e]>b&&a[e]--; -1!=d&&c===k&&a.splice(d,1)}function da(a,b,c,d){var e=a.aoData[b],f,g=function(c,d){for(;c.childNodes.length;)c.removeChild(c.firstChild);
c.innerHTML=B(a,b,d,"display")};if("dom"===c||(!c||"auto"===c)&&"dom"===e.src)e._aData=Ka(a,e,d,d===k?k:e._aData).data;else{var j=e.anCells;if(j)if(d!==k)g(j[d],d);else{c=0;for(f=j.length;c<f;c++)g(j[c],c)}}e._aSortData=null;e._aFilterData=null;g=a.aoColumns;if(d!==k)g[d].sType=null;else{c=0;for(f=g.length;c<f;c++)g[c].sType=null;Na(a,e)}}function Ka(a,b,c,d){var e=[],f=b.firstChild,g,j,i=0,n,l=a.aoColumns,q=a._rowReadObject,d=d!==k?d:q?{}:[],r=function(a,b){if("string"===typeof a){var c=a.indexOf("@");
-1!==c&&(c=a.substring(c+1),S(a)(d,b.getAttribute(c)))}},m=function(a){if(c===k||c===i)j=l[i],n=h.trim(a.innerHTML),j&&j._bAttrSrc?(S(j.mData._)(d,n),r(j.mData.sort,a),r(j.mData.type,a),r(j.mData.filter,a)):q?(j._setter||(j._setter=S(j.mData)),j._setter(d,n)):d[i]=n;i++};if(f)for(;f;){g=f.nodeName.toUpperCase();if("TD"==g||"TH"==g)m(f),e.push(f);f=f.nextSibling}else{e=b.anCells;f=0;for(g=e.length;f<g;f++)m(e[f])}if(b=b.firstChild?b:b.nTr)(b=b.getAttribute("id"))&&S(a.rowId)(d,b);return{data:d,cells:e}}
function Ja(a,b,c,d){var e=a.aoData[b],f=e._aData,g=[],j,i,n,l,q;if(null===e.nTr){j=c||H.createElement("tr");e.nTr=j;e.anCells=g;j._DT_RowIndex=b;Na(a,e);l=0;for(q=a.aoColumns.length;l<q;l++){n=a.aoColumns[l];i=c?d[l]:H.createElement(n.sCellType);i._DT_CellIndex={row:b,column:l};g.push(i);if((!c||n.mRender||n.mData!==l)&&(!h.isPlainObject(n.mData)||n.mData._!==l+".display"))i.innerHTML=B(a,b,l,"display");n.sClass&&(i.className+=" "+n.sClass);n.bVisible&&!c?j.appendChild(i):!n.bVisible&&c&&i.parentNode.removeChild(i);
n.fnCreatedCell&&n.fnCreatedCell.call(a.oInstance,i,B(a,b,l),f,b,l)}s(a,"aoRowCreatedCallback",null,[j,f,b])}e.nTr.setAttribute("role","row")}function Na(a,b){var c=b.nTr,d=b._aData;if(c){var e=a.rowIdFn(d);e&&(c.id=e);d.DT_RowClass&&(e=d.DT_RowClass.split(" "),b.__rowc=b.__rowc?sa(b.__rowc.concat(e)):e,h(c).removeClass(b.__rowc.join(" ")).addClass(d.DT_RowClass));d.DT_RowAttr&&h(c).attr(d.DT_RowAttr);d.DT_RowData&&h(c).data(d.DT_RowData)}}function mb(a){var b,c,d,e,f,g=a.nTHead,j=a.nTFoot,i=0===
h("th, td",g).length,n=a.oClasses,l=a.aoColumns;i&&(e=h("<tr/>").appendTo(g));b=0;for(c=l.length;b<c;b++)f=l[b],d=h(f.nTh).addClass(f.sClass),i&&d.appendTo(e),a.oFeatures.bSort&&(d.addClass(f.sSortingClass),!1!==f.bSortable&&(d.attr("tabindex",a.iTabIndex).attr("aria-controls",a.sTableId),Oa(a,f.nTh,b))),f.sTitle!=d[0].innerHTML&&d.html(f.sTitle),Pa(a,"header")(a,d,f,n);i&&ea(a.aoHeader,g);h(g).find(">tr").attr("role","row");h(g).find(">tr>th, >tr>td").addClass(n.sHeaderTH);h(j).find(">tr>th, >tr>td").addClass(n.sFooterTH);
if(null!==j){a=a.aoFooter[0];b=0;for(c=a.length;b<c;b++)f=l[b],f.nTf=a[b].cell,f.sClass&&h(f.nTf).addClass(f.sClass)}}function fa(a,b,c){var d,e,f,g=[],j=[],i=a.aoColumns.length,n;if(b){c===k&&(c=!1);d=0;for(e=b.length;d<e;d++){g[d]=b[d].slice();g[d].nTr=b[d].nTr;for(f=i-1;0<=f;f--)!a.aoColumns[f].bVisible&&!c&&g[d].splice(f,1);j.push([])}d=0;for(e=g.length;d<e;d++){if(a=g[d].nTr)for(;f=a.firstChild;)a.removeChild(f);f=0;for(b=g[d].length;f<b;f++)if(n=i=1,j[d][f]===k){a.appendChild(g[d][f].cell);
for(j[d][f]=1;g[d+i]!==k&&g[d][f].cell==g[d+i][f].cell;)j[d+i][f]=1,i++;for(;g[d][f+n]!==k&&g[d][f].cell==g[d][f+n].cell;){for(c=0;c<i;c++)j[d+c][f+n]=1;n++}h(g[d][f].cell).attr("rowspan",i).attr("colspan",n)}}}}function O(a){var b=s(a,"aoPreDrawCallback","preDraw",[a]);if(-1!==h.inArray(!1,b))C(a,!1);else{var b=[],c=0,d=a.asStripeClasses,e=d.length,f=a.oLanguage,g=a.iInitDisplayStart,j="ssp"==y(a),i=a.aiDisplay;a.bDrawing=!0;g!==k&&-1!==g&&(a._iDisplayStart=j?g:g>=a.fnRecordsDisplay()?0:g,a.iInitDisplayStart=
-1);var g=a._iDisplayStart,n=a.fnDisplayEnd();if(a.bDeferLoading)a.bDeferLoading=!1,a.iDraw++,C(a,!1);else if(j){if(!a.bDestroying&&!nb(a))return}else a.iDraw++;if(0!==i.length){f=j?a.aoData.length:n;for(j=j?0:g;j<f;j++){var l=i[j],q=a.aoData[l];null===q.nTr&&Ja(a,l);l=q.nTr;if(0!==e){var r=d[c%e];q._sRowStripe!=r&&(h(l).removeClass(q._sRowStripe).addClass(r),q._sRowStripe=r)}s(a,"aoRowCallback",null,[l,q._aData,c,j]);b.push(l);c++}}else c=f.sZeroRecords,1==a.iDraw&&"ajax"==y(a)?c=f.sLoadingRecords:
f.sEmptyTable&&0===a.fnRecordsTotal()&&(c=f.sEmptyTable),b[0]=h("<tr/>",{"class":e?d[0]:""}).append(h("<td />",{valign:"top",colSpan:ba(a),"class":a.oClasses.sRowEmpty}).html(c))[0];s(a,"aoHeaderCallback","header",[h(a.nTHead).children("tr")[0],Ma(a),g,n,i]);s(a,"aoFooterCallback","footer",[h(a.nTFoot).children("tr")[0],Ma(a),g,n,i]);d=h(a.nTBody);d.children().detach();d.append(h(b));s(a,"aoDrawCallback","draw",[a]);a.bSorted=!1;a.bFiltered=!1;a.bDrawing=!1}}function T(a,b){var c=a.oFeatures,d=c.bFilter;
c.bSort&&ob(a);d?ga(a,a.oPreviousSearch):a.aiDisplay=a.aiDisplayMaster.slice();!0!==b&&(a._iDisplayStart=0);a._drawHold=b;O(a);a._drawHold=!1}function pb(a){var b=a.oClasses,c=h(a.nTable),c=h("<div/>").insertBefore(c),d=a.oFeatures,e=h("<div/>",{id:a.sTableId+"_wrapper","class":b.sWrapper+(a.nTFoot?"":" "+b.sNoFooter)});a.nHolding=c[0];a.nTableWrapper=e[0];a.nTableReinsertBefore=a.nTable.nextSibling;for(var f=a.sDom.split(""),g,j,i,n,l,q,k=0;k<f.length;k++){g=null;j=f[k];if("<"==j){i=h("<div/>")[0];
n=f[k+1];if("'"==n||'"'==n){l="";for(q=2;f[k+q]!=n;)l+=f[k+q],q++;"H"==l?l=b.sJUIHeader:"F"==l&&(l=b.sJUIFooter);-1!=l.indexOf(".")?(n=l.split("."),i.id=n[0].substr(1,n[0].length-1),i.className=n[1]):"#"==l.charAt(0)?i.id=l.substr(1,l.length-1):i.className=l;k+=q}e.append(i);e=h(i)}else if(">"==j)e=e.parent();else if("l"==j&&d.bPaginate&&d.bLengthChange)g=qb(a);else if("f"==j&&d.bFilter)g=rb(a);else if("r"==j&&d.bProcessing)g=sb(a);else if("t"==j)g=tb(a);else if("i"==j&&d.bInfo)g=ub(a);else if("p"==
j&&d.bPaginate)g=vb(a);else if(0!==m.ext.feature.length){i=m.ext.feature;q=0;for(n=i.length;q<n;q++)if(j==i[q].cFeature){g=i[q].fnInit(a);break}}g&&(i=a.aanFeatures,i[j]||(i[j]=[]),i[j].push(g),e.append(g))}c.replaceWith(e);a.nHolding=null}function ea(a,b){var c=h(b).children("tr"),d,e,f,g,j,i,n,l,q,k;a.splice(0,a.length);f=0;for(i=c.length;f<i;f++)a.push([]);f=0;for(i=c.length;f<i;f++){d=c[f];for(e=d.firstChild;e;){if("TD"==e.nodeName.toUpperCase()||"TH"==e.nodeName.toUpperCase()){l=1*e.getAttribute("colspan");
q=1*e.getAttribute("rowspan");l=!l||0===l||1===l?1:l;q=!q||0===q||1===q?1:q;g=0;for(j=a[f];j[g];)g++;n=g;k=1===l?!0:!1;for(j=0;j<l;j++)for(g=0;g<q;g++)a[f+g][n+j]={cell:e,unique:k},a[f+g].nTr=d}e=e.nextSibling}}}function ta(a,b,c){var d=[];c||(c=a.aoHeader,b&&(c=[],ea(c,b)));for(var b=0,e=c.length;b<e;b++)for(var f=0,g=c[b].length;f<g;f++)if(c[b][f].unique&&(!d[f]||!a.bSortCellsTop))d[f]=c[b][f].cell;return d}function ua(a,b,c){s(a,"aoServerParams","serverParams",[b]);if(b&&h.isArray(b)){var d={},
e=/(.*?)\[\]$/;h.each(b,function(a,b){var c=b.name.match(e);c?(c=c[0],d[c]||(d[c]=[]),d[c].push(b.value)):d[b.name]=b.value});b=d}var f,g=a.ajax,j=a.oInstance,i=function(b){s(a,null,"xhr",[a,b,a.jqXHR]);c(b)};if(h.isPlainObject(g)&&g.data){f=g.data;var n=h.isFunction(f)?f(b,a):f,b=h.isFunction(f)&&n?n:h.extend(!0,b,n);delete g.data}n={data:b,success:function(b){var c=b.error||b.sError;c&&K(a,0,c);a.json=b;i(b)},dataType:"json",cache:!1,type:a.sServerMethod,error:function(b,c){var d=s(a,null,"xhr",
[a,null,a.jqXHR]);-1===h.inArray(!0,d)&&("parsererror"==c?K(a,0,"Invalid JSON response",1):4===b.readyState&&K(a,0,"Ajax error",7));C(a,!1)}};a.oAjaxData=b;s(a,null,"preXhr",[a,b]);a.fnServerData?a.fnServerData.call(j,a.sAjaxSource,h.map(b,function(a,b){return{name:b,value:a}}),i,a):a.sAjaxSource||"string"===typeof g?a.jqXHR=h.ajax(h.extend(n,{url:g||a.sAjaxSource})):h.isFunction(g)?a.jqXHR=g.call(j,b,i,a):(a.jqXHR=h.ajax(h.extend(n,g)),g.data=f)}function nb(a){return a.bAjaxDataGet?(a.iDraw++,C(a,
!0),ua(a,wb(a),function(b){xb(a,b)}),!1):!0}function wb(a){var b=a.aoColumns,c=b.length,d=a.oFeatures,e=a.oPreviousSearch,f=a.aoPreSearchCols,g,j=[],i,n,l,k=W(a);g=a._iDisplayStart;i=!1!==d.bPaginate?a._iDisplayLength:-1;var r=function(a,b){j.push({name:a,value:b})};r("sEcho",a.iDraw);r("iColumns",c);r("sColumns",D(b,"sName").join(","));r("iDisplayStart",g);r("iDisplayLength",i);var ra={draw:a.iDraw,columns:[],order:[],start:g,length:i,search:{value:e.sSearch,regex:e.bRegex}};for(g=0;g<c;g++)n=b[g],
l=f[g],i="function"==typeof n.mData?"function":n.mData,ra.columns.push({data:i,name:n.sName,searchable:n.bSearchable,orderable:n.bSortable,search:{value:l.sSearch,regex:l.bRegex}}),r("mDataProp_"+g,i),d.bFilter&&(r("sSearch_"+g,l.sSearch),r("bRegex_"+g,l.bRegex),r("bSearchable_"+g,n.bSearchable)),d.bSort&&r("bSortable_"+g,n.bSortable);d.bFilter&&(r("sSearch",e.sSearch),r("bRegex",e.bRegex));d.bSort&&(h.each(k,function(a,b){ra.order.push({column:b.col,dir:b.dir});r("iSortCol_"+a,b.col);r("sSortDir_"+
a,b.dir)}),r("iSortingCols",k.length));b=m.ext.legacy.ajax;return null===b?a.sAjaxSource?j:ra:b?j:ra}function xb(a,b){var c=va(a,b),d=b.sEcho!==k?b.sEcho:b.draw,e=b.iTotalRecords!==k?b.iTotalRecords:b.recordsTotal,f=b.iTotalDisplayRecords!==k?b.iTotalDisplayRecords:b.recordsFiltered;if(d){if(1*d<a.iDraw)return;a.iDraw=1*d}pa(a);a._iRecordsTotal=parseInt(e,10);a._iRecordsDisplay=parseInt(f,10);d=0;for(e=c.length;d<e;d++)N(a,c[d]);a.aiDisplay=a.aiDisplayMaster.slice();a.bAjaxDataGet=!1;O(a);a._bInitComplete||
wa(a,b);a.bAjaxDataGet=!0;C(a,!1)}function va(a,b){var c=h.isPlainObject(a.ajax)&&a.ajax.dataSrc!==k?a.ajax.dataSrc:a.sAjaxDataProp;return"data"===c?b.aaData||b[c]:""!==c?R(c)(b):b}function rb(a){var b=a.oClasses,c=a.sTableId,d=a.oLanguage,e=a.oPreviousSearch,f=a.aanFeatures,g='<input type="search" class="'+b.sFilterInput+'"/>',j=d.sSearch,j=j.match(/_INPUT_/)?j.replace("_INPUT_",g):j+g,b=h("<div/>",{id:!f.f?c+"_filter":null,"class":b.sFilter}).append(h("<label/>").append(j)),f=function(){var b=!this.value?
"":this.value;b!=e.sSearch&&(ga(a,{sSearch:b,bRegex:e.bRegex,bSmart:e.bSmart,bCaseInsensitive:e.bCaseInsensitive}),a._iDisplayStart=0,O(a))},g=null!==a.searchDelay?a.searchDelay:"ssp"===y(a)?400:0,i=h("input",b).val(e.sSearch).attr("placeholder",d.sSearchPlaceholder).on("keyup.DT search.DT input.DT paste.DT cut.DT",g?Qa(f,g):f).on("keypress.DT",function(a){if(13==a.keyCode)return!1}).attr("aria-controls",c);h(a.nTable).on("search.dt.DT",function(b,c){if(a===c)try{i[0]!==H.activeElement&&i.val(e.sSearch)}catch(d){}});
return b[0]}function ga(a,b,c){var d=a.oPreviousSearch,e=a.aoPreSearchCols,f=function(a){d.sSearch=a.sSearch;d.bRegex=a.bRegex;d.bSmart=a.bSmart;d.bCaseInsensitive=a.bCaseInsensitive};Ia(a);if("ssp"!=y(a)){yb(a,b.sSearch,c,b.bEscapeRegex!==k?!b.bEscapeRegex:b.bRegex,b.bSmart,b.bCaseInsensitive);f(b);for(b=0;b<e.length;b++)zb(a,e[b].sSearch,b,e[b].bEscapeRegex!==k?!e[b].bEscapeRegex:e[b].bRegex,e[b].bSmart,e[b].bCaseInsensitive);Ab(a)}else f(b);a.bFiltered=!0;s(a,null,"search",[a])}function Ab(a){for(var b=
m.ext.search,c=a.aiDisplay,d,e,f=0,g=b.length;f<g;f++){for(var j=[],i=0,n=c.length;i<n;i++)e=c[i],d=a.aoData[e],b[f](a,d._aFilterData,e,d._aData,i)&&j.push(e);c.length=0;h.merge(c,j)}}function zb(a,b,c,d,e,f){if(""!==b){for(var g=[],j=a.aiDisplay,d=Ra(b,d,e,f),e=0;e<j.length;e++)b=a.aoData[j[e]]._aFilterData[c],d.test(b)&&g.push(j[e]);a.aiDisplay=g}}function yb(a,b,c,d,e,f){var d=Ra(b,d,e,f),f=a.oPreviousSearch.sSearch,g=a.aiDisplayMaster,j,e=[];0!==m.ext.search.length&&(c=!0);j=Bb(a);if(0>=b.length)a.aiDisplay=
g.slice();else{if(j||c||f.length>b.length||0!==b.indexOf(f)||a.bSorted)a.aiDisplay=g.slice();b=a.aiDisplay;for(c=0;c<b.length;c++)d.test(a.aoData[b[c]]._sFilterRow)&&e.push(b[c]);a.aiDisplay=e}}function Ra(a,b,c,d){a=b?a:Sa(a);c&&(a="^(?=.*?"+h.map(a.match(/"[^"]+"|[^ ]+/g)||[""],function(a){if('"'===a.charAt(0))var b=a.match(/^"(.*)"$/),a=b?b[1]:a;return a.replace('"',"")}).join(")(?=.*?")+").*$");return RegExp(a,d?"i":"")}function Bb(a){var b=a.aoColumns,c,d,e,f,g,j,i,h,l=m.ext.type.search;c=!1;
d=0;for(f=a.aoData.length;d<f;d++)if(h=a.aoData[d],!h._aFilterData){j=[];e=0;for(g=b.length;e<g;e++)c=b[e],c.bSearchable?(i=B(a,d,e,"filter"),l[c.sType]&&(i=l[c.sType](i)),null===i&&(i=""),"string"!==typeof i&&i.toString&&(i=i.toString())):i="",i.indexOf&&-1!==i.indexOf("&")&&(xa.innerHTML=i,i=$b?xa.textContent:xa.innerText),i.replace&&(i=i.replace(/[\r\n]/g,"")),j.push(i);h._aFilterData=j;h._sFilterRow=j.join("  ");c=!0}return c}function Cb(a){return{search:a.sSearch,smart:a.bSmart,regex:a.bRegex,
caseInsensitive:a.bCaseInsensitive}}function Db(a){return{sSearch:a.search,bSmart:a.smart,bRegex:a.regex,bCaseInsensitive:a.caseInsensitive}}function ub(a){var b=a.sTableId,c=a.aanFeatures.i,d=h("<div/>",{"class":a.oClasses.sInfo,id:!c?b+"_info":null});c||(a.aoDrawCallback.push({fn:Eb,sName:"information"}),d.attr("role","status").attr("aria-live","polite"),h(a.nTable).attr("aria-describedby",b+"_info"));return d[0]}function Eb(a){var b=a.aanFeatures.i;if(0!==b.length){var c=a.oLanguage,d=a._iDisplayStart+
1,e=a.fnDisplayEnd(),f=a.fnRecordsTotal(),g=a.fnRecordsDisplay(),j=g?c.sInfo:c.sInfoEmpty;g!==f&&(j+=" "+c.sInfoFiltered);j+=c.sInfoPostFix;j=Fb(a,j);c=c.fnInfoCallback;null!==c&&(j=c.call(a.oInstance,a,d,e,f,g,j));h(b).html(j)}}function Fb(a,b){var c=a.fnFormatNumber,d=a._iDisplayStart+1,e=a._iDisplayLength,f=a.fnRecordsDisplay(),g=-1===e;return b.replace(/_START_/g,c.call(a,d)).replace(/_END_/g,c.call(a,a.fnDisplayEnd())).replace(/_MAX_/g,c.call(a,a.fnRecordsTotal())).replace(/_TOTAL_/g,c.call(a,
f)).replace(/_PAGE_/g,c.call(a,g?1:Math.ceil(d/e))).replace(/_PAGES_/g,c.call(a,g?1:Math.ceil(f/e)))}function ha(a){var b,c,d=a.iInitDisplayStart,e=a.aoColumns,f;c=a.oFeatures;var g=a.bDeferLoading;if(a.bInitialised){pb(a);mb(a);fa(a,a.aoHeader);fa(a,a.aoFooter);C(a,!0);c.bAutoWidth&&Ha(a);b=0;for(c=e.length;b<c;b++)f=e[b],f.sWidth&&(f.nTh.style.width=v(f.sWidth));s(a,null,"preInit",[a]);T(a);e=y(a);if("ssp"!=e||g)"ajax"==e?ua(a,[],function(c){var f=va(a,c);for(b=0;b<f.length;b++)N(a,f[b]);a.iInitDisplayStart=
d;T(a);C(a,!1);wa(a,c)},a):(C(a,!1),wa(a))}else setTimeout(function(){ha(a)},200)}function wa(a,b){a._bInitComplete=!0;(b||a.oInit.aaData)&&Z(a);s(a,null,"plugin-init",[a,b]);s(a,"aoInitComplete","init",[a,b])}function Ta(a,b){var c=parseInt(b,10);a._iDisplayLength=c;Ua(a);s(a,null,"length",[a,c])}function qb(a){for(var b=a.oClasses,c=a.sTableId,d=a.aLengthMenu,e=h.isArray(d[0]),f=e?d[0]:d,d=e?d[1]:d,e=h("<select/>",{name:c+"_length","aria-controls":c,"class":b.sLengthSelect}),g=0,j=f.length;g<j;g++)e[0][g]=
new Option(d[g],f[g]);var i=h("<div><label/></div>").addClass(b.sLength);a.aanFeatures.l||(i[0].id=c+"_length");i.children().append(a.oLanguage.sLengthMenu.replace("_MENU_",e[0].outerHTML));h("select",i).val(a._iDisplayLength).on("change.DT",function(){Ta(a,h(this).val());O(a)});h(a.nTable).on("length.dt.DT",function(b,c,d){a===c&&h("select",i).val(d)});return i[0]}function vb(a){var b=a.sPaginationType,c=m.ext.pager[b],d="function"===typeof c,e=function(a){O(a)},b=h("<div/>").addClass(a.oClasses.sPaging+
b)[0],f=a.aanFeatures;d||c.fnInit(a,b,e);f.p||(b.id=a.sTableId+"_paginate",a.aoDrawCallback.push({fn:function(a){if(d){var b=a._iDisplayStart,i=a._iDisplayLength,h=a.fnRecordsDisplay(),l=-1===i,b=l?0:Math.ceil(b/i),i=l?1:Math.ceil(h/i),h=c(b,i),k,l=0;for(k=f.p.length;l<k;l++)Pa(a,"pageButton")(a,f.p[l],l,h,b,i)}else c.fnUpdate(a,e)},sName:"pagination"}));return b}function Va(a,b,c){var d=a._iDisplayStart,e=a._iDisplayLength,f=a.fnRecordsDisplay();0===f||-1===e?d=0:"number"===typeof b?(d=b*e,d>f&&
(d=0)):"first"==b?d=0:"previous"==b?(d=0<=e?d-e:0,0>d&&(d=0)):"next"==b?d+e<f&&(d+=e):"last"==b?d=Math.floor((f-1)/e)*e:K(a,0,"Unknown paging action: "+b,5);b=a._iDisplayStart!==d;a._iDisplayStart=d;b&&(s(a,null,"page",[a]),c&&O(a));return b}function sb(a){return h("<div/>",{id:!a.aanFeatures.r?a.sTableId+"_processing":null,"class":a.oClasses.sProcessing}).html(a.oLanguage.sProcessing).insertBefore(a.nTable)[0]}function C(a,b){a.oFeatures.bProcessing&&h(a.aanFeatures.r).css("display",b?"block":"none");
s(a,null,"processing",[a,b])}function tb(a){var b=h(a.nTable);b.attr("role","grid");var c=a.oScroll;if(""===c.sX&&""===c.sY)return a.nTable;var d=c.sX,e=c.sY,f=a.oClasses,g=b.children("caption"),j=g.length?g[0]._captionSide:null,i=h(b[0].cloneNode(!1)),n=h(b[0].cloneNode(!1)),l=b.children("tfoot");l.length||(l=null);i=h("<div/>",{"class":f.sScrollWrapper}).append(h("<div/>",{"class":f.sScrollHead}).css({overflow:"hidden",position:"relative",border:0,width:d?!d?null:v(d):"100%"}).append(h("<div/>",
{"class":f.sScrollHeadInner}).css({"box-sizing":"content-box",width:c.sXInner||"100%"}).append(i.removeAttr("id").css("margin-left",0).append("top"===j?g:null).append(b.children("thead"))))).append(h("<div/>",{"class":f.sScrollBody}).css({position:"relative",overflow:"auto",width:!d?null:v(d)}).append(b));l&&i.append(h("<div/>",{"class":f.sScrollFoot}).css({overflow:"hidden",border:0,width:d?!d?null:v(d):"100%"}).append(h("<div/>",{"class":f.sScrollFootInner}).append(n.removeAttr("id").css("margin-left",
0).append("bottom"===j?g:null).append(b.children("tfoot")))));var b=i.children(),k=b[0],f=b[1],r=l?b[2]:null;if(d)h(f).on("scroll.DT",function(){var a=this.scrollLeft;k.scrollLeft=a;l&&(r.scrollLeft=a)});h(f).css(e&&c.bCollapse?"max-height":"height",e);a.nScrollHead=k;a.nScrollBody=f;a.nScrollFoot=r;a.aoDrawCallback.push({fn:ma,sName:"scrolling"});return i[0]}function ma(a){var b=a.oScroll,c=b.sX,d=b.sXInner,e=b.sY,b=b.iBarWidth,f=h(a.nScrollHead),g=f[0].style,j=f.children("div"),i=j[0].style,n=j.children("table"),
j=a.nScrollBody,l=h(j),q=j.style,r=h(a.nScrollFoot).children("div"),m=r.children("table"),p=h(a.nTHead),o=h(a.nTable),t=o[0],s=t.style,u=a.nTFoot?h(a.nTFoot):null,x=a.oBrowser,U=x.bScrollOversize,ac=D(a.aoColumns,"nTh"),P,L,Q,w,Wa=[],y=[],z=[],A=[],B,C=function(a){a=a.style;a.paddingTop="0";a.paddingBottom="0";a.borderTopWidth="0";a.borderBottomWidth="0";a.height=0};L=j.scrollHeight>j.clientHeight;if(a.scrollBarVis!==L&&a.scrollBarVis!==k)a.scrollBarVis=L,Z(a);else{a.scrollBarVis=L;o.children("thead, tfoot").remove();
u&&(Q=u.clone().prependTo(o),P=u.find("tr"),Q=Q.find("tr"));w=p.clone().prependTo(o);p=p.find("tr");L=w.find("tr");w.find("th, td").removeAttr("tabindex");c||(q.width="100%",f[0].style.width="100%");h.each(ta(a,w),function(b,c){B=$(a,b);c.style.width=a.aoColumns[B].sWidth});u&&I(function(a){a.style.width=""},Q);f=o.outerWidth();if(""===c){s.width="100%";if(U&&(o.find("tbody").height()>j.offsetHeight||"scroll"==l.css("overflow-y")))s.width=v(o.outerWidth()-b);f=o.outerWidth()}else""!==d&&(s.width=
v(d),f=o.outerWidth());I(C,L);I(function(a){z.push(a.innerHTML);Wa.push(v(h(a).css("width")))},L);I(function(a,b){if(h.inArray(a,ac)!==-1)a.style.width=Wa[b]},p);h(L).height(0);u&&(I(C,Q),I(function(a){A.push(a.innerHTML);y.push(v(h(a).css("width")))},Q),I(function(a,b){a.style.width=y[b]},P),h(Q).height(0));I(function(a,b){a.innerHTML='<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+z[b]+"</div>";a.style.width=Wa[b]},L);u&&I(function(a,b){a.innerHTML='<div class="dataTables_sizing" style="height:0;overflow:hidden;">'+
A[b]+"</div>";a.style.width=y[b]},Q);if(o.outerWidth()<f){P=j.scrollHeight>j.offsetHeight||"scroll"==l.css("overflow-y")?f+b:f;if(U&&(j.scrollHeight>j.offsetHeight||"scroll"==l.css("overflow-y")))s.width=v(P-b);(""===c||""!==d)&&K(a,1,"Possible column misalignment",6)}else P="100%";q.width=v(P);g.width=v(P);u&&(a.nScrollFoot.style.width=v(P));!e&&U&&(q.height=v(t.offsetHeight+b));c=o.outerWidth();n[0].style.width=v(c);i.width=v(c);d=o.height()>j.clientHeight||"scroll"==l.css("overflow-y");e="padding"+
(x.bScrollbarLeft?"Left":"Right");i[e]=d?b+"px":"0px";u&&(m[0].style.width=v(c),r[0].style.width=v(c),r[0].style[e]=d?b+"px":"0px");o.children("colgroup").insertBefore(o.children("thead"));l.scroll();if((a.bSorted||a.bFiltered)&&!a._drawHold)j.scrollTop=0}}function I(a,b,c){for(var d=0,e=0,f=b.length,g,j;e<f;){g=b[e].firstChild;for(j=c?c[e].firstChild:null;g;)1===g.nodeType&&(c?a(g,j,d):a(g,d),d++),g=g.nextSibling,j=c?j.nextSibling:null;e++}}function Ha(a){var b=a.nTable,c=a.aoColumns,d=a.oScroll,
e=d.sY,f=d.sX,g=d.sXInner,j=c.length,i=na(a,"bVisible"),n=h("th",a.nTHead),l=b.getAttribute("width"),k=b.parentNode,r=!1,m,p,o=a.oBrowser,d=o.bScrollOversize;(m=b.style.width)&&-1!==m.indexOf("%")&&(l=m);for(m=0;m<i.length;m++)p=c[i[m]],null!==p.sWidth&&(p.sWidth=Gb(p.sWidthOrig,k),r=!0);if(d||!r&&!f&&!e&&j==ba(a)&&j==n.length)for(m=0;m<j;m++)i=$(a,m),null!==i&&(c[i].sWidth=v(n.eq(m).width()));else{j=h(b).clone().css("visibility","hidden").removeAttr("id");j.find("tbody tr").remove();var t=h("<tr/>").appendTo(j.find("tbody"));
j.find("thead, tfoot").remove();j.append(h(a.nTHead).clone()).append(h(a.nTFoot).clone());j.find("tfoot th, tfoot td").css("width","");n=ta(a,j.find("thead")[0]);for(m=0;m<i.length;m++)p=c[i[m]],n[m].style.width=null!==p.sWidthOrig&&""!==p.sWidthOrig?v(p.sWidthOrig):"",p.sWidthOrig&&f&&h(n[m]).append(h("<div/>").css({width:p.sWidthOrig,margin:0,padding:0,border:0,height:1}));if(a.aoData.length)for(m=0;m<i.length;m++)r=i[m],p=c[r],h(Hb(a,r)).clone(!1).append(p.sContentPadding).appendTo(t);h("[name]",
j).removeAttr("name");p=h("<div/>").css(f||e?{position:"absolute",top:0,left:0,height:1,right:0,overflow:"hidden"}:{}).append(j).appendTo(k);f&&g?j.width(g):f?(j.css("width","auto"),j.removeAttr("width"),j.width()<k.clientWidth&&l&&j.width(k.clientWidth)):e?j.width(k.clientWidth):l&&j.width(l);for(m=e=0;m<i.length;m++)k=h(n[m]),g=k.outerWidth()-k.width(),k=o.bBounding?Math.ceil(n[m].getBoundingClientRect().width):k.outerWidth(),e+=k,c[i[m]].sWidth=v(k-g);b.style.width=v(e);p.remove()}l&&(b.style.width=
v(l));if((l||f)&&!a._reszEvt)b=function(){h(E).on("resize.DT-"+a.sInstance,Qa(function(){Z(a)}))},d?setTimeout(b,1E3):b(),a._reszEvt=!0}function Gb(a,b){if(!a)return 0;var c=h("<div/>").css("width",v(a)).appendTo(b||H.body),d=c[0].offsetWidth;c.remove();return d}function Hb(a,b){var c=Ib(a,b);if(0>c)return null;var d=a.aoData[c];return!d.nTr?h("<td/>").html(B(a,c,b,"display"))[0]:d.anCells[b]}function Ib(a,b){for(var c,d=-1,e=-1,f=0,g=a.aoData.length;f<g;f++)c=B(a,f,b,"display")+"",c=c.replace(bc,
""),c=c.replace(/&nbsp;/g," "),c.length>d&&(d=c.length,e=f);return e}function v(a){return null===a?"0px":"number"==typeof a?0>a?"0px":a+"px":a.match(/\d$/)?a+"px":a}function W(a){var b,c,d=[],e=a.aoColumns,f,g,j,i;b=a.aaSortingFixed;c=h.isPlainObject(b);var n=[];f=function(a){a.length&&!h.isArray(a[0])?n.push(a):h.merge(n,a)};h.isArray(b)&&f(b);c&&b.pre&&f(b.pre);f(a.aaSorting);c&&b.post&&f(b.post);for(a=0;a<n.length;a++){i=n[a][0];f=e[i].aDataSort;b=0;for(c=f.length;b<c;b++)g=f[b],j=e[g].sType||
"string",n[a]._idx===k&&(n[a]._idx=h.inArray(n[a][1],e[g].asSorting)),d.push({src:i,col:g,dir:n[a][1],index:n[a]._idx,type:j,formatter:m.ext.type.order[j+"-pre"]})}return d}function ob(a){var b,c,d=[],e=m.ext.type.order,f=a.aoData,g=0,j,i=a.aiDisplayMaster,h;Ia(a);h=W(a);b=0;for(c=h.length;b<c;b++)j=h[b],j.formatter&&g++,Jb(a,j.col);if("ssp"!=y(a)&&0!==h.length){b=0;for(c=i.length;b<c;b++)d[i[b]]=b;g===h.length?i.sort(function(a,b){var c,e,g,j,i=h.length,k=f[a]._aSortData,m=f[b]._aSortData;for(g=
0;g<i;g++)if(j=h[g],c=k[j.col],e=m[j.col],c=c<e?-1:c>e?1:0,0!==c)return"asc"===j.dir?c:-c;c=d[a];e=d[b];return c<e?-1:c>e?1:0}):i.sort(function(a,b){var c,g,j,i,k=h.length,m=f[a]._aSortData,p=f[b]._aSortData;for(j=0;j<k;j++)if(i=h[j],c=m[i.col],g=p[i.col],i=e[i.type+"-"+i.dir]||e["string-"+i.dir],c=i(c,g),0!==c)return c;c=d[a];g=d[b];return c<g?-1:c>g?1:0})}a.bSorted=!0}function Kb(a){for(var b,c,d=a.aoColumns,e=W(a),a=a.oLanguage.oAria,f=0,g=d.length;f<g;f++){c=d[f];var j=c.asSorting;b=c.sTitle.replace(/<.*?>/g,
"");var i=c.nTh;i.removeAttribute("aria-sort");c.bSortable&&(0<e.length&&e[0].col==f?(i.setAttribute("aria-sort","asc"==e[0].dir?"ascending":"descending"),c=j[e[0].index+1]||j[0]):c=j[0],b+="asc"===c?a.sSortAscending:a.sSortDescending);i.setAttribute("aria-label",b)}}function Xa(a,b,c,d){var e=a.aaSorting,f=a.aoColumns[b].asSorting,g=function(a,b){var c=a._idx;c===k&&(c=h.inArray(a[1],f));return c+1<f.length?c+1:b?null:0};"number"===typeof e[0]&&(e=a.aaSorting=[e]);c&&a.oFeatures.bSortMulti?(c=h.inArray(b,
D(e,"0")),-1!==c?(b=g(e[c],!0),null===b&&1===e.length&&(b=0),null===b?e.splice(c,1):(e[c][1]=f[b],e[c]._idx=b)):(e.push([b,f[0],0]),e[e.length-1]._idx=0)):e.length&&e[0][0]==b?(b=g(e[0]),e.length=1,e[0][1]=f[b],e[0]._idx=b):(e.length=0,e.push([b,f[0]]),e[0]._idx=0);T(a);"function"==typeof d&&d(a)}function Oa(a,b,c,d){var e=a.aoColumns[c];Ya(b,{},function(b){!1!==e.bSortable&&(a.oFeatures.bProcessing?(C(a,!0),setTimeout(function(){Xa(a,c,b.shiftKey,d);"ssp"!==y(a)&&C(a,!1)},0)):Xa(a,c,b.shiftKey,d))})}
function ya(a){var b=a.aLastSort,c=a.oClasses.sSortColumn,d=W(a),e=a.oFeatures,f,g;if(e.bSort&&e.bSortClasses){e=0;for(f=b.length;e<f;e++)g=b[e].src,h(D(a.aoData,"anCells",g)).removeClass(c+(2>e?e+1:3));e=0;for(f=d.length;e<f;e++)g=d[e].src,h(D(a.aoData,"anCells",g)).addClass(c+(2>e?e+1:3))}a.aLastSort=d}function Jb(a,b){var c=a.aoColumns[b],d=m.ext.order[c.sSortDataType],e;d&&(e=d.call(a.oInstance,a,b,aa(a,b)));for(var f,g=m.ext.type.order[c.sType+"-pre"],j=0,i=a.aoData.length;j<i;j++)if(c=a.aoData[j],
c._aSortData||(c._aSortData=[]),!c._aSortData[b]||d)f=d?e[j]:B(a,j,b,"sort"),c._aSortData[b]=g?g(f):f}function za(a){if(a.oFeatures.bStateSave&&!a.bDestroying){var b={time:+new Date,start:a._iDisplayStart,length:a._iDisplayLength,order:h.extend(!0,[],a.aaSorting),search:Cb(a.oPreviousSearch),columns:h.map(a.aoColumns,function(b,d){return{visible:b.bVisible,search:Cb(a.aoPreSearchCols[d])}})};s(a,"aoStateSaveParams","stateSaveParams",[a,b]);a.oSavedState=b;a.fnStateSaveCallback.call(a.oInstance,a,
b)}}function Lb(a,b,c){var d,e,f=a.aoColumns,b=function(b){if(b&&b.time){var g=s(a,"aoStateLoadParams","stateLoadParams",[a,b]);if(-1===h.inArray(!1,g)&&(g=a.iStateDuration,!(0<g&&b.time<+new Date-1E3*g)&&!(b.columns&&f.length!==b.columns.length))){a.oLoadedState=h.extend(!0,{},b);b.start!==k&&(a._iDisplayStart=b.start,a.iInitDisplayStart=b.start);b.length!==k&&(a._iDisplayLength=b.length);b.order!==k&&(a.aaSorting=[],h.each(b.order,function(b,c){a.aaSorting.push(c[0]>=f.length?[0,c[1]]:c)}));b.search!==
k&&h.extend(a.oPreviousSearch,Db(b.search));if(b.columns){d=0;for(e=b.columns.length;d<e;d++)g=b.columns[d],g.visible!==k&&(f[d].bVisible=g.visible),g.search!==k&&h.extend(a.aoPreSearchCols[d],Db(g.search))}s(a,"aoStateLoaded","stateLoaded",[a,b])}}c()};if(a.oFeatures.bStateSave){var g=a.fnStateLoadCallback.call(a.oInstance,a,b);g!==k&&b(g)}else c()}function Aa(a){var b=m.settings,a=h.inArray(a,D(b,"nTable"));return-1!==a?b[a]:null}function K(a,b,c,d){c="DataTables warning: "+(a?"table id="+a.sTableId+
" - ":"")+c;d&&(c+=". For more information about this error, please see http://datatables.net/tn/"+d);if(b)E.console&&console.log&&console.log(c);else if(b=m.ext,b=b.sErrMode||b.errMode,a&&s(a,null,"error",[a,d,c]),"alert"==b)alert(c);else{if("throw"==b)throw Error(c);"function"==typeof b&&b(a,d,c)}}function F(a,b,c,d){h.isArray(c)?h.each(c,function(c,d){h.isArray(d)?F(a,b,d[0],d[1]):F(a,b,d)}):(d===k&&(d=c),b[c]!==k&&(a[d]=b[c]))}function Mb(a,b,c){var d,e;for(e in b)b.hasOwnProperty(e)&&(d=b[e],
h.isPlainObject(d)?(h.isPlainObject(a[e])||(a[e]={}),h.extend(!0,a[e],d)):a[e]=c&&"data"!==e&&"aaData"!==e&&h.isArray(d)?d.slice():d);return a}function Ya(a,b,c){h(a).on("click.DT",b,function(b){a.blur();c(b)}).on("keypress.DT",b,function(a){13===a.which&&(a.preventDefault(),c(a))}).on("selectstart.DT",function(){return!1})}function z(a,b,c,d){c&&a[b].push({fn:c,sName:d})}function s(a,b,c,d){var e=[];b&&(e=h.map(a[b].slice().reverse(),function(b){return b.fn.apply(a.oInstance,d)}));null!==c&&(b=h.Event(c+
".dt"),h(a.nTable).trigger(b,d),e.push(b.result));return e}function Ua(a){var b=a._iDisplayStart,c=a.fnDisplayEnd(),d=a._iDisplayLength;b>=c&&(b=c-d);b-=b%d;if(-1===d||0>b)b=0;a._iDisplayStart=b}function Pa(a,b){var c=a.renderer,d=m.ext.renderer[b];return h.isPlainObject(c)&&c[b]?d[c[b]]||d._:"string"===typeof c?d[c]||d._:d._}function y(a){return a.oFeatures.bServerSide?"ssp":a.ajax||a.sAjaxSource?"ajax":"dom"}function ia(a,b){var c=[],c=Nb.numbers_length,d=Math.floor(c/2);b<=c?c=X(0,b):a<=d?(c=X(0,
c-2),c.push("ellipsis"),c.push(b-1)):(a>=b-1-d?c=X(b-(c-2),b):(c=X(a-d+2,a+d-1),c.push("ellipsis"),c.push(b-1)),c.splice(0,0,"ellipsis"),c.splice(0,0,0));c.DT_el="span";return c}function fb(a){h.each({num:function(b){return Ba(b,a)},"num-fmt":function(b){return Ba(b,a,Za)},"html-num":function(b){return Ba(b,a,Ca)},"html-num-fmt":function(b){return Ba(b,a,Ca,Za)}},function(b,c){x.type.order[b+a+"-pre"]=c;b.match(/^html\-/)&&(x.type.search[b+a]=x.type.search.html)})}function Ob(a){return function(){var b=
[Aa(this[m.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));return m.ext.internal[a].apply(this,b)}}var m=function(a){this.$=function(a,b){return this.api(!0).$(a,b)};this._=function(a,b){return this.api(!0).rows(a,b).data()};this.api=function(a){return a?new t(Aa(this[x.iApiIndex])):new t(this)};this.fnAddData=function(a,b){var c=this.api(!0),d=h.isArray(a)&&(h.isArray(a[0])||h.isPlainObject(a[0]))?c.rows.add(a):c.row.add(a);(b===k||b)&&c.draw();return d.flatten().toArray()};this.fnAdjustColumnSizing=
function(a){var b=this.api(!0).columns.adjust(),c=b.settings()[0],d=c.oScroll;a===k||a?b.draw(!1):(""!==d.sX||""!==d.sY)&&ma(c)};this.fnClearTable=function(a){var b=this.api(!0).clear();(a===k||a)&&b.draw()};this.fnClose=function(a){this.api(!0).row(a).child.hide()};this.fnDeleteRow=function(a,b,c){var d=this.api(!0),a=d.rows(a),e=a.settings()[0],h=e.aoData[a[0][0]];a.remove();b&&b.call(this,e,h);(c===k||c)&&d.draw();return h};this.fnDestroy=function(a){this.api(!0).destroy(a)};this.fnDraw=function(a){this.api(!0).draw(a)};
this.fnFilter=function(a,b,c,d,e,h){e=this.api(!0);null===b||b===k?e.search(a,c,d,h):e.column(b).search(a,c,d,h);e.draw()};this.fnGetData=function(a,b){var c=this.api(!0);if(a!==k){var d=a.nodeName?a.nodeName.toLowerCase():"";return b!==k||"td"==d||"th"==d?c.cell(a,b).data():c.row(a).data()||null}return c.data().toArray()};this.fnGetNodes=function(a){var b=this.api(!0);return a!==k?b.row(a).node():b.rows().nodes().flatten().toArray()};this.fnGetPosition=function(a){var b=this.api(!0),c=a.nodeName.toUpperCase();
return"TR"==c?b.row(a).index():"TD"==c||"TH"==c?(a=b.cell(a).index(),[a.row,a.columnVisible,a.column]):null};this.fnIsOpen=function(a){return this.api(!0).row(a).child.isShown()};this.fnOpen=function(a,b,c){return this.api(!0).row(a).child(b,c).show().child()[0]};this.fnPageChange=function(a,b){var c=this.api(!0).page(a);(b===k||b)&&c.draw(!1)};this.fnSetColumnVis=function(a,b,c){a=this.api(!0).column(a).visible(b);(c===k||c)&&a.columns.adjust().draw()};this.fnSettings=function(){return Aa(this[x.iApiIndex])};
this.fnSort=function(a){this.api(!0).order(a).draw()};this.fnSortListener=function(a,b,c){this.api(!0).order.listener(a,b,c)};this.fnUpdate=function(a,b,c,d,e){var h=this.api(!0);c===k||null===c?h.row(b).data(a):h.cell(b,c).data(a);(e===k||e)&&h.columns.adjust();(d===k||d)&&h.draw();return 0};this.fnVersionCheck=x.fnVersionCheck;var b=this,c=a===k,d=this.length;c&&(a={});this.oApi=this.internal=x.internal;for(var e in m.ext.internal)e&&(this[e]=Ob(e));this.each(function(){var e={},g=1<d?Mb(e,a,!0):
a,j=0,i,e=this.getAttribute("id"),n=!1,l=m.defaults,q=h(this);if("table"!=this.nodeName.toLowerCase())K(null,0,"Non-table node initialisation ("+this.nodeName+")",2);else{gb(l);hb(l.column);J(l,l,!0);J(l.column,l.column,!0);J(l,h.extend(g,q.data()));var r=m.settings,j=0;for(i=r.length;j<i;j++){var p=r[j];if(p.nTable==this||p.nTHead.parentNode==this||p.nTFoot&&p.nTFoot.parentNode==this){var t=g.bRetrieve!==k?g.bRetrieve:l.bRetrieve;if(c||t)return p.oInstance;if(g.bDestroy!==k?g.bDestroy:l.bDestroy){p.oInstance.fnDestroy();
break}else{K(p,0,"Cannot reinitialise DataTable",3);return}}if(p.sTableId==this.id){r.splice(j,1);break}}if(null===e||""===e)this.id=e="DataTables_Table_"+m.ext._unique++;var o=h.extend(!0,{},m.models.oSettings,{sDestroyWidth:q[0].style.width,sInstance:e,sTableId:e});o.nTable=this;o.oApi=b.internal;o.oInit=g;r.push(o);o.oInstance=1===b.length?b:q.dataTable();gb(g);g.oLanguage&&Fa(g.oLanguage);g.aLengthMenu&&!g.iDisplayLength&&(g.iDisplayLength=h.isArray(g.aLengthMenu[0])?g.aLengthMenu[0][0]:g.aLengthMenu[0]);
g=Mb(h.extend(!0,{},l),g);F(o.oFeatures,g,"bPaginate bLengthChange bFilter bSort bSortMulti bInfo bProcessing bAutoWidth bSortClasses bServerSide bDeferRender".split(" "));F(o,g,["asStripeClasses","ajax","fnServerData","fnFormatNumber","sServerMethod","aaSorting","aaSortingFixed","aLengthMenu","sPaginationType","sAjaxSource","sAjaxDataProp","iStateDuration","sDom","bSortCellsTop","iTabIndex","fnStateLoadCallback","fnStateSaveCallback","renderer","searchDelay","rowId",["iCookieDuration","iStateDuration"],
["oSearch","oPreviousSearch"],["aoSearchCols","aoPreSearchCols"],["iDisplayLength","_iDisplayLength"],["bJQueryUI","bJUI"]]);F(o.oScroll,g,[["sScrollX","sX"],["sScrollXInner","sXInner"],["sScrollY","sY"],["bScrollCollapse","bCollapse"]]);F(o.oLanguage,g,"fnInfoCallback");z(o,"aoDrawCallback",g.fnDrawCallback,"user");z(o,"aoServerParams",g.fnServerParams,"user");z(o,"aoStateSaveParams",g.fnStateSaveParams,"user");z(o,"aoStateLoadParams",g.fnStateLoadParams,"user");z(o,"aoStateLoaded",g.fnStateLoaded,
"user");z(o,"aoRowCallback",g.fnRowCallback,"user");z(o,"aoRowCreatedCallback",g.fnCreatedRow,"user");z(o,"aoHeaderCallback",g.fnHeaderCallback,"user");z(o,"aoFooterCallback",g.fnFooterCallback,"user");z(o,"aoInitComplete",g.fnInitComplete,"user");z(o,"aoPreDrawCallback",g.fnPreDrawCallback,"user");o.rowIdFn=R(g.rowId);ib(o);var u=o.oClasses;g.bJQueryUI?(h.extend(u,m.ext.oJUIClasses,g.oClasses),g.sDom===l.sDom&&"lfrtip"===l.sDom&&(o.sDom='<"H"lfr>t<"F"ip>'),o.renderer)?h.isPlainObject(o.renderer)&&
!o.renderer.header&&(o.renderer.header="jqueryui"):o.renderer="jqueryui":h.extend(u,m.ext.classes,g.oClasses);q.addClass(u.sTable);o.iInitDisplayStart===k&&(o.iInitDisplayStart=g.iDisplayStart,o._iDisplayStart=g.iDisplayStart);null!==g.iDeferLoading&&(o.bDeferLoading=!0,e=h.isArray(g.iDeferLoading),o._iRecordsDisplay=e?g.iDeferLoading[0]:g.iDeferLoading,o._iRecordsTotal=e?g.iDeferLoading[1]:g.iDeferLoading);var v=o.oLanguage;h.extend(!0,v,g.oLanguage);v.sUrl&&(h.ajax({dataType:"json",url:v.sUrl,success:function(a){Fa(a);
J(l.oLanguage,a);h.extend(true,v,a);ha(o)},error:function(){ha(o)}}),n=!0);null===g.asStripeClasses&&(o.asStripeClasses=[u.sStripeOdd,u.sStripeEven]);var e=o.asStripeClasses,x=q.children("tbody").find("tr").eq(0);-1!==h.inArray(!0,h.map(e,function(a){return x.hasClass(a)}))&&(h("tbody tr",this).removeClass(e.join(" ")),o.asDestroyStripes=e.slice());e=[];r=this.getElementsByTagName("thead");0!==r.length&&(ea(o.aoHeader,r[0]),e=ta(o));if(null===g.aoColumns){r=[];j=0;for(i=e.length;j<i;j++)r.push(null)}else r=
g.aoColumns;j=0;for(i=r.length;j<i;j++)Ga(o,e?e[j]:null);kb(o,g.aoColumnDefs,r,function(a,b){la(o,a,b)});if(x.length){var w=function(a,b){return a.getAttribute("data-"+b)!==null?b:null};h(x[0]).children("th, td").each(function(a,b){var c=o.aoColumns[a];if(c.mData===a){var d=w(b,"sort")||w(b,"order"),e=w(b,"filter")||w(b,"search");if(d!==null||e!==null){c.mData={_:a+".display",sort:d!==null?a+".@data-"+d:k,type:d!==null?a+".@data-"+d:k,filter:e!==null?a+".@data-"+e:k};la(o,a)}}})}var U=o.oFeatures,
e=function(){if(g.aaSorting===k){var a=o.aaSorting;j=0;for(i=a.length;j<i;j++)a[j][1]=o.aoColumns[j].asSorting[0]}ya(o);U.bSort&&z(o,"aoDrawCallback",function(){if(o.bSorted){var a=W(o),b={};h.each(a,function(a,c){b[c.src]=c.dir});s(o,null,"order",[o,a,b]);Kb(o)}});z(o,"aoDrawCallback",function(){(o.bSorted||y(o)==="ssp"||U.bDeferRender)&&ya(o)},"sc");var a=q.children("caption").each(function(){this._captionSide=h(this).css("caption-side")}),b=q.children("thead");b.length===0&&(b=h("<thead/>").appendTo(q));
o.nTHead=b[0];b=q.children("tbody");b.length===0&&(b=h("<tbody/>").appendTo(q));o.nTBody=b[0];b=q.children("tfoot");if(b.length===0&&a.length>0&&(o.oScroll.sX!==""||o.oScroll.sY!==""))b=h("<tfoot/>").appendTo(q);if(b.length===0||b.children().length===0)q.addClass(u.sNoFooter);else if(b.length>0){o.nTFoot=b[0];ea(o.aoFooter,o.nTFoot)}if(g.aaData)for(j=0;j<g.aaData.length;j++)N(o,g.aaData[j]);else(o.bDeferLoading||y(o)=="dom")&&oa(o,h(o.nTBody).children("tr"));o.aiDisplay=o.aiDisplayMaster.slice();
o.bInitialised=true;n===false&&ha(o)};g.bStateSave?(U.bStateSave=!0,z(o,"aoDrawCallback",za,"state_save"),Lb(o,g,e)):e()}});b=null;return this},x,t,p,u,$a={},Pb=/[\r\n]/g,Ca=/<.*?>/g,cc=/^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/,dc=RegExp("(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\|\\$|\\^|\\-)","g"),Za=/[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi,M=function(a){return!a||!0===a||"-"===a?!0:!1},Qb=function(a){var b=parseInt(a,10);return!isNaN(b)&&
isFinite(a)?b:null},Rb=function(a,b){$a[b]||($a[b]=RegExp(Sa(b),"g"));return"string"===typeof a&&"."!==b?a.replace(/\./g,"").replace($a[b],"."):a},ab=function(a,b,c){var d="string"===typeof a;if(M(a))return!0;b&&d&&(a=Rb(a,b));c&&d&&(a=a.replace(Za,""));return!isNaN(parseFloat(a))&&isFinite(a)},Sb=function(a,b,c){return M(a)?!0:!(M(a)||"string"===typeof a)?null:ab(a.replace(Ca,""),b,c)?!0:null},D=function(a,b,c){var d=[],e=0,f=a.length;if(c!==k)for(;e<f;e++)a[e]&&a[e][b]&&d.push(a[e][b][c]);else for(;e<
f;e++)a[e]&&d.push(a[e][b]);return d},ja=function(a,b,c,d){var e=[],f=0,g=b.length;if(d!==k)for(;f<g;f++)a[b[f]][c]&&e.push(a[b[f]][c][d]);else for(;f<g;f++)e.push(a[b[f]][c]);return e},X=function(a,b){var c=[],d;b===k?(b=0,d=a):(d=b,b=a);for(var e=b;e<d;e++)c.push(e);return c},Tb=function(a){for(var b=[],c=0,d=a.length;c<d;c++)a[c]&&b.push(a[c]);return b},sa=function(a){var b;a:{if(!(2>a.length)){b=a.slice().sort();for(var c=b[0],d=1,e=b.length;d<e;d++){if(b[d]===c){b=!1;break a}c=b[d]}}b=!0}if(b)return a.slice();
b=[];var e=a.length,f,g=0,d=0;a:for(;d<e;d++){c=a[d];for(f=0;f<g;f++)if(b[f]===c)continue a;b.push(c);g++}return b};m.util={throttle:function(a,b){var c=b!==k?b:200,d,e;return function(){var b=this,g=+new Date,h=arguments;d&&g<d+c?(clearTimeout(e),e=setTimeout(function(){d=k;a.apply(b,h)},c)):(d=g,a.apply(b,h))}},escapeRegex:function(a){return a.replace(dc,"\\$1")}};var A=function(a,b,c){a[b]!==k&&(a[c]=a[b])},ca=/\[.*?\]$/,V=/\(\)$/,Sa=m.util.escapeRegex,xa=h("<div>")[0],$b=xa.textContent!==k,bc=
/<.*?>/g,Qa=m.util.throttle,Ub=[],w=Array.prototype,ec=function(a){var b,c,d=m.settings,e=h.map(d,function(a){return a.nTable});if(a){if(a.nTable&&a.oApi)return[a];if(a.nodeName&&"table"===a.nodeName.toLowerCase())return b=h.inArray(a,e),-1!==b?[d[b]]:null;if(a&&"function"===typeof a.settings)return a.settings().toArray();"string"===typeof a?c=h(a):a instanceof h&&(c=a)}else return[];if(c)return c.map(function(){b=h.inArray(this,e);return-1!==b?d[b]:null}).toArray()};t=function(a,b){if(!(this instanceof
t))return new t(a,b);var c=[],d=function(a){(a=ec(a))&&(c=c.concat(a))};if(h.isArray(a))for(var e=0,f=a.length;e<f;e++)d(a[e]);else d(a);this.context=sa(c);b&&h.merge(this,b);this.selector={rows:null,cols:null,opts:null};t.extend(this,this,Ub)};m.Api=t;h.extend(t.prototype,{any:function(){return 0!==this.count()},concat:w.concat,context:[],count:function(){return this.flatten().length},each:function(a){for(var b=0,c=this.length;b<c;b++)a.call(this,this[b],b,this);return this},eq:function(a){var b=
this.context;return b.length>a?new t(b[a],this[a]):null},filter:function(a){var b=[];if(w.filter)b=w.filter.call(this,a,this);else for(var c=0,d=this.length;c<d;c++)a.call(this,this[c],c,this)&&b.push(this[c]);return new t(this.context,b)},flatten:function(){var a=[];return new t(this.context,a.concat.apply(a,this.toArray()))},join:w.join,indexOf:w.indexOf||function(a,b){for(var c=b||0,d=this.length;c<d;c++)if(this[c]===a)return c;return-1},iterator:function(a,b,c,d){var e=[],f,g,h,i,n,l=this.context,
m,p,u=this.selector;"string"===typeof a&&(d=c,c=b,b=a,a=!1);g=0;for(h=l.length;g<h;g++){var s=new t(l[g]);if("table"===b)f=c.call(s,l[g],g),f!==k&&e.push(f);else if("columns"===b||"rows"===b)f=c.call(s,l[g],this[g],g),f!==k&&e.push(f);else if("column"===b||"column-rows"===b||"row"===b||"cell"===b){p=this[g];"column-rows"===b&&(m=Da(l[g],u.opts));i=0;for(n=p.length;i<n;i++)f=p[i],f="cell"===b?c.call(s,l[g],f.row,f.column,g,i):c.call(s,l[g],f,g,i,m),f!==k&&e.push(f)}}return e.length||d?(a=new t(l,a?
e.concat.apply([],e):e),b=a.selector,b.rows=u.rows,b.cols=u.cols,b.opts=u.opts,a):this},lastIndexOf:w.lastIndexOf||function(a,b){return this.indexOf.apply(this.toArray.reverse(),arguments)},length:0,map:function(a){var b=[];if(w.map)b=w.map.call(this,a,this);else for(var c=0,d=this.length;c<d;c++)b.push(a.call(this,this[c],c));return new t(this.context,b)},pluck:function(a){return this.map(function(b){return b[a]})},pop:w.pop,push:w.push,reduce:w.reduce||function(a,b){return jb(this,a,b,0,this.length,
1)},reduceRight:w.reduceRight||function(a,b){return jb(this,a,b,this.length-1,-1,-1)},reverse:w.reverse,selector:null,shift:w.shift,slice:function(){return new t(this.context,this)},sort:w.sort,splice:w.splice,toArray:function(){return w.slice.call(this)},to$:function(){return h(this)},toJQuery:function(){return h(this)},unique:function(){return new t(this.context,sa(this))},unshift:w.unshift});t.extend=function(a,b,c){if(c.length&&b&&(b instanceof t||b.__dt_wrapper)){var d,e,f,g=function(a,b,c){return function(){var d=
b.apply(a,arguments);t.extend(d,d,c.methodExt);return d}};d=0;for(e=c.length;d<e;d++)f=c[d],b[f.name]="function"===typeof f.val?g(a,f.val,f):h.isPlainObject(f.val)?{}:f.val,b[f.name].__dt_wrapper=!0,t.extend(a,b[f.name],f.propExt)}};t.register=p=function(a,b){if(h.isArray(a))for(var c=0,d=a.length;c<d;c++)t.register(a[c],b);else for(var e=a.split("."),f=Ub,g,j,c=0,d=e.length;c<d;c++){g=(j=-1!==e[c].indexOf("()"))?e[c].replace("()",""):e[c];var i;a:{i=0;for(var n=f.length;i<n;i++)if(f[i].name===g){i=
f[i];break a}i=null}i||(i={name:g,val:{},methodExt:[],propExt:[]},f.push(i));c===d-1?i.val=b:f=j?i.methodExt:i.propExt}};t.registerPlural=u=function(a,b,c){t.register(a,c);t.register(b,function(){var a=c.apply(this,arguments);return a===this?this:a instanceof t?a.length?h.isArray(a[0])?new t(a.context,a[0]):a[0]:k:a})};p("tables()",function(a){var b;if(a){b=t;var c=this.context;if("number"===typeof a)a=[c[a]];else var d=h.map(c,function(a){return a.nTable}),a=h(d).filter(a).map(function(){var a=h.inArray(this,
d);return c[a]}).toArray();b=new b(a)}else b=this;return b});p("table()",function(a){var a=this.tables(a),b=a.context;return b.length?new t(b[0]):a});u("tables().nodes()","table().node()",function(){return this.iterator("table",function(a){return a.nTable},1)});u("tables().body()","table().body()",function(){return this.iterator("table",function(a){return a.nTBody},1)});u("tables().header()","table().header()",function(){return this.iterator("table",function(a){return a.nTHead},1)});u("tables().footer()",
"table().footer()",function(){return this.iterator("table",function(a){return a.nTFoot},1)});u("tables().containers()","table().container()",function(){return this.iterator("table",function(a){return a.nTableWrapper},1)});p("draw()",function(a){return this.iterator("table",function(b){"page"===a?O(b):("string"===typeof a&&(a="full-hold"===a?!1:!0),T(b,!1===a))})});p("page()",function(a){return a===k?this.page.info().page:this.iterator("table",function(b){Va(b,a)})});p("page.info()",function(){if(0===
this.context.length)return k;var a=this.context[0],b=a._iDisplayStart,c=a.oFeatures.bPaginate?a._iDisplayLength:-1,d=a.fnRecordsDisplay(),e=-1===c;return{page:e?0:Math.floor(b/c),pages:e?1:Math.ceil(d/c),start:b,end:a.fnDisplayEnd(),length:c,recordsTotal:a.fnRecordsTotal(),recordsDisplay:d,serverSide:"ssp"===y(a)}});p("page.len()",function(a){return a===k?0!==this.context.length?this.context[0]._iDisplayLength:k:this.iterator("table",function(b){Ta(b,a)})});var Vb=function(a,b,c){if(c){var d=new t(a);
d.one("draw",function(){c(d.ajax.json())})}if("ssp"==y(a))T(a,b);else{C(a,!0);var e=a.jqXHR;e&&4!==e.readyState&&e.abort();ua(a,[],function(c){pa(a);for(var c=va(a,c),d=0,e=c.length;d<e;d++)N(a,c[d]);T(a,b);C(a,!1)})}};p("ajax.json()",function(){var a=this.context;if(0<a.length)return a[0].json});p("ajax.params()",function(){var a=this.context;if(0<a.length)return a[0].oAjaxData});p("ajax.reload()",function(a,b){return this.iterator("table",function(c){Vb(c,!1===b,a)})});p("ajax.url()",function(a){var b=
this.context;if(a===k){if(0===b.length)return k;b=b[0];return b.ajax?h.isPlainObject(b.ajax)?b.ajax.url:b.ajax:b.sAjaxSource}return this.iterator("table",function(b){h.isPlainObject(b.ajax)?b.ajax.url=a:b.ajax=a})});p("ajax.url().load()",function(a,b){return this.iterator("table",function(c){Vb(c,!1===b,a)})});var bb=function(a,b,c,d,e){var f=[],g,j,i,n,l,m;i=typeof b;if(!b||"string"===i||"function"===i||b.length===k)b=[b];i=0;for(n=b.length;i<n;i++){j=b[i]&&b[i].split&&!b[i].match(/[\[\(:]/)?b[i].split(","):
[b[i]];l=0;for(m=j.length;l<m;l++)(g=c("string"===typeof j[l]?h.trim(j[l]):j[l]))&&g.length&&(f=f.concat(g))}a=x.selector[a];if(a.length){i=0;for(n=a.length;i<n;i++)f=a[i](d,e,f)}return sa(f)},cb=function(a){a||(a={});a.filter&&a.search===k&&(a.search=a.filter);return h.extend({search:"none",order:"current",page:"all"},a)},db=function(a){for(var b=0,c=a.length;b<c;b++)if(0<a[b].length)return a[0]=a[b],a[0].length=1,a.length=1,a.context=[a.context[b]],a;a.length=0;return a},Da=function(a,b){var c,
d,e,f=[],g=a.aiDisplay;c=a.aiDisplayMaster;var j=b.search;d=b.order;e=b.page;if("ssp"==y(a))return"removed"===j?[]:X(0,c.length);if("current"==e){c=a._iDisplayStart;for(d=a.fnDisplayEnd();c<d;c++)f.push(g[c])}else if("current"==d||"applied"==d)f="none"==j?c.slice():"applied"==j?g.slice():h.map(c,function(a){return-1===h.inArray(a,g)?a:null});else if("index"==d||"original"==d){c=0;for(d=a.aoData.length;c<d;c++)"none"==j?f.push(c):(e=h.inArray(c,g),(-1===e&&"removed"==j||0<=e&&"applied"==j)&&f.push(c))}return f};
p("rows()",function(a,b){a===k?a="":h.isPlainObject(a)&&(b=a,a="");var b=cb(b),c=this.iterator("table",function(c){var e=b,f;return bb("row",a,function(a){var b=Qb(a);if(b!==null&&!e)return[b];f||(f=Da(c,e));if(b!==null&&h.inArray(b,f)!==-1)return[b];if(a===null||a===k||a==="")return f;if(typeof a==="function")return h.map(f,function(b){var e=c.aoData[b];return a(b,e._aData,e.nTr)?b:null});b=Tb(ja(c.aoData,f,"nTr"));if(a.nodeName){if(a._DT_RowIndex!==k)return[a._DT_RowIndex];if(a._DT_CellIndex)return[a._DT_CellIndex.row];
b=h(a).closest("*[data-dt-row]");return b.length?[b.data("dt-row")]:[]}if(typeof a==="string"&&a.charAt(0)==="#"){var i=c.aIds[a.replace(/^#/,"")];if(i!==k)return[i.idx]}return h(b).filter(a).map(function(){return this._DT_RowIndex}).toArray()},c,e)},1);c.selector.rows=a;c.selector.opts=b;return c});p("rows().nodes()",function(){return this.iterator("row",function(a,b){return a.aoData[b].nTr||k},1)});p("rows().data()",function(){return this.iterator(!0,"rows",function(a,b){return ja(a.aoData,b,"_aData")},
1)});u("rows().cache()","row().cache()",function(a){return this.iterator("row",function(b,c){var d=b.aoData[c];return"search"===a?d._aFilterData:d._aSortData},1)});u("rows().invalidate()","row().invalidate()",function(a){return this.iterator("row",function(b,c){da(b,c,a)})});u("rows().indexes()","row().index()",function(){return this.iterator("row",function(a,b){return b},1)});u("rows().ids()","row().id()",function(a){for(var b=[],c=this.context,d=0,e=c.length;d<e;d++)for(var f=0,g=this[d].length;f<
g;f++){var h=c[d].rowIdFn(c[d].aoData[this[d][f]]._aData);b.push((!0===a?"#":"")+h)}return new t(c,b)});u("rows().remove()","row().remove()",function(){var a=this;this.iterator("row",function(b,c,d){var e=b.aoData,f=e[c],g,h,i,n,l;e.splice(c,1);g=0;for(h=e.length;g<h;g++)if(i=e[g],l=i.anCells,null!==i.nTr&&(i.nTr._DT_RowIndex=g),null!==l){i=0;for(n=l.length;i<n;i++)l[i]._DT_CellIndex.row=g}qa(b.aiDisplayMaster,c);qa(b.aiDisplay,c);qa(a[d],c,!1);Ua(b);c=b.rowIdFn(f._aData);c!==k&&delete b.aIds[c]});
this.iterator("table",function(a){for(var c=0,d=a.aoData.length;c<d;c++)a.aoData[c].idx=c});return this});p("rows.add()",function(a){var b=this.iterator("table",function(b){var c,f,g,h=[];f=0;for(g=a.length;f<g;f++)c=a[f],c.nodeName&&"TR"===c.nodeName.toUpperCase()?h.push(oa(b,c)[0]):h.push(N(b,c));return h},1),c=this.rows(-1);c.pop();h.merge(c,b);return c});p("row()",function(a,b){return db(this.rows(a,b))});p("row().data()",function(a){var b=this.context;if(a===k)return b.length&&this.length?b[0].aoData[this[0]]._aData:
k;b[0].aoData[this[0]]._aData=a;da(b[0],this[0],"data");return this});p("row().node()",function(){var a=this.context;return a.length&&this.length?a[0].aoData[this[0]].nTr||null:null});p("row.add()",function(a){a instanceof h&&a.length&&(a=a[0]);var b=this.iterator("table",function(b){return a.nodeName&&"TR"===a.nodeName.toUpperCase()?oa(b,a)[0]:N(b,a)});return this.row(b[0])});var eb=function(a,b){var c=a.context;if(c.length&&(c=c[0].aoData[b!==k?b:a[0]])&&c._details)c._details.remove(),c._detailsShow=
k,c._details=k},Wb=function(a,b){var c=a.context;if(c.length&&a.length){var d=c[0].aoData[a[0]];if(d._details){(d._detailsShow=b)?d._details.insertAfter(d.nTr):d._details.detach();var e=c[0],f=new t(e),g=e.aoData;f.off("draw.dt.DT_details column-visibility.dt.DT_details destroy.dt.DT_details");0<D(g,"_details").length&&(f.on("draw.dt.DT_details",function(a,b){e===b&&f.rows({page:"current"}).eq(0).each(function(a){a=g[a];a._detailsShow&&a._details.insertAfter(a.nTr)})}),f.on("column-visibility.dt.DT_details",
function(a,b){if(e===b)for(var c,d=ba(b),f=0,h=g.length;f<h;f++)c=g[f],c._details&&c._details.children("td[colspan]").attr("colspan",d)}),f.on("destroy.dt.DT_details",function(a,b){if(e===b)for(var c=0,d=g.length;c<d;c++)g[c]._details&&eb(f,c)}))}}};p("row().child()",function(a,b){var c=this.context;if(a===k)return c.length&&this.length?c[0].aoData[this[0]]._details:k;if(!0===a)this.child.show();else if(!1===a)eb(this);else if(c.length&&this.length){var d=c[0],c=c[0].aoData[this[0]],e=[],f=function(a,
b){if(h.isArray(a)||a instanceof h)for(var c=0,k=a.length;c<k;c++)f(a[c],b);else a.nodeName&&"tr"===a.nodeName.toLowerCase()?e.push(a):(c=h("<tr><td/></tr>").addClass(b),h("td",c).addClass(b).html(a)[0].colSpan=ba(d),e.push(c[0]))};f(a,b);c._details&&c._details.detach();c._details=h(e);c._detailsShow&&c._details.insertAfter(c.nTr)}return this});p(["row().child.show()","row().child().show()"],function(){Wb(this,!0);return this});p(["row().child.hide()","row().child().hide()"],function(){Wb(this,!1);
return this});p(["row().child.remove()","row().child().remove()"],function(){eb(this);return this});p("row().child.isShown()",function(){var a=this.context;return a.length&&this.length?a[0].aoData[this[0]]._detailsShow||!1:!1});var fc=/^([^:]+):(name|visIdx|visible)$/,Xb=function(a,b,c,d,e){for(var c=[],d=0,f=e.length;d<f;d++)c.push(B(a,e[d],b));return c};p("columns()",function(a,b){a===k?a="":h.isPlainObject(a)&&(b=a,a="");var b=cb(b),c=this.iterator("table",function(c){var e=a,f=b,g=c.aoColumns,
j=D(g,"sName"),i=D(g,"nTh");return bb("column",e,function(a){var b=Qb(a);if(a==="")return X(g.length);if(b!==null)return[b>=0?b:g.length+b];if(typeof a==="function"){var e=Da(c,f);return h.map(g,function(b,f){return a(f,Xb(c,f,0,0,e),i[f])?f:null})}var k=typeof a==="string"?a.match(fc):"";if(k)switch(k[2]){case "visIdx":case "visible":b=parseInt(k[1],10);if(b<0){var m=h.map(g,function(a,b){return a.bVisible?b:null});return[m[m.length+b]]}return[$(c,b)];case "name":return h.map(j,function(a,b){return a===
k[1]?b:null});default:return[]}if(a.nodeName&&a._DT_CellIndex)return[a._DT_CellIndex.column];b=h(i).filter(a).map(function(){return h.inArray(this,i)}).toArray();if(b.length||!a.nodeName)return b;b=h(a).closest("*[data-dt-column]");return b.length?[b.data("dt-column")]:[]},c,f)},1);c.selector.cols=a;c.selector.opts=b;return c});u("columns().header()","column().header()",function(){return this.iterator("column",function(a,b){return a.aoColumns[b].nTh},1)});u("columns().footer()","column().footer()",
function(){return this.iterator("column",function(a,b){return a.aoColumns[b].nTf},1)});u("columns().data()","column().data()",function(){return this.iterator("column-rows",Xb,1)});u("columns().dataSrc()","column().dataSrc()",function(){return this.iterator("column",function(a,b){return a.aoColumns[b].mData},1)});u("columns().cache()","column().cache()",function(a){return this.iterator("column-rows",function(b,c,d,e,f){return ja(b.aoData,f,"search"===a?"_aFilterData":"_aSortData",c)},1)});u("columns().nodes()",
"column().nodes()",function(){return this.iterator("column-rows",function(a,b,c,d,e){return ja(a.aoData,e,"anCells",b)},1)});u("columns().visible()","column().visible()",function(a,b){var c=this.iterator("column",function(b,c){if(a===k)return b.aoColumns[c].bVisible;var f=b.aoColumns,g=f[c],j=b.aoData,i,n,l;if(a!==k&&g.bVisible!==a){if(a){var m=h.inArray(!0,D(f,"bVisible"),c+1);i=0;for(n=j.length;i<n;i++)l=j[i].nTr,f=j[i].anCells,l&&l.insertBefore(f[c],f[m]||null)}else h(D(b.aoData,"anCells",c)).detach();
g.bVisible=a;fa(b,b.aoHeader);fa(b,b.aoFooter);za(b)}});a!==k&&(this.iterator("column",function(c,e){s(c,null,"column-visibility",[c,e,a,b])}),(b===k||b)&&this.columns.adjust());return c});u("columns().indexes()","column().index()",function(a){return this.iterator("column",function(b,c){return"visible"===a?aa(b,c):c},1)});p("columns.adjust()",function(){return this.iterator("table",function(a){Z(a)},1)});p("column.index()",function(a,b){if(0!==this.context.length){var c=this.context[0];if("fromVisible"===
a||"toData"===a)return $(c,b);if("fromData"===a||"toVisible"===a)return aa(c,b)}});p("column()",function(a,b){return db(this.columns(a,b))});p("cells()",function(a,b,c){h.isPlainObject(a)&&(a.row===k?(c=a,a=null):(c=b,b=null));h.isPlainObject(b)&&(c=b,b=null);if(null===b||b===k)return this.iterator("table",function(b){var d=a,e=cb(c),f=b.aoData,g=Da(b,e),j=Tb(ja(f,g,"anCells")),i=h([].concat.apply([],j)),l,n=b.aoColumns.length,m,p,u,t,s,v;return bb("cell",d,function(a){var c=typeof a==="function";
if(a===null||a===k||c){m=[];p=0;for(u=g.length;p<u;p++){l=g[p];for(t=0;t<n;t++){s={row:l,column:t};if(c){v=f[l];a(s,B(b,l,t),v.anCells?v.anCells[t]:null)&&m.push(s)}else m.push(s)}}return m}if(h.isPlainObject(a))return[a];c=i.filter(a).map(function(a,b){return{row:b._DT_CellIndex.row,column:b._DT_CellIndex.column}}).toArray();if(c.length||!a.nodeName)return c;v=h(a).closest("*[data-dt-row]");return v.length?[{row:v.data("dt-row"),column:v.data("dt-column")}]:[]},b,e)});var d=this.columns(b,c),e=this.rows(a,
c),f,g,j,i,n,l=this.iterator("table",function(a,b){f=[];g=0;for(j=e[b].length;g<j;g++){i=0;for(n=d[b].length;i<n;i++)f.push({row:e[b][g],column:d[b][i]})}return f},1);h.extend(l.selector,{cols:b,rows:a,opts:c});return l});u("cells().nodes()","cell().node()",function(){return this.iterator("cell",function(a,b,c){return(a=a.aoData[b])&&a.anCells?a.anCells[c]:k},1)});p("cells().data()",function(){return this.iterator("cell",function(a,b,c){return B(a,b,c)},1)});u("cells().cache()","cell().cache()",function(a){a=
"search"===a?"_aFilterData":"_aSortData";return this.iterator("cell",function(b,c,d){return b.aoData[c][a][d]},1)});u("cells().render()","cell().render()",function(a){return this.iterator("cell",function(b,c,d){return B(b,c,d,a)},1)});u("cells().indexes()","cell().index()",function(){return this.iterator("cell",function(a,b,c){return{row:b,column:c,columnVisible:aa(a,c)}},1)});u("cells().invalidate()","cell().invalidate()",function(a){return this.iterator("cell",function(b,c,d){da(b,c,a,d)})});p("cell()",
function(a,b,c){return db(this.cells(a,b,c))});p("cell().data()",function(a){var b=this.context,c=this[0];if(a===k)return b.length&&c.length?B(b[0],c[0].row,c[0].column):k;lb(b[0],c[0].row,c[0].column,a);da(b[0],c[0].row,"data",c[0].column);return this});p("order()",function(a,b){var c=this.context;if(a===k)return 0!==c.length?c[0].aaSorting:k;"number"===typeof a?a=[[a,b]]:a.length&&!h.isArray(a[0])&&(a=Array.prototype.slice.call(arguments));return this.iterator("table",function(b){b.aaSorting=a.slice()})});
p("order.listener()",function(a,b,c){return this.iterator("table",function(d){Oa(d,a,b,c)})});p("order.fixed()",function(a){if(!a){var b=this.context,b=b.length?b[0].aaSortingFixed:k;return h.isArray(b)?{pre:b}:b}return this.iterator("table",function(b){b.aaSortingFixed=h.extend(!0,{},a)})});p(["columns().order()","column().order()"],function(a){var b=this;return this.iterator("table",function(c,d){var e=[];h.each(b[d],function(b,c){e.push([c,a])});c.aaSorting=e})});p("search()",function(a,b,c,d){var e=
this.context;return a===k?0!==e.length?e[0].oPreviousSearch.sSearch:k:this.iterator("table",function(e){e.oFeatures.bFilter&&ga(e,h.extend({},e.oPreviousSearch,{sSearch:a+"",bRegex:null===b?!1:b,bSmart:null===c?!0:c,bCaseInsensitive:null===d?!0:d}),1)})});u("columns().search()","column().search()",function(a,b,c,d){return this.iterator("column",function(e,f){var g=e.aoPreSearchCols;if(a===k)return g[f].sSearch;e.oFeatures.bFilter&&(h.extend(g[f],{sSearch:a+"",bRegex:null===b?!1:b,bSmart:null===c?
!0:c,bCaseInsensitive:null===d?!0:d}),ga(e,e.oPreviousSearch,1))})});p("state()",function(){return this.context.length?this.context[0].oSavedState:null});p("state.clear()",function(){return this.iterator("table",function(a){a.fnStateSaveCallback.call(a.oInstance,a,{})})});p("state.loaded()",function(){return this.context.length?this.context[0].oLoadedState:null});p("state.save()",function(){return this.iterator("table",function(a){za(a)})});m.versionCheck=m.fnVersionCheck=function(a){for(var b=m.version.split("."),
a=a.split("."),c,d,e=0,f=a.length;e<f;e++)if(c=parseInt(b[e],10)||0,d=parseInt(a[e],10)||0,c!==d)return c>d;return!0};m.isDataTable=m.fnIsDataTable=function(a){var b=h(a).get(0),c=!1;if(a instanceof m.Api)return!0;h.each(m.settings,function(a,e){var f=e.nScrollHead?h("table",e.nScrollHead)[0]:null,g=e.nScrollFoot?h("table",e.nScrollFoot)[0]:null;if(e.nTable===b||f===b||g===b)c=!0});return c};m.tables=m.fnTables=function(a){var b=!1;h.isPlainObject(a)&&(b=a.api,a=a.visible);var c=h.map(m.settings,
function(b){if(!a||a&&h(b.nTable).is(":visible"))return b.nTable});return b?new t(c):c};m.camelToHungarian=J;p("$()",function(a,b){var c=this.rows(b).nodes(),c=h(c);return h([].concat(c.filter(a).toArray(),c.find(a).toArray()))});h.each(["on","one","off"],function(a,b){p(b+"()",function(){var a=Array.prototype.slice.call(arguments);a[0]=h.map(a[0].split(/\s/),function(a){return!a.match(/\.dt\b/)?a+".dt":a}).join(" ");var d=h(this.tables().nodes());d[b].apply(d,a);return this})});p("clear()",function(){return this.iterator("table",
function(a){pa(a)})});p("settings()",function(){return new t(this.context,this.context)});p("init()",function(){var a=this.context;return a.length?a[0].oInit:null});p("data()",function(){return this.iterator("table",function(a){return D(a.aoData,"_aData")}).flatten()});p("destroy()",function(a){a=a||!1;return this.iterator("table",function(b){var c=b.nTableWrapper.parentNode,d=b.oClasses,e=b.nTable,f=b.nTBody,g=b.nTHead,j=b.nTFoot,i=h(e),f=h(f),k=h(b.nTableWrapper),l=h.map(b.aoData,function(a){return a.nTr}),
p;b.bDestroying=!0;s(b,"aoDestroyCallback","destroy",[b]);a||(new t(b)).columns().visible(!0);k.off(".DT").find(":not(tbody *)").off(".DT");h(E).off(".DT-"+b.sInstance);e!=g.parentNode&&(i.children("thead").detach(),i.append(g));j&&e!=j.parentNode&&(i.children("tfoot").detach(),i.append(j));b.aaSorting=[];b.aaSortingFixed=[];ya(b);h(l).removeClass(b.asStripeClasses.join(" "));h("th, td",g).removeClass(d.sSortable+" "+d.sSortableAsc+" "+d.sSortableDesc+" "+d.sSortableNone);b.bJUI&&(h("th span."+d.sSortIcon+
", td span."+d.sSortIcon,g).detach(),h("th, td",g).each(function(){var a=h("div."+d.sSortJUIWrapper,this);h(this).append(a.contents());a.detach()}));f.children().detach();f.append(l);g=a?"remove":"detach";i[g]();k[g]();!a&&c&&(c.insertBefore(e,b.nTableReinsertBefore),i.css("width",b.sDestroyWidth).removeClass(d.sTable),(p=b.asDestroyStripes.length)&&f.children().each(function(a){h(this).addClass(b.asDestroyStripes[a%p])}));c=h.inArray(b,m.settings);-1!==c&&m.settings.splice(c,1)})});h.each(["column",
"row","cell"],function(a,b){p(b+"s().every()",function(a){var d=this.selector.opts,e=this;return this.iterator(b,function(f,g,h,i,m){a.call(e[b](g,"cell"===b?h:d,"cell"===b?d:k),g,h,i,m)})})});p("i18n()",function(a,b,c){var d=this.context[0],a=R(a)(d.oLanguage);a===k&&(a=b);c!==k&&h.isPlainObject(a)&&(a=a[c]!==k?a[c]:a._);return a.replace("%d",c)});m.version="1.10.15";m.settings=[];m.models={};m.models.oSearch={bCaseInsensitive:!0,sSearch:"",bRegex:!1,bSmart:!0};m.models.oRow={nTr:null,anCells:null,
_aData:[],_aSortData:null,_aFilterData:null,_sFilterRow:null,_sRowStripe:"",src:null,idx:-1};m.models.oColumn={idx:null,aDataSort:null,asSorting:null,bSearchable:null,bSortable:null,bVisible:null,_sManualType:null,_bAttrSrc:!1,fnCreatedCell:null,fnGetData:null,fnSetData:null,mData:null,mRender:null,nTh:null,nTf:null,sClass:null,sContentPadding:null,sDefaultContent:null,sName:null,sSortDataType:"std",sSortingClass:null,sSortingClassJUI:null,sTitle:null,sType:null,sWidth:null,sWidthOrig:null};m.defaults=
{aaData:null,aaSorting:[[0,"asc"]],aaSortingFixed:[],ajax:null,aLengthMenu:[10,25,50,100],aoColumns:null,aoColumnDefs:null,aoSearchCols:[],asStripeClasses:null,bAutoWidth:!0,bDeferRender:!1,bDestroy:!1,bFilter:!0,bInfo:!0,bJQueryUI:!1,bLengthChange:!0,bPaginate:!0,bProcessing:!1,bRetrieve:!1,bScrollCollapse:!1,bServerSide:!1,bSort:!0,bSortMulti:!0,bSortCellsTop:!1,bSortClasses:!0,bStateSave:!1,fnCreatedRow:null,fnDrawCallback:null,fnFooterCallback:null,fnFormatNumber:function(a){return a.toString().replace(/\B(?=(\d{3})+(?!\d))/g,
this.oLanguage.sThousands)},fnHeaderCallback:null,fnInfoCallback:null,fnInitComplete:null,fnPreDrawCallback:null,fnRowCallback:null,fnServerData:null,fnServerParams:null,fnStateLoadCallback:function(a){try{return JSON.parse((-1===a.iStateDuration?sessionStorage:localStorage).getItem("DataTables_"+a.sInstance+"_"+location.pathname))}catch(b){}},fnStateLoadParams:null,fnStateLoaded:null,fnStateSaveCallback:function(a,b){try{(-1===a.iStateDuration?sessionStorage:localStorage).setItem("DataTables_"+a.sInstance+
"_"+location.pathname,JSON.stringify(b))}catch(c){}},fnStateSaveParams:null,iStateDuration:7200,iDeferLoading:null,iDisplayLength:10,iDisplayStart:0,iTabIndex:0,oClasses:{},oLanguage:{oAria:{sSortAscending:": activate to sort column ascending",sSortDescending:": activate to sort column descending"},oPaginate:{sFirst:"First",sLast:"Last",sNext:"Next",sPrevious:"Previous"},sEmptyTable:"No data available in table",sInfo:"Showing _START_ to _END_ of _TOTAL_ entries",sInfoEmpty:"Showing 0 to 0 of 0 entries",
sInfoFiltered:"(filtered from _MAX_ total entries)",sInfoPostFix:"",sDecimal:"",sThousands:",",sLengthMenu:"Show _MENU_ entries",sLoadingRecords:"Loading...",sProcessing:"Processing...",sSearch:"Search:",sSearchPlaceholder:"",sUrl:"",sZeroRecords:"No matching records found"},oSearch:h.extend({},m.models.oSearch),sAjaxDataProp:"data",sAjaxSource:null,sDom:"lfrtip",searchDelay:null,sPaginationType:"simple_numbers",sScrollX:"",sScrollXInner:"",sScrollY:"",sServerMethod:"GET",renderer:null,rowId:"DT_RowId"};
Y(m.defaults);m.defaults.column={aDataSort:null,iDataSort:-1,asSorting:["asc","desc"],bSearchable:!0,bSortable:!0,bVisible:!0,fnCreatedCell:null,mData:null,mRender:null,sCellType:"td",sClass:"",sContentPadding:"",sDefaultContent:null,sName:"",sSortDataType:"std",sTitle:null,sType:null,sWidth:null};Y(m.defaults.column);m.models.oSettings={oFeatures:{bAutoWidth:null,bDeferRender:null,bFilter:null,bInfo:null,bLengthChange:null,bPaginate:null,bProcessing:null,bServerSide:null,bSort:null,bSortMulti:null,
bSortClasses:null,bStateSave:null},oScroll:{bCollapse:null,iBarWidth:0,sX:null,sXInner:null,sY:null},oLanguage:{fnInfoCallback:null},oBrowser:{bScrollOversize:!1,bScrollbarLeft:!1,bBounding:!1,barWidth:0},ajax:null,aanFeatures:[],aoData:[],aiDisplay:[],aiDisplayMaster:[],aIds:{},aoColumns:[],aoHeader:[],aoFooter:[],oPreviousSearch:{},aoPreSearchCols:[],aaSorting:null,aaSortingFixed:[],asStripeClasses:null,asDestroyStripes:[],sDestroyWidth:0,aoRowCallback:[],aoHeaderCallback:[],aoFooterCallback:[],
aoDrawCallback:[],aoRowCreatedCallback:[],aoPreDrawCallback:[],aoInitComplete:[],aoStateSaveParams:[],aoStateLoadParams:[],aoStateLoaded:[],sTableId:"",nTable:null,nTHead:null,nTFoot:null,nTBody:null,nTableWrapper:null,bDeferLoading:!1,bInitialised:!1,aoOpenRows:[],sDom:null,searchDelay:null,sPaginationType:"two_button",iStateDuration:0,aoStateSave:[],aoStateLoad:[],oSavedState:null,oLoadedState:null,sAjaxSource:null,sAjaxDataProp:null,bAjaxDataGet:!0,jqXHR:null,json:k,oAjaxData:k,fnServerData:null,
aoServerParams:[],sServerMethod:null,fnFormatNumber:null,aLengthMenu:null,iDraw:0,bDrawing:!1,iDrawError:-1,_iDisplayLength:10,_iDisplayStart:0,_iRecordsTotal:0,_iRecordsDisplay:0,bJUI:null,oClasses:{},bFiltered:!1,bSorted:!1,bSortCellsTop:null,oInit:null,aoDestroyCallback:[],fnRecordsTotal:function(){return"ssp"==y(this)?1*this._iRecordsTotal:this.aiDisplayMaster.length},fnRecordsDisplay:function(){return"ssp"==y(this)?1*this._iRecordsDisplay:this.aiDisplay.length},fnDisplayEnd:function(){var a=
this._iDisplayLength,b=this._iDisplayStart,c=b+a,d=this.aiDisplay.length,e=this.oFeatures,f=e.bPaginate;return e.bServerSide?!1===f||-1===a?b+d:Math.min(b+a,this._iRecordsDisplay):!f||c>d||-1===a?d:c},oInstance:null,sInstance:null,iTabIndex:0,nScrollHead:null,nScrollFoot:null,aLastSort:[],oPlugins:{},rowIdFn:null,rowId:null};m.ext=x={buttons:{},classes:{},builder:"-source-",errMode:"alert",feature:[],search:[],selector:{cell:[],column:[],row:[]},internal:{},legacy:{ajax:null},pager:{},renderer:{pageButton:{},
header:{}},order:{},type:{detect:[],search:{},order:{}},_unique:0,fnVersionCheck:m.fnVersionCheck,iApiIndex:0,oJUIClasses:{},sVersion:m.version};h.extend(x,{afnFiltering:x.search,aTypes:x.type.detect,ofnSearch:x.type.search,oSort:x.type.order,afnSortData:x.order,aoFeatures:x.feature,oApi:x.internal,oStdClasses:x.classes,oPagination:x.pager});h.extend(m.ext.classes,{sTable:"dataTable",sNoFooter:"no-footer",sPageButton:"paginate_button",sPageButtonActive:"current",sPageButtonDisabled:"disabled",sStripeOdd:"odd",
sStripeEven:"even",sRowEmpty:"dataTables_empty",sWrapper:"dataTables_wrapper",sFilter:"dataTables_filter",sInfo:"dataTables_info",sPaging:"dataTables_paginate paging_",sLength:"dataTables_length",sProcessing:"dataTables_processing",sSortAsc:"sorting_asc",sSortDesc:"sorting_desc",sSortable:"sorting",sSortableAsc:"sorting_asc_disabled",sSortableDesc:"sorting_desc_disabled",sSortableNone:"sorting_disabled",sSortColumn:"sorting_",sFilterInput:"",sLengthSelect:"",sScrollWrapper:"dataTables_scroll",sScrollHead:"dataTables_scrollHead",
sScrollHeadInner:"dataTables_scrollHeadInner",sScrollBody:"dataTables_scrollBody",sScrollFoot:"dataTables_scrollFoot",sScrollFootInner:"dataTables_scrollFootInner",sHeaderTH:"",sFooterTH:"",sSortJUIAsc:"",sSortJUIDesc:"",sSortJUI:"",sSortJUIAscAllowed:"",sSortJUIDescAllowed:"",sSortJUIWrapper:"",sSortIcon:"",sJUIHeader:"",sJUIFooter:""});var Ea="",Ea="",G=Ea+"ui-state-default",ka=Ea+"css_right ui-icon ui-icon-",Yb=Ea+"fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix";h.extend(m.ext.oJUIClasses,
m.ext.classes,{sPageButton:"fg-button ui-button "+G,sPageButtonActive:"ui-state-disabled",sPageButtonDisabled:"ui-state-disabled",sPaging:"dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi paging_",sSortAsc:G+" sorting_asc",sSortDesc:G+" sorting_desc",sSortable:G+" sorting",sSortableAsc:G+" sorting_asc_disabled",sSortableDesc:G+" sorting_desc_disabled",sSortableNone:G+" sorting_disabled",sSortJUIAsc:ka+"triangle-1-n",sSortJUIDesc:ka+"triangle-1-s",sSortJUI:ka+"carat-2-n-s",
sSortJUIAscAllowed:ka+"carat-1-n",sSortJUIDescAllowed:ka+"carat-1-s",sSortJUIWrapper:"DataTables_sort_wrapper",sSortIcon:"DataTables_sort_icon",sScrollHead:"dataTables_scrollHead "+G,sScrollFoot:"dataTables_scrollFoot "+G,sHeaderTH:G,sFooterTH:G,sJUIHeader:Yb+" ui-corner-tl ui-corner-tr",sJUIFooter:Yb+" ui-corner-bl ui-corner-br"});var Nb=m.ext.pager;h.extend(Nb,{simple:function(){return["previous","next"]},full:function(){return["first","previous","next","last"]},numbers:function(a,b){return[ia(a,
b)]},simple_numbers:function(a,b){return["previous",ia(a,b),"next"]},full_numbers:function(a,b){return["first","previous",ia(a,b),"next","last"]},first_last_numbers:function(a,b){return["first",ia(a,b),"last"]},_numbers:ia,numbers_length:7});h.extend(!0,m.ext.renderer,{pageButton:{_:function(a,b,c,d,e,f){var g=a.oClasses,j=a.oLanguage.oPaginate,i=a.oLanguage.oAria.paginate||{},m,l,p=0,r=function(b,d){var k,t,u,s,v=function(b){Va(a,b.data.action,true)};k=0;for(t=d.length;k<t;k++){s=d[k];if(h.isArray(s)){u=
h("<"+(s.DT_el||"div")+"/>").appendTo(b);r(u,s)}else{m=null;l="";switch(s){case "ellipsis":b.append('<span class="ellipsis">&#x2026;</span>');break;case "first":m=j.sFirst;l=s+(e>0?"":" "+g.sPageButtonDisabled);break;case "previous":m=j.sPrevious;l=s+(e>0?"":" "+g.sPageButtonDisabled);break;case "next":m=j.sNext;l=s+(e<f-1?"":" "+g.sPageButtonDisabled);break;case "last":m=j.sLast;l=s+(e<f-1?"":" "+g.sPageButtonDisabled);break;default:m=s+1;l=e===s?g.sPageButtonActive:""}if(m!==null){u=h("<a>",{"class":g.sPageButton+
" "+l,"aria-controls":a.sTableId,"aria-label":i[s],"data-dt-idx":p,tabindex:a.iTabIndex,id:c===0&&typeof s==="string"?a.sTableId+"_"+s:null}).html(m).appendTo(b);Ya(u,{action:s},v);p++}}}},t;try{t=h(b).find(H.activeElement).data("dt-idx")}catch(u){}r(h(b).empty(),d);t!==k&&h(b).find("[data-dt-idx="+t+"]").focus()}}});h.extend(m.ext.type.detect,[function(a,b){var c=b.oLanguage.sDecimal;return ab(a,c)?"num"+c:null},function(a){if(a&&!(a instanceof Date)&&!cc.test(a))return null;var b=Date.parse(a);
return null!==b&&!isNaN(b)||M(a)?"date":null},function(a,b){var c=b.oLanguage.sDecimal;return ab(a,c,!0)?"num-fmt"+c:null},function(a,b){var c=b.oLanguage.sDecimal;return Sb(a,c)?"html-num"+c:null},function(a,b){var c=b.oLanguage.sDecimal;return Sb(a,c,!0)?"html-num-fmt"+c:null},function(a){return M(a)||"string"===typeof a&&-1!==a.indexOf("<")?"html":null}]);h.extend(m.ext.type.search,{html:function(a){return M(a)?a:"string"===typeof a?a.replace(Pb," ").replace(Ca,""):""},string:function(a){return M(a)?
a:"string"===typeof a?a.replace(Pb," "):a}});var Ba=function(a,b,c,d){if(0!==a&&(!a||"-"===a))return-Infinity;b&&(a=Rb(a,b));a.replace&&(c&&(a=a.replace(c,"")),d&&(a=a.replace(d,"")));return 1*a};h.extend(x.type.order,{"date-pre":function(a){return Date.parse(a)||-Infinity},"html-pre":function(a){return M(a)?"":a.replace?a.replace(/<.*?>/g,"").toLowerCase():a+""},"string-pre":function(a){return M(a)?"":"string"===typeof a?a.toLowerCase():!a.toString?"":a.toString()},"string-asc":function(a,b){return a<
b?-1:a>b?1:0},"string-desc":function(a,b){return a<b?1:a>b?-1:0}});fb("");h.extend(!0,m.ext.renderer,{header:{_:function(a,b,c,d){h(a.nTable).on("order.dt.DT",function(e,f,g,h){if(a===f){e=c.idx;b.removeClass(c.sSortingClass+" "+d.sSortAsc+" "+d.sSortDesc).addClass(h[e]=="asc"?d.sSortAsc:h[e]=="desc"?d.sSortDesc:c.sSortingClass)}})},jqueryui:function(a,b,c,d){h("<div/>").addClass(d.sSortJUIWrapper).append(b.contents()).append(h("<span/>").addClass(d.sSortIcon+" "+c.sSortingClassJUI)).appendTo(b);
h(a.nTable).on("order.dt.DT",function(e,f,g,h){if(a===f){e=c.idx;b.removeClass(d.sSortAsc+" "+d.sSortDesc).addClass(h[e]=="asc"?d.sSortAsc:h[e]=="desc"?d.sSortDesc:c.sSortingClass);b.find("span."+d.sSortIcon).removeClass(d.sSortJUIAsc+" "+d.sSortJUIDesc+" "+d.sSortJUI+" "+d.sSortJUIAscAllowed+" "+d.sSortJUIDescAllowed).addClass(h[e]=="asc"?d.sSortJUIAsc:h[e]=="desc"?d.sSortJUIDesc:c.sSortingClassJUI)}})}}});var Zb=function(a){return"string"===typeof a?a.replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,
"&quot;"):a};m.render={number:function(a,b,c,d,e){return{display:function(f){if("number"!==typeof f&&"string"!==typeof f)return f;var g=0>f?"-":"",h=parseFloat(f);if(isNaN(h))return Zb(f);h=h.toFixed(c);f=Math.abs(h);h=parseInt(f,10);f=c?b+(f-h).toFixed(c).substring(2):"";return g+(d||"")+h.toString().replace(/\B(?=(\d{3})+(?!\d))/g,a)+f+(e||"")}}},text:function(){return{display:Zb}}};h.extend(m.ext.internal,{_fnExternApiFunc:Ob,_fnBuildAjax:ua,_fnAjaxUpdate:nb,_fnAjaxParameters:wb,_fnAjaxUpdateDraw:xb,
_fnAjaxDataSrc:va,_fnAddColumn:Ga,_fnColumnOptions:la,_fnAdjustColumnSizing:Z,_fnVisibleToColumnIndex:$,_fnColumnIndexToVisible:aa,_fnVisbleColumns:ba,_fnGetColumns:na,_fnColumnTypes:Ia,_fnApplyColumnDefs:kb,_fnHungarianMap:Y,_fnCamelToHungarian:J,_fnLanguageCompat:Fa,_fnBrowserDetect:ib,_fnAddData:N,_fnAddTr:oa,_fnNodeToDataIndex:function(a,b){return b._DT_RowIndex!==k?b._DT_RowIndex:null},_fnNodeToColumnIndex:function(a,b,c){return h.inArray(c,a.aoData[b].anCells)},_fnGetCellData:B,_fnSetCellData:lb,
_fnSplitObjNotation:La,_fnGetObjectDataFn:R,_fnSetObjectDataFn:S,_fnGetDataMaster:Ma,_fnClearTable:pa,_fnDeleteIndex:qa,_fnInvalidate:da,_fnGetRowElements:Ka,_fnCreateTr:Ja,_fnBuildHead:mb,_fnDrawHead:fa,_fnDraw:O,_fnReDraw:T,_fnAddOptionsHtml:pb,_fnDetectHeader:ea,_fnGetUniqueThs:ta,_fnFeatureHtmlFilter:rb,_fnFilterComplete:ga,_fnFilterCustom:Ab,_fnFilterColumn:zb,_fnFilter:yb,_fnFilterCreateSearch:Ra,_fnEscapeRegex:Sa,_fnFilterData:Bb,_fnFeatureHtmlInfo:ub,_fnUpdateInfo:Eb,_fnInfoMacros:Fb,_fnInitialise:ha,
_fnInitComplete:wa,_fnLengthChange:Ta,_fnFeatureHtmlLength:qb,_fnFeatureHtmlPaginate:vb,_fnPageChange:Va,_fnFeatureHtmlProcessing:sb,_fnProcessingDisplay:C,_fnFeatureHtmlTable:tb,_fnScrollDraw:ma,_fnApplyToChildren:I,_fnCalculateColumnWidths:Ha,_fnThrottle:Qa,_fnConvertToWidth:Gb,_fnGetWidestNode:Hb,_fnGetMaxLenString:Ib,_fnStringToCss:v,_fnSortFlatten:W,_fnSort:ob,_fnSortAria:Kb,_fnSortListener:Xa,_fnSortAttachListener:Oa,_fnSortingClasses:ya,_fnSortData:Jb,_fnSaveState:za,_fnLoadState:Lb,_fnSettingsFromNode:Aa,
_fnLog:K,_fnMap:F,_fnBindAction:Ya,_fnCallbackReg:z,_fnCallbackFire:s,_fnLengthOverflow:Ua,_fnRenderer:Pa,_fnDataSource:y,_fnRowAttributes:Na,_fnCalculateEnd:function(){}});h.fn.dataTable=m;m.$=h;h.fn.dataTableSettings=m.settings;h.fn.dataTableExt=m.ext;h.fn.DataTable=function(a){return h(this).dataTable(a).api()};h.each(m,function(a,b){h.fn.DataTable[a]=b});return h.fn.dataTable});

/*!
 DataTables Bootstrap 3 integration
 ©2011-2015 SpryMedia Ltd - datatables.net/license
*/
(function(b){"function"===typeof define&&define.amd?define(["jquery","datatables.net"],function(a){return b(a,window,document)}):"object"===typeof exports?module.exports=function(a,d){a||(a=window);if(!d||!d.fn.dataTable)d=require("datatables.net")(a,d).$;return b(d,a,a.document)}:b(jQuery,window,document)})(function(b,a,d,m){var f=b.fn.dataTable;b.extend(!0,f.defaults,{dom:"<'row'<'col-sm-6'l><'col-sm-6'f>><'row'<'col-sm-12'tr>><'row'<'col-sm-5'i><'col-sm-7'p>>",renderer:"bootstrap"});b.extend(f.ext.classes,
{sWrapper:"dataTables_wrapper dt-bootstrap",sFilterInput:"form-control input-sm",sLengthSelect:"form-control input-sm",sProcessing:"dataTables_processing panel panel-default"});f.ext.renderer.pageButton.bootstrap=function(a,h,r,s,j,n){var o=new f.Api(a),t=a.oClasses,k=a.oLanguage.oPaginate,u=a.oLanguage.oAria.paginate||{},e,g,p=0,q=function(d,f){var l,h,i,c,m=function(a){a.preventDefault();!b(a.currentTarget).hasClass("disabled")&&o.page()!=a.data.action&&o.page(a.data.action).draw("page")};
l=0;for(h=f.length;l<h;l++)if(c=f[l],b.isArray(c))q(d,c);else{g=e="";switch(c){case "ellipsis":e="&#x2026;";g="disabled";break;case "first":e=k.sFirst;g=c+(0<j?"":" disabled");break;case "previous":e=k.sPrevious;g=c+(0<j?"":" disabled");break;case "next":e=k.sNext;g=c+(j<n-1?"":" disabled");break;case "last":e=k.sLast;g=c+(j<n-1?"":" disabled");break;default:e=c+1,g=j===c?"active":""}e&&(i=b("<li>",{"class":t.sPageButton+" "+g,id:0===r&&"string"===typeof c?a.sTableId+"_"+c:null}).append(b("<a>",{href:"#",
"aria-controls":a.sTableId,"aria-label":u[c],"data-dt-idx":p,tabindex:a.iTabIndex}).html(e)).appendTo(d),a.oApi._fnBindAction(i,{action:c},m),p++)}},i;try{i=b(h).find(d.activeElement).data("dt-idx")}catch(v){}q(b(h).empty().html('<ul class="pagination"/>').children("ul"),s);i!==m&&b(h).find("[data-dt-idx="+i+"]").focus()};return f});

/*
 Copyright (C) Federico Zivolo 2017
 Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).
 */(function(e,t){'object'==typeof exports&&'undefined'!=typeof module?module.exports=t():'function'==typeof define&&define.amd?define(t):e.Popper=t()})(this,function(){'use strict';function e(e){return e&&'[object Function]'==={}.toString.call(e)}function t(e,t){if(1!==e.nodeType)return[];var o=window.getComputedStyle(e,null);return t?o[t]:o}function o(e){return'HTML'===e.nodeName?e:e.parentNode||e.host}function n(e){if(!e||-1!==['HTML','BODY','#document'].indexOf(e.nodeName))return window.document.body;var i=t(e),r=i.overflow,p=i.overflowX,s=i.overflowY;return /(auto|scroll)/.test(r+s+p)?e:n(o(e))}function r(e){var o=e&&e.offsetParent,i=o&&o.nodeName;return i&&'BODY'!==i&&'HTML'!==i?-1!==['TD','TABLE'].indexOf(o.nodeName)&&'static'===t(o,'position')?r(o):o:window.document.documentElement}function p(e){var t=e.nodeName;return'BODY'!==t&&('HTML'===t||r(e.firstElementChild)===e)}function s(e){return null===e.parentNode?e:s(e.parentNode)}function d(e,t){if(!e||!e.nodeType||!t||!t.nodeType)return window.document.documentElement;var o=e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_FOLLOWING,i=o?e:t,n=o?t:e,a=document.createRange();a.setStart(i,0),a.setEnd(n,0);var f=a.commonAncestorContainer;if(e!==f&&t!==f||i.contains(n))return p(f)?f:r(f);var l=s(e);return l.host?d(l.host,t):d(e,s(t).host)}function a(e){var t=1<arguments.length&&void 0!==arguments[1]?arguments[1]:'top',o='top'===t?'scrollTop':'scrollLeft',i=e.nodeName;if('BODY'===i||'HTML'===i){var n=window.document.documentElement,r=window.document.scrollingElement||n;return r[o]}return e[o]}function f(e,t){var o=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=a(t,'top'),n=a(t,'left'),r=o?-1:1;return e.top+=i*r,e.bottom+=i*r,e.left+=n*r,e.right+=n*r,e}function l(e,t){var o='x'===t?'Left':'Top',i='Left'==o?'Right':'Bottom';return+e['border'+o+'Width'].split('px')[0]+ +e['border'+i+'Width'].split('px')[0]}function m(e,t,o,i){return _(t['offset'+e],o['client'+e],o['offset'+e],ie()?o['offset'+e]+i['margin'+('Height'===e?'Top':'Left')]+i['margin'+('Height'===e?'Bottom':'Right')]:0)}function h(){var e=window.document.body,t=window.document.documentElement,o=ie()&&window.getComputedStyle(t);return{height:m('Height',e,t,o),width:m('Width',e,t,o)}}function c(e){return se({},e,{right:e.left+e.width,bottom:e.top+e.height})}function g(e){var o={};if(ie())try{o=e.getBoundingClientRect();var i=a(e,'top'),n=a(e,'left');o.top+=i,o.left+=n,o.bottom+=i,o.right+=n}catch(e){}else o=e.getBoundingClientRect();var r={left:o.left,top:o.top,width:o.right-o.left,height:o.bottom-o.top},p='HTML'===e.nodeName?h():{},s=p.width||e.clientWidth||r.right-r.left,d=p.height||e.clientHeight||r.bottom-r.top,f=e.offsetWidth-s,m=e.offsetHeight-d;if(f||m){var g=t(e);f-=l(g,'x'),m-=l(g,'y'),r.width-=f,r.height-=m}return c(r)}function u(e,o){var i=ie(),r='HTML'===o.nodeName,p=g(e),s=g(o),d=n(e),a=t(o),l=+a.borderTopWidth.split('px')[0],m=+a.borderLeftWidth.split('px')[0],h=c({top:p.top-s.top-l,left:p.left-s.left-m,width:p.width,height:p.height});if(h.marginTop=0,h.marginLeft=0,!i&&r){var u=+a.marginTop.split('px')[0],b=+a.marginLeft.split('px')[0];h.top-=l-u,h.bottom-=l-u,h.left-=m-b,h.right-=m-b,h.marginTop=u,h.marginLeft=b}return(i?o.contains(d):o===d&&'BODY'!==d.nodeName)&&(h=f(h,o)),h}function b(e){var t=window.document.documentElement,o=u(e,t),i=_(t.clientWidth,window.innerWidth||0),n=_(t.clientHeight,window.innerHeight||0),r=a(t),p=a(t,'left'),s={top:r-o.top+o.marginTop,left:p-o.left+o.marginLeft,width:i,height:n};return c(s)}function y(e){var i=e.nodeName;return'BODY'===i||'HTML'===i?!1:'fixed'===t(e,'position')||y(o(e))}function w(e,t,i,r){var p={top:0,left:0},s=d(e,t);if('viewport'===r)p=b(s);else{var a;'scrollParent'===r?(a=n(o(e)),'BODY'===a.nodeName&&(a=window.document.documentElement)):'window'===r?a=window.document.documentElement:a=r;var f=u(a,s);if('HTML'===a.nodeName&&!y(s)){var l=h(),m=l.height,c=l.width;p.top+=f.top-f.marginTop,p.bottom=m+f.top,p.left+=f.left-f.marginLeft,p.right=c+f.left}else p=f}return p.left+=i,p.top+=i,p.right-=i,p.bottom-=i,p}function v(e){var t=e.width,o=e.height;return t*o}function E(e,t,o,i,n){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===e.indexOf('auto'))return e;var p=w(o,i,r,n),s={top:{width:p.width,height:t.top-p.top},right:{width:p.right-t.right,height:p.height},bottom:{width:p.width,height:p.bottom-t.bottom},left:{width:t.left-p.left,height:p.height}},d=Object.keys(s).map(function(e){return se({key:e},s[e],{area:v(s[e])})}).sort(function(e,t){return t.area-e.area}),a=d.filter(function(e){var t=e.width,i=e.height;return t>=o.clientWidth&&i>=o.clientHeight}),f=0<a.length?a[0].key:d[0].key,l=e.split('-')[1];return f+(l?'-'+l:'')}function x(e,t,o){var i=d(t,o);return u(o,i)}function O(e){var t=window.getComputedStyle(e),o=parseFloat(t.marginTop)+parseFloat(t.marginBottom),i=parseFloat(t.marginLeft)+parseFloat(t.marginRight),n={width:e.offsetWidth+i,height:e.offsetHeight+o};return n}function L(e){var t={left:'right',right:'left',bottom:'top',top:'bottom'};return e.replace(/left|right|bottom|top/g,function(e){return t[e]})}function S(e,t,o){o=o.split('-')[0];var i=O(e),n={width:i.width,height:i.height},r=-1!==['right','left'].indexOf(o),p=r?'top':'left',s=r?'left':'top',d=r?'height':'width',a=r?'width':'height';return n[p]=t[p]+t[d]/2-i[d]/2,n[s]=o===s?t[s]-i[a]:t[L(s)],n}function T(e,t){return Array.prototype.find?e.find(t):e.filter(t)[0]}function C(e,t,o){if(Array.prototype.findIndex)return e.findIndex(function(e){return e[t]===o});var i=T(e,function(e){return e[t]===o});return e.indexOf(i)}function N(t,o,i){var n=void 0===i?t:t.slice(0,C(t,'name',i));return n.forEach(function(t){t.function&&console.warn('`modifier.function` is deprecated, use `modifier.fn`!');var i=t.function||t.fn;t.enabled&&e(i)&&(o.offsets.popper=c(o.offsets.popper),o.offsets.reference=c(o.offsets.reference),o=i(o,t))}),o}function k(){if(!this.state.isDestroyed){var e={instance:this,styles:{},attributes:{},flipped:!1,offsets:{}};e.offsets.reference=x(this.state,this.popper,this.reference),e.placement=E(this.options.placement,e.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),e.originalPlacement=e.placement,e.offsets.popper=S(this.popper,e.offsets.reference,e.placement),e.offsets.popper.position='absolute',e=N(this.modifiers,e),this.state.isCreated?this.options.onUpdate(e):(this.state.isCreated=!0,this.options.onCreate(e))}}function W(e,t){return e.some(function(e){var o=e.name,i=e.enabled;return i&&o===t})}function B(e){for(var t=[!1,'ms','Webkit','Moz','O'],o=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<t.length-1;n++){var i=t[n],r=i?''+i+o:e;if('undefined'!=typeof window.document.body.style[r])return r}return null}function D(){return this.state.isDestroyed=!0,W(this.modifiers,'applyStyle')&&(this.popper.removeAttribute('x-placement'),this.popper.style.left='',this.popper.style.position='',this.popper.style.top='',this.popper.style[B('transform')]=''),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}function H(e,t,o,i){var r='BODY'===e.nodeName,p=r?window:e;p.addEventListener(t,o,{passive:!0}),r||H(n(p.parentNode),t,o,i),i.push(p)}function P(e,t,o,i){o.updateBound=i,window.addEventListener('resize',o.updateBound,{passive:!0});var r=n(e);return H(r,'scroll',o.updateBound,o.scrollParents),o.scrollElement=r,o.eventsEnabled=!0,o}function A(){this.state.eventsEnabled||(this.state=P(this.reference,this.options,this.state,this.scheduleUpdate))}function M(e,t){return window.removeEventListener('resize',t.updateBound),t.scrollParents.forEach(function(e){e.removeEventListener('scroll',t.updateBound)}),t.updateBound=null,t.scrollParents=[],t.scrollElement=null,t.eventsEnabled=!1,t}function I(){this.state.eventsEnabled&&(window.cancelAnimationFrame(this.scheduleUpdate),this.state=M(this.reference,this.state))}function R(e){return''!==e&&!isNaN(parseFloat(e))&&isFinite(e)}function U(e,t){Object.keys(t).forEach(function(o){var i='';-1!==['width','height','top','right','bottom','left'].indexOf(o)&&R(t[o])&&(i='px'),e.style[o]=t[o]+i})}function Y(e,t){Object.keys(t).forEach(function(o){var i=t[o];!1===i?e.removeAttribute(o):e.setAttribute(o,t[o])})}function F(e,t,o){var i=T(e,function(e){var o=e.name;return o===t}),n=!!i&&e.some(function(e){return e.name===o&&e.enabled&&e.order<i.order});if(!n){var r='`'+t+'`';console.warn('`'+o+'`'+' modifier is required by '+r+' modifier in order to work, be sure to include it before '+r+'!')}return n}function j(e){return'end'===e?'start':'start'===e?'end':e}function K(e){var t=1<arguments.length&&void 0!==arguments[1]&&arguments[1],o=ae.indexOf(e),i=ae.slice(o+1).concat(ae.slice(0,o));return t?i.reverse():i}function q(e,t,o,i){var n=e.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+n[1],p=n[2];if(!r)return e;if(0===p.indexOf('%')){var s;switch(p){case'%p':s=o;break;case'%':case'%r':default:s=i;}var d=c(s);return d[t]/100*r}if('vh'===p||'vw'===p){var a;return a='vh'===p?_(document.documentElement.clientHeight,window.innerHeight||0):_(document.documentElement.clientWidth,window.innerWidth||0),a/100*r}return r}function G(e,t,o,i){var n=[0,0],r=-1!==['right','left'].indexOf(i),p=e.split(/(\+|\-)/).map(function(e){return e.trim()}),s=p.indexOf(T(p,function(e){return-1!==e.search(/,|\s/)}));p[s]&&-1===p[s].indexOf(',')&&console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');var d=/\s*,\s*|\s+/,a=-1===s?[p]:[p.slice(0,s).concat([p[s].split(d)[0]]),[p[s].split(d)[1]].concat(p.slice(s+1))];return a=a.map(function(e,i){var n=(1===i?!r:r)?'height':'width',p=!1;return e.reduce(function(e,t){return''===e[e.length-1]&&-1!==['+','-'].indexOf(t)?(e[e.length-1]=t,p=!0,e):p?(e[e.length-1]+=t,p=!1,e):e.concat(t)},[]).map(function(e){return q(e,n,t,o)})}),a.forEach(function(e,t){e.forEach(function(o,i){R(o)&&(n[t]+=o*('-'===e[i-1]?-1:1))})}),n}for(var z=Math.min,V=Math.floor,_=Math.max,X=['native code','[object MutationObserverConstructor]'],Q=function(e){return X.some(function(t){return-1<(e||'').toString().indexOf(t)})},J='undefined'!=typeof window,Z=['Edge','Trident','Firefox'],$=0,ee=0;ee<Z.length;ee+=1)if(J&&0<=navigator.userAgent.indexOf(Z[ee])){$=1;break}var i,te=J&&Q(window.MutationObserver),oe=te?function(e){var t=!1,o=0,i=document.createElement('span'),n=new MutationObserver(function(){e(),t=!1});return n.observe(i,{attributes:!0}),function(){t||(t=!0,i.setAttribute('x-index',o),++o)}}:function(e){var t=!1;return function(){t||(t=!0,setTimeout(function(){t=!1,e()},$))}},ie=function(){return void 0==i&&(i=-1!==navigator.appVersion.indexOf('MSIE 10')),i},ne=function(e,t){if(!(e instanceof t))throw new TypeError('Cannot call a class as a function')},re=function(){function e(e,t){for(var o,n=0;n<t.length;n++)o=t[n],o.enumerable=o.enumerable||!1,o.configurable=!0,'value'in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}return function(t,o,i){return o&&e(t.prototype,o),i&&e(t,i),t}}(),pe=function(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e},se=Object.assign||function(e){for(var t,o=1;o<arguments.length;o++)for(var i in t=arguments[o],t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e},de=['auto-start','auto','auto-end','top-start','top','top-end','right-start','right','right-end','bottom-end','bottom','bottom-start','left-end','left','left-start'],ae=de.slice(3),fe={FLIP:'flip',CLOCKWISE:'clockwise',COUNTERCLOCKWISE:'counterclockwise'},le=function(){function t(o,i){var n=this,r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};ne(this,t),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=oe(this.update.bind(this)),this.options=se({},t.Defaults,r),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=o.jquery?o[0]:o,this.popper=i.jquery?i[0]:i,this.options.modifiers={},Object.keys(se({},t.Defaults.modifiers,r.modifiers)).forEach(function(e){n.options.modifiers[e]=se({},t.Defaults.modifiers[e]||{},r.modifiers?r.modifiers[e]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(e){return se({name:e},n.options.modifiers[e])}).sort(function(e,t){return e.order-t.order}),this.modifiers.forEach(function(t){t.enabled&&e(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var p=this.options.eventsEnabled;p&&this.enableEventListeners(),this.state.eventsEnabled=p}return re(t,[{key:'update',value:function(){return k.call(this)}},{key:'destroy',value:function(){return D.call(this)}},{key:'enableEventListeners',value:function(){return A.call(this)}},{key:'disableEventListeners',value:function(){return I.call(this)}}]),t}();return le.Utils=('undefined'==typeof window?global:window).PopperUtils,le.placements=de,le.Defaults={placement:'bottom',eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(e){var t=e.placement,o=t.split('-')[0],i=t.split('-')[1];if(i){var n=e.offsets,r=n.reference,p=n.popper,s=-1!==['bottom','top'].indexOf(o),d=s?'left':'top',a=s?'width':'height',f={start:pe({},d,r[d]),end:pe({},d,r[d]+r[a]-p[a])};e.offsets.popper=se({},p,f[i])}return e}},offset:{order:200,enabled:!0,fn:function(e,t){var o,i=t.offset,n=e.placement,r=e.offsets,p=r.popper,s=r.reference,d=n.split('-')[0];return o=R(+i)?[+i,0]:G(i,p,s,d),'left'===d?(p.top+=o[0],p.left-=o[1]):'right'===d?(p.top+=o[0],p.left+=o[1]):'top'===d?(p.left+=o[0],p.top-=o[1]):'bottom'===d&&(p.left+=o[0],p.top+=o[1]),e.popper=p,e},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(e,t){var o=t.boundariesElement||r(e.instance.popper);e.instance.reference===o&&(o=r(o));var i=w(e.instance.popper,e.instance.reference,t.padding,o);t.boundaries=i;var n=t.priority,p=e.offsets.popper,s={primary:function(e){var o=p[e];return p[e]<i[e]&&!t.escapeWithReference&&(o=_(p[e],i[e])),pe({},e,o)},secondary:function(e){var o='right'===e?'left':'top',n=p[o];return p[e]>i[e]&&!t.escapeWithReference&&(n=z(p[o],i[e]-('right'===e?p.width:p.height))),pe({},o,n)}};return n.forEach(function(e){var t=-1===['left','top'].indexOf(e)?'secondary':'primary';p=se({},p,s[t](e))}),e.offsets.popper=p,e},priority:['left','right','top','bottom'],padding:5,boundariesElement:'scrollParent'},keepTogether:{order:400,enabled:!0,fn:function(e){var t=e.offsets,o=t.popper,i=t.reference,n=e.placement.split('-')[0],r=V,p=-1!==['top','bottom'].indexOf(n),s=p?'right':'bottom',d=p?'left':'top',a=p?'width':'height';return o[s]<r(i[d])&&(e.offsets.popper[d]=r(i[d])-o[a]),o[d]>r(i[s])&&(e.offsets.popper[d]=r(i[s])),e}},arrow:{order:500,enabled:!0,fn:function(e,t){if(!F(e.instance.modifiers,'arrow','keepTogether'))return e;var o=t.element;if('string'==typeof o){if(o=e.instance.popper.querySelector(o),!o)return e;}else if(!e.instance.popper.contains(o))return console.warn('WARNING: `arrow.element` must be child of its popper element!'),e;var i=e.placement.split('-')[0],n=e.offsets,r=n.popper,p=n.reference,s=-1!==['left','right'].indexOf(i),d=s?'height':'width',a=s?'top':'left',f=s?'left':'top',l=s?'bottom':'right',m=O(o)[d];p[l]-m<r[a]&&(e.offsets.popper[a]-=r[a]-(p[l]-m)),p[a]+m>r[l]&&(e.offsets.popper[a]+=p[a]+m-r[l]);var h=p[a]+p[d]/2-m/2,g=h-c(e.offsets.popper)[a];return g=_(z(r[d]-m,g),0),e.arrowElement=o,e.offsets.arrow={},e.offsets.arrow[a]=Math.round(g),e.offsets.arrow[f]='',e},element:'[x-arrow]'},flip:{order:600,enabled:!0,fn:function(e,t){if(W(e.instance.modifiers,'inner'))return e;if(e.flipped&&e.placement===e.originalPlacement)return e;var o=w(e.instance.popper,e.instance.reference,t.padding,t.boundariesElement),i=e.placement.split('-')[0],n=L(i),r=e.placement.split('-')[1]||'',p=[];switch(t.behavior){case fe.FLIP:p=[i,n];break;case fe.CLOCKWISE:p=K(i);break;case fe.COUNTERCLOCKWISE:p=K(i,!0);break;default:p=t.behavior;}return p.forEach(function(s,d){if(i!==s||p.length===d+1)return e;i=e.placement.split('-')[0],n=L(i);var a=e.offsets.popper,f=e.offsets.reference,l=V,m='left'===i&&l(a.right)>l(f.left)||'right'===i&&l(a.left)<l(f.right)||'top'===i&&l(a.bottom)>l(f.top)||'bottom'===i&&l(a.top)<l(f.bottom),h=l(a.left)<l(o.left),c=l(a.right)>l(o.right),g=l(a.top)<l(o.top),u=l(a.bottom)>l(o.bottom),b='left'===i&&h||'right'===i&&c||'top'===i&&g||'bottom'===i&&u,y=-1!==['top','bottom'].indexOf(i),w=!!t.flipVariations&&(y&&'start'===r&&h||y&&'end'===r&&c||!y&&'start'===r&&g||!y&&'end'===r&&u);(m||b||w)&&(e.flipped=!0,(m||b)&&(i=p[d+1]),w&&(r=j(r)),e.placement=i+(r?'-'+r:''),e.offsets.popper=se({},e.offsets.popper,S(e.instance.popper,e.offsets.reference,e.placement)),e=N(e.instance.modifiers,e,'flip'))}),e},behavior:'flip',padding:5,boundariesElement:'viewport'},inner:{order:700,enabled:!1,fn:function(e){var t=e.placement,o=t.split('-')[0],i=e.offsets,n=i.popper,r=i.reference,p=-1!==['left','right'].indexOf(o),s=-1===['top','left'].indexOf(o);return n[p?'left':'top']=r[t]-(s?n[p?'width':'height']:0),e.placement=L(t),e.offsets.popper=c(n),e}},hide:{order:800,enabled:!0,fn:function(e){if(!F(e.instance.modifiers,'hide','preventOverflow'))return e;var t=e.offsets.reference,o=T(e.instance.modifiers,function(e){return'preventOverflow'===e.name}).boundaries;if(t.bottom<o.top||t.left>o.right||t.top>o.bottom||t.right<o.left){if(!0===e.hide)return e;e.hide=!0,e.attributes['x-out-of-boundaries']=''}else{if(!1===e.hide)return e;e.hide=!1,e.attributes['x-out-of-boundaries']=!1}return e}},computeStyle:{order:850,enabled:!0,fn:function(e,t){var o=t.x,i=t.y,n=e.offsets.popper,p=T(e.instance.modifiers,function(e){return'applyStyle'===e.name}).gpuAcceleration;void 0!==p&&console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');var s,d,a=void 0===p?t.gpuAcceleration:p,f=r(e.instance.popper),l=g(f),m={position:n.position},h={left:V(n.left),top:V(n.top),bottom:V(n.bottom),right:V(n.right)},c='bottom'===o?'top':'bottom',u='right'===i?'left':'right',b=B('transform');if(d='bottom'==c?-l.height+h.bottom:h.top,s='right'==u?-l.width+h.right:h.left,a&&b)m[b]='translate3d('+s+'px, '+d+'px, 0)',m[c]=0,m[u]=0,m.willChange='transform';else{var y='bottom'==c?-1:1,w='right'==u?-1:1;m[c]=d*y,m[u]=s*w,m.willChange=c+', '+u}var v={"x-placement":e.placement};return e.attributes=se({},v,e.attributes),e.styles=se({},m,e.styles),e},gpuAcceleration:!0,x:'bottom',y:'right'},applyStyle:{order:900,enabled:!0,fn:function(e){return U(e.instance.popper,e.styles),Y(e.instance.popper,e.attributes),e.offsets.arrow&&U(e.arrowElement,e.offsets.arrow),e},onLoad:function(e,t,o,i,n){var r=x(n,t,e),p=E(o.placement,r,t,e,o.modifiers.flip.boundariesElement,o.modifiers.flip.padding);return t.setAttribute('x-placement',p),U(t,{position:'absolute'}),o},gpuAcceleration:void 0}}},le});
//# sourceMappingURL=popper.min.js.map

/*!
 * Bootstrap v4.0.0-beta (https://getbootstrap.com)
 * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if("undefined"==typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");!function(t){var e=jQuery.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1==e[0]&&9==e[1]&&e[2]<1||e[0]>=4)throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}(),function(){function t(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function e(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},o=function(){function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}}(),r=function(t){function e(t){return{}.toString.call(t).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function n(t){return(t[0]||t).nodeType}function i(){return{bindType:s.end,delegateType:s.end,handle:function(e){if(t(e.target).is(this))return e.handleObj.handler.apply(this,arguments)}}}function o(){if(window.QUnit)return!1;var t=document.createElement("bootstrap");for(var e in a)if(void 0!==t.style[e])return{end:a[e]};return!1}function r(e){var n=this,i=!1;return t(this).one(l.TRANSITION_END,function(){i=!0}),setTimeout(function(){i||l.triggerTransitionEnd(n)},e),this}var s=!1,a={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd otransitionend",transition:"transitionend"},l={TRANSITION_END:"bsTransitionEnd",getUID:function(t){do{t+=~~(1e6*Math.random())}while(document.getElementById(t));return t},getSelectorFromElement:function(e){var n=e.getAttribute("data-target");n&&"#"!==n||(n=e.getAttribute("href")||"");try{return t(n).length>0?n:null}catch(t){return null}},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(e){t(e).trigger(s.end)},supportsTransitionEnd:function(){return Boolean(s)},typeCheckConfig:function(t,i,o){for(var r in o)if(o.hasOwnProperty(r)){var s=o[r],a=i[r],l=a&&n(a)?"element":e(a);if(!new RegExp(s).test(l))throw new Error(t.toUpperCase()+': Option "'+r+'" provided type "'+l+'" but expected type "'+s+'".')}}};return s=o(),t.fn.emulateTransitionEnd=r,l.supportsTransitionEnd()&&(t.event.special[l.TRANSITION_END]=i()),l}(jQuery),s=(function(t){var e="alert",i=t.fn[e],s={DISMISS:'[data-dismiss="alert"]'},a={CLOSE:"close.bs.alert",CLOSED:"closed.bs.alert",CLICK_DATA_API:"click.bs.alert.data-api"},l={ALERT:"alert",FADE:"fade",SHOW:"show"},h=function(){function e(t){n(this,e),this._element=t}return e.prototype.close=function(t){t=t||this._element;var e=this._getRootElement(t);this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},e.prototype.dispose=function(){t.removeData(this._element,"bs.alert"),this._element=null},e.prototype._getRootElement=function(e){var n=r.getSelectorFromElement(e),i=!1;return n&&(i=t(n)[0]),i||(i=t(e).closest("."+l.ALERT)[0]),i},e.prototype._triggerCloseEvent=function(e){var n=t.Event(a.CLOSE);return t(e).trigger(n),n},e.prototype._removeElement=function(e){var n=this;t(e).removeClass(l.SHOW),r.supportsTransitionEnd()&&t(e).hasClass(l.FADE)?t(e).one(r.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(150):this._destroyElement(e)},e.prototype._destroyElement=function(e){t(e).detach().trigger(a.CLOSED).remove()},e._jQueryInterface=function(n){return this.each(function(){var i=t(this),o=i.data("bs.alert");o||(o=new e(this),i.data("bs.alert",o)),"close"===n&&o[n](this)})},e._handleDismiss=function(t){return function(e){e&&e.preventDefault(),t.close(this)}},o(e,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}}]),e}();t(document).on(a.CLICK_DATA_API,s.DISMISS,h._handleDismiss(new h)),t.fn[e]=h._jQueryInterface,t.fn[e].Constructor=h,t.fn[e].noConflict=function(){return t.fn[e]=i,h._jQueryInterface}}(jQuery),function(t){var e="button",i=t.fn[e],r={ACTIVE:"active",BUTTON:"btn",FOCUS:"focus"},s={DATA_TOGGLE_CARROT:'[data-toggle^="button"]',DATA_TOGGLE:'[data-toggle="buttons"]',INPUT:"input",ACTIVE:".active",BUTTON:".btn"},a={CLICK_DATA_API:"click.bs.button.data-api",FOCUS_BLUR_DATA_API:"focus.bs.button.data-api blur.bs.button.data-api"},l=function(){function e(t){n(this,e),this._element=t}return e.prototype.toggle=function(){var e=!0,n=!0,i=t(this._element).closest(s.DATA_TOGGLE)[0];if(i){var o=t(this._element).find(s.INPUT)[0];if(o){if("radio"===o.type)if(o.checked&&t(this._element).hasClass(r.ACTIVE))e=!1;else{var a=t(i).find(s.ACTIVE)[0];a&&t(a).removeClass(r.ACTIVE)}if(e){if(o.hasAttribute("disabled")||i.hasAttribute("disabled")||o.classList.contains("disabled")||i.classList.contains("disabled"))return;o.checked=!t(this._element).hasClass(r.ACTIVE),t(o).trigger("change")}o.focus(),n=!1}}n&&this._element.setAttribute("aria-pressed",!t(this._element).hasClass(r.ACTIVE)),e&&t(this._element).toggleClass(r.ACTIVE)},e.prototype.dispose=function(){t.removeData(this._element,"bs.button"),this._element=null},e._jQueryInterface=function(n){return this.each(function(){var i=t(this).data("bs.button");i||(i=new e(this),t(this).data("bs.button",i)),"toggle"===n&&i[n]()})},o(e,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}}]),e}();t(document).on(a.CLICK_DATA_API,s.DATA_TOGGLE_CARROT,function(e){e.preventDefault();var n=e.target;t(n).hasClass(r.BUTTON)||(n=t(n).closest(s.BUTTON)),l._jQueryInterface.call(t(n),"toggle")}).on(a.FOCUS_BLUR_DATA_API,s.DATA_TOGGLE_CARROT,function(e){var n=t(e.target).closest(s.BUTTON)[0];t(n).toggleClass(r.FOCUS,/^focus(in)?$/.test(e.type))}),t.fn[e]=l._jQueryInterface,t.fn[e].Constructor=l,t.fn[e].noConflict=function(){return t.fn[e]=i,l._jQueryInterface}}(jQuery),function(t){var e="carousel",s="bs.carousel",a="."+s,l=t.fn[e],h={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0},c={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean"},u={NEXT:"next",PREV:"prev",LEFT:"left",RIGHT:"right"},d={SLIDE:"slide"+a,SLID:"slid"+a,KEYDOWN:"keydown"+a,MOUSEENTER:"mouseenter"+a,MOUSELEAVE:"mouseleave"+a,TOUCHEND:"touchend"+a,LOAD_DATA_API:"load.bs.carousel.data-api",CLICK_DATA_API:"click.bs.carousel.data-api"},f={CAROUSEL:"carousel",ACTIVE:"active",SLIDE:"slide",RIGHT:"carousel-item-right",LEFT:"carousel-item-left",NEXT:"carousel-item-next",PREV:"carousel-item-prev",ITEM:"carousel-item"},p={ACTIVE:".active",ACTIVE_ITEM:".active.carousel-item",ITEM:".carousel-item",NEXT_PREV:".carousel-item-next, .carousel-item-prev",INDICATORS:".carousel-indicators",DATA_SLIDE:"[data-slide], [data-slide-to]",DATA_RIDE:'[data-ride="carousel"]'},_=function(){function l(e,i){n(this,l),this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this._config=this._getConfig(i),this._element=t(e)[0],this._indicatorsElement=t(this._element).find(p.INDICATORS)[0],this._addEventListeners()}return l.prototype.next=function(){this._isSliding||this._slide(u.NEXT)},l.prototype.nextWhenVisible=function(){document.hidden||this.next()},l.prototype.prev=function(){this._isSliding||this._slide(u.PREV)},l.prototype.pause=function(e){e||(this._isPaused=!0),t(this._element).find(p.NEXT_PREV)[0]&&r.supportsTransitionEnd()&&(r.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},l.prototype.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},l.prototype.to=function(e){var n=this;this._activeElement=t(this._element).find(p.ACTIVE_ITEM)[0];var i=this._getItemIndex(this._activeElement);if(!(e>this._items.length-1||e<0))if(this._isSliding)t(this._element).one(d.SLID,function(){return n.to(e)});else{if(i===e)return this.pause(),void this.cycle();var o=e>i?u.NEXT:u.PREV;this._slide(o,this._items[e])}},l.prototype.dispose=function(){t(this._element).off(a),t.removeData(this._element,s),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},l.prototype._getConfig=function(n){return n=t.extend({},h,n),r.typeCheckConfig(e,n,c),n},l.prototype._addEventListeners=function(){var e=this;this._config.keyboard&&t(this._element).on(d.KEYDOWN,function(t){return e._keydown(t)}),"hover"===this._config.pause&&(t(this._element).on(d.MOUSEENTER,function(t){return e.pause(t)}).on(d.MOUSELEAVE,function(t){return e.cycle(t)}),"ontouchstart"in document.documentElement&&t(this._element).on(d.TOUCHEND,function(){e.pause(),e.touchTimeout&&clearTimeout(e.touchTimeout),e.touchTimeout=setTimeout(function(t){return e.cycle(t)},500+e._config.interval)}))},l.prototype._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next();break;default:return}},l.prototype._getItemIndex=function(e){return this._items=t.makeArray(t(e).parent().find(p.ITEM)),this._items.indexOf(e)},l.prototype._getItemByDirection=function(t,e){var n=t===u.NEXT,i=t===u.PREV,o=this._getItemIndex(e),r=this._items.length-1;if((i&&0===o||n&&o===r)&&!this._config.wrap)return e;var s=(o+(t===u.PREV?-1:1))%this._items.length;return-1===s?this._items[this._items.length-1]:this._items[s]},l.prototype._triggerSlideEvent=function(e,n){var i=this._getItemIndex(e),o=this._getItemIndex(t(this._element).find(p.ACTIVE_ITEM)[0]),r=t.Event(d.SLIDE,{relatedTarget:e,direction:n,from:o,to:i});return t(this._element).trigger(r),r},l.prototype._setActiveIndicatorElement=function(e){if(this._indicatorsElement){t(this._indicatorsElement).find(p.ACTIVE).removeClass(f.ACTIVE);var n=this._indicatorsElement.children[this._getItemIndex(e)];n&&t(n).addClass(f.ACTIVE)}},l.prototype._slide=function(e,n){var i=this,o=t(this._element).find(p.ACTIVE_ITEM)[0],s=this._getItemIndex(o),a=n||o&&this._getItemByDirection(e,o),l=this._getItemIndex(a),h=Boolean(this._interval),c=void 0,_=void 0,g=void 0;if(e===u.NEXT?(c=f.LEFT,_=f.NEXT,g=u.LEFT):(c=f.RIGHT,_=f.PREV,g=u.RIGHT),a&&t(a).hasClass(f.ACTIVE))this._isSliding=!1;else if(!this._triggerSlideEvent(a,g).isDefaultPrevented()&&o&&a){this._isSliding=!0,h&&this.pause(),this._setActiveIndicatorElement(a);var m=t.Event(d.SLID,{relatedTarget:a,direction:g,from:s,to:l});r.supportsTransitionEnd()&&t(this._element).hasClass(f.SLIDE)?(t(a).addClass(_),r.reflow(a),t(o).addClass(c),t(a).addClass(c),t(o).one(r.TRANSITION_END,function(){t(a).removeClass(c+" "+_).addClass(f.ACTIVE),t(o).removeClass(f.ACTIVE+" "+_+" "+c),i._isSliding=!1,setTimeout(function(){return t(i._element).trigger(m)},0)}).emulateTransitionEnd(600)):(t(o).removeClass(f.ACTIVE),t(a).addClass(f.ACTIVE),this._isSliding=!1,t(this._element).trigger(m)),h&&this.cycle()}},l._jQueryInterface=function(e){return this.each(function(){var n=t(this).data(s),o=t.extend({},h,t(this).data());"object"===(void 0===e?"undefined":i(e))&&t.extend(o,e);var r="string"==typeof e?e:o.slide;if(n||(n=new l(this,o),t(this).data(s,n)),"number"==typeof e)n.to(e);else if("string"==typeof r){if(void 0===n[r])throw new Error('No method named "'+r+'"');n[r]()}else o.interval&&(n.pause(),n.cycle())})},l._dataApiClickHandler=function(e){var n=r.getSelectorFromElement(this);if(n){var i=t(n)[0];if(i&&t(i).hasClass(f.CAROUSEL)){var o=t.extend({},t(i).data(),t(this).data()),a=this.getAttribute("data-slide-to");a&&(o.interval=!1),l._jQueryInterface.call(t(i),o),a&&t(i).data(s).to(a),e.preventDefault()}}},o(l,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return h}}]),l}();t(document).on(d.CLICK_DATA_API,p.DATA_SLIDE,_._dataApiClickHandler),t(window).on(d.LOAD_DATA_API,function(){t(p.DATA_RIDE).each(function(){var e=t(this);_._jQueryInterface.call(e,e.data())})}),t.fn[e]=_._jQueryInterface,t.fn[e].Constructor=_,t.fn[e].noConflict=function(){return t.fn[e]=l,_._jQueryInterface}}(jQuery),function(t){var e="collapse",s="bs.collapse",a=t.fn[e],l={toggle:!0,parent:""},h={toggle:"boolean",parent:"string"},c={SHOW:"show.bs.collapse",SHOWN:"shown.bs.collapse",HIDE:"hide.bs.collapse",HIDDEN:"hidden.bs.collapse",CLICK_DATA_API:"click.bs.collapse.data-api"},u={SHOW:"show",COLLAPSE:"collapse",COLLAPSING:"collapsing",COLLAPSED:"collapsed"},d={WIDTH:"width",HEIGHT:"height"},f={ACTIVES:".show, .collapsing",DATA_TOGGLE:'[data-toggle="collapse"]'},p=function(){function a(e,i){n(this,a),this._isTransitioning=!1,this._element=e,this._config=this._getConfig(i),this._triggerArray=t.makeArray(t('[data-toggle="collapse"][href="#'+e.id+'"],[data-toggle="collapse"][data-target="#'+e.id+'"]'));for(var o=t(f.DATA_TOGGLE),s=0;s<o.length;s++){var l=o[s],h=r.getSelectorFromElement(l);null!==h&&t(h).filter(e).length>0&&this._triggerArray.push(l)}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}return a.prototype.toggle=function(){t(this._element).hasClass(u.SHOW)?this.hide():this.show()},a.prototype.show=function(){var e=this;if(!this._isTransitioning&&!t(this._element).hasClass(u.SHOW)){var n=void 0,i=void 0;if(this._parent&&((n=t.makeArray(t(this._parent).children().children(f.ACTIVES))).length||(n=null)),!(n&&(i=t(n).data(s))&&i._isTransitioning)){var o=t.Event(c.SHOW);if(t(this._element).trigger(o),!o.isDefaultPrevented()){n&&(a._jQueryInterface.call(t(n),"hide"),i||t(n).data(s,null));var l=this._getDimension();t(this._element).removeClass(u.COLLAPSE).addClass(u.COLLAPSING),this._element.style[l]=0,this._triggerArray.length&&t(this._triggerArray).removeClass(u.COLLAPSED).attr("aria-expanded",!0),this.setTransitioning(!0);var h=function(){t(e._element).removeClass(u.COLLAPSING).addClass(u.COLLAPSE).addClass(u.SHOW),e._element.style[l]="",e.setTransitioning(!1),t(e._element).trigger(c.SHOWN)};if(r.supportsTransitionEnd()){var d="scroll"+(l[0].toUpperCase()+l.slice(1));t(this._element).one(r.TRANSITION_END,h).emulateTransitionEnd(600),this._element.style[l]=this._element[d]+"px"}else h()}}}},a.prototype.hide=function(){var e=this;if(!this._isTransitioning&&t(this._element).hasClass(u.SHOW)){var n=t.Event(c.HIDE);if(t(this._element).trigger(n),!n.isDefaultPrevented()){var i=this._getDimension();if(this._element.style[i]=this._element.getBoundingClientRect()[i]+"px",r.reflow(this._element),t(this._element).addClass(u.COLLAPSING).removeClass(u.COLLAPSE).removeClass(u.SHOW),this._triggerArray.length)for(var o=0;o<this._triggerArray.length;o++){var s=this._triggerArray[o],a=r.getSelectorFromElement(s);null!==a&&(t(a).hasClass(u.SHOW)||t(s).addClass(u.COLLAPSED).attr("aria-expanded",!1))}this.setTransitioning(!0);var l=function(){e.setTransitioning(!1),t(e._element).removeClass(u.COLLAPSING).addClass(u.COLLAPSE).trigger(c.HIDDEN)};this._element.style[i]="",r.supportsTransitionEnd()?t(this._element).one(r.TRANSITION_END,l).emulateTransitionEnd(600):l()}}},a.prototype.setTransitioning=function(t){this._isTransitioning=t},a.prototype.dispose=function(){t.removeData(this._element,s),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},a.prototype._getConfig=function(n){return n=t.extend({},l,n),n.toggle=Boolean(n.toggle),r.typeCheckConfig(e,n,h),n},a.prototype._getDimension=function(){return t(this._element).hasClass(d.WIDTH)?d.WIDTH:d.HEIGHT},a.prototype._getParent=function(){var e=this,n=t(this._config.parent)[0],i='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]';return t(n).find(i).each(function(t,n){e._addAriaAndCollapsedClass(a._getTargetFromElement(n),[n])}),n},a.prototype._addAriaAndCollapsedClass=function(e,n){if(e){var i=t(e).hasClass(u.SHOW);n.length&&t(n).toggleClass(u.COLLAPSED,!i).attr("aria-expanded",i)}},a._getTargetFromElement=function(e){var n=r.getSelectorFromElement(e);return n?t(n)[0]:null},a._jQueryInterface=function(e){return this.each(function(){var n=t(this),o=n.data(s),r=t.extend({},l,n.data(),"object"===(void 0===e?"undefined":i(e))&&e);if(!o&&r.toggle&&/show|hide/.test(e)&&(r.toggle=!1),o||(o=new a(this,r),n.data(s,o)),"string"==typeof e){if(void 0===o[e])throw new Error('No method named "'+e+'"');o[e]()}})},o(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return l}}]),a}();t(document).on(c.CLICK_DATA_API,f.DATA_TOGGLE,function(e){/input|textarea/i.test(e.target.tagName)||e.preventDefault();var n=t(this),i=r.getSelectorFromElement(this);t(i).each(function(){var e=t(this),i=e.data(s)?"toggle":n.data();p._jQueryInterface.call(e,i)})}),t.fn[e]=p._jQueryInterface,t.fn[e].Constructor=p,t.fn[e].noConflict=function(){return t.fn[e]=a,p._jQueryInterface}}(jQuery),function(t){if("undefined"==typeof Popper)throw new Error("Bootstrap dropdown require Popper.js (https://popper.js.org)");var e="dropdown",s="bs.dropdown",a="."+s,l=t.fn[e],h=new RegExp("38|40|27"),c={HIDE:"hide"+a,HIDDEN:"hidden"+a,SHOW:"show"+a,SHOWN:"shown"+a,CLICK:"click"+a,CLICK_DATA_API:"click.bs.dropdown.data-api",KEYDOWN_DATA_API:"keydown.bs.dropdown.data-api",KEYUP_DATA_API:"keyup.bs.dropdown.data-api"},u={DISABLED:"disabled",SHOW:"show",DROPUP:"dropup",MENURIGHT:"dropdown-menu-right",MENULEFT:"dropdown-menu-left"},d={DATA_TOGGLE:'[data-toggle="dropdown"]',FORM_CHILD:".dropdown form",MENU:".dropdown-menu",NAVBAR_NAV:".navbar-nav",VISIBLE_ITEMS:".dropdown-menu .dropdown-item:not(.disabled)"},f={TOP:"top-start",TOPEND:"top-end",BOTTOM:"bottom-start",BOTTOMEND:"bottom-end"},p={placement:f.BOTTOM,offset:0,flip:!0},_={placement:"string",offset:"(number|string)",flip:"boolean"},g=function(){function l(t,e){n(this,l),this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}return l.prototype.toggle=function(){if(!this._element.disabled&&!t(this._element).hasClass(u.DISABLED)){var e=l._getParentFromElement(this._element),n=t(this._menu).hasClass(u.SHOW);if(l._clearMenus(),!n){var i={relatedTarget:this._element},o=t.Event(c.SHOW,i);if(t(e).trigger(o),!o.isDefaultPrevented()){var r=this._element;t(e).hasClass(u.DROPUP)&&(t(this._menu).hasClass(u.MENULEFT)||t(this._menu).hasClass(u.MENURIGHT))&&(r=e),this._popper=new Popper(r,this._menu,this._getPopperConfig()),"ontouchstart"in document.documentElement&&!t(e).closest(d.NAVBAR_NAV).length&&t("body").children().on("mouseover",null,t.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),t(this._menu).toggleClass(u.SHOW),t(e).toggleClass(u.SHOW).trigger(t.Event(c.SHOWN,i))}}}},l.prototype.dispose=function(){t.removeData(this._element,s),t(this._element).off(a),this._element=null,this._menu=null,null!==this._popper&&this._popper.destroy(),this._popper=null},l.prototype.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},l.prototype._addEventListeners=function(){var e=this;t(this._element).on(c.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},l.prototype._getConfig=function(n){var i=t(this._element).data();return void 0!==i.placement&&(i.placement=f[i.placement.toUpperCase()]),n=t.extend({},this.constructor.Default,t(this._element).data(),n),r.typeCheckConfig(e,n,this.constructor.DefaultType),n},l.prototype._getMenuElement=function(){if(!this._menu){var e=l._getParentFromElement(this._element);this._menu=t(e).find(d.MENU)[0]}return this._menu},l.prototype._getPlacement=function(){var e=t(this._element).parent(),n=this._config.placement;return e.hasClass(u.DROPUP)||this._config.placement===f.TOP?(n=f.TOP,t(this._menu).hasClass(u.MENURIGHT)&&(n=f.TOPEND)):t(this._menu).hasClass(u.MENURIGHT)&&(n=f.BOTTOMEND),n},l.prototype._detectNavbar=function(){return t(this._element).closest(".navbar").length>0},l.prototype._getPopperConfig=function(){var t={placement:this._getPlacement(),modifiers:{offset:{offset:this._config.offset},flip:{enabled:this._config.flip}}};return this._inNavbar&&(t.modifiers.applyStyle={enabled:!this._inNavbar}),t},l._jQueryInterface=function(e){return this.each(function(){var n=t(this).data(s),o="object"===(void 0===e?"undefined":i(e))?e:null;if(n||(n=new l(this,o),t(this).data(s,n)),"string"==typeof e){if(void 0===n[e])throw new Error('No method named "'+e+'"');n[e]()}})},l._clearMenus=function(e){if(!e||3!==e.which&&("keyup"!==e.type||9===e.which))for(var n=t.makeArray(t(d.DATA_TOGGLE)),i=0;i<n.length;i++){var o=l._getParentFromElement(n[i]),r=t(n[i]).data(s),a={relatedTarget:n[i]};if(r){var h=r._menu;if(t(o).hasClass(u.SHOW)&&!(e&&("click"===e.type&&/input|textarea/i.test(e.target.tagName)||"keyup"===e.type&&9===e.which)&&t.contains(o,e.target))){var f=t.Event(c.HIDE,a);t(o).trigger(f),f.isDefaultPrevented()||("ontouchstart"in document.documentElement&&t("body").children().off("mouseover",null,t.noop),n[i].setAttribute("aria-expanded","false"),t(h).removeClass(u.SHOW),t(o).removeClass(u.SHOW).trigger(t.Event(c.HIDDEN,a)))}}}},l._getParentFromElement=function(e){var n=void 0,i=r.getSelectorFromElement(e);return i&&(n=t(i)[0]),n||e.parentNode},l._dataApiKeydownHandler=function(e){if(!(!h.test(e.which)||/button/i.test(e.target.tagName)&&32===e.which||/input|textarea/i.test(e.target.tagName)||(e.preventDefault(),e.stopPropagation(),this.disabled||t(this).hasClass(u.DISABLED)))){var n=l._getParentFromElement(this),i=t(n).hasClass(u.SHOW);if((i||27===e.which&&32===e.which)&&(!i||27!==e.which&&32!==e.which)){var o=t(n).find(d.VISIBLE_ITEMS).get();if(o.length){var r=o.indexOf(e.target);38===e.which&&r>0&&r--,40===e.which&&r<o.length-1&&r++,r<0&&(r=0),o[r].focus()}}else{if(27===e.which){var s=t(n).find(d.DATA_TOGGLE)[0];t(s).trigger("focus")}t(this).trigger("click")}}},o(l,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return p}},{key:"DefaultType",get:function(){return _}}]),l}();t(document).on(c.KEYDOWN_DATA_API,d.DATA_TOGGLE,g._dataApiKeydownHandler).on(c.KEYDOWN_DATA_API,d.MENU,g._dataApiKeydownHandler).on(c.CLICK_DATA_API+" "+c.KEYUP_DATA_API,g._clearMenus).on(c.CLICK_DATA_API,d.DATA_TOGGLE,function(e){e.preventDefault(),e.stopPropagation(),g._jQueryInterface.call(t(this),"toggle")}).on(c.CLICK_DATA_API,d.FORM_CHILD,function(t){t.stopPropagation()}),t.fn[e]=g._jQueryInterface,t.fn[e].Constructor=g,t.fn[e].noConflict=function(){return t.fn[e]=l,g._jQueryInterface}}(jQuery),function(t){var e="modal",s=".bs.modal",a=t.fn[e],l={backdrop:!0,keyboard:!0,focus:!0,show:!0},h={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},c={HIDE:"hide.bs.modal",HIDDEN:"hidden.bs.modal",SHOW:"show.bs.modal",SHOWN:"shown.bs.modal",FOCUSIN:"focusin.bs.modal",RESIZE:"resize.bs.modal",CLICK_DISMISS:"click.dismiss.bs.modal",KEYDOWN_DISMISS:"keydown.dismiss.bs.modal",MOUSEUP_DISMISS:"mouseup.dismiss.bs.modal",MOUSEDOWN_DISMISS:"mousedown.dismiss.bs.modal",CLICK_DATA_API:"click.bs.modal.data-api"},u={SCROLLBAR_MEASURER:"modal-scrollbar-measure",BACKDROP:"modal-backdrop",OPEN:"modal-open",FADE:"fade",SHOW:"show"},d={DIALOG:".modal-dialog",DATA_TOGGLE:'[data-toggle="modal"]',DATA_DISMISS:'[data-dismiss="modal"]',FIXED_CONTENT:".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",NAVBAR_TOGGLER:".navbar-toggler"},f=function(){function a(e,i){n(this,a),this._config=this._getConfig(i),this._element=e,this._dialog=t(e).find(d.DIALOG)[0],this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._originalBodyPadding=0,this._scrollbarWidth=0}return a.prototype.toggle=function(t){return this._isShown?this.hide():this.show(t)},a.prototype.show=function(e){var n=this;if(!this._isTransitioning){r.supportsTransitionEnd()&&t(this._element).hasClass(u.FADE)&&(this._isTransitioning=!0);var i=t.Event(c.SHOW,{relatedTarget:e});t(this._element).trigger(i),this._isShown||i.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),t(document.body).addClass(u.OPEN),this._setEscapeEvent(),this._setResizeEvent(),t(this._element).on(c.CLICK_DISMISS,d.DATA_DISMISS,function(t){return n.hide(t)}),t(this._dialog).on(c.MOUSEDOWN_DISMISS,function(){t(n._element).one(c.MOUSEUP_DISMISS,function(e){t(e.target).is(n._element)&&(n._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return n._showElement(e)}))}},a.prototype.hide=function(e){var n=this;if(e&&e.preventDefault(),!this._isTransitioning&&this._isShown){var i=r.supportsTransitionEnd()&&t(this._element).hasClass(u.FADE);i&&(this._isTransitioning=!0);var o=t.Event(c.HIDE);t(this._element).trigger(o),this._isShown&&!o.isDefaultPrevented()&&(this._isShown=!1,this._setEscapeEvent(),this._setResizeEvent(),t(document).off(c.FOCUSIN),t(this._element).removeClass(u.SHOW),t(this._element).off(c.CLICK_DISMISS),t(this._dialog).off(c.MOUSEDOWN_DISMISS),i?t(this._element).one(r.TRANSITION_END,function(t){return n._hideModal(t)}).emulateTransitionEnd(300):this._hideModal())}},a.prototype.dispose=function(){t.removeData(this._element,"bs.modal"),t(window,document,this._element,this._backdrop).off(s),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._scrollbarWidth=null},a.prototype.handleUpdate=function(){this._adjustDialog()},a.prototype._getConfig=function(n){return n=t.extend({},l,n),r.typeCheckConfig(e,n,h),n},a.prototype._showElement=function(e){var n=this,i=r.supportsTransitionEnd()&&t(this._element).hasClass(u.FADE);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.scrollTop=0,i&&r.reflow(this._element),t(this._element).addClass(u.SHOW),this._config.focus&&this._enforceFocus();var o=t.Event(c.SHOWN,{relatedTarget:e}),s=function(){n._config.focus&&n._element.focus(),n._isTransitioning=!1,t(n._element).trigger(o)};i?t(this._dialog).one(r.TRANSITION_END,s).emulateTransitionEnd(300):s()},a.prototype._enforceFocus=function(){var e=this;t(document).off(c.FOCUSIN).on(c.FOCUSIN,function(n){document===n.target||e._element===n.target||t(e._element).has(n.target).length||e._element.focus()})},a.prototype._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?t(this._element).on(c.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||t(this._element).off(c.KEYDOWN_DISMISS)},a.prototype._setResizeEvent=function(){var e=this;this._isShown?t(window).on(c.RESIZE,function(t){return e.handleUpdate(t)}):t(window).off(c.RESIZE)},a.prototype._hideModal=function(){var e=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._isTransitioning=!1,this._showBackdrop(function(){t(document.body).removeClass(u.OPEN),e._resetAdjustments(),e._resetScrollbar(),t(e._element).trigger(c.HIDDEN)})},a.prototype._removeBackdrop=function(){this._backdrop&&(t(this._backdrop).remove(),this._backdrop=null)},a.prototype._showBackdrop=function(e){var n=this,i=t(this._element).hasClass(u.FADE)?u.FADE:"";if(this._isShown&&this._config.backdrop){var o=r.supportsTransitionEnd()&&i;if(this._backdrop=document.createElement("div"),this._backdrop.className=u.BACKDROP,i&&t(this._backdrop).addClass(i),t(this._backdrop).appendTo(document.body),t(this._element).on(c.CLICK_DISMISS,function(t){n._ignoreBackdropClick?n._ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"===n._config.backdrop?n._element.focus():n.hide())}),o&&r.reflow(this._backdrop),t(this._backdrop).addClass(u.SHOW),!e)return;if(!o)return void e();t(this._backdrop).one(r.TRANSITION_END,e).emulateTransitionEnd(150)}else if(!this._isShown&&this._backdrop){t(this._backdrop).removeClass(u.SHOW);var s=function(){n._removeBackdrop(),e&&e()};r.supportsTransitionEnd()&&t(this._element).hasClass(u.FADE)?t(this._backdrop).one(r.TRANSITION_END,s).emulateTransitionEnd(150):s()}else e&&e()},a.prototype._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},a.prototype._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},a.prototype._checkScrollbar=function(){this._isBodyOverflowing=document.body.clientWidth<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},a.prototype._setScrollbar=function(){var e=this;if(this._isBodyOverflowing){t(d.FIXED_CONTENT).each(function(n,i){var o=t(i)[0].style.paddingRight,r=t(i).css("padding-right");t(i).data("padding-right",o).css("padding-right",parseFloat(r)+e._scrollbarWidth+"px")}),t(d.NAVBAR_TOGGLER).each(function(n,i){var o=t(i)[0].style.marginRight,r=t(i).css("margin-right");t(i).data("margin-right",o).css("margin-right",parseFloat(r)+e._scrollbarWidth+"px")});var n=document.body.style.paddingRight,i=t("body").css("padding-right");t("body").data("padding-right",n).css("padding-right",parseFloat(i)+this._scrollbarWidth+"px")}},a.prototype._resetScrollbar=function(){t(d.FIXED_CONTENT).each(function(e,n){var i=t(n).data("padding-right");void 0!==i&&t(n).css("padding-right",i).removeData("padding-right")}),t(d.NAVBAR_TOGGLER).each(function(e,n){var i=t(n).data("margin-right");void 0!==i&&t(n).css("margin-right",i).removeData("margin-right")});var e=t("body").data("padding-right");void 0!==e&&t("body").css("padding-right",e).removeData("padding-right")},a.prototype._getScrollbarWidth=function(){var t=document.createElement("div");t.className=u.SCROLLBAR_MEASURER,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},a._jQueryInterface=function(e,n){return this.each(function(){var o=t(this).data("bs.modal"),r=t.extend({},a.Default,t(this).data(),"object"===(void 0===e?"undefined":i(e))&&e);if(o||(o=new a(this,r),t(this).data("bs.modal",o)),"string"==typeof e){if(void 0===o[e])throw new Error('No method named "'+e+'"');o[e](n)}else r.show&&o.show(n)})},o(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return l}}]),a}();t(document).on(c.CLICK_DATA_API,d.DATA_TOGGLE,function(e){var n=this,i=void 0,o=r.getSelectorFromElement(this);o&&(i=t(o)[0]);var s=t(i).data("bs.modal")?"toggle":t.extend({},t(i).data(),t(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||e.preventDefault();var a=t(i).one(c.SHOW,function(e){e.isDefaultPrevented()||a.one(c.HIDDEN,function(){t(n).is(":visible")&&n.focus()})});f._jQueryInterface.call(t(i),s,this)}),t.fn[e]=f._jQueryInterface,t.fn[e].Constructor=f,t.fn[e].noConflict=function(){return t.fn[e]=a,f._jQueryInterface}}(jQuery),function(t){var e="scrollspy",s=t.fn[e],a={offset:10,method:"auto",target:""},l={offset:"number",method:"string",target:"(string|element)"},h={ACTIVATE:"activate.bs.scrollspy",SCROLL:"scroll.bs.scrollspy",LOAD_DATA_API:"load.bs.scrollspy.data-api"},c={DROPDOWN_ITEM:"dropdown-item",DROPDOWN_MENU:"dropdown-menu",ACTIVE:"active"},u={DATA_SPY:'[data-spy="scroll"]',ACTIVE:".active",NAV_LIST_GROUP:".nav, .list-group",NAV_LINKS:".nav-link",LIST_ITEMS:".list-group-item",DROPDOWN:".dropdown",DROPDOWN_ITEMS:".dropdown-item",DROPDOWN_TOGGLE:".dropdown-toggle"},d={OFFSET:"offset",POSITION:"position"},f=function(){function s(e,i){var o=this;n(this,s),this._element=e,this._scrollElement="BODY"===e.tagName?window:e,this._config=this._getConfig(i),this._selector=this._config.target+" "+u.NAV_LINKS+","+this._config.target+" "+u.LIST_ITEMS+","+this._config.target+" "+u.DROPDOWN_ITEMS,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,t(this._scrollElement).on(h.SCROLL,function(t){return o._process(t)}),this.refresh(),this._process()}return s.prototype.refresh=function(){var e=this,n=this._scrollElement!==this._scrollElement.window?d.POSITION:d.OFFSET,i="auto"===this._config.method?n:this._config.method,o=i===d.POSITION?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),t.makeArray(t(this._selector)).map(function(e){var n=void 0,s=r.getSelectorFromElement(e);if(s&&(n=t(s)[0]),n){var a=n.getBoundingClientRect();if(a.width||a.height)return[t(n)[i]().top+o,s]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},s.prototype.dispose=function(){t.removeData(this._element,"bs.scrollspy"),t(this._scrollElement).off(".bs.scrollspy"),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},s.prototype._getConfig=function(n){if("string"!=typeof(n=t.extend({},a,n)).target){var i=t(n.target).attr("id");i||(i=r.getUID(e),t(n.target).attr("id",i)),n.target="#"+i}return r.typeCheckConfig(e,n,l),n},s.prototype._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},s.prototype._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},s.prototype._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},s.prototype._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),t>=n){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&this._offsets[0]>0)return this._activeTarget=null,void this._clear();for(var o=this._offsets.length;o--;)this._activeTarget!==this._targets[o]&&t>=this._offsets[o]&&(void 0===this._offsets[o+1]||t<this._offsets[o+1])&&this._activate(this._targets[o])}},s.prototype._activate=function(e){this._activeTarget=e,this._clear();var n=this._selector.split(",");n=n.map(function(t){return t+'[data-target="'+e+'"],'+t+'[href="'+e+'"]'});var i=t(n.join(","));i.hasClass(c.DROPDOWN_ITEM)?(i.closest(u.DROPDOWN).find(u.DROPDOWN_TOGGLE).addClass(c.ACTIVE),i.addClass(c.ACTIVE)):(i.addClass(c.ACTIVE),i.parents(u.NAV_LIST_GROUP).prev(u.NAV_LINKS+", "+u.LIST_ITEMS).addClass(c.ACTIVE)),t(this._scrollElement).trigger(h.ACTIVATE,{relatedTarget:e})},s.prototype._clear=function(){t(this._selector).filter(u.ACTIVE).removeClass(c.ACTIVE)},s._jQueryInterface=function(e){return this.each(function(){var n=t(this).data("bs.scrollspy"),o="object"===(void 0===e?"undefined":i(e))&&e;if(n||(n=new s(this,o),t(this).data("bs.scrollspy",n)),"string"==typeof e){if(void 0===n[e])throw new Error('No method named "'+e+'"');n[e]()}})},o(s,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return a}}]),s}();t(window).on(h.LOAD_DATA_API,function(){for(var e=t.makeArray(t(u.DATA_SPY)),n=e.length;n--;){var i=t(e[n]);f._jQueryInterface.call(i,i.data())}}),t.fn[e]=f._jQueryInterface,t.fn[e].Constructor=f,t.fn[e].noConflict=function(){return t.fn[e]=s,f._jQueryInterface}}(jQuery),function(t){var e=t.fn.tab,i={HIDE:"hide.bs.tab",HIDDEN:"hidden.bs.tab",SHOW:"show.bs.tab",SHOWN:"shown.bs.tab",CLICK_DATA_API:"click.bs.tab.data-api"},s={DROPDOWN_MENU:"dropdown-menu",ACTIVE:"active",DISABLED:"disabled",FADE:"fade",SHOW:"show"},a={DROPDOWN:".dropdown",NAV_LIST_GROUP:".nav, .list-group",ACTIVE:".active",DATA_TOGGLE:'[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',DROPDOWN_TOGGLE:".dropdown-toggle",DROPDOWN_ACTIVE_CHILD:"> .dropdown-menu .active"},l=function(){function e(t){n(this,e),this._element=t}return e.prototype.show=function(){var e=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&t(this._element).hasClass(s.ACTIVE)||t(this._element).hasClass(s.DISABLED))){var n=void 0,o=void 0,l=t(this._element).closest(a.NAV_LIST_GROUP)[0],h=r.getSelectorFromElement(this._element);l&&(o=t.makeArray(t(l).find(a.ACTIVE)),o=o[o.length-1]);var c=t.Event(i.HIDE,{relatedTarget:this._element}),u=t.Event(i.SHOW,{relatedTarget:o});if(o&&t(o).trigger(c),t(this._element).trigger(u),!u.isDefaultPrevented()&&!c.isDefaultPrevented()){h&&(n=t(h)[0]),this._activate(this._element,l);var d=function(){var n=t.Event(i.HIDDEN,{relatedTarget:e._element}),r=t.Event(i.SHOWN,{relatedTarget:o});t(o).trigger(n),t(e._element).trigger(r)};n?this._activate(n,n.parentNode,d):d()}}},e.prototype.dispose=function(){t.removeData(this._element,"bs.tab"),this._element=null},e.prototype._activate=function(e,n,i){var o=this,l=t(n).find(a.ACTIVE)[0],h=i&&r.supportsTransitionEnd()&&l&&t(l).hasClass(s.FADE),c=function(){return o._transitionComplete(e,l,h,i)};l&&h?t(l).one(r.TRANSITION_END,c).emulateTransitionEnd(150):c(),l&&t(l).removeClass(s.SHOW)},e.prototype._transitionComplete=function(e,n,i,o){if(n){t(n).removeClass(s.ACTIVE);var l=t(n.parentNode).find(a.DROPDOWN_ACTIVE_CHILD)[0];l&&t(l).removeClass(s.ACTIVE),n.setAttribute("aria-expanded",!1)}if(t(e).addClass(s.ACTIVE),e.setAttribute("aria-expanded",!0),i?(r.reflow(e),t(e).addClass(s.SHOW)):t(e).removeClass(s.FADE),e.parentNode&&t(e.parentNode).hasClass(s.DROPDOWN_MENU)){var h=t(e).closest(a.DROPDOWN)[0];h&&t(h).find(a.DROPDOWN_TOGGLE).addClass(s.ACTIVE),e.setAttribute("aria-expanded",!0)}o&&o()},e._jQueryInterface=function(n){return this.each(function(){var i=t(this),o=i.data("bs.tab");if(o||(o=new e(this),i.data("bs.tab",o)),"string"==typeof n){if(void 0===o[n])throw new Error('No method named "'+n+'"');o[n]()}})},o(e,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}}]),e}();t(document).on(i.CLICK_DATA_API,a.DATA_TOGGLE,function(e){e.preventDefault(),l._jQueryInterface.call(t(this),"show")}),t.fn.tab=l._jQueryInterface,t.fn.tab.Constructor=l,t.fn.tab.noConflict=function(){return t.fn.tab=e,l._jQueryInterface}}(jQuery),function(t){if("undefined"==typeof Popper)throw new Error("Bootstrap tooltips require Popper.js (https://popper.js.org)");var e="tooltip",s=".bs.tooltip",a=t.fn[e],l=new RegExp("(^|\\s)bs-tooltip\\S+","g"),h={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)"},c={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},u={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,fallbackPlacement:"flip"},d={SHOW:"show",OUT:"out"},f={HIDE:"hide"+s,HIDDEN:"hidden"+s,SHOW:"show"+s,SHOWN:"shown"+s,INSERTED:"inserted"+s,CLICK:"click"+s,FOCUSIN:"focusin"+s,FOCUSOUT:"focusout"+s,MOUSEENTER:"mouseenter"+s,MOUSELEAVE:"mouseleave"+s},p={FADE:"fade",SHOW:"show"},_={TOOLTIP:".tooltip",TOOLTIP_INNER:".tooltip-inner",ARROW:".arrow"},g={HOVER:"hover",FOCUS:"focus",CLICK:"click",MANUAL:"manual"},m=function(){function a(t,e){n(this,a),this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}return a.prototype.enable=function(){this._isEnabled=!0},a.prototype.disable=function(){this._isEnabled=!1},a.prototype.toggleEnabled=function(){this._isEnabled=!this._isEnabled},a.prototype.toggle=function(e){if(e){var n=this.constructor.DATA_KEY,i=t(e.currentTarget).data(n);i||(i=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(n,i)),i._activeTrigger.click=!i._activeTrigger.click,i._isWithActiveTrigger()?i._enter(null,i):i._leave(null,i)}else{if(t(this.getTipElement()).hasClass(p.SHOW))return void this._leave(null,this);this._enter(null,this)}},a.prototype.dispose=function(){clearTimeout(this._timeout),t.removeData(this.element,this.constructor.DATA_KEY),t(this.element).off(this.constructor.EVENT_KEY),t(this.element).closest(".modal").off("hide.bs.modal"),this.tip&&t(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,this._activeTrigger=null,null!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},a.prototype.show=function(){var e=this;if("none"===t(this.element).css("display"))throw new Error("Please use show on visible elements");var n=t.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){t(this.element).trigger(n);var i=t.contains(this.element.ownerDocument.documentElement,this.element);if(n.isDefaultPrevented()||!i)return;var o=this.getTipElement(),s=r.getUID(this.constructor.NAME);o.setAttribute("id",s),this.element.setAttribute("aria-describedby",s),this.setContent(),this.config.animation&&t(o).addClass(p.FADE);var l="function"==typeof this.config.placement?this.config.placement.call(this,o,this.element):this.config.placement,h=this._getAttachment(l);this.addAttachmentClass(h);var c=!1===this.config.container?document.body:t(this.config.container);t(o).data(this.constructor.DATA_KEY,this),t.contains(this.element.ownerDocument.documentElement,this.tip)||t(o).appendTo(c),t(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new Popper(this.element,o,{placement:h,modifiers:{offset:{offset:this.config.offset},flip:{behavior:this.config.fallbackPlacement},arrow:{element:_.ARROW}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){e._handlePopperPlacementChange(t)}}),t(o).addClass(p.SHOW),"ontouchstart"in document.documentElement&&t("body").children().on("mouseover",null,t.noop);var u=function(){e.config.animation&&e._fixTransition();var n=e._hoverState;e._hoverState=null,t(e.element).trigger(e.constructor.Event.SHOWN),n===d.OUT&&e._leave(null,e)};r.supportsTransitionEnd()&&t(this.tip).hasClass(p.FADE)?t(this.tip).one(r.TRANSITION_END,u).emulateTransitionEnd(a._TRANSITION_DURATION):u()}},a.prototype.hide=function(e){var n=this,i=this.getTipElement(),o=t.Event(this.constructor.Event.HIDE),s=function(){n._hoverState!==d.SHOW&&i.parentNode&&i.parentNode.removeChild(i),n._cleanTipClass(),n.element.removeAttribute("aria-describedby"),t(n.element).trigger(n.constructor.Event.HIDDEN),null!==n._popper&&n._popper.destroy(),e&&e()};t(this.element).trigger(o),o.isDefaultPrevented()||(t(i).removeClass(p.SHOW),"ontouchstart"in document.documentElement&&t("body").children().off("mouseover",null,t.noop),this._activeTrigger[g.CLICK]=!1,this._activeTrigger[g.FOCUS]=!1,this._activeTrigger[g.HOVER]=!1,r.supportsTransitionEnd()&&t(this.tip).hasClass(p.FADE)?t(i).one(r.TRANSITION_END,s).emulateTransitionEnd(150):s(),this._hoverState="")},a.prototype.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},a.prototype.isWithContent=function(){return Boolean(this.getTitle())},a.prototype.addAttachmentClass=function(e){t(this.getTipElement()).addClass("bs-tooltip-"+e)},a.prototype.getTipElement=function(){return this.tip=this.tip||t(this.config.template)[0]},a.prototype.setContent=function(){var e=t(this.getTipElement());this.setElementContent(e.find(_.TOOLTIP_INNER),this.getTitle()),e.removeClass(p.FADE+" "+p.SHOW)},a.prototype.setElementContent=function(e,n){var o=this.config.html;"object"===(void 0===n?"undefined":i(n))&&(n.nodeType||n.jquery)?o?t(n).parent().is(e)||e.empty().append(n):e.text(t(n).text()):e[o?"html":"text"](n)},a.prototype.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},a.prototype._getAttachment=function(t){return c[t.toUpperCase()]},a.prototype._setListeners=function(){var e=this;this.config.trigger.split(" ").forEach(function(n){if("click"===n)t(e.element).on(e.constructor.Event.CLICK,e.config.selector,function(t){return e.toggle(t)});else if(n!==g.MANUAL){var i=n===g.HOVER?e.constructor.Event.MOUSEENTER:e.constructor.Event.FOCUSIN,o=n===g.HOVER?e.constructor.Event.MOUSELEAVE:e.constructor.Event.FOCUSOUT;t(e.element).on(i,e.config.selector,function(t){return e._enter(t)}).on(o,e.config.selector,function(t){return e._leave(t)})}t(e.element).closest(".modal").on("hide.bs.modal",function(){return e.hide()})}),this.config.selector?this.config=t.extend({},this.config,{trigger:"manual",selector:""}):this._fixTitle()},a.prototype._fixTitle=function(){var t=i(this.element.getAttribute("data-original-title"));(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},a.prototype._enter=function(e,n){var i=this.constructor.DATA_KEY;(n=n||t(e.currentTarget).data(i))||(n=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(i,n)),e&&(n._activeTrigger["focusin"===e.type?g.FOCUS:g.HOVER]=!0),t(n.getTipElement()).hasClass(p.SHOW)||n._hoverState===d.SHOW?n._hoverState=d.SHOW:(clearTimeout(n._timeout),n._hoverState=d.SHOW,n.config.delay&&n.config.delay.show?n._timeout=setTimeout(function(){n._hoverState===d.SHOW&&n.show()},n.config.delay.show):n.show())},a.prototype._leave=function(e,n){var i=this.constructor.DATA_KEY;(n=n||t(e.currentTarget).data(i))||(n=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(i,n)),e&&(n._activeTrigger["focusout"===e.type?g.FOCUS:g.HOVER]=!1),n._isWithActiveTrigger()||(clearTimeout(n._timeout),n._hoverState=d.OUT,n.config.delay&&n.config.delay.hide?n._timeout=setTimeout(function(){n._hoverState===d.OUT&&n.hide()},n.config.delay.hide):n.hide())},a.prototype._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},a.prototype._getConfig=function(n){return(n=t.extend({},this.constructor.Default,t(this.element).data(),n)).delay&&"number"==typeof n.delay&&(n.delay={show:n.delay,hide:n.delay}),n.title&&"number"==typeof n.title&&(n.title=n.title.toString()),n.content&&"number"==typeof n.content&&(n.content=n.content.toString()),r.typeCheckConfig(e,n,this.constructor.DefaultType),n},a.prototype._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},a.prototype._cleanTipClass=function(){var e=t(this.getTipElement()),n=e.attr("class").match(l);null!==n&&n.length>0&&e.removeClass(n.join(""))},a.prototype._handlePopperPlacementChange=function(t){this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},a.prototype._fixTransition=function(){var e=this.getTipElement(),n=this.config.animation;null===e.getAttribute("x-placement")&&(t(e).removeClass(p.FADE),this.config.animation=!1,this.hide(),this.show(),this.config.animation=n)},a._jQueryInterface=function(e){return this.each(function(){var n=t(this).data("bs.tooltip"),o="object"===(void 0===e?"undefined":i(e))&&e;if((n||!/dispose|hide/.test(e))&&(n||(n=new a(this,o),t(this).data("bs.tooltip",n)),"string"==typeof e)){if(void 0===n[e])throw new Error('No method named "'+e+'"');n[e]()}})},o(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return u}},{key:"NAME",get:function(){return e}},{key:"DATA_KEY",get:function(){return"bs.tooltip"}},{key:"Event",get:function(){return f}},{key:"EVENT_KEY",get:function(){return s}},{key:"DefaultType",get:function(){return h}}]),a}();return t.fn[e]=m._jQueryInterface,t.fn[e].Constructor=m,t.fn[e].noConflict=function(){return t.fn[e]=a,m._jQueryInterface},m}(jQuery));!function(r){var a="popover",l=".bs.popover",h=r.fn[a],c=new RegExp("(^|\\s)bs-popover\\S+","g"),u=r.extend({},s.Default,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),d=r.extend({},s.DefaultType,{content:"(string|element|function)"}),f={FADE:"fade",SHOW:"show"},p={TITLE:".popover-header",CONTENT:".popover-body"},_={HIDE:"hide"+l,HIDDEN:"hidden"+l,SHOW:"show"+l,SHOWN:"shown"+l,INSERTED:"inserted"+l,CLICK:"click"+l,FOCUSIN:"focusin"+l,FOCUSOUT:"focusout"+l,MOUSEENTER:"mouseenter"+l,MOUSELEAVE:"mouseleave"+l},g=function(s){function h(){return n(this,h),t(this,s.apply(this,arguments))}return e(h,s),h.prototype.isWithContent=function(){return this.getTitle()||this._getContent()},h.prototype.addAttachmentClass=function(t){r(this.getTipElement()).addClass("bs-popover-"+t)},h.prototype.getTipElement=function(){return this.tip=this.tip||r(this.config.template)[0]},h.prototype.setContent=function(){var t=r(this.getTipElement());this.setElementContent(t.find(p.TITLE),this.getTitle()),this.setElementContent(t.find(p.CONTENT),this._getContent()),t.removeClass(f.FADE+" "+f.SHOW)},h.prototype._getContent=function(){return this.element.getAttribute("data-content")||("function"==typeof this.config.content?this.config.content.call(this.element):this.config.content)},h.prototype._cleanTipClass=function(){var t=r(this.getTipElement()),e=t.attr("class").match(c);null!==e&&e.length>0&&t.removeClass(e.join(""))},h._jQueryInterface=function(t){return this.each(function(){var e=r(this).data("bs.popover"),n="object"===(void 0===t?"undefined":i(t))?t:null;if((e||!/destroy|hide/.test(t))&&(e||(e=new h(this,n),r(this).data("bs.popover",e)),"string"==typeof t)){if(void 0===e[t])throw new Error('No method named "'+t+'"');e[t]()}})},o(h,null,[{key:"VERSION",get:function(){return"4.0.0-beta"}},{key:"Default",get:function(){return u}},{key:"NAME",get:function(){return a}},{key:"DATA_KEY",get:function(){return"bs.popover"}},{key:"Event",get:function(){return _}},{key:"EVENT_KEY",get:function(){return l}},{key:"DefaultType",get:function(){return d}}]),h}(s);r.fn[a]=g._jQueryInterface,r.fn[a].Constructor=g,r.fn[a].noConflict=function(){return r.fn[a]=h,g._jQueryInterface}}(jQuery)}();
/*!
 * Packery PACKAGED v2.1.1
 * Gapless, draggable grid layouts
 *
 * Licensed GPLv3 for open source use
 * or Packery Commercial License for commercial use
 *
 * http://packery.metafizzy.co
 * Copyright 2016 Metafizzy
 */

!function(t,e){"use strict";"function"==typeof define&&define.amd?define("jquery-bridget/jquery-bridget",["jquery"],function(i){e(t,i)}):"object"==typeof module&&module.exports?module.exports=e(t,require("jquery")):t.jQueryBridget=e(t,t.jQuery)}(window,function(t,e){"use strict";function i(i,s,a){function h(t,e,n){var o,s="$()."+i+'("'+e+'")';return t.each(function(t,h){var u=a.data(h,i);if(!u)return void r(i+" not initialized. Cannot call methods, i.e. "+s);var c=u[e];if(!c||"_"==e.charAt(0))return void r(s+" is not a valid method");var d=c.apply(u,n);o=void 0===o?d:o}),void 0!==o?o:t}function u(t,e){t.each(function(t,n){var o=a.data(n,i);o?(o.option(e),o._init()):(o=new s(n,e),a.data(n,i,o))})}a=a||e||t.jQuery,a&&(s.prototype.option||(s.prototype.option=function(t){a.isPlainObject(t)&&(this.options=a.extend(!0,this.options,t))}),a.fn[i]=function(t){if("string"==typeof t){var e=o.call(arguments,1);return h(this,t,e)}return u(this,t),this},n(a))}function n(t){!t||t&&t.bridget||(t.bridget=i)}var o=Array.prototype.slice,s=t.console,r="undefined"==typeof s?function(){}:function(t){s.error(t)};return n(e||t.jQuery),i}),function(t,e){"use strict";"function"==typeof define&&define.amd?define("get-size/get-size",[],function(){return e()}):"object"==typeof module&&module.exports?module.exports=e():t.getSize=e()}(window,function(){"use strict";function t(t){var e=parseFloat(t),i=-1==t.indexOf("%")&&!isNaN(e);return i&&e}function e(){}function i(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},e=0;u>e;e++){var i=h[e];t[i]=0}return t}function n(t){var e=getComputedStyle(t);return e||a("Style returned "+e+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),e}function o(){if(!c){c=!0;var e=document.createElement("div");e.style.width="200px",e.style.padding="1px 2px 3px 4px",e.style.borderStyle="solid",e.style.borderWidth="1px 2px 3px 4px",e.style.boxSizing="border-box";var i=document.body||document.documentElement;i.appendChild(e);var o=n(e);s.isBoxSizeOuter=r=200==t(o.width),i.removeChild(e)}}function s(e){if(o(),"string"==typeof e&&(e=document.querySelector(e)),e&&"object"==typeof e&&e.nodeType){var s=n(e);if("none"==s.display)return i();var a={};a.width=e.offsetWidth,a.height=e.offsetHeight;for(var c=a.isBorderBox="border-box"==s.boxSizing,d=0;u>d;d++){var f=h[d],l=s[f],p=parseFloat(l);a[f]=isNaN(p)?0:p}var g=a.paddingLeft+a.paddingRight,m=a.paddingTop+a.paddingBottom,y=a.marginLeft+a.marginRight,v=a.marginTop+a.marginBottom,_=a.borderLeftWidth+a.borderRightWidth,x=a.borderTopWidth+a.borderBottomWidth,b=c&&r,E=t(s.width);E!==!1&&(a.width=E+(b?0:g+_));var T=t(s.height);return T!==!1&&(a.height=T+(b?0:m+x)),a.innerWidth=a.width-(g+_),a.innerHeight=a.height-(m+x),a.outerWidth=a.width+y,a.outerHeight=a.height+v,a}}var r,a="undefined"==typeof console?e:function(t){console.error(t)},h=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],u=h.length,c=!1;return s}),function(t,e){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",e):"object"==typeof module&&module.exports?module.exports=e():t.EvEmitter=e()}(this,function(){function t(){}var e=t.prototype;return e.on=function(t,e){if(t&&e){var i=this._events=this._events||{},n=i[t]=i[t]||[];return-1==n.indexOf(e)&&n.push(e),this}},e.once=function(t,e){if(t&&e){this.on(t,e);var i=this._onceEvents=this._onceEvents||{},n=i[t]=i[t]||{};return n[e]=!0,this}},e.off=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=i.indexOf(e);return-1!=n&&i.splice(n,1),this}},e.emitEvent=function(t,e){var i=this._events&&this._events[t];if(i&&i.length){var n=0,o=i[n];e=e||[];for(var s=this._onceEvents&&this._onceEvents[t];o;){var r=s&&s[o];r&&(this.off(t,o),delete s[o]),o.apply(this,e),n+=r?0:1,o=i[n]}return this}},t}),function(t,e){"use strict";"function"==typeof define&&define.amd?define("desandro-matches-selector/matches-selector",e):"object"==typeof module&&module.exports?module.exports=e():t.matchesSelector=e()}(window,function(){"use strict";var t=function(){var t=Element.prototype;if(t.matches)return"matches";if(t.matchesSelector)return"matchesSelector";for(var e=["webkit","moz","ms","o"],i=0;i<e.length;i++){var n=e[i],o=n+"MatchesSelector";if(t[o])return o}}();return function(e,i){return e[t](i)}}),function(t,e){"function"==typeof define&&define.amd?define("fizzy-ui-utils/utils",["desandro-matches-selector/matches-selector"],function(i){return e(t,i)}):"object"==typeof module&&module.exports?module.exports=e(t,require("desandro-matches-selector")):t.fizzyUIUtils=e(t,t.matchesSelector)}(window,function(t,e){var i={};i.extend=function(t,e){for(var i in e)t[i]=e[i];return t},i.modulo=function(t,e){return(t%e+e)%e},i.makeArray=function(t){var e=[];if(Array.isArray(t))e=t;else if(t&&"number"==typeof t.length)for(var i=0;i<t.length;i++)e.push(t[i]);else e.push(t);return e},i.removeFrom=function(t,e){var i=t.indexOf(e);-1!=i&&t.splice(i,1)},i.getParent=function(t,i){for(;t!=document.body;)if(t=t.parentNode,e(t,i))return t},i.getQueryElement=function(t){return"string"==typeof t?document.querySelector(t):t},i.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},i.filterFindElements=function(t,n){t=i.makeArray(t);var o=[];return t.forEach(function(t){if(t instanceof HTMLElement){if(!n)return void o.push(t);e(t,n)&&o.push(t);for(var i=t.querySelectorAll(n),s=0;s<i.length;s++)o.push(i[s])}}),o},i.debounceMethod=function(t,e,i){var n=t.prototype[e],o=e+"Timeout";t.prototype[e]=function(){var t=this[o];t&&clearTimeout(t);var e=arguments,s=this;this[o]=setTimeout(function(){n.apply(s,e),delete s[o]},i||100)}},i.docReady=function(t){"complete"==document.readyState?t():document.addEventListener("DOMContentLoaded",t)},i.toDashed=function(t){return t.replace(/(.)([A-Z])/g,function(t,e,i){return e+"-"+i}).toLowerCase()};var n=t.console;return i.htmlInit=function(e,o){i.docReady(function(){var s=i.toDashed(o),r="data-"+s,a=document.querySelectorAll("["+r+"]"),h=document.querySelectorAll(".js-"+s),u=i.makeArray(a).concat(i.makeArray(h)),c=r+"-options",d=t.jQuery;u.forEach(function(t){var i,s=t.getAttribute(r)||t.getAttribute(c);try{i=s&&JSON.parse(s)}catch(a){return void(n&&n.error("Error parsing "+r+" on "+t.className+": "+a))}var h=new e(t,i);d&&d.data(t,o,h)})})},i}),function(t,e){"function"==typeof define&&define.amd?define("outlayer/item",["ev-emitter/ev-emitter","get-size/get-size"],e):"object"==typeof module&&module.exports?module.exports=e(require("ev-emitter"),require("get-size")):(t.Outlayer={},t.Outlayer.Item=e(t.EvEmitter,t.getSize))}(window,function(t,e){"use strict";function i(t){for(var e in t)return!1;return e=null,!0}function n(t,e){t&&(this.element=t,this.layout=e,this.position={x:0,y:0},this._create())}function o(t){return t.replace(/([A-Z])/g,function(t){return"-"+t.toLowerCase()})}var s=document.documentElement.style,r="string"==typeof s.transition?"transition":"WebkitTransition",a="string"==typeof s.transform?"transform":"WebkitTransform",h={WebkitTransition:"webkitTransitionEnd",transition:"transitionend"}[r],u={transform:a,transition:r,transitionDuration:r+"Duration",transitionProperty:r+"Property",transitionDelay:r+"Delay"},c=n.prototype=Object.create(t.prototype);c.constructor=n,c._create=function(){this._transn={ingProperties:{},clean:{},onEnd:{}},this.css({position:"absolute"})},c.handleEvent=function(t){var e="on"+t.type;this[e]&&this[e](t)},c.getSize=function(){this.size=e(this.element)},c.css=function(t){var e=this.element.style;for(var i in t){var n=u[i]||i;e[n]=t[i]}},c.getPosition=function(){var t=getComputedStyle(this.element),e=this.layout._getOption("originLeft"),i=this.layout._getOption("originTop"),n=t[e?"left":"right"],o=t[i?"top":"bottom"],s=this.layout.size,r=-1!=n.indexOf("%")?parseFloat(n)/100*s.width:parseInt(n,10),a=-1!=o.indexOf("%")?parseFloat(o)/100*s.height:parseInt(o,10);r=isNaN(r)?0:r,a=isNaN(a)?0:a,r-=e?s.paddingLeft:s.paddingRight,a-=i?s.paddingTop:s.paddingBottom,this.position.x=r,this.position.y=a},c.layoutPosition=function(){var t=this.layout.size,e={},i=this.layout._getOption("originLeft"),n=this.layout._getOption("originTop"),o=i?"paddingLeft":"paddingRight",s=i?"left":"right",r=i?"right":"left",a=this.position.x+t[o];e[s]=this.getXValue(a),e[r]="";var h=n?"paddingTop":"paddingBottom",u=n?"top":"bottom",c=n?"bottom":"top",d=this.position.y+t[h];e[u]=this.getYValue(d),e[c]="",this.css(e),this.emitEvent("layout",[this])},c.getXValue=function(t){var e=this.layout._getOption("horizontal");return this.layout.options.percentPosition&&!e?t/this.layout.size.width*100+"%":t+"px"},c.getYValue=function(t){var e=this.layout._getOption("horizontal");return this.layout.options.percentPosition&&e?t/this.layout.size.height*100+"%":t+"px"},c._transitionTo=function(t,e){this.getPosition();var i=this.position.x,n=this.position.y,o=parseInt(t,10),s=parseInt(e,10),r=o===this.position.x&&s===this.position.y;if(this.setPosition(t,e),r&&!this.isTransitioning)return void this.layoutPosition();var a=t-i,h=e-n,u={};u.transform=this.getTranslate(a,h),this.transition({to:u,onTransitionEnd:{transform:this.layoutPosition},isCleaning:!0})},c.getTranslate=function(t,e){var i=this.layout._getOption("originLeft"),n=this.layout._getOption("originTop");return t=i?t:-t,e=n?e:-e,"translate3d("+t+"px, "+e+"px, 0)"},c.goTo=function(t,e){this.setPosition(t,e),this.layoutPosition()},c.moveTo=c._transitionTo,c.setPosition=function(t,e){this.position.x=parseInt(t,10),this.position.y=parseInt(e,10)},c._nonTransition=function(t){this.css(t.to),t.isCleaning&&this._removeStyles(t.to);for(var e in t.onTransitionEnd)t.onTransitionEnd[e].call(this)},c.transition=function(t){if(!parseFloat(this.layout.options.transitionDuration))return void this._nonTransition(t);var e=this._transn;for(var i in t.onTransitionEnd)e.onEnd[i]=t.onTransitionEnd[i];for(i in t.to)e.ingProperties[i]=!0,t.isCleaning&&(e.clean[i]=!0);if(t.from){this.css(t.from);var n=this.element.offsetHeight;n=null}this.enableTransition(t.to),this.css(t.to),this.isTransitioning=!0};var d="opacity,"+o(a);c.enableTransition=function(){if(!this.isTransitioning){var t=this.layout.options.transitionDuration;t="number"==typeof t?t+"ms":t,this.css({transitionProperty:d,transitionDuration:t,transitionDelay:this.staggerDelay||0}),this.element.addEventListener(h,this,!1)}},c.onwebkitTransitionEnd=function(t){this.ontransitionend(t)},c.onotransitionend=function(t){this.ontransitionend(t)};var f={"-webkit-transform":"transform"};c.ontransitionend=function(t){if(t.target===this.element){var e=this._transn,n=f[t.propertyName]||t.propertyName;if(delete e.ingProperties[n],i(e.ingProperties)&&this.disableTransition(),n in e.clean&&(this.element.style[t.propertyName]="",delete e.clean[n]),n in e.onEnd){var o=e.onEnd[n];o.call(this),delete e.onEnd[n]}this.emitEvent("transitionEnd",[this])}},c.disableTransition=function(){this.removeTransitionStyles(),this.element.removeEventListener(h,this,!1),this.isTransitioning=!1},c._removeStyles=function(t){var e={};for(var i in t)e[i]="";this.css(e)};var l={transitionProperty:"",transitionDuration:"",transitionDelay:""};return c.removeTransitionStyles=function(){this.css(l)},c.stagger=function(t){t=isNaN(t)?0:t,this.staggerDelay=t+"ms"},c.removeElem=function(){this.element.parentNode.removeChild(this.element),this.css({display:""}),this.emitEvent("remove",[this])},c.remove=function(){return r&&parseFloat(this.layout.options.transitionDuration)?(this.once("transitionEnd",function(){this.removeElem()}),void this.hide()):void this.removeElem()},c.reveal=function(){delete this.isHidden,this.css({display:""});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty("visibleStyle");e[i]=this.onRevealTransitionEnd,this.transition({from:t.hiddenStyle,to:t.visibleStyle,isCleaning:!0,onTransitionEnd:e})},c.onRevealTransitionEnd=function(){this.isHidden||this.emitEvent("reveal")},c.getHideRevealTransitionEndProperty=function(t){var e=this.layout.options[t];if(e.opacity)return"opacity";for(var i in e)return i},c.hide=function(){this.isHidden=!0,this.css({display:""});var t=this.layout.options,e={},i=this.getHideRevealTransitionEndProperty("hiddenStyle");e[i]=this.onHideTransitionEnd,this.transition({from:t.visibleStyle,to:t.hiddenStyle,isCleaning:!0,onTransitionEnd:e})},c.onHideTransitionEnd=function(){this.isHidden&&(this.css({display:"none"}),this.emitEvent("hide"))},c.destroy=function(){this.css({position:"",left:"",right:"",top:"",bottom:"",transition:"",transform:""})},n}),function(t,e){"use strict";"function"==typeof define&&define.amd?define("outlayer/outlayer",["ev-emitter/ev-emitter","get-size/get-size","fizzy-ui-utils/utils","./item"],function(i,n,o,s){return e(t,i,n,o,s)}):"object"==typeof module&&module.exports?module.exports=e(t,require("ev-emitter"),require("get-size"),require("fizzy-ui-utils"),require("./item")):t.Outlayer=e(t,t.EvEmitter,t.getSize,t.fizzyUIUtils,t.Outlayer.Item)}(window,function(t,e,i,n,o){"use strict";function s(t,e){var i=n.getQueryElement(t);if(!i)return void(h&&h.error("Bad element for "+this.constructor.namespace+": "+(i||t)));this.element=i,u&&(this.$element=u(this.element)),this.options=n.extend({},this.constructor.defaults),this.option(e);var o=++d;this.element.outlayerGUID=o,f[o]=this,this._create();var s=this._getOption("initLayout");s&&this.layout()}function r(t){function e(){t.apply(this,arguments)}return e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e}function a(t){if("number"==typeof t)return t;var e=t.match(/(^\d*\.?\d*)(\w*)/),i=e&&e[1],n=e&&e[2];if(!i.length)return 0;i=parseFloat(i);var o=p[n]||1;return i*o}var h=t.console,u=t.jQuery,c=function(){},d=0,f={};s.namespace="outlayer",s.Item=o,s.defaults={containerStyle:{position:"relative"},initLayout:!0,originLeft:!0,originTop:!0,resize:!0,resizeContainer:!0,transitionDuration:"0.4s",hiddenStyle:{opacity:0,transform:"scale(0.001)"},visibleStyle:{opacity:1,transform:"scale(1)"}};var l=s.prototype;n.extend(l,e.prototype),l.option=function(t){n.extend(this.options,t)},l._getOption=function(t){var e=this.constructor.compatOptions[t];return e&&void 0!==this.options[e]?this.options[e]:this.options[t]},s.compatOptions={initLayout:"isInitLayout",horizontal:"isHorizontal",layoutInstant:"isLayoutInstant",originLeft:"isOriginLeft",originTop:"isOriginTop",resize:"isResizeBound",resizeContainer:"isResizingContainer"},l._create=function(){this.reloadItems(),this.stamps=[],this.stamp(this.options.stamp),n.extend(this.element.style,this.options.containerStyle);var t=this._getOption("resize");t&&this.bindResize()},l.reloadItems=function(){this.items=this._itemize(this.element.children)},l._itemize=function(t){for(var e=this._filterFindItemElements(t),i=this.constructor.Item,n=[],o=0;o<e.length;o++){var s=e[o],r=new i(s,this);n.push(r)}return n},l._filterFindItemElements=function(t){return n.filterFindElements(t,this.options.itemSelector)},l.getItemElements=function(){return this.items.map(function(t){return t.element})},l.layout=function(){this._resetLayout(),this._manageStamps();var t=this._getOption("layoutInstant"),e=void 0!==t?t:!this._isLayoutInited;this.layoutItems(this.items,e),this._isLayoutInited=!0},l._init=l.layout,l._resetLayout=function(){this.getSize()},l.getSize=function(){this.size=i(this.element)},l._getMeasurement=function(t,e){var n,o=this.options[t];o?("string"==typeof o?n=this.element.querySelector(o):o instanceof HTMLElement&&(n=o),this[t]=n?i(n)[e]:o):this[t]=0},l.layoutItems=function(t,e){t=this._getItemsForLayout(t),this._layoutItems(t,e),this._postLayout()},l._getItemsForLayout=function(t){return t.filter(function(t){return!t.isIgnored})},l._layoutItems=function(t,e){if(this._emitCompleteOnItems("layout",t),t&&t.length){var i=[];t.forEach(function(t){var n=this._getItemLayoutPosition(t);n.item=t,n.isInstant=e||t.isLayoutInstant,i.push(n)},this),this._processLayoutQueue(i)}},l._getItemLayoutPosition=function(){return{x:0,y:0}},l._processLayoutQueue=function(t){this.updateStagger(),t.forEach(function(t,e){this._positionItem(t.item,t.x,t.y,t.isInstant,e)},this)},l.updateStagger=function(){var t=this.options.stagger;return null===t||void 0===t?void(this.stagger=0):(this.stagger=a(t),this.stagger)},l._positionItem=function(t,e,i,n,o){n?t.goTo(e,i):(t.stagger(o*this.stagger),t.moveTo(e,i))},l._postLayout=function(){this.resizeContainer()},l.resizeContainer=function(){var t=this._getOption("resizeContainer");if(t){var e=this._getContainerSize();e&&(this._setContainerMeasure(e.width,!0),this._setContainerMeasure(e.height,!1))}},l._getContainerSize=c,l._setContainerMeasure=function(t,e){if(void 0!==t){var i=this.size;i.isBorderBox&&(t+=e?i.paddingLeft+i.paddingRight+i.borderLeftWidth+i.borderRightWidth:i.paddingBottom+i.paddingTop+i.borderTopWidth+i.borderBottomWidth),t=Math.max(t,0),this.element.style[e?"width":"height"]=t+"px"}},l._emitCompleteOnItems=function(t,e){function i(){o.dispatchEvent(t+"Complete",null,[e])}function n(){r++,r==s&&i()}var o=this,s=e.length;if(!e||!s)return void i();var r=0;e.forEach(function(e){e.once(t,n)})},l.dispatchEvent=function(t,e,i){var n=e?[e].concat(i):i;if(this.emitEvent(t,n),u)if(this.$element=this.$element||u(this.element),e){var o=u.Event(e);o.type=t,this.$element.trigger(o,i)}else this.$element.trigger(t,i)},l.ignore=function(t){var e=this.getItem(t);e&&(e.isIgnored=!0)},l.unignore=function(t){var e=this.getItem(t);e&&delete e.isIgnored},l.stamp=function(t){t=this._find(t),t&&(this.stamps=this.stamps.concat(t),t.forEach(this.ignore,this))},l.unstamp=function(t){t=this._find(t),t&&t.forEach(function(t){n.removeFrom(this.stamps,t),this.unignore(t)},this)},l._find=function(t){return t?("string"==typeof t&&(t=this.element.querySelectorAll(t)),t=n.makeArray(t)):void 0},l._manageStamps=function(){this.stamps&&this.stamps.length&&(this._getBoundingRect(),this.stamps.forEach(this._manageStamp,this))},l._getBoundingRect=function(){var t=this.element.getBoundingClientRect(),e=this.size;this._boundingRect={left:t.left+e.paddingLeft+e.borderLeftWidth,top:t.top+e.paddingTop+e.borderTopWidth,right:t.right-(e.paddingRight+e.borderRightWidth),bottom:t.bottom-(e.paddingBottom+e.borderBottomWidth)}},l._manageStamp=c,l._getElementOffset=function(t){var e=t.getBoundingClientRect(),n=this._boundingRect,o=i(t),s={left:e.left-n.left-o.marginLeft,top:e.top-n.top-o.marginTop,right:n.right-e.right-o.marginRight,bottom:n.bottom-e.bottom-o.marginBottom};return s},l.handleEvent=n.handleEvent,l.bindResize=function(){t.addEventListener("resize",this),this.isResizeBound=!0},l.unbindResize=function(){t.removeEventListener("resize",this),this.isResizeBound=!1},l.onresize=function(){this.resize()},n.debounceMethod(s,"onresize",100),l.resize=function(){this.isResizeBound&&this.needsResizeLayout()&&this.layout()},l.needsResizeLayout=function(){var t=i(this.element),e=this.size&&t;return e&&t.innerWidth!==this.size.innerWidth},l.addItems=function(t){var e=this._itemize(t);return e.length&&(this.items=this.items.concat(e)),e},l.appended=function(t){var e=this.addItems(t);e.length&&(this.layoutItems(e,!0),this.reveal(e))},l.prepended=function(t){var e=this._itemize(t);if(e.length){var i=this.items.slice(0);this.items=e.concat(i),this._resetLayout(),this._manageStamps(),this.layoutItems(e,!0),this.reveal(e),this.layoutItems(i)}},l.reveal=function(t){if(this._emitCompleteOnItems("reveal",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.reveal()})}},l.hide=function(t){if(this._emitCompleteOnItems("hide",t),t&&t.length){var e=this.updateStagger();t.forEach(function(t,i){t.stagger(i*e),t.hide()})}},l.revealItemElements=function(t){var e=this.getItems(t);this.reveal(e)},l.hideItemElements=function(t){var e=this.getItems(t);this.hide(e)},l.getItem=function(t){for(var e=0;e<this.items.length;e++){var i=this.items[e];if(i.element==t)return i}},l.getItems=function(t){t=n.makeArray(t);var e=[];return t.forEach(function(t){var i=this.getItem(t);i&&e.push(i)},this),e},l.remove=function(t){var e=this.getItems(t);this._emitCompleteOnItems("remove",e),e&&e.length&&e.forEach(function(t){t.remove(),n.removeFrom(this.items,t)},this)},l.destroy=function(){var t=this.element.style;t.height="",t.position="",t.width="",this.items.forEach(function(t){t.destroy()}),this.unbindResize();var e=this.element.outlayerGUID;delete f[e],delete this.element.outlayerGUID,u&&u.removeData(this.element,this.constructor.namespace)},s.data=function(t){t=n.getQueryElement(t);var e=t&&t.outlayerGUID;return e&&f[e]},s.create=function(t,e){var i=r(s);return i.defaults=n.extend({},s.defaults),n.extend(i.defaults,e),i.compatOptions=n.extend({},s.compatOptions),i.namespace=t,i.data=s.data,i.Item=r(o),n.htmlInit(i,t),u&&u.bridget&&u.bridget(t,i),i};var p={ms:1,s:1e3};return s.Item=o,s}),function(t,e){"function"==typeof define&&define.amd?define("packery/js/rect",e):"object"==typeof module&&module.exports?module.exports=e():(t.Packery=t.Packery||{},t.Packery.Rect=e())}(window,function(){"use strict";function t(e){for(var i in t.defaults)this[i]=t.defaults[i];for(i in e)this[i]=e[i]}t.defaults={x:0,y:0,width:0,height:0};var e=t.prototype;return e.contains=function(t){var e=t.width||0,i=t.height||0;return this.x<=t.x&&this.y<=t.y&&this.x+this.width>=t.x+e&&this.y+this.height>=t.y+i},e.overlaps=function(t){var e=this.x+this.width,i=this.y+this.height,n=t.x+t.width,o=t.y+t.height;return this.x<n&&e>t.x&&this.y<o&&i>t.y},e.getMaximalFreeRects=function(e){if(!this.overlaps(e))return!1;var i,n=[],o=this.x+this.width,s=this.y+this.height,r=e.x+e.width,a=e.y+e.height;return this.y<e.y&&(i=new t({x:this.x,y:this.y,width:this.width,height:e.y-this.y}),n.push(i)),o>r&&(i=new t({x:r,y:this.y,width:o-r,height:this.height}),n.push(i)),s>a&&(i=new t({x:this.x,y:a,width:this.width,height:s-a}),n.push(i)),this.x<e.x&&(i=new t({x:this.x,y:this.y,width:e.x-this.x,height:this.height}),n.push(i)),n},e.canFit=function(t){return this.width>=t.width&&this.height>=t.height},t}),function(t,e){if("function"==typeof define&&define.amd)define("packery/js/packer",["./rect"],e);else if("object"==typeof module&&module.exports)module.exports=e(require("./rect"));else{var i=t.Packery=t.Packery||{};i.Packer=e(i.Rect)}}(window,function(t){"use strict";function e(t,e,i){this.width=t||0,this.height=e||0,this.sortDirection=i||"downwardLeftToRight",this.reset()}var i=e.prototype;i.reset=function(){this.spaces=[];var e=new t({x:0,y:0,width:this.width,height:this.height});this.spaces.push(e),this.sorter=n[this.sortDirection]||n.downwardLeftToRight},i.pack=function(t){for(var e=0;e<this.spaces.length;e++){var i=this.spaces[e];if(i.canFit(t)){this.placeInSpace(t,i);break}}},i.columnPack=function(t){for(var e=0;e<this.spaces.length;e++){var i=this.spaces[e],n=i.x<=t.x&&i.x+i.width>=t.x+t.width&&i.height>=t.height-.01;if(n){t.y=i.y,this.placed(t);break}}},i.rowPack=function(t){for(var e=0;e<this.spaces.length;e++){var i=this.spaces[e],n=i.y<=t.y&&i.y+i.height>=t.y+t.height&&i.width>=t.width-.01;if(n){t.x=i.x,this.placed(t);break}}},i.placeInSpace=function(t,e){t.x=e.x,t.y=e.y,this.placed(t)},i.placed=function(t){for(var e=[],i=0;i<this.spaces.length;i++){var n=this.spaces[i],o=n.getMaximalFreeRects(t);o?e.push.apply(e,o):e.push(n)}this.spaces=e,this.mergeSortSpaces()},i.mergeSortSpaces=function(){e.mergeRects(this.spaces),this.spaces.sort(this.sorter)},i.addSpace=function(t){this.spaces.push(t),this.mergeSortSpaces()},e.mergeRects=function(t){var e=0,i=t[e];t:for(;i;){for(var n=0,o=t[e+n];o;){if(o==i)n++;else{if(o.contains(i)){t.splice(e,1),i=t[e];continue t}i.contains(o)?t.splice(e+n,1):n++}o=t[e+n]}e++,i=t[e]}return t};var n={downwardLeftToRight:function(t,e){return t.y-e.y||t.x-e.x},rightwardTopToBottom:function(t,e){return t.x-e.x||t.y-e.y}};return e}),function(t,e){"function"==typeof define&&define.amd?define("packery/js/item",["outlayer/outlayer","./rect"],e):"object"==typeof module&&module.exports?module.exports=e(require("outlayer"),require("./rect")):t.Packery.Item=e(t.Outlayer,t.Packery.Rect)}(window,function(t,e){"use strict";var i=document.documentElement.style,n="string"==typeof i.transform?"transform":"WebkitTransform",o=function(){t.Item.apply(this,arguments)},s=o.prototype=Object.create(t.Item.prototype),r=s._create;s._create=function(){r.call(this),this.rect=new e};var a=s.moveTo;return s.moveTo=function(t,e){var i=Math.abs(this.position.x-t),n=Math.abs(this.position.y-e),o=this.layout.dragItemCount&&!this.isPlacing&&!this.isTransitioning&&1>i&&1>n;return o?void this.goTo(t,e):void a.apply(this,arguments)},s.enablePlacing=function(){this.removeTransitionStyles(),this.isTransitioning&&n&&(this.element.style[n]="none"),this.isTransitioning=!1,this.getSize(),this.layout._setRectSize(this.element,this.rect),this.isPlacing=!0},s.disablePlacing=function(){this.isPlacing=!1},s.removeElem=function(){this.element.parentNode.removeChild(this.element),this.layout.packer.addSpace(this.rect),this.emitEvent("remove",[this])},s.showDropPlaceholder=function(){var t=this.dropPlaceholder;t||(t=this.dropPlaceholder=document.createElement("div"),t.className="packery-drop-placeholder",t.style.position="absolute"),t.style.width=this.size.width+"px",t.style.height=this.size.height+"px",this.positionDropPlaceholder(),this.layout.element.appendChild(t)},s.positionDropPlaceholder=function(){this.dropPlaceholder.style[n]="translate("+this.rect.x+"px, "+this.rect.y+"px)"},s.hideDropPlaceholder=function(){var t=this.dropPlaceholder.parentNode;t&&t.removeChild(this.dropPlaceholder)},o}),function(t,e){"function"==typeof define&&define.amd?define(["get-size/get-size","outlayer/outlayer","packery/js/rect","packery/js/packer","packery/js/item"],e):"object"==typeof module&&module.exports?module.exports=e(require("get-size"),require("outlayer"),require("./rect"),require("./packer"),require("./item")):t.Packery=e(t.getSize,t.Outlayer,t.Packery.Rect,t.Packery.Packer,t.Packery.Item)}(window,function(t,e,i,n,o){"use strict";function s(t,e){return t.position.y-e.position.y||t.position.x-e.position.x}function r(t,e){return t.position.x-e.position.x||t.position.y-e.position.y}function a(t,e){var i=e.x-t.x,n=e.y-t.y;return Math.sqrt(i*i+n*n)}i.prototype.canFit=function(t){return this.width>=t.width-1&&this.height>=t.height-1};var h=e.create("packery");h.Item=o;var u=h.prototype;u._create=function(){e.prototype._create.call(this),this.packer=new n,this.shiftPacker=new n,this.isEnabled=!0,this.dragItemCount=0;var t=this;this.handleDraggabilly={dragStart:function(){t.itemDragStart(this.element)},dragMove:function(){t.itemDragMove(this.element,this.position.x,this.position.y)},dragEnd:function(){t.itemDragEnd(this.element)}},this.handleUIDraggable={start:function(e,i){i&&t.itemDragStart(e.currentTarget)},drag:function(e,i){i&&t.itemDragMove(e.currentTarget,i.position.left,i.position.top)},stop:function(e,i){i&&t.itemDragEnd(e.currentTarget)}}},u._resetLayout=function(){this.getSize(),this._getMeasurements();var t,e,i;this._getOption("horizontal")?(t=1/0,e=this.size.innerHeight+this.gutter,i="rightwardTopToBottom"):(t=this.size.innerWidth+this.gutter,e=1/0,i="downwardLeftToRight"),this.packer.width=this.shiftPacker.width=t,this.packer.height=this.shiftPacker.height=e,this.packer.sortDirection=this.shiftPacker.sortDirection=i,this.packer.reset(),this.maxY=0,this.maxX=0},u._getMeasurements=function(){this._getMeasurement("columnWidth","width"),this._getMeasurement("rowHeight","height"),this._getMeasurement("gutter","width")},u._getItemLayoutPosition=function(t){if(this._setRectSize(t.element,t.rect),this.isShifting||this.dragItemCount>0){var e=this._getPackMethod();this.packer[e](t.rect)}else this.packer.pack(t.rect);return this._setMaxXY(t.rect),t.rect},u.shiftLayout=function(){this.isShifting=!0,this.layout(),delete this.isShifting},u._getPackMethod=function(){return this._getOption("horizontal")?"rowPack":"columnPack"},u._setMaxXY=function(t){this.maxX=Math.max(t.x+t.width,this.maxX),this.maxY=Math.max(t.y+t.height,this.maxY)},u._setRectSize=function(e,i){var n=t(e),o=n.outerWidth,s=n.outerHeight;(o||s)&&(o=this._applyGridGutter(o,this.columnWidth),s=this._applyGridGutter(s,this.rowHeight)),i.width=Math.min(o,this.packer.width),i.height=Math.min(s,this.packer.height)},u._applyGridGutter=function(t,e){if(!e)return t+this.gutter;e+=this.gutter;var i=t%e,n=i&&1>i?"round":"ceil";return t=Math[n](t/e)*e},u._getContainerSize=function(){return this._getOption("horizontal")?{width:this.maxX-this.gutter}:{height:this.maxY-this.gutter}},u._manageStamp=function(t){var e,n=this.getItem(t);if(n&&n.isPlacing)e=n.rect;else{var o=this._getElementOffset(t);e=new i({x:this._getOption("originLeft")?o.left:o.right,y:this._getOption("originTop")?o.top:o.bottom})}this._setRectSize(t,e),this.packer.placed(e),this._setMaxXY(e)},u.sortItemsByPosition=function(){var t=this._getOption("horizontal")?r:s;this.items.sort(t)},u.fit=function(t,e,i){var n=this.getItem(t);n&&(this.stamp(n.element),n.enablePlacing(),this.updateShiftTargets(n),e=void 0===e?n.rect.x:e,i=void 0===i?n.rect.y:i,this.shift(n,e,i),this._bindFitEvents(n),n.moveTo(n.rect.x,n.rect.y),this.shiftLayout(),this.unstamp(n.element),this.sortItemsByPosition(),n.disablePlacing())},u._bindFitEvents=function(t){function e(){n++,2==n&&i.dispatchEvent("fitComplete",null,[t])}var i=this,n=0;t.once("layout",e),this.once("layoutComplete",e)},u.resize=function(){this.isResizeBound&&this.needsResizeLayout()&&(this.options.shiftPercentResize?this.resizeShiftPercentLayout():this.layout())},u.needsResizeLayout=function(){var e=t(this.element),i=this._getOption("horizontal")?"innerHeight":"innerWidth";return e[i]!=this.size[i]},u.resizeShiftPercentLayout=function(){var e=this._getItemsForLayout(this.items),i=this._getOption("horizontal"),n=i?"y":"x",o=i?"height":"width",s=i?"rowHeight":"columnWidth",r=i?"innerHeight":"innerWidth",a=this[s];if(a=a&&a+this.gutter){this._getMeasurements();var h=this[s]+this.gutter;e.forEach(function(t){var e=Math.round(t.rect[n]/a);t.rect[n]=e*h})}else{var u=t(this.element)[r]+this.gutter,c=this.packer[o];e.forEach(function(t){t.rect[n]=t.rect[n]/c*u})}this.shiftLayout()},u.itemDragStart=function(t){if(this.isEnabled){this.stamp(t);var e=this.getItem(t);e&&(e.enablePlacing(),e.showDropPlaceholder(),this.dragItemCount++,this.updateShiftTargets(e))}},u.updateShiftTargets=function(t){this.shiftPacker.reset(),this._getBoundingRect();var e=this._getOption("originLeft"),n=this._getOption("originTop");this.stamps.forEach(function(t){var o=this.getItem(t);if(!o||!o.isPlacing){var s=this._getElementOffset(t),r=new i({x:e?s.left:s.right,y:n?s.top:s.bottom});this._setRectSize(t,r),this.shiftPacker.placed(r)}},this);var o=this._getOption("horizontal"),s=o?"rowHeight":"columnWidth",r=o?"height":"width";this.shiftTargetKeys=[],this.shiftTargets=[];var a,h=this[s];if(h=h&&h+this.gutter){var u=Math.ceil(t.rect[r]/h),c=Math.floor((this.shiftPacker[r]+this.gutter)/h);a=(c-u)*h;for(var d=0;c>d;d++){var f=o?0:d*h,l=o?d*h:0;this._addShiftTarget(f,l,a)}}else a=this.shiftPacker[r]+this.gutter-t.rect[r],this._addShiftTarget(0,0,a);var p=this._getItemsForLayout(this.items),g=this._getPackMethod();p.forEach(function(t){var e=t.rect;this._setRectSize(t.element,e),this.shiftPacker[g](e),this._addShiftTarget(e.x,e.y,a);var i=o?e.x+e.width:e.x,n=o?e.y:e.y+e.height;if(this._addShiftTarget(i,n,a),h)for(var s=Math.round(e[r]/h),u=1;s>u;u++){var c=o?i:e.x+h*u,d=o?e.y+h*u:n;this._addShiftTarget(c,d,a)}},this)},u._addShiftTarget=function(t,e,i){var n=this._getOption("horizontal")?e:t;if(!(0!==n&&n>i)){var o=t+","+e,s=-1!=this.shiftTargetKeys.indexOf(o);s||(this.shiftTargetKeys.push(o),this.shiftTargets.push({x:t,y:e}))}},u.shift=function(t,e,i){var n,o=1/0,s={x:e,y:i};this.shiftTargets.forEach(function(t){var e=a(t,s);o>e&&(n=t,o=e)}),t.rect.x=n.x,t.rect.y=n.y};var c=120;u.itemDragMove=function(t,e,i){
function n(){s.shift(o,e,i),o.positionDropPlaceholder(),s.layout()}var o=this.isEnabled&&this.getItem(t);if(o){e-=this.size.paddingLeft,i-=this.size.paddingTop;var s=this,r=new Date;this._itemDragTime&&r-this._itemDragTime<c?(clearTimeout(this.dragTimeout),this.dragTimeout=setTimeout(n,c)):(n(),this._itemDragTime=r)}},u.itemDragEnd=function(t){function e(){n++,2==n&&(i.element.classList.remove("is-positioning-post-drag"),i.hideDropPlaceholder(),o.dispatchEvent("dragItemPositioned",null,[i]))}var i=this.isEnabled&&this.getItem(t);if(i){clearTimeout(this.dragTimeout),i.element.classList.add("is-positioning-post-drag");var n=0,o=this;i.once("layout",e),this.once("layoutComplete",e),i.moveTo(i.rect.x,i.rect.y),this.layout(),this.dragItemCount=Math.max(0,this.dragItemCount-1),this.sortItemsByPosition(),i.disablePlacing(),this.unstamp(i.element)}},u.bindDraggabillyEvents=function(t){this._bindDraggabillyEvents(t,"on")},u.unbindDraggabillyEvents=function(t){this._bindDraggabillyEvents(t,"off")},u._bindDraggabillyEvents=function(t,e){var i=this.handleDraggabilly;t[e]("dragStart",i.dragStart),t[e]("dragMove",i.dragMove),t[e]("dragEnd",i.dragEnd)},u.bindUIDraggableEvents=function(t){this._bindUIDraggableEvents(t,"on")},u.unbindUIDraggableEvents=function(t){this._bindUIDraggableEvents(t,"off")},u._bindUIDraggableEvents=function(t,e){var i=this.handleUIDraggable;t[e]("dragstart",i.start)[e]("drag",i.drag)[e]("dragstop",i.stop)};var d=u.destroy;return u.destroy=function(){d.apply(this,arguments),this.isEnabled=!1},h.Rect=i,h.Packer=n,h});
/*!
 * Draggabilly PACKAGED v2.1.1
 * Make that shiz draggable
 * http://draggabilly.desandro.com
 * MIT license
 */

!function(t,i){"function"==typeof define&&define.amd?define("jquery-bridget/jquery-bridget",["jquery"],function(e){i(t,e)}):"object"==typeof module&&module.exports?module.exports=i(t,require("jquery")):t.jQueryBridget=i(t,t.jQuery)}(window,function(t,i){function e(e,r,a){function d(t,i,n){var o,r="$()."+e+'("'+i+'")';return t.each(function(t,d){var h=a.data(d,e);if(!h)return void s(e+" not initialized. Cannot call methods, i.e. "+r);var u=h[i];if(!u||"_"==i.charAt(0))return void s(r+" is not a valid method");var c=u.apply(h,n);o=void 0===o?c:o}),void 0!==o?o:t}function h(t,i){t.each(function(t,n){var o=a.data(n,e);o?(o.option(i),o._init()):(o=new r(n,i),a.data(n,e,o))})}a=a||i||t.jQuery,a&&(r.prototype.option||(r.prototype.option=function(t){a.isPlainObject(t)&&(this.options=a.extend(!0,this.options,t))}),a.fn[e]=function(t){if("string"==typeof t){var i=o.call(arguments,1);return d(this,t,i)}return h(this,t),this},n(a))}function n(t){!t||t&&t.bridget||(t.bridget=e)}var o=Array.prototype.slice,r=t.console,s="undefined"==typeof r?function(){}:function(t){r.error(t)};return n(i||t.jQuery),e}),function(t,i){"function"==typeof define&&define.amd?define("get-size/get-size",[],function(){return i()}):"object"==typeof module&&module.exports?module.exports=i():t.getSize=i()}(window,function(){function t(t){var i=parseFloat(t),e=-1==t.indexOf("%")&&!isNaN(i);return e&&i}function i(){}function e(){for(var t={width:0,height:0,innerWidth:0,innerHeight:0,outerWidth:0,outerHeight:0},i=0;h>i;i++){var e=d[i];t[e]=0}return t}function n(t){var i=getComputedStyle(t);return i||a("Style returned "+i+". Are you running this code in a hidden iframe on Firefox? See http://bit.ly/getsizebug1"),i}function o(){if(!u){u=!0;var i=document.createElement("div");i.style.width="200px",i.style.padding="1px 2px 3px 4px",i.style.borderStyle="solid",i.style.borderWidth="1px 2px 3px 4px",i.style.boxSizing="border-box";var e=document.body||document.documentElement;e.appendChild(i);var o=n(i);r.isBoxSizeOuter=s=200==t(o.width),e.removeChild(i)}}function r(i){if(o(),"string"==typeof i&&(i=document.querySelector(i)),i&&"object"==typeof i&&i.nodeType){var r=n(i);if("none"==r.display)return e();var a={};a.width=i.offsetWidth,a.height=i.offsetHeight;for(var u=a.isBorderBox="border-box"==r.boxSizing,c=0;h>c;c++){var p=d[c],f=r[p],g=parseFloat(f);a[p]=isNaN(g)?0:g}var l=a.paddingLeft+a.paddingRight,v=a.paddingTop+a.paddingBottom,m=a.marginLeft+a.marginRight,y=a.marginTop+a.marginBottom,b=a.borderLeftWidth+a.borderRightWidth,P=a.borderTopWidth+a.borderBottomWidth,E=u&&s,_=t(r.width);_!==!1&&(a.width=_+(E?0:l+b));var x=t(r.height);return x!==!1&&(a.height=x+(E?0:v+P)),a.innerWidth=a.width-(l+b),a.innerHeight=a.height-(v+P),a.outerWidth=a.width+m,a.outerHeight=a.height+y,a}}var s,a="undefined"==typeof console?i:function(t){console.error(t)},d=["paddingLeft","paddingRight","paddingTop","paddingBottom","marginLeft","marginRight","marginTop","marginBottom","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth"],h=d.length,u=!1;return r}),function(t,i){"function"==typeof define&&define.amd?define("ev-emitter/ev-emitter",i):"object"==typeof module&&module.exports?module.exports=i():t.EvEmitter=i()}("undefined"!=typeof window?window:this,function(){function t(){}var i=t.prototype;return i.on=function(t,i){if(t&&i){var e=this._events=this._events||{},n=e[t]=e[t]||[];return-1==n.indexOf(i)&&n.push(i),this}},i.once=function(t,i){if(t&&i){this.on(t,i);var e=this._onceEvents=this._onceEvents||{},n=e[t]=e[t]||{};return n[i]=!0,this}},i.off=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){var n=e.indexOf(i);return-1!=n&&e.splice(n,1),this}},i.emitEvent=function(t,i){var e=this._events&&this._events[t];if(e&&e.length){var n=0,o=e[n];i=i||[];for(var r=this._onceEvents&&this._onceEvents[t];o;){var s=r&&r[o];s&&(this.off(t,o),delete r[o]),o.apply(this,i),n+=s?0:1,o=e[n]}return this}},t}),function(t,i){"function"==typeof define&&define.amd?define("unipointer/unipointer",["ev-emitter/ev-emitter"],function(e){return i(t,e)}):"object"==typeof module&&module.exports?module.exports=i(t,require("ev-emitter")):t.Unipointer=i(t,t.EvEmitter)}(window,function(t,i){function e(){}function n(){}var o=n.prototype=Object.create(i.prototype);o.bindStartEvent=function(t){this._bindStartEvent(t,!0)},o.unbindStartEvent=function(t){this._bindStartEvent(t,!1)},o._bindStartEvent=function(i,e){e=void 0===e?!0:!!e;var n=e?"addEventListener":"removeEventListener";t.navigator.pointerEnabled?i[n]("pointerdown",this):t.navigator.msPointerEnabled?i[n]("MSPointerDown",this):(i[n]("mousedown",this),i[n]("touchstart",this))},o.handleEvent=function(t){var i="on"+t.type;this[i]&&this[i](t)},o.getTouch=function(t){for(var i=0;i<t.length;i++){var e=t[i];if(e.identifier==this.pointerIdentifier)return e}},o.onmousedown=function(t){var i=t.button;i&&0!==i&&1!==i||this._pointerDown(t,t)},o.ontouchstart=function(t){this._pointerDown(t,t.changedTouches[0])},o.onMSPointerDown=o.onpointerdown=function(t){this._pointerDown(t,t)},o._pointerDown=function(t,i){this.isPointerDown||(this.isPointerDown=!0,this.pointerIdentifier=void 0!==i.pointerId?i.pointerId:i.identifier,this.pointerDown(t,i))},o.pointerDown=function(t,i){this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i])};var r={mousedown:["mousemove","mouseup"],touchstart:["touchmove","touchend","touchcancel"],pointerdown:["pointermove","pointerup","pointercancel"],MSPointerDown:["MSPointerMove","MSPointerUp","MSPointerCancel"]};return o._bindPostStartEvents=function(i){if(i){var e=r[i.type];e.forEach(function(i){t.addEventListener(i,this)},this),this._boundPointerEvents=e}},o._unbindPostStartEvents=function(){this._boundPointerEvents&&(this._boundPointerEvents.forEach(function(i){t.removeEventListener(i,this)},this),delete this._boundPointerEvents)},o.onmousemove=function(t){this._pointerMove(t,t)},o.onMSPointerMove=o.onpointermove=function(t){t.pointerId==this.pointerIdentifier&&this._pointerMove(t,t)},o.ontouchmove=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerMove(t,i)},o._pointerMove=function(t,i){this.pointerMove(t,i)},o.pointerMove=function(t,i){this.emitEvent("pointerMove",[t,i])},o.onmouseup=function(t){this._pointerUp(t,t)},o.onMSPointerUp=o.onpointerup=function(t){t.pointerId==this.pointerIdentifier&&this._pointerUp(t,t)},o.ontouchend=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerUp(t,i)},o._pointerUp=function(t,i){this._pointerDone(),this.pointerUp(t,i)},o.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i])},o._pointerDone=function(){this.isPointerDown=!1,delete this.pointerIdentifier,this._unbindPostStartEvents(),this.pointerDone()},o.pointerDone=e,o.onMSPointerCancel=o.onpointercancel=function(t){t.pointerId==this.pointerIdentifier&&this._pointerCancel(t,t)},o.ontouchcancel=function(t){var i=this.getTouch(t.changedTouches);i&&this._pointerCancel(t,i)},o._pointerCancel=function(t,i){this._pointerDone(),this.pointerCancel(t,i)},o.pointerCancel=function(t,i){this.emitEvent("pointerCancel",[t,i])},n.getPointerPoint=function(t){return{x:t.pageX,y:t.pageY}},n}),function(t,i){"function"==typeof define&&define.amd?define("unidragger/unidragger",["unipointer/unipointer"],function(e){return i(t,e)}):"object"==typeof module&&module.exports?module.exports=i(t,require("unipointer")):t.Unidragger=i(t,t.Unipointer)}(window,function(t,i){function e(){}function n(){}var o=n.prototype=Object.create(i.prototype);o.bindHandles=function(){this._bindHandles(!0)},o.unbindHandles=function(){this._bindHandles(!1)};var r=t.navigator;return o._bindHandles=function(t){t=void 0===t?!0:!!t;var i;i=r.pointerEnabled?function(i){i.style.touchAction=t?"none":""}:r.msPointerEnabled?function(i){i.style.msTouchAction=t?"none":""}:e;for(var n=t?"addEventListener":"removeEventListener",o=0;o<this.handles.length;o++){var s=this.handles[o];this._bindStartEvent(s,t),i(s),s[n]("click",this)}},o.pointerDown=function(t,i){if("INPUT"==t.target.nodeName&&"range"==t.target.type)return this.isPointerDown=!1,void delete this.pointerIdentifier;this._dragPointerDown(t,i);var e=document.activeElement;e&&e.blur&&e.blur(),this._bindPostStartEvents(t),this.emitEvent("pointerDown",[t,i])},o._dragPointerDown=function(t,e){this.pointerDownPoint=i.getPointerPoint(e);var n=this.canPreventDefaultOnPointerDown(t,e);n&&t.preventDefault()},o.canPreventDefaultOnPointerDown=function(t){return"SELECT"!=t.target.nodeName},o.pointerMove=function(t,i){var e=this._dragPointerMove(t,i);this.emitEvent("pointerMove",[t,i,e]),this._dragMove(t,i,e)},o._dragPointerMove=function(t,e){var n=i.getPointerPoint(e),o={x:n.x-this.pointerDownPoint.x,y:n.y-this.pointerDownPoint.y};return!this.isDragging&&this.hasDragStarted(o)&&this._dragStart(t,e),o},o.hasDragStarted=function(t){return Math.abs(t.x)>3||Math.abs(t.y)>3},o.pointerUp=function(t,i){this.emitEvent("pointerUp",[t,i]),this._dragPointerUp(t,i)},o._dragPointerUp=function(t,i){this.isDragging?this._dragEnd(t,i):this._staticClick(t,i)},o._dragStart=function(t,e){this.isDragging=!0,this.dragStartPoint=i.getPointerPoint(e),this.isPreventingClicks=!0,this.dragStart(t,e)},o.dragStart=function(t,i){this.emitEvent("dragStart",[t,i])},o._dragMove=function(t,i,e){this.isDragging&&this.dragMove(t,i,e)},o.dragMove=function(t,i,e){t.preventDefault(),this.emitEvent("dragMove",[t,i,e])},o._dragEnd=function(t,i){this.isDragging=!1,setTimeout(function(){delete this.isPreventingClicks}.bind(this)),this.dragEnd(t,i)},o.dragEnd=function(t,i){this.emitEvent("dragEnd",[t,i])},o.onclick=function(t){this.isPreventingClicks&&t.preventDefault()},o._staticClick=function(t,i){if(!this.isIgnoringMouseUp||"mouseup"!=t.type){var e=t.target.nodeName;("INPUT"==e||"TEXTAREA"==e)&&t.target.focus(),this.staticClick(t,i),"mouseup"!=t.type&&(this.isIgnoringMouseUp=!0,setTimeout(function(){delete this.isIgnoringMouseUp}.bind(this),400))}},o.staticClick=function(t,i){this.emitEvent("staticClick",[t,i])},n.getPointerPoint=i.getPointerPoint,n}),function(t,i){"function"==typeof define&&define.amd?define(["get-size/get-size","unidragger/unidragger"],function(e,n){return i(t,e,n)}):"object"==typeof module&&module.exports?module.exports=i(t,require("get-size"),require("unidragger")):t.Draggabilly=i(t,t.getSize,t.Unidragger)}(window,function(t,i,e){function n(){}function o(t,i){for(var e in i)t[e]=i[e];return t}function r(t){return t instanceof HTMLElement}function s(t,i){this.element="string"==typeof t?d.querySelector(t):t,f&&(this.$element=f(this.element)),this.options=o({},this.constructor.defaults),this.option(i),this._create()}function a(t,i,e){return e=e||"round",i?Math[e](t/i)*i:t}var d=t.document,h=t.requestAnimationFrame||t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame,u=0;h||(h=function(t){var i=(new Date).getTime(),e=Math.max(0,16-(i-u)),n=setTimeout(t,e);return u=i+e,n});var c=d.documentElement,p="string"==typeof c.style.transform?"transform":"WebkitTransform",f=t.jQuery,g=s.prototype=Object.create(e.prototype);s.defaults={},g.option=function(t){o(this.options,t)};var l={relative:!0,absolute:!0,fixed:!0};return g._create=function(){this.position={},this._getPosition(),this.startPoint={x:0,y:0},this.dragPoint={x:0,y:0},this.startPosition=o({},this.position);var t=getComputedStyle(this.element);l[t.position]||(this.element.style.position="relative"),this.enable(),this.setHandles()},g.setHandles=function(){this.handles=this.options.handle?this.element.querySelectorAll(this.options.handle):[this.element],this.bindHandles()},g.dispatchEvent=function(i,e,n){var o=[e].concat(n);this.emitEvent(i,o);var r=t.jQuery;if(r&&this.$element)if(e){var s=r.Event(e);s.type=i,this.$element.trigger(s,n)}else this.$element.trigger(i,n)},g._getPosition=function(){var t=getComputedStyle(this.element),i=this._getPositionCoord(t.left,"width"),e=this._getPositionCoord(t.top,"height");this.position.x=isNaN(i)?0:i,this.position.y=isNaN(e)?0:e,this._addTransformPosition(t)},g._getPositionCoord=function(t,e){if(-1!=t.indexOf("%")){var n=i(this.element.parentNode);return n?parseFloat(t)/100*n[e]:0}return parseInt(t,10)},g._addTransformPosition=function(t){var i=t[p];if(0===i.indexOf("matrix")){var e=i.split(","),n=0===i.indexOf("matrix3d")?12:4,o=parseInt(e[n],10),r=parseInt(e[n+1],10);this.position.x+=o,this.position.y+=r}},g.pointerDown=function(t,i){this._dragPointerDown(t,i);var e=d.activeElement;e&&e.blur&&e!=d.body&&e.blur(),this._bindPostStartEvents(t),this.element.classList.add("is-pointer-down"),this.dispatchEvent("pointerDown",t,[i])},g.pointerMove=function(t,i){var e=this._dragPointerMove(t,i);this.dispatchEvent("pointerMove",t,[i,e]),this._dragMove(t,i,e)},g.dragStart=function(t,i){this.isEnabled&&(this._getPosition(),this.measureContainment(),this.startPosition.x=this.position.x,this.startPosition.y=this.position.y,this.setLeftTop(),this.dragPoint.x=0,this.dragPoint.y=0,this.element.classList.add("is-dragging"),this.dispatchEvent("dragStart",t,[i]),this.animate())},g.measureContainment=function(){var t=this.options.containment;if(t){var e=r(t)?t:"string"==typeof t?d.querySelector(t):this.element.parentNode,n=i(this.element),o=i(e),s=this.element.getBoundingClientRect(),a=e.getBoundingClientRect(),h=o.borderLeftWidth+o.borderRightWidth,u=o.borderTopWidth+o.borderBottomWidth,c=this.relativeStartPosition={x:s.left-(a.left+o.borderLeftWidth),y:s.top-(a.top+o.borderTopWidth)};this.containSize={width:o.width-h-c.x-n.width,height:o.height-u-c.y-n.height}}},g.dragMove=function(t,i,e){if(this.isEnabled){var n=e.x,o=e.y,r=this.options.grid,s=r&&r[0],d=r&&r[1];n=a(n,s),o=a(o,d),n=this.containDrag("x",n,s),o=this.containDrag("y",o,d),n="y"==this.options.axis?0:n,o="x"==this.options.axis?0:o,this.position.x=this.startPosition.x+n,this.position.y=this.startPosition.y+o,this.dragPoint.x=n,this.dragPoint.y=o,this.dispatchEvent("dragMove",t,[i,e])}},g.containDrag=function(t,i,e){if(!this.options.containment)return i;var n="x"==t?"width":"height",o=this.relativeStartPosition[t],r=a(-o,e,"ceil"),s=this.containSize[n];return s=a(s,e,"floor"),Math.min(s,Math.max(r,i))},g.pointerUp=function(t,i){this.element.classList.remove("is-pointer-down"),this.dispatchEvent("pointerUp",t,[i]),this._dragPointerUp(t,i)},g.dragEnd=function(t,i){this.isEnabled&&(p&&(this.element.style[p]="",this.setLeftTop()),this.element.classList.remove("is-dragging"),this.dispatchEvent("dragEnd",t,[i]))},g.animate=function(){if(this.isDragging){this.positionDrag();var t=this;h(function(){t.animate()})}},g.setLeftTop=function(){this.element.style.left=this.position.x+"px",this.element.style.top=this.position.y+"px"},g.positionDrag=function(){this.element.style[p]="translate3d( "+this.dragPoint.x+"px, "+this.dragPoint.y+"px, 0)"},g.staticClick=function(t,i){this.dispatchEvent("staticClick",t,[i])},g.enable=function(){this.isEnabled=!0},g.disable=function(){this.isEnabled=!1,this.isDragging&&this.dragEnd()},g.destroy=function(){this.disable(),this.element.style[p]="",this.element.style.left="",this.element.style.top="",this.element.style.position="",this.unbindHandles(),this.$element&&this.$element.removeData("draggabilly")},g._init=n,f&&f.bridget&&f.bridget("draggabilly",s),s});
// Form Actions 
function oneDelete(action) {
    var ele = document.getElementById("delete-modal");
    if (ele != null)
        ele.outerHTML="";
    $.get(action, function (data) {
        $('<div id="delete-modal" class="modal fade">' + data + '</div>').modal();
        $(window).on('shown.bs.modal', function() {
            $("#delete-modal").find("script").each(function(i) {
                eval($(this).text());
            });
            console.log("oneDelete @ shown.bs.modal");
        });
    });
}

function oneActivate(action) {
    var ele = document.getElementById("activate-modal");
    if (ele != null)
        ele.outerHTML="";

    $.get(action, function (data) {
        $('<div id="activate-modal" class="modal fade">' + data + '</div>').modal();
        $(window).on('shown.bs.modal', function() {
            $("#delete-modal").find("script").each(function(i) {
                eval($(this).text());
            });
            console.log("oneActivate @ shown.bs.modal");
        });
    });
}

// Reload Date and Time Pickers
function loadDatePickers(){
    $('.oneDatePicker').datepicker({
        format: 'yyyy-mm-dd',
        orientation: 'bottom auto',
        autoclose: true,
        todayHighlight: true
    });
}

function loadTimePickers(){
    $('.oneTimePicker').clockpicker({
        default: 'now',
        donetext: "OK"
    });
}

function loadDateRangePickers(){
    $(".input-daterange").datepicker({
        format: 'yyyy-mm-dd',
        orientation: 'bottom auto',
    });
}

function convertTimezone(){
    /*
     convert and show timestamps in the user timezone
     */
    $('.convertTimezone').each(function(){
        var offset = new Date().getTimezoneOffset();
        var diference = offset/60;
        var format = $(this).attr("data-format");
        var writeDate = '';

        var signal = '+';
        if (diference > 0){
            signal = '-'
        }

        var myDate = new Date($(this).attr("data-timestamp") * 1000);

        if (!format){
            writeDate = myDate.getDate() + '-' + (myDate.getMonth()+1) + '-' + myDate.getFullYear() + ' ' + myDate.getHours() + ':' + myDate.getMinutes();
        } else {
            var year = myDate.getFullYear();
            var month = (myDate.getMonth()+1);
            var day = myDate.getDate();

            var elements = format.toLowerCase().split("-");
            var dateFormated = [];

            for (var i = 0; i < elements.length; i++) {
                switch(elements[i]) {
                    case 'y':
                        dateFormated[i] = year;
                        break;
                    case 'm':
                        dateFormated[i] = month;
                        break;
                    case 'd':
                        dateFormated[i] = day;
                        break;
                    default:
                        break
                }
            }
            writeDate = dateFormated[0] + '-' + dateFormated[1] + '-' + dateFormated[2] + ' ' + myDate.getHours() + ':' + myDate.getMinutes();
        }
        $(this).html(writeDate+'  GMT '+ signal +' '+ Math.abs(diference));
    });
}

// Load date and Time Pickers
$( document ).ready(function() {
    // Load Date Pickers
    loadDatePickers();
    loadTimePickers();
    loadDateRangePickers();
    //Load timezone converter
    convertTimezone();
});
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    (function (global){
        /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
        /* eslint-disable no-proto */

        'use strict'

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')
        var isArray = require('isarray')

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50
        Buffer.poolSize = 8192 // not used by this implementation

        var rootParent = {}

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.

         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
            ? global.TYPED_ARRAY_SUPPORT
            : typedArraySupport()

        function typedArraySupport () {
            try {
                var arr = new Uint8Array(1)
                arr.foo = function () { return 42 }
                return arr.foo() === 42 && // typed array instances can be augmented
                    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                    arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
            } catch (e) {
                return false
            }
        }

        function kMaxLength () {
            return Buffer.TYPED_ARRAY_SUPPORT
                ? 0x7fffffff
                : 0x3fffffff
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */
        function Buffer (arg) {
            if (!(this instanceof Buffer)) {
                // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
                if (arguments.length > 1) return new Buffer(arg, arguments[1])
                return new Buffer(arg)
            }

            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                this.length = 0
                this.parent = undefined
            }

            // Common case.
            if (typeof arg === 'number') {
                return fromNumber(this, arg)
            }

            // Slightly less common case.
            if (typeof arg === 'string') {
                return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
            }

            // Unusual.
            return fromObject(this, arg)
        }

// TODO: Legacy, not needed anymore. Remove in next major version.
        Buffer._augment = function (arr) {
            arr.__proto__ = Buffer.prototype
            return arr
        }

        function fromNumber (that, length) {
            that = allocate(that, length < 0 ? 0 : checked(length) | 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
                for (var i = 0; i < length; i++) {
                    that[i] = 0
                }
            }
            return that
        }

        function fromString (that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

            // Assumption: byteLength() return value is always < kMaxLength.
            var length = byteLength(string, encoding) | 0
            that = allocate(that, length)

            that.write(string, encoding)
            return that
        }

        function fromObject (that, object) {
            if (Buffer.isBuffer(object)) return fromBuffer(that, object)

            if (isArray(object)) return fromArray(that, object)

            if (object == null) {
                throw new TypeError('must start with number, buffer, array or string')
            }

            if (typeof ArrayBuffer !== 'undefined') {
                if (object.buffer instanceof ArrayBuffer) {
                    return fromTypedArray(that, object)
                }
                if (object instanceof ArrayBuffer) {
                    return fromArrayBuffer(that, object)
                }
            }

            if (object.length) return fromArrayLike(that, object)

            return fromJsonObject(that, object)
        }

        function fromBuffer (that, buffer) {
            var length = checked(buffer.length) | 0
            that = allocate(that, length)
            buffer.copy(that, 0, 0, length)
            return that
        }

        function fromArray (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

// Duplicate of fromArray() to keep fromArray() monomorphic.
        function fromTypedArray (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            // Truncating the elements is probably not what people expect from typed
            // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
            // of the old Buffer constructor.
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

        function fromArrayBuffer (that, array) {
            array.byteLength // this throws if `array` is not a valid ArrayBuffer

            if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(array)
                that.__proto__ = Buffer.prototype
            } else {
                // Fallback: Return an object instance of the Buffer class
                that = fromTypedArray(that, new Uint8Array(array))
            }
            return that
        }

        function fromArrayLike (that, array) {
            var length = checked(array.length) | 0
            that = allocate(that, length)
            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
        function fromJsonObject (that, object) {
            var array
            var length = 0

            if (object.type === 'Buffer' && isArray(object.data)) {
                array = object.data
                length = checked(array.length) | 0
            }
            that = allocate(that, length)

            for (var i = 0; i < length; i += 1) {
                that[i] = array[i] & 255
            }
            return that
        }

        if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype
            Buffer.__proto__ = Uint8Array
        } else {
            // pre-set for values that may exist in the future
            Buffer.prototype.length = undefined
            Buffer.prototype.parent = undefined
        }

        function allocate (that, length) {
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                // Return an augmented `Uint8Array` instance, for best performance
                that = new Uint8Array(length)
                that.__proto__ = Buffer.prototype
            } else {
                // Fallback: Return an object instance of the Buffer class
                that.length = length
            }

            var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
            if (fromPool) that.parent = rootParent

            return that
        }

        function checked (length) {
            // Note: cannot use `length < kMaxLength` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
                throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                    'size: 0x' + kMaxLength().toString(16) + ' bytes')
            }
            return length | 0
        }

        function SlowBuffer (subject, encoding) {
            if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

            var buf = new Buffer(subject, encoding)
            delete buf.parent
            return buf
        }

        Buffer.isBuffer = function isBuffer (b) {
            return !!(b != null && b._isBuffer)
        }

        Buffer.compare = function compare (a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                throw new TypeError('Arguments must be Buffers')
            }

            if (a === b) return 0

            var x = a.length
            var y = b.length

            var i = 0
            var len = Math.min(x, y)
            while (i < len) {
                if (a[i] !== b[i]) break

                ++i
            }

            if (i !== len) {
                x = a[i]
                y = b[i]
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
        }

        Buffer.isEncoding = function isEncoding (encoding) {
            switch (String(encoding).toLowerCase()) {
                case 'hex':
                case 'utf8':
                case 'utf-8':
                case 'ascii':
                case 'binary':
                case 'base64':
                case 'raw':
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                    return true
                default:
                    return false
            }
        }

        Buffer.concat = function concat (list, length) {
            if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

            if (list.length === 0) {
                return new Buffer(0)
            }

            var i
            if (length === undefined) {
                length = 0
                for (i = 0; i < list.length; i++) {
                    length += list[i].length
                }
            }

            var buf = new Buffer(length)
            var pos = 0
            for (i = 0; i < list.length; i++) {
                var item = list[i]
                item.copy(buf, pos)
                pos += item.length
            }
            return buf
        }

        function byteLength (string, encoding) {
            if (typeof string !== 'string') string = '' + string

            var len = string.length
            if (len === 0) return 0

            // Use a for loop to avoid recursion
            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'ascii':
                    case 'binary':
                    // Deprecated
                    case 'raw':
                    case 'raws':
                        return len
                    case 'utf8':
                    case 'utf-8':
                        return utf8ToBytes(string).length
                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return len * 2
                    case 'hex':
                        return len >>> 1
                    case 'base64':
                        return base64ToBytes(string).length
                    default:
                        if (loweredCase) return utf8ToBytes(string).length // assume utf8
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }
        Buffer.byteLength = byteLength

        function slowToString (encoding, start, end) {
            var loweredCase = false

            start = start | 0
            end = end === undefined || end === Infinity ? this.length : end | 0

            if (!encoding) encoding = 'utf8'
            if (start < 0) start = 0
            if (end > this.length) end = this.length
            if (end <= start) return ''

            while (true) {
                switch (encoding) {
                    case 'hex':
                        return hexSlice(this, start, end)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Slice(this, start, end)

                    case 'ascii':
                        return asciiSlice(this, start, end)

                    case 'binary':
                        return binarySlice(this, start, end)

                    case 'base64':
                        return base64Slice(this, start, end)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return utf16leSlice(this, start, end)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = (encoding + '').toLowerCase()
                        loweredCase = true
                }
            }
        }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
        Buffer.prototype._isBuffer = true

        Buffer.prototype.toString = function toString () {
            var length = this.length | 0
            if (length === 0) return ''
            if (arguments.length === 0) return utf8Slice(this, 0, length)
            return slowToString.apply(this, arguments)
        }

        Buffer.prototype.equals = function equals (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return true
            return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect () {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
                str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
                if (this.length > max) str += ' ... '
            }
            return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function compare (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return 0
            return Buffer.compare(this, b)
        }

        Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
            if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
            else if (byteOffset < -0x80000000) byteOffset = -0x80000000
            byteOffset >>= 0

            if (this.length === 0) return -1
            if (byteOffset >= this.length) return -1

            // Negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

            if (typeof val === 'string') {
                if (val.length === 0) return -1 // special case: looking for empty string always fails
                return String.prototype.indexOf.call(this, val, byteOffset)
            }
            if (Buffer.isBuffer(val)) {
                return arrayIndexOf(this, val, byteOffset)
            }
            if (typeof val === 'number') {
                if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
                    return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
                }
                return arrayIndexOf(this, [ val ], byteOffset)
            }

            function arrayIndexOf (arr, val, byteOffset) {
                var foundIndex = -1
                for (var i = 0; byteOffset + i < arr.length; i++) {
                    if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
                        if (foundIndex === -1) foundIndex = i
                        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
                    } else {
                        foundIndex = -1
                    }
                }
                return -1
            }

            throw new TypeError('val must be string, number or Buffer')
        }

        function hexWrite (buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
                length = remaining
            } else {
                length = Number(length)
                if (length > remaining) {
                    length = remaining
                }
            }

            // must be an even number of digits
            var strLen = string.length
            if (strLen % 2 !== 0) throw new Error('Invalid hex string')

            if (length > strLen / 2) {
                length = strLen / 2
            }
            for (var i = 0; i < length; i++) {
                var parsed = parseInt(string.substr(i * 2, 2), 16)
                if (isNaN(parsed)) throw new Error('Invalid hex string')
                buf[offset + i] = parsed
            }
            return i
        }

        function utf8Write (buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite (buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function binaryWrite (buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
        }

        function base64Write (buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write (buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }

        Buffer.prototype.write = function write (string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
                encoding = 'utf8'
                length = this.length
                offset = 0
                // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
                encoding = offset
                length = this.length
                offset = 0
                // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
                offset = offset | 0
                if (isFinite(length)) {
                    length = length | 0
                    if (encoding === undefined) encoding = 'utf8'
                } else {
                    encoding = length
                    length = undefined
                }
                // legacy write(string, encoding, offset, length) - remove in v0.13
            } else {
                var swap = encoding
                encoding = offset
                offset = length | 0
                length = swap
            }

            var remaining = this.length - offset
            if (length === undefined || length > remaining) length = remaining

            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                throw new RangeError('attempt to write outside buffer bounds')
            }

            if (!encoding) encoding = 'utf8'

            var loweredCase = false
            for (;;) {
                switch (encoding) {
                    case 'hex':
                        return hexWrite(this, string, offset, length)

                    case 'utf8':
                    case 'utf-8':
                        return utf8Write(this, string, offset, length)

                    case 'ascii':
                        return asciiWrite(this, string, offset, length)

                    case 'binary':
                        return binaryWrite(this, string, offset, length)

                    case 'base64':
                        // Warning: maxLength not taken into account in base64Write
                        return base64Write(this, string, offset, length)

                    case 'ucs2':
                    case 'ucs-2':
                    case 'utf16le':
                    case 'utf-16le':
                        return ucs2Write(this, string, offset, length)

                    default:
                        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                        encoding = ('' + encoding).toLowerCase()
                        loweredCase = true
                }
            }
        }

        Buffer.prototype.toJSON = function toJSON () {
            return {
                type: 'Buffer',
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }

        function base64Slice (buf, start, end) {
            if (start === 0 && end === buf.length) {
                return base64.fromByteArray(buf)
            } else {
                return base64.fromByteArray(buf.slice(start, end))
            }
        }

        function utf8Slice (buf, start, end) {
            end = Math.min(buf.length, end)
            var res = []

            var i = start
            while (i < end) {
                var firstByte = buf[i]
                var codePoint = null
                var bytesPerSequence = (firstByte > 0xEF) ? 4
                    : (firstByte > 0xDF) ? 3
                        : (firstByte > 0xBF) ? 2
                            : 1

                if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint

                    switch (bytesPerSequence) {
                        case 1:
                            if (firstByte < 0x80) {
                                codePoint = firstByte
                            }
                            break
                        case 2:
                            secondByte = buf[i + 1]
                            if ((secondByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                                if (tempCodePoint > 0x7F) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 3:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                    codePoint = tempCodePoint
                                }
                            }
                            break
                        case 4:
                            secondByte = buf[i + 1]
                            thirdByte = buf[i + 2]
                            fourthByte = buf[i + 3]
                            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                    codePoint = tempCodePoint
                                }
                            }
                    }
                }

                if (codePoint === null) {
                    // we did not generate a valid codePoint so insert a
                    // replacement char (U+FFFD) and advance only 1 byte
                    codePoint = 0xFFFD
                    bytesPerSequence = 1
                } else if (codePoint > 0xFFFF) {
                    // encode to utf16 (surrogate pair dance)
                    codePoint -= 0x10000
                    res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                    codePoint = 0xDC00 | codePoint & 0x3FF
                }

                res.push(codePoint)
                i += bytesPerSequence
            }

            return decodeCodePointsArray(res)
        }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray (codePoints) {
            var len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
                return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = ''
            var i = 0
            while (i < len) {
                res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                )
            }
            return res
        }

        function asciiSlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i] & 0x7F)
            }
            return ret
        }

        function binarySlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; i++) {
                ret += String.fromCharCode(buf[i])
            }
            return ret
        }

        function hexSlice (buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; i++) {
                out += toHex(buf[i])
            }
            return out
        }

        function utf16leSlice (buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
                res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
        }

        Buffer.prototype.slice = function slice (start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
                start += len
                if (start < 0) start = 0
            } else if (start > len) {
                start = len
            }

            if (end < 0) {
                end += len
                if (end < 0) end = 0
            } else if (end > len) {
                end = len
            }

            if (end < start) end = start

            var newBuf
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                newBuf = this.subarray(start, end)
                newBuf.__proto__ = Buffer.prototype
            } else {
                var sliceLen = end - start
                newBuf = new Buffer(sliceLen, undefined)
                for (var i = 0; i < sliceLen; i++) {
                    newBuf[i] = this[i + start]
                }
            }

            if (newBuf.length) newBuf.parent = this.parent || this

            return newBuf
        }

        /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
        function checkOffset (offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }

            return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) {
                checkOffset(offset, byteLength, this.length)
            }

            var val = this[offset + --byteLength]
            var mul = 1
            while (byteLength > 0 && (mul *= 0x100)) {
                val += this[offset + --byteLength] * mul
            }

            return val
        }

        Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return ((this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16)) +
                (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] * 0x1000000) +
                ((this[offset + 1] << 16) |
                    (this[offset + 2] << 8) |
                    this[offset + 3])
        }

        Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
                val += this[offset + i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var i = byteLength
            var mul = 1
            var val = this[offset + --i]
            while (i > 0 && (mul *= 0x100)) {
                val += this[offset + --i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
        }

        Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80)) return (this[offset])
            return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset]) |
                (this[offset + 1] << 8) |
                (this[offset + 2] << 16) |
                (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] << 24) |
                (this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt (buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
            if (value > max || value < min) throw new RangeError('value is out of bounds')
            if (offset + ext > buf.length) throw new RangeError('index out of range')
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

            var mul = 1
            var i = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

            var i = byteLength - 1
            var mul = 1
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            this[offset] = (value & 0xff)
            return offset + 1
        }

        function objectWriteUInt16 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
                buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                    (littleEndian ? i : 1 - i) * 8
            }
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
            } else {
                objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
            } else {
                objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
        }

        function objectWriteUInt32 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
                buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
            }
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset + 3] = (value >>> 24)
                this[offset + 2] = (value >>> 16)
                this[offset + 1] = (value >>> 8)
                this[offset] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = 0
            var mul = 1
            var sub = value < 0 ? 1 : 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1)

                checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = byteLength - 1
            var mul = 1
            var sub = value < 0 ? 1 : 0
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
                this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            if (value < 0) value = 0xff + value + 1
            this[offset] = (value & 0xff)
            return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
            } else {
                objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 8)
                this[offset + 1] = (value & 0xff)
            } else {
                objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value & 0xff)
                this[offset + 1] = (value >>> 8)
                this[offset + 2] = (value >>> 16)
                this[offset + 3] = (value >>> 24)
            } else {
                objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            if (Buffer.TYPED_ARRAY_SUPPORT) {
                this[offset] = (value >>> 24)
                this[offset + 1] = (value >>> 16)
                this[offset + 2] = (value >>> 8)
                this[offset + 3] = (value & 0xff)
            } else {
                objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
        }

        function checkIEEE754 (buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('index out of range')
            if (offset < 0) throw new RangeError('index out of range')
        }

        function writeFloat (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
                checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
        }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy (target, targetStart, start, end) {
            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (targetStart >= target.length) targetStart = target.length
            if (!targetStart) targetStart = 0
            if (end > 0 && end < start) end = start

            // Copy 0 bytes; we're done
            if (end === start) return 0
            if (target.length === 0 || this.length === 0) return 0

            // Fatal error conditions
            if (targetStart < 0) {
                throw new RangeError('targetStart out of bounds')
            }
            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
            if (end < 0) throw new RangeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length) end = this.length
            if (target.length - targetStart < end - start) {
                end = target.length - targetStart + start
            }

            var len = end - start
            var i

            if (this === target && start < targetStart && targetStart < end) {
                // descending copy from end
                for (i = len - 1; i >= 0; i--) {
                    target[i + targetStart] = this[i + start]
                }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                // ascending copy from start
                for (i = 0; i < len; i++) {
                    target[i + targetStart] = this[i + start]
                }
            } else {
                Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, start + len),
                    targetStart
                )
            }

            return len
        }

// fill(value, start=0, end=buffer.length)
        Buffer.prototype.fill = function fill (value, start, end) {
            if (!value) value = 0
            if (!start) start = 0
            if (!end) end = this.length

            if (end < start) throw new RangeError('end < start')

            // Fill 0 bytes; we're done
            if (end === start) return
            if (this.length === 0) return

            if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
            if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

            var i
            if (typeof value === 'number') {
                for (i = start; i < end; i++) {
                    this[i] = value
                }
            } else {
                var bytes = utf8ToBytes(value.toString())
                var len = bytes.length
                for (i = start; i < end; i++) {
                    this[i] = bytes[i % len]
                }
            }

            return this
        }

// HELPER FUNCTIONS
// ================

        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

        function base64clean (str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '')
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return ''
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
                str = str + '='
            }
            return str
        }

        function stringtrim (str) {
            if (str.trim) return str.trim()
            return str.replace(/^\s+|\s+$/g, '')
        }

        function toHex (n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
        }

        function utf8ToBytes (string, units) {
            units = units || Infinity
            var codePoint
            var length = string.length
            var leadSurrogate = null
            var bytes = []

            for (var i = 0; i < length; i++) {
                codePoint = string.charCodeAt(i)

                // is surrogate component
                if (codePoint > 0xD7FF && codePoint < 0xE000) {
                    // last char was a lead
                    if (!leadSurrogate) {
                        // no lead yet
                        if (codePoint > 0xDBFF) {
                            // unexpected trail
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        } else if (i + 1 === length) {
                            // unpaired lead
                            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                            continue
                        }

                        // valid lead
                        leadSurrogate = codePoint

                        continue
                    }

                    // 2 leads in a row
                    if (codePoint < 0xDC00) {
                        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                        leadSurrogate = codePoint
                        continue
                    }

                    // valid surrogate pair
                    codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
                } else if (leadSurrogate) {
                    // valid bmp char, but last char was a lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                }

                leadSurrogate = null

                // encode utf8
                if (codePoint < 0x80) {
                    if ((units -= 1) < 0) break
                    bytes.push(codePoint)
                } else if (codePoint < 0x800) {
                    if ((units -= 2) < 0) break
                    bytes.push(
                        codePoint >> 0x6 | 0xC0,
                        codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x10000) {
                    if ((units -= 3) < 0) break
                    bytes.push(
                        codePoint >> 0xC | 0xE0,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                    )
                } else if (codePoint < 0x110000) {
                    if ((units -= 4) < 0) break
                    bytes.push(
                        codePoint >> 0x12 | 0xF0,
                        codePoint >> 0xC & 0x3F | 0x80,
                        codePoint >> 0x6 & 0x3F | 0x80,
                        codePoint & 0x3F | 0x80
                    )
                } else {
                    throw new Error('Invalid code point')
                }
            }

            return bytes
        }

        function asciiToBytes (str) {
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                // Node's code seems to be doing this and not & 0x7F..
                byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
        }

        function utf16leToBytes (str, units) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; i++) {
                if ((units -= 2) < 0) break

                c = str.charCodeAt(i)
                hi = c >> 8
                lo = c % 256
                byteArray.push(lo)
                byteArray.push(hi)
            }

            return byteArray
        }

        function base64ToBytes (str) {
            return base64.toByteArray(base64clean(str))
        }

        function blitBuffer (src, dst, offset, length) {
            for (var i = 0; i < length; i++) {
                if ((i + offset >= dst.length) || (i >= src.length)) break
                dst[i + offset] = src[i]
            }
            return i
        }

    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":2,"ieee754":3,"isarray":4}],2:[function(require,module,exports){
    ;(function (exports) {
        'use strict'

        var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'

        var Arr = (typeof Uint8Array !== 'undefined')
            ? Uint8Array
            : Array

        var PLUS = '+'.charCodeAt(0)
        var SLASH = '/'.charCodeAt(0)
        var NUMBER = '0'.charCodeAt(0)
        var LOWER = 'a'.charCodeAt(0)
        var UPPER = 'A'.charCodeAt(0)
        var PLUS_URL_SAFE = '-'.charCodeAt(0)
        var SLASH_URL_SAFE = '_'.charCodeAt(0)

        function decode (elt) {
            var code = elt.charCodeAt(0)
            if (code === PLUS || code === PLUS_URL_SAFE) return 62 // '+'
            if (code === SLASH || code === SLASH_URL_SAFE) return 63 // '/'
            if (code < NUMBER) return -1 // no match
            if (code < NUMBER + 10) return code - NUMBER + 26 + 26
            if (code < UPPER + 26) return code - UPPER
            if (code < LOWER + 26) return code - LOWER + 26
        }

        function b64ToByteArray (b64) {
            var i, j, l, tmp, placeHolders, arr

            if (b64.length % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4')
            }

            // the number of equal signs (place holders)
            // if there are two placeholders, than the two characters before it
            // represent one byte
            // if there is only one, then the three characters before it represent 2 bytes
            // this is just a cheap hack to not do indexOf twice
            var len = b64.length
            placeHolders = b64.charAt(len - 2) === '=' ? 2 : b64.charAt(len - 1) === '=' ? 1 : 0

            // base64 is 4/3 + up to two characters of the original data
            arr = new Arr(b64.length * 3 / 4 - placeHolders)

            // if there are placeholders, only get up to the last complete 4 chars
            l = placeHolders > 0 ? b64.length - 4 : b64.length

            var L = 0

            function push (v) {
                arr[L++] = v
            }

            for (i = 0, j = 0; i < l; i += 4, j += 3) {
                tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
                push((tmp & 0xFF0000) >> 16)
                push((tmp & 0xFF00) >> 8)
                push(tmp & 0xFF)
            }

            if (placeHolders === 2) {
                tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
                push(tmp & 0xFF)
            } else if (placeHolders === 1) {
                tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
                push((tmp >> 8) & 0xFF)
                push(tmp & 0xFF)
            }

            return arr
        }

        function uint8ToBase64 (uint8) {
            var i
            var extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes
            var output = ''
            var temp, length

            function encode (num) {
                return lookup.charAt(num)
            }

            function tripletToBase64 (num) {
                return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
            }

            // go through the array every three bytes, we'll deal with trailing stuff later
            for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
                temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
                output += tripletToBase64(temp)
            }

            // pad the end with zeros, but make sure to not forget the extra bytes
            switch (extraBytes) {
                case 1:
                    temp = uint8[uint8.length - 1]
                    output += encode(temp >> 2)
                    output += encode((temp << 4) & 0x3F)
                    output += '=='
                    break
                case 2:
                    temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
                    output += encode(temp >> 10)
                    output += encode((temp >> 4) & 0x3F)
                    output += encode((temp << 2) & 0x3F)
                    output += '='
                    break
                default:
                    break
            }

            return output
        }

        exports.toByteArray = b64ToByteArray
        exports.fromByteArray = uint8ToBase64
    }(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],3:[function(require,module,exports){
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var nBits = -7
        var i = isLE ? (nBytes - 1) : 0
        var d = isLE ? -1 : 1
        var s = buffer[offset + i]

        i += d

        e = s & ((1 << (-nBits)) - 1)
        s >>= (-nBits)
        nBits += eLen
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1)
        e >>= (-nBits)
        nBits += mLen
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
        } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c
        var eLen = nBytes * 8 - mLen - 1
        var eMax = (1 << eLen) - 1
        var eBias = eMax >> 1
        var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
        var i = isLE ? 0 : (nBytes - 1)
        var d = isLE ? 1 : -1
        var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

        value = Math.abs(value)

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
        } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--
                c *= 2
            }
            if (e + eBias >= 1) {
                value += rt / c
            } else {
                value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
                e++
                c /= 2
            }

            if (e + eBias >= eMax) {
                m = 0
                e = eMax
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen)
                e = e + eBias
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
                e = 0
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m
        eLen += mLen
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128
    }

},{}],4:[function(require,module,exports){
    var toString = {}.toString;

    module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
    };

},{}],5:[function(require,module,exports){
    !function() {
        var d3 = {
            version: "3.5.15"
        };
        var d3_arraySlice = [].slice, d3_array = function(list) {
            return d3_arraySlice.call(list);
        };
        var d3_document = this.document;
        function d3_documentElement(node) {
            return node && (node.ownerDocument || node.document || node).documentElement;
        }
        function d3_window(node) {
            return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
        }
        if (d3_document) {
            try {
                d3_array(d3_document.documentElement.childNodes)[0].nodeType;
            } catch (e) {
                d3_array = function(list) {
                    var i = list.length, array = new Array(i);
                    while (i--) array[i] = list[i];
                    return array;
                };
            }
        }
        if (!Date.now) Date.now = function() {
            return +new Date();
        };
        if (d3_document) {
            try {
                d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
            } catch (error) {
                var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
                d3_element_prototype.setAttribute = function(name, value) {
                    d3_element_setAttribute.call(this, name, value + "");
                };
                d3_element_prototype.setAttributeNS = function(space, local, value) {
                    d3_element_setAttributeNS.call(this, space, local, value + "");
                };
                d3_style_prototype.setProperty = function(name, value, priority) {
                    d3_style_setProperty.call(this, name, value + "", priority);
                };
            }
        }
        d3.ascending = d3_ascending;
        function d3_ascending(a, b) {
            return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
        }
        d3.descending = function(a, b) {
            return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
        };
        d3.min = function(array, f) {
            var i = -1, n = array.length, a, b;
            if (arguments.length === 1) {
                while (++i < n) if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
                while (++i < n) if ((b = array[i]) != null && a > b) a = b;
            } else {
                while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
                while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
            }
            return a;
        };
        d3.max = function(array, f) {
            var i = -1, n = array.length, a, b;
            if (arguments.length === 1) {
                while (++i < n) if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
                while (++i < n) if ((b = array[i]) != null && b > a) a = b;
            } else {
                while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
                while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
            }
            return a;
        };
        d3.extent = function(array, f) {
            var i = -1, n = array.length, a, b, c;
            if (arguments.length === 1) {
                while (++i < n) if ((b = array[i]) != null && b >= b) {
                    a = c = b;
                    break;
                }
                while (++i < n) if ((b = array[i]) != null) {
                    if (a > b) a = b;
                    if (c < b) c = b;
                }
            } else {
                while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = c = b;
                    break;
                }
                while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b) a = b;
                    if (c < b) c = b;
                }
            }
            return [ a, c ];
        };
        function d3_number(x) {
            return x === null ? NaN : +x;
        }
        function d3_numeric(x) {
            return !isNaN(x);
        }
        d3.sum = function(array, f) {
            var s = 0, n = array.length, a, i = -1;
            if (arguments.length === 1) {
                while (++i < n) if (d3_numeric(a = +array[i])) s += a;
            } else {
                while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
            }
            return s;
        };
        d3.mean = function(array, f) {
            var s = 0, n = array.length, a, i = -1, j = n;
            if (arguments.length === 1) {
                while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
            } else {
                while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
            }
            if (j) return s / j;
        };
        d3.quantile = function(values, p) {
            var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
            return e ? v + e * (values[h] - v) : v;
        };
        d3.median = function(array, f) {
            var numbers = [], n = array.length, a, i = -1;
            if (arguments.length === 1) {
                while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
            } else {
                while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
            }
            if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
        };
        d3.variance = function(array, f) {
            var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
            if (arguments.length === 1) {
                while (++i < n) {
                    if (d3_numeric(a = d3_number(array[i]))) {
                        d = a - m;
                        m += d / ++j;
                        s += d * (a - m);
                    }
                }
            } else {
                while (++i < n) {
                    if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                        d = a - m;
                        m += d / ++j;
                        s += d * (a - m);
                    }
                }
            }
            if (j > 1) return s / (j - 1);
        };
        d3.deviation = function() {
            var v = d3.variance.apply(this, arguments);
            return v ? Math.sqrt(v) : v;
        };
        function d3_bisector(compare) {
            return {
                left: function(a, x, lo, hi) {
                    if (arguments.length < 3) lo = 0;
                    if (arguments.length < 4) hi = a.length;
                    while (lo < hi) {
                        var mid = lo + hi >>> 1;
                        if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
                    }
                    return lo;
                },
                right: function(a, x, lo, hi) {
                    if (arguments.length < 3) lo = 0;
                    if (arguments.length < 4) hi = a.length;
                    while (lo < hi) {
                        var mid = lo + hi >>> 1;
                        if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
                    }
                    return lo;
                }
            };
        }
        var d3_bisect = d3_bisector(d3_ascending);
        d3.bisectLeft = d3_bisect.left;
        d3.bisect = d3.bisectRight = d3_bisect.right;
        d3.bisector = function(f) {
            return d3_bisector(f.length === 1 ? function(d, x) {
                return d3_ascending(f(d), x);
            } : f);
        };
        d3.shuffle = function(array, i0, i1) {
            if ((m = arguments.length) < 3) {
                i1 = array.length;
                if (m < 2) i0 = 0;
            }
            var m = i1 - i0, t, i;
            while (m) {
                i = Math.random() * m-- | 0;
                t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
            }
            return array;
        };
        d3.permute = function(array, indexes) {
            var i = indexes.length, permutes = new Array(i);
            while (i--) permutes[i] = array[indexes[i]];
            return permutes;
        };
        d3.pairs = function(array) {
            var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
            while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
            return pairs;
        };
        d3.transpose = function(matrix) {
            if (!(n = matrix.length)) return [];
            for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
                for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
                    row[j] = matrix[j][i];
                }
            }
            return transpose;
        };
        function d3_transposeLength(d) {
            return d.length;
        }
        d3.zip = function() {
            return d3.transpose(arguments);
        };
        d3.keys = function(map) {
            var keys = [];
            for (var key in map) keys.push(key);
            return keys;
        };
        d3.values = function(map) {
            var values = [];
            for (var key in map) values.push(map[key]);
            return values;
        };
        d3.entries = function(map) {
            var entries = [];
            for (var key in map) entries.push({
                key: key,
                value: map[key]
            });
            return entries;
        };
        d3.merge = function(arrays) {
            var n = arrays.length, m, i = -1, j = 0, merged, array;
            while (++i < n) j += arrays[i].length;
            merged = new Array(j);
            while (--n >= 0) {
                array = arrays[n];
                m = array.length;
                while (--m >= 0) {
                    merged[--j] = array[m];
                }
            }
            return merged;
        };
        var abs = Math.abs;
        d3.range = function(start, stop, step) {
            if (arguments.length < 3) {
                step = 1;
                if (arguments.length < 2) {
                    stop = start;
                    start = 0;
                }
            }
            if ((stop - start) / step === Infinity) throw new Error("infinite range");
            var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
            start *= k, stop *= k, step *= k;
            if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
            return range;
        };
        function d3_range_integerScale(x) {
            var k = 1;
            while (x * k % 1) k *= 10;
            return k;
        }
        function d3_class(ctor, properties) {
            for (var key in properties) {
                Object.defineProperty(ctor.prototype, key, {
                    value: properties[key],
                    enumerable: false
                });
            }
        }
        d3.map = function(object, f) {
            var map = new d3_Map();
            if (object instanceof d3_Map) {
                object.forEach(function(key, value) {
                    map.set(key, value);
                });
            } else if (Array.isArray(object)) {
                var i = -1, n = object.length, o;
                if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
            } else {
                for (var key in object) map.set(key, object[key]);
            }
            return map;
        };
        function d3_Map() {
            this._ = Object.create(null);
        }
        var d3_map_proto = "__proto__", d3_map_zero = "\x00";
        d3_class(d3_Map, {
            has: d3_map_has,
            get: function(key) {
                return this._[d3_map_escape(key)];
            },
            set: function(key, value) {
                return this._[d3_map_escape(key)] = value;
            },
            remove: d3_map_remove,
            keys: d3_map_keys,
            values: function() {
                var values = [];
                for (var key in this._) values.push(this._[key]);
                return values;
            },
            entries: function() {
                var entries = [];
                for (var key in this._) entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
                return entries;
            },
            size: d3_map_size,
            empty: d3_map_empty,
            forEach: function(f) {
                for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
            }
        });
        function d3_map_escape(key) {
            return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
        }
        function d3_map_unescape(key) {
            return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
        }
        function d3_map_has(key) {
            return d3_map_escape(key) in this._;
        }
        function d3_map_remove(key) {
            return (key = d3_map_escape(key)) in this._ && delete this._[key];
        }
        function d3_map_keys() {
            var keys = [];
            for (var key in this._) keys.push(d3_map_unescape(key));
            return keys;
        }
        function d3_map_size() {
            var size = 0;
            for (var key in this._) ++size;
            return size;
        }
        function d3_map_empty() {
            for (var key in this._) return false;
            return true;
        }
        d3.nest = function() {
            var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
            function map(mapType, array, depth) {
                if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
                var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
                while (++i < n) {
                    if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                        values.push(object);
                    } else {
                        valuesByKey.set(keyValue, [ object ]);
                    }
                }
                if (mapType) {
                    object = mapType();
                    setter = function(keyValue, values) {
                        object.set(keyValue, map(mapType, values, depth));
                    };
                } else {
                    object = {};
                    setter = function(keyValue, values) {
                        object[keyValue] = map(mapType, values, depth);
                    };
                }
                valuesByKey.forEach(setter);
                return object;
            }
            function entries(map, depth) {
                if (depth >= keys.length) return map;
                var array = [], sortKey = sortKeys[depth++];
                map.forEach(function(key, keyMap) {
                    array.push({
                        key: key,
                        values: entries(keyMap, depth)
                    });
                });
                return sortKey ? array.sort(function(a, b) {
                    return sortKey(a.key, b.key);
                }) : array;
            }
            nest.map = function(array, mapType) {
                return map(mapType, array, 0);
            };
            nest.entries = function(array) {
                return entries(map(d3.map, array, 0), 0);
            };
            nest.key = function(d) {
                keys.push(d);
                return nest;
            };
            nest.sortKeys = function(order) {
                sortKeys[keys.length - 1] = order;
                return nest;
            };
            nest.sortValues = function(order) {
                sortValues = order;
                return nest;
            };
            nest.rollup = function(f) {
                rollup = f;
                return nest;
            };
            return nest;
        };
        d3.set = function(array) {
            var set = new d3_Set();
            if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
            return set;
        };
        function d3_Set() {
            this._ = Object.create(null);
        }
        d3_class(d3_Set, {
            has: d3_map_has,
            add: function(key) {
                this._[d3_map_escape(key += "")] = true;
                return key;
            },
            remove: d3_map_remove,
            values: d3_map_keys,
            size: d3_map_size,
            empty: d3_map_empty,
            forEach: function(f) {
                for (var key in this._) f.call(this, d3_map_unescape(key));
            }
        });
        d3.behavior = {};
        function d3_identity(d) {
            return d;
        }
        d3.rebind = function(target, source) {
            var i = 1, n = arguments.length, method;
            while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
            return target;
        };
        function d3_rebind(target, source, method) {
            return function() {
                var value = method.apply(source, arguments);
                return value === source ? target : value;
            };
        }
        function d3_vendorSymbol(object, name) {
            if (name in object) return name;
            name = name.charAt(0).toUpperCase() + name.slice(1);
            for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
                var prefixName = d3_vendorPrefixes[i] + name;
                if (prefixName in object) return prefixName;
            }
        }
        var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
        function d3_noop() {}
        d3.dispatch = function() {
            var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
            while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
            return dispatch;
        };
        function d3_dispatch() {}
        d3_dispatch.prototype.on = function(type, listener) {
            var i = type.indexOf("."), name = "";
            if (i >= 0) {
                name = type.slice(i + 1);
                type = type.slice(0, i);
            }
            if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
            if (arguments.length === 2) {
                if (listener == null) for (type in this) {
                    if (this.hasOwnProperty(type)) this[type].on(name, null);
                }
                return this;
            }
        };
        function d3_dispatch_event(dispatch) {
            var listeners = [], listenerByName = new d3_Map();
            function event() {
                var z = listeners, i = -1, n = z.length, l;
                while (++i < n) if (l = z[i].on) l.apply(this, arguments);
                return dispatch;
            }
            event.on = function(name, listener) {
                var l = listenerByName.get(name), i;
                if (arguments.length < 2) return l && l.on;
                if (l) {
                    l.on = null;
                    listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                    listenerByName.remove(name);
                }
                if (listener) listeners.push(listenerByName.set(name, {
                    on: listener
                }));
                return dispatch;
            };
            return event;
        }
        d3.event = null;
        function d3_eventPreventDefault() {
            d3.event.preventDefault();
        }
        function d3_eventSource() {
            var e = d3.event, s;
            while (s = e.sourceEvent) e = s;
            return e;
        }
        function d3_eventDispatch(target) {
            var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
            while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
            dispatch.of = function(thiz, argumentz) {
                return function(e1) {
                    try {
                        var e0 = e1.sourceEvent = d3.event;
                        e1.target = target;
                        d3.event = e1;
                        dispatch[e1.type].apply(thiz, argumentz);
                    } finally {
                        d3.event = e0;
                    }
                };
            };
            return dispatch;
        }
        d3.requote = function(s) {
            return s.replace(d3_requote_re, "\\$&");
        };
        var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
        var d3_subclass = {}.__proto__ ? function(object, prototype) {
            object.__proto__ = prototype;
        } : function(object, prototype) {
            for (var property in prototype) object[property] = prototype[property];
        };
        function d3_selection(groups) {
            d3_subclass(groups, d3_selectionPrototype);
            return groups;
        }
        var d3_select = function(s, n) {
            return n.querySelector(s);
        }, d3_selectAll = function(s, n) {
            return n.querySelectorAll(s);
        }, d3_selectMatches = function(n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
            d3_selectMatches = function(n, s) {
                return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
        };
        if (typeof Sizzle === "function") {
            d3_select = function(s, n) {
                return Sizzle(s, n)[0] || null;
            };
            d3_selectAll = Sizzle;
            d3_selectMatches = Sizzle.matchesSelector;
        }
        d3.selection = function() {
            return d3.select(d3_document.documentElement);
        };
        var d3_selectionPrototype = d3.selection.prototype = [];
        d3_selectionPrototype.select = function(selector) {
            var subgroups = [], subgroup, subnode, group, node;
            selector = d3_selection_selector(selector);
            for (var j = -1, m = this.length; ++j < m; ) {
                subgroups.push(subgroup = []);
                subgroup.parentNode = (group = this[j]).parentNode;
                for (var i = -1, n = group.length; ++i < n; ) {
                    if (node = group[i]) {
                        subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                        if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
                    } else {
                        subgroup.push(null);
                    }
                }
            }
            return d3_selection(subgroups);
        };
        function d3_selection_selector(selector) {
            return typeof selector === "function" ? selector : function() {
                return d3_select(selector, this);
            };
        }
        d3_selectionPrototype.selectAll = function(selector) {
            var subgroups = [], subgroup, node;
            selector = d3_selection_selectorAll(selector);
            for (var j = -1, m = this.length; ++j < m; ) {
                for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                    if (node = group[i]) {
                        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                        subgroup.parentNode = node;
                    }
                }
            }
            return d3_selection(subgroups);
        };
        function d3_selection_selectorAll(selector) {
            return typeof selector === "function" ? selector : function() {
                return d3_selectAll(selector, this);
            };
        }
        var d3_nsPrefix = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        };
        d3.ns = {
            prefix: d3_nsPrefix,
            qualify: function(name) {
                var i = name.indexOf(":"), prefix = name;
                if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
                return d3_nsPrefix.hasOwnProperty(prefix) ? {
                    space: d3_nsPrefix[prefix],
                    local: name
                } : name;
            }
        };
        d3_selectionPrototype.attr = function(name, value) {
            if (arguments.length < 2) {
                if (typeof name === "string") {
                    var node = this.node();
                    name = d3.ns.qualify(name);
                    return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
                }
                for (value in name) this.each(d3_selection_attr(value, name[value]));
                return this;
            }
            return this.each(d3_selection_attr(name, value));
        };
        function d3_selection_attr(name, value) {
            name = d3.ns.qualify(name);
            function attrNull() {
                this.removeAttribute(name);
            }
            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local);
            }
            function attrConstant() {
                this.setAttribute(name, value);
            }
            function attrConstantNS() {
                this.setAttributeNS(name.space, name.local, value);
            }
            function attrFunction() {
                var x = value.apply(this, arguments);
                if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
            }
            function attrFunctionNS() {
                var x = value.apply(this, arguments);
                if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
            }
            return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
        }
        function d3_collapse(s) {
            return s.trim().replace(/\s+/g, " ");
        }
        d3_selectionPrototype.classed = function(name, value) {
            if (arguments.length < 2) {
                if (typeof name === "string") {
                    var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                    if (value = node.classList) {
                        while (++i < n) if (!value.contains(name[i])) return false;
                    } else {
                        value = node.getAttribute("class");
                        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
                    }
                    return true;
                }
                for (value in name) this.each(d3_selection_classed(value, name[value]));
                return this;
            }
            return this.each(d3_selection_classed(name, value));
        };
        function d3_selection_classedRe(name) {
            return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
        }
        function d3_selection_classes(name) {
            return (name + "").trim().split(/^|\s+/);
        }
        function d3_selection_classed(name, value) {
            name = d3_selection_classes(name).map(d3_selection_classedName);
            var n = name.length;
            function classedConstant() {
                var i = -1;
                while (++i < n) name[i](this, value);
            }
            function classedFunction() {
                var i = -1, x = value.apply(this, arguments);
                while (++i < n) name[i](this, x);
            }
            return typeof value === "function" ? classedFunction : classedConstant;
        }
        function d3_selection_classedName(name) {
            var re = d3_selection_classedRe(name);
            return function(node, value) {
                if (c = node.classList) return value ? c.add(name) : c.remove(name);
                var c = node.getAttribute("class") || "";
                if (value) {
                    re.lastIndex = 0;
                    if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
                } else {
                    node.setAttribute("class", d3_collapse(c.replace(re, " ")));
                }
            };
        }
        d3_selectionPrototype.style = function(name, value, priority) {
            var n = arguments.length;
            if (n < 3) {
                if (typeof name !== "string") {
                    if (n < 2) value = "";
                    for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
                    return this;
                }
                if (n < 2) {
                    var node = this.node();
                    return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
                }
                priority = "";
            }
            return this.each(d3_selection_style(name, value, priority));
        };
        function d3_selection_style(name, value, priority) {
            function styleNull() {
                this.style.removeProperty(name);
            }
            function styleConstant() {
                this.style.setProperty(name, value, priority);
            }
            function styleFunction() {
                var x = value.apply(this, arguments);
                if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
            }
            return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
        }
        d3_selectionPrototype.property = function(name, value) {
            if (arguments.length < 2) {
                if (typeof name === "string") return this.node()[name];
                for (value in name) this.each(d3_selection_property(value, name[value]));
                return this;
            }
            return this.each(d3_selection_property(name, value));
        };
        function d3_selection_property(name, value) {
            function propertyNull() {
                delete this[name];
            }
            function propertyConstant() {
                this[name] = value;
            }
            function propertyFunction() {
                var x = value.apply(this, arguments);
                if (x == null) delete this[name]; else this[name] = x;
            }
            return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
        }
        d3_selectionPrototype.text = function(value) {
            return arguments.length ? this.each(typeof value === "function" ? function() {
                var v = value.apply(this, arguments);
                this.textContent = v == null ? "" : v;
            } : value == null ? function() {
                this.textContent = "";
            } : function() {
                this.textContent = value;
            }) : this.node().textContent;
        };
        d3_selectionPrototype.html = function(value) {
            return arguments.length ? this.each(typeof value === "function" ? function() {
                var v = value.apply(this, arguments);
                this.innerHTML = v == null ? "" : v;
            } : value == null ? function() {
                this.innerHTML = "";
            } : function() {
                this.innerHTML = value;
            }) : this.node().innerHTML;
        };
        d3_selectionPrototype.append = function(name) {
            name = d3_selection_creator(name);
            return this.select(function() {
                return this.appendChild(name.apply(this, arguments));
            });
        };
        function d3_selection_creator(name) {
            function create() {
                var document = this.ownerDocument, namespace = this.namespaceURI;
                return namespace && namespace !== document.documentElement.namespaceURI ? document.createElementNS(namespace, name) : document.createElement(name);
            }
            function createNS() {
                return this.ownerDocument.createElementNS(name.space, name.local);
            }
            return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
        }
        d3_selectionPrototype.insert = function(name, before) {
            name = d3_selection_creator(name);
            before = d3_selection_selector(before);
            return this.select(function() {
                return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
            });
        };
        d3_selectionPrototype.remove = function() {
            return this.each(d3_selectionRemove);
        };
        function d3_selectionRemove() {
            var parent = this.parentNode;
            if (parent) parent.removeChild(this);
        }
        d3_selectionPrototype.data = function(value, key) {
            var i = -1, n = this.length, group, node;
            if (!arguments.length) {
                value = new Array(n = (group = this[0]).length);
                while (++i < n) {
                    if (node = group[i]) {
                        value[i] = node.__data__;
                    }
                }
                return value;
            }
            function bind(group, groupData) {
                var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
                if (key) {
                    var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                    for (i = -1; ++i < n; ) {
                        if (node = group[i]) {
                            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                                exitNodes[i] = node;
                            } else {
                                nodeByKeyValue.set(keyValue, node);
                            }
                            keyValues[i] = keyValue;
                        }
                    }
                    for (i = -1; ++i < m; ) {
                        if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                            enterNodes[i] = d3_selection_dataNode(nodeData);
                        } else if (node !== true) {
                            updateNodes[i] = node;
                            node.__data__ = nodeData;
                        }
                        nodeByKeyValue.set(keyValue, true);
                    }
                    for (i = -1; ++i < n; ) {
                        if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                            exitNodes[i] = group[i];
                        }
                    }
                } else {
                    for (i = -1; ++i < n0; ) {
                        node = group[i];
                        nodeData = groupData[i];
                        if (node) {
                            node.__data__ = nodeData;
                            updateNodes[i] = node;
                        } else {
                            enterNodes[i] = d3_selection_dataNode(nodeData);
                        }
                    }
                    for (;i < m; ++i) {
                        enterNodes[i] = d3_selection_dataNode(groupData[i]);
                    }
                    for (;i < n; ++i) {
                        exitNodes[i] = group[i];
                    }
                }
                enterNodes.update = updateNodes;
                enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
                enter.push(enterNodes);
                update.push(updateNodes);
                exit.push(exitNodes);
            }
            var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
            if (typeof value === "function") {
                while (++i < n) {
                    bind(group = this[i], value.call(group, group.parentNode.__data__, i));
                }
            } else {
                while (++i < n) {
                    bind(group = this[i], value);
                }
            }
            update.enter = function() {
                return enter;
            };
            update.exit = function() {
                return exit;
            };
            return update;
        };
        function d3_selection_dataNode(data) {
            return {
                __data__: data
            };
        }
        d3_selectionPrototype.datum = function(value) {
            return arguments.length ? this.property("__data__", value) : this.property("__data__");
        };
        d3_selectionPrototype.filter = function(filter) {
            var subgroups = [], subgroup, group, node;
            if (typeof filter !== "function") filter = d3_selection_filter(filter);
            for (var j = 0, m = this.length; j < m; j++) {
                subgroups.push(subgroup = []);
                subgroup.parentNode = (group = this[j]).parentNode;
                for (var i = 0, n = group.length; i < n; i++) {
                    if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                        subgroup.push(node);
                    }
                }
            }
            return d3_selection(subgroups);
        };
        function d3_selection_filter(selector) {
            return function() {
                return d3_selectMatches(this, selector);
            };
        }
        d3_selectionPrototype.order = function() {
            for (var j = -1, m = this.length; ++j < m; ) {
                for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
                    if (node = group[i]) {
                        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
                        next = node;
                    }
                }
            }
            return this;
        };
        d3_selectionPrototype.sort = function(comparator) {
            comparator = d3_selection_sortComparator.apply(this, arguments);
            for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
            return this.order();
        };
        function d3_selection_sortComparator(comparator) {
            if (!arguments.length) comparator = d3_ascending;
            return function(a, b) {
                return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
            };
        }
        d3_selectionPrototype.each = function(callback) {
            return d3_selection_each(this, function(node, i, j) {
                callback.call(node, node.__data__, i, j);
            });
        };
        function d3_selection_each(groups, callback) {
            for (var j = 0, m = groups.length; j < m; j++) {
                for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                    if (node = group[i]) callback(node, i, j);
                }
            }
            return groups;
        }
        d3_selectionPrototype.call = function(callback) {
            var args = d3_array(arguments);
            callback.apply(args[0] = this, args);
            return this;
        };
        d3_selectionPrototype.empty = function() {
            return !this.node();
        };
        d3_selectionPrototype.node = function() {
            for (var j = 0, m = this.length; j < m; j++) {
                for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                    var node = group[i];
                    if (node) return node;
                }
            }
            return null;
        };
        d3_selectionPrototype.size = function() {
            var n = 0;
            d3_selection_each(this, function() {
                ++n;
            });
            return n;
        };
        function d3_selection_enter(selection) {
            d3_subclass(selection, d3_selection_enterPrototype);
            return selection;
        }
        var d3_selection_enterPrototype = [];
        d3.selection.enter = d3_selection_enter;
        d3.selection.enter.prototype = d3_selection_enterPrototype;
        d3_selection_enterPrototype.append = d3_selectionPrototype.append;
        d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
        d3_selection_enterPrototype.node = d3_selectionPrototype.node;
        d3_selection_enterPrototype.call = d3_selectionPrototype.call;
        d3_selection_enterPrototype.size = d3_selectionPrototype.size;
        d3_selection_enterPrototype.select = function(selector) {
            var subgroups = [], subgroup, subnode, upgroup, group, node;
            for (var j = -1, m = this.length; ++j < m; ) {
                upgroup = (group = this[j]).update;
                subgroups.push(subgroup = []);
                subgroup.parentNode = group.parentNode;
                for (var i = -1, n = group.length; ++i < n; ) {
                    if (node = group[i]) {
                        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                        subnode.__data__ = node.__data__;
                    } else {
                        subgroup.push(null);
                    }
                }
            }
            return d3_selection(subgroups);
        };
        d3_selection_enterPrototype.insert = function(name, before) {
            if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
            return d3_selectionPrototype.insert.call(this, name, before);
        };
        function d3_selection_enterInsertBefore(enter) {
            var i0, j0;
            return function(d, i, j) {
                var group = enter[j].update, n = group.length, node;
                if (j != j0) j0 = j, i0 = 0;
                if (i >= i0) i0 = i + 1;
                while (!(node = group[i0]) && ++i0 < n) ;
                return node;
            };
        }
        d3.select = function(node) {
            var group;
            if (typeof node === "string") {
                group = [ d3_select(node, d3_document) ];
                group.parentNode = d3_document.documentElement;
            } else {
                group = [ node ];
                group.parentNode = d3_documentElement(node);
            }
            return d3_selection([ group ]);
        };
        d3.selectAll = function(nodes) {
            var group;
            if (typeof nodes === "string") {
                group = d3_array(d3_selectAll(nodes, d3_document));
                group.parentNode = d3_document.documentElement;
            } else {
                group = d3_array(nodes);
                group.parentNode = null;
            }
            return d3_selection([ group ]);
        };
        d3_selectionPrototype.on = function(type, listener, capture) {
            var n = arguments.length;
            if (n < 3) {
                if (typeof type !== "string") {
                    if (n < 2) listener = false;
                    for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
                    return this;
                }
                if (n < 2) return (n = this.node()["__on" + type]) && n._;
                capture = false;
            }
            return this.each(d3_selection_on(type, listener, capture));
        };
        function d3_selection_on(type, listener, capture) {
            var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
            if (i > 0) type = type.slice(0, i);
            var filter = d3_selection_onFilters.get(type);
            if (filter) type = filter, wrap = d3_selection_onFilter;
            function onRemove() {
                var l = this[name];
                if (l) {
                    this.removeEventListener(type, l, l.$);
                    delete this[name];
                }
            }
            function onAdd() {
                var l = wrap(listener, d3_array(arguments));
                onRemove.call(this);
                this.addEventListener(type, this[name] = l, l.$ = capture);
                l._ = listener;
            }
            function removeAll() {
                var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
                for (var name in this) {
                    if (match = name.match(re)) {
                        var l = this[name];
                        this.removeEventListener(match[1], l, l.$);
                        delete this[name];
                    }
                }
            }
            return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
        }
        var d3_selection_onFilters = d3.map({
            mouseenter: "mouseover",
            mouseleave: "mouseout"
        });
        if (d3_document) {
            d3_selection_onFilters.forEach(function(k) {
                if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
            });
        }
        function d3_selection_onListener(listener, argumentz) {
            return function(e) {
                var o = d3.event;
                d3.event = e;
                argumentz[0] = this.__data__;
                try {
                    listener.apply(this, argumentz);
                } finally {
                    d3.event = o;
                }
            };
        }
        function d3_selection_onFilter(listener, argumentz) {
            var l = d3_selection_onListener(listener, argumentz);
            return function(e) {
                var target = this, related = e.relatedTarget;
                if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                    l.call(target, e);
                }
            };
        }
        var d3_event_dragSelect, d3_event_dragId = 0;
        function d3_event_dragSuppress(node) {
            var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
            if (d3_event_dragSelect == null) {
                d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
            }
            if (d3_event_dragSelect) {
                var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
                style[d3_event_dragSelect] = "none";
            }
            return function(suppressClick) {
                w.on(name, null);
                if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
                if (suppressClick) {
                    var off = function() {
                        w.on(click, null);
                    };
                    w.on(click, function() {
                        d3_eventPreventDefault();
                        off();
                    }, true);
                    setTimeout(off, 0);
                }
            };
        }
        d3.mouse = function(container) {
            return d3_mousePoint(container, d3_eventSource());
        };
        var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
        function d3_mousePoint(container, e) {
            if (e.changedTouches) e = e.changedTouches[0];
            var svg = container.ownerSVGElement || container;
            if (svg.createSVGPoint) {
                var point = svg.createSVGPoint();
                if (d3_mouse_bug44083 < 0) {
                    var window = d3_window(container);
                    if (window.scrollX || window.scrollY) {
                        svg = d3.select("body").append("svg").style({
                            position: "absolute",
                            top: 0,
                            left: 0,
                            margin: 0,
                            padding: 0,
                            border: "none"
                        }, "important");
                        var ctm = svg[0][0].getScreenCTM();
                        d3_mouse_bug44083 = !(ctm.f || ctm.e);
                        svg.remove();
                    }
                }
                if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX,
                    point.y = e.clientY;
                point = point.matrixTransform(container.getScreenCTM().inverse());
                return [ point.x, point.y ];
            }
            var rect = container.getBoundingClientRect();
            return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
        }
        d3.touch = function(container, touches, identifier) {
            if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
            if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
        };
        d3.behavior.drag = function() {
            var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
            function drag() {
                this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
            }
            function dragstart(id, position, subject, move, end) {
                return function() {
                    var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                    if (origin) {
                        dragOffset = origin.apply(that, arguments);
                        dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
                    } else {
                        dragOffset = [ 0, 0 ];
                    }
                    dispatch({
                        type: "dragstart"
                    });
                    function moved() {
                        var position1 = position(parent, dragId), dx, dy;
                        if (!position1) return;
                        dx = position1[0] - position0[0];
                        dy = position1[1] - position0[1];
                        dragged |= dx | dy;
                        position0 = position1;
                        dispatch({
                            type: "drag",
                            x: position1[0] + dragOffset[0],
                            y: position1[1] + dragOffset[1],
                            dx: dx,
                            dy: dy
                        });
                    }
                    function ended() {
                        if (!position(parent, dragId)) return;
                        dragSubject.on(move + dragName, null).on(end + dragName, null);
                        dragRestore(dragged);
                        dispatch({
                            type: "dragend"
                        });
                    }
                };
            }
            drag.origin = function(x) {
                if (!arguments.length) return origin;
                origin = x;
                return drag;
            };
            return d3.rebind(drag, event, "on");
        };
        function d3_behavior_dragTouchId() {
            return d3.event.changedTouches[0].identifier;
        }
        d3.touches = function(container, touches) {
            if (arguments.length < 2) touches = d3_eventSource().touches;
            return touches ? d3_array(touches).map(function(touch) {
                var point = d3_mousePoint(container, touch);
                point.identifier = touch.identifier;
                return point;
            }) : [];
        };
        var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
        function d3_sgn(x) {
            return x > 0 ? 1 : x < 0 ? -1 : 0;
        }
        function d3_cross2d(a, b, c) {
            return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
        }
        function d3_acos(x) {
            return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
        }
        function d3_asin(x) {
            return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
        }
        function d3_sinh(x) {
            return ((x = Math.exp(x)) - 1 / x) / 2;
        }
        function d3_cosh(x) {
            return ((x = Math.exp(x)) + 1 / x) / 2;
        }
        function d3_tanh(x) {
            return ((x = Math.exp(2 * x)) - 1) / (x + 1);
        }
        function d3_haversin(x) {
            return (x = Math.sin(x / 2)) * x;
        }
        var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
        d3.interpolateZoom = function(p0, p1) {
            var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
            if (d2 < ε2) {
                S = Math.log(w1 / w0) / ρ;
                i = function(t) {
                    return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
                };
            } else {
                var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
                S = (r1 - r0) / ρ;
                i = function(t) {
                    var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                    return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
                };
            }
            i.duration = S * 1e3;
            return i;
        };
        d3.behavior.zoom = function() {
            var view = {
                x: 0,
                y: 0,
                k: 1
            }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
            if (!d3_behavior_zoomWheel) {
                d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                    return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
                }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
                    return d3.event.wheelDelta;
                }, "mousewheel") : (d3_behavior_zoomDelta = function() {
                    return -d3.event.detail;
                }, "MozMousePixelScroll");
            }
            function zoom(g) {
                g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
            }
            zoom.event = function(g) {
                g.each(function() {
                    var dispatch = event.of(this, arguments), view1 = view;
                    if (d3_transitionInheritId) {
                        d3.select(this).transition().each("start.zoom", function() {
                            view = this.__chart__ || {
                                x: 0,
                                y: 0,
                                k: 1
                            };
                            zoomstarted(dispatch);
                        }).tween("zoom:zoom", function() {
                            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
                            return function(t) {
                                var l = i(t), k = dx / l[2];
                                this.__chart__ = view = {
                                    x: cx - l[0] * k,
                                    y: cy - l[1] * k,
                                    k: k
                                };
                                zoomed(dispatch);
                            };
                        }).each("interrupt.zoom", function() {
                            zoomended(dispatch);
                        }).each("end.zoom", function() {
                            zoomended(dispatch);
                        });
                    } else {
                        this.__chart__ = view;
                        zoomstarted(dispatch);
                        zoomed(dispatch);
                        zoomended(dispatch);
                    }
                });
            };
            zoom.translate = function(_) {
                if (!arguments.length) return [ view.x, view.y ];
                view = {
                    x: +_[0],
                    y: +_[1],
                    k: view.k
                };
                rescale();
                return zoom;
            };
            zoom.scale = function(_) {
                if (!arguments.length) return view.k;
                view = {
                    x: view.x,
                    y: view.y,
                    k: null
                };
                scaleTo(+_);
                rescale();
                return zoom;
            };
            zoom.scaleExtent = function(_) {
                if (!arguments.length) return scaleExtent;
                scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
                return zoom;
            };
            zoom.center = function(_) {
                if (!arguments.length) return center;
                center = _ && [ +_[0], +_[1] ];
                return zoom;
            };
            zoom.size = function(_) {
                if (!arguments.length) return size;
                size = _ && [ +_[0], +_[1] ];
                return zoom;
            };
            zoom.duration = function(_) {
                if (!arguments.length) return duration;
                duration = +_;
                return zoom;
            };
            zoom.x = function(z) {
                if (!arguments.length) return x1;
                x1 = z;
                x0 = z.copy();
                view = {
                    x: 0,
                    y: 0,
                    k: 1
                };
                return zoom;
            };
            zoom.y = function(z) {
                if (!arguments.length) return y1;
                y1 = z;
                y0 = z.copy();
                view = {
                    x: 0,
                    y: 0,
                    k: 1
                };
                return zoom;
            };
            function location(p) {
                return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
            }
            function point(l) {
                return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
            }
            function scaleTo(s) {
                view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
            }
            function translateTo(p, l) {
                l = point(l);
                view.x += p[0] - l[0];
                view.y += p[1] - l[1];
            }
            function zoomTo(that, p, l, k) {
                that.__chart__ = {
                    x: view.x,
                    y: view.y,
                    k: view.k
                };
                scaleTo(Math.pow(2, k));
                translateTo(center0 = p, l);
                that = d3.select(that);
                if (duration > 0) that = that.transition().duration(duration);
                that.call(zoom.event);
            }
            function rescale() {
                if (x1) x1.domain(x0.range().map(function(x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
                if (y1) y1.domain(y0.range().map(function(y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
            }
            function zoomstarted(dispatch) {
                if (!zooming++) dispatch({
                    type: "zoomstart"
                });
            }
            function zoomed(dispatch) {
                rescale();
                dispatch({
                    type: "zoom",
                    scale: view.k,
                    translate: [ view.x, view.y ]
                });
            }
            function zoomended(dispatch) {
                if (!--zooming) dispatch({
                    type: "zoomend"
                }), center0 = null;
            }
            function mousedowned() {
                var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
                d3_selection_interrupt.call(that);
                zoomstarted(dispatch);
                function moved() {
                    dragged = 1;
                    translateTo(d3.mouse(that), location0);
                    zoomed(dispatch);
                }
                function ended() {
                    subject.on(mousemove, null).on(mouseup, null);
                    dragRestore(dragged);
                    zoomended(dispatch);
                }
            }
            function touchstarted() {
                var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
                started();
                zoomstarted(dispatch);
                subject.on(mousedown, null).on(touchstart, started);
                function relocate() {
                    var touches = d3.touches(that);
                    scale0 = view.k;
                    touches.forEach(function(t) {
                        if (t.identifier in locations0) locations0[t.identifier] = location(t);
                    });
                    return touches;
                }
                function started() {
                    var target = d3.event.target;
                    d3.select(target).on(touchmove, moved).on(touchend, ended);
                    targets.push(target);
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        locations0[changed[i].identifier] = null;
                    }
                    var touches = relocate(), now = Date.now();
                    if (touches.length === 1) {
                        if (now - touchtime < 500) {
                            var p = touches[0];
                            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                            d3_eventPreventDefault();
                        }
                        touchtime = now;
                    } else if (touches.length > 1) {
                        var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                        distance0 = dx * dx + dy * dy;
                    }
                }
                function moved() {
                    var touches = d3.touches(that), p0, l0, p1, l1;
                    d3_selection_interrupt.call(that);
                    for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                        p1 = touches[i];
                        if (l1 = locations0[p1.identifier]) {
                            if (l0) break;
                            p0 = p1, l0 = l1;
                        }
                    }
                    if (l1) {
                        var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                        p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
                        l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
                        scaleTo(scale1 * scale0);
                    }
                    touchtime = null;
                    translateTo(p0, l0);
                    zoomed(dispatch);
                }
                function ended() {
                    if (d3.event.touches.length) {
                        var changed = d3.event.changedTouches;
                        for (var i = 0, n = changed.length; i < n; ++i) {
                            delete locations0[changed[i].identifier];
                        }
                        for (var identifier in locations0) {
                            return void relocate();
                        }
                    }
                    d3.selectAll(targets).on(zoomName, null);
                    subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                    dragRestore();
                    zoomended(dispatch);
                }
            }
            function mousewheeled() {
                var dispatch = event.of(this, arguments);
                if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this),
                    translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
                mousewheelTimer = setTimeout(function() {
                    mousewheelTimer = null;
                    zoomended(dispatch);
                }, 50);
                d3_eventPreventDefault();
                scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
                translateTo(center0, translate0);
                zoomed(dispatch);
            }
            function dblclicked() {
                var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
                zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
            }
            return d3.rebind(zoom, event, "on");
        };
        var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
        d3.color = d3_color;
        function d3_color() {}
        d3_color.prototype.toString = function() {
            return this.rgb() + "";
        };
        d3.hsl = d3_hsl;
        function d3_hsl(h, s, l) {
            return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
        }
        var d3_hslPrototype = d3_hsl.prototype = new d3_color();
        d3_hslPrototype.brighter = function(k) {
            k = Math.pow(.7, arguments.length ? k : 1);
            return new d3_hsl(this.h, this.s, this.l / k);
        };
        d3_hslPrototype.darker = function(k) {
            k = Math.pow(.7, arguments.length ? k : 1);
            return new d3_hsl(this.h, this.s, k * this.l);
        };
        d3_hslPrototype.rgb = function() {
            return d3_hsl_rgb(this.h, this.s, this.l);
        };
        function d3_hsl_rgb(h, s, l) {
            var m1, m2;
            h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
            s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
            l = l < 0 ? 0 : l > 1 ? 1 : l;
            m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
            m1 = 2 * l - m2;
            function v(h) {
                if (h > 360) h -= 360; else if (h < 0) h += 360;
                if (h < 60) return m1 + (m2 - m1) * h / 60;
                if (h < 180) return m2;
                if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
                return m1;
            }
            function vv(h) {
                return Math.round(v(h) * 255);
            }
            return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
        }
        d3.hcl = d3_hcl;
        function d3_hcl(h, c, l) {
            return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
        }
        var d3_hclPrototype = d3_hcl.prototype = new d3_color();
        d3_hclPrototype.brighter = function(k) {
            return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.darker = function(k) {
            return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
        };
        d3_hclPrototype.rgb = function() {
            return d3_hcl_lab(this.h, this.c, this.l).rgb();
        };
        function d3_hcl_lab(h, c, l) {
            if (isNaN(h)) h = 0;
            if (isNaN(c)) c = 0;
            return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
        }
        d3.lab = d3_lab;
        function d3_lab(l, a, b) {
            return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
        }
        var d3_lab_K = 18;
        var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
        var d3_labPrototype = d3_lab.prototype = new d3_color();
        d3_labPrototype.brighter = function(k) {
            return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.darker = function(k) {
            return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
        };
        d3_labPrototype.rgb = function() {
            return d3_lab_rgb(this.l, this.a, this.b);
        };
        function d3_lab_rgb(l, a, b) {
            var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
            x = d3_lab_xyz(x) * d3_lab_X;
            y = d3_lab_xyz(y) * d3_lab_Y;
            z = d3_lab_xyz(z) * d3_lab_Z;
            return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
        }
        function d3_lab_hcl(l, a, b) {
            return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
        }
        function d3_lab_xyz(x) {
            return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
        }
        function d3_xyz_lab(x) {
            return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
        }
        function d3_xyz_rgb(r) {
            return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
        }
        d3.rgb = d3_rgb;
        function d3_rgb(r, g, b) {
            return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
        }
        function d3_rgbNumber(value) {
            return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
        }
        function d3_rgbString(value) {
            return d3_rgbNumber(value) + "";
        }
        var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
        d3_rgbPrototype.brighter = function(k) {
            k = Math.pow(.7, arguments.length ? k : 1);
            var r = this.r, g = this.g, b = this.b, i = 30;
            if (!r && !g && !b) return new d3_rgb(i, i, i);
            if (r && r < i) r = i;
            if (g && g < i) g = i;
            if (b && b < i) b = i;
            return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
        };
        d3_rgbPrototype.darker = function(k) {
            k = Math.pow(.7, arguments.length ? k : 1);
            return new d3_rgb(k * this.r, k * this.g, k * this.b);
        };
        d3_rgbPrototype.hsl = function() {
            return d3_rgb_hsl(this.r, this.g, this.b);
        };
        d3_rgbPrototype.toString = function() {
            return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
        };
        function d3_rgb_hex(v) {
            return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
        }
        function d3_rgb_parse(format, rgb, hsl) {
            var r = 0, g = 0, b = 0, m1, m2, color;
            m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
            if (m1) {
                m2 = m1[2].split(",");
                switch (m1[1]) {
                    case "hsl":
                    {
                        return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                    }

                    case "rgb":
                    {
                        return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                    }
                }
            }
            if (color = d3_rgb_names.get(format)) {
                return rgb(color.r, color.g, color.b);
            }
            if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
                if (format.length === 4) {
                    r = (color & 3840) >> 4;
                    r = r >> 4 | r;
                    g = color & 240;
                    g = g >> 4 | g;
                    b = color & 15;
                    b = b << 4 | b;
                } else if (format.length === 7) {
                    r = (color & 16711680) >> 16;
                    g = (color & 65280) >> 8;
                    b = color & 255;
                }
            }
            return rgb(r, g, b);
        }
        function d3_rgb_hsl(r, g, b) {
            var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
            if (d) {
                s = l < .5 ? d / (max + min) : d / (2 - max - min);
                if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
                h *= 60;
            } else {
                h = NaN;
                s = l > 0 && l < 1 ? 0 : h;
            }
            return new d3_hsl(h, s, l);
        }
        function d3_rgb_lab(r, g, b) {
            r = d3_rgb_xyz(r);
            g = d3_rgb_xyz(g);
            b = d3_rgb_xyz(b);
            var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
            return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
        }
        function d3_rgb_xyz(r) {
            return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
        }
        function d3_rgb_parseNumber(c) {
            var f = parseFloat(c);
            return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
        }
        var d3_rgb_names = d3.map({
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        });
        d3_rgb_names.forEach(function(key, value) {
            d3_rgb_names.set(key, d3_rgbNumber(value));
        });
        function d3_functor(v) {
            return typeof v === "function" ? v : function() {
                return v;
            };
        }
        d3.functor = d3_functor;
        d3.xhr = d3_xhrType(d3_identity);
        function d3_xhrType(response) {
            return function(url, mimeType, callback) {
                if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType,
                    mimeType = null;
                return d3_xhr(url, mimeType, response, callback);
            };
        }
        function d3_xhr(url, mimeType, response, callback) {
            var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
            if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
            "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
                request.readyState > 3 && respond();
            };
            function respond() {
                var status = request.status, result;
                if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                    try {
                        result = response.call(xhr, request);
                    } catch (e) {
                        dispatch.error.call(xhr, e);
                        return;
                    }
                    dispatch.load.call(xhr, result);
                } else {
                    dispatch.error.call(xhr, request);
                }
            }
            request.onprogress = function(event) {
                var o = d3.event;
                d3.event = event;
                try {
                    dispatch.progress.call(xhr, request);
                } finally {
                    d3.event = o;
                }
            };
            xhr.header = function(name, value) {
                name = (name + "").toLowerCase();
                if (arguments.length < 2) return headers[name];
                if (value == null) delete headers[name]; else headers[name] = value + "";
                return xhr;
            };
            xhr.mimeType = function(value) {
                if (!arguments.length) return mimeType;
                mimeType = value == null ? null : value + "";
                return xhr;
            };
            xhr.responseType = function(value) {
                if (!arguments.length) return responseType;
                responseType = value;
                return xhr;
            };
            xhr.response = function(value) {
                response = value;
                return xhr;
            };
            [ "get", "post" ].forEach(function(method) {
                xhr[method] = function() {
                    return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
                };
            });
            xhr.send = function(method, data, callback) {
                if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
                request.open(method, url, true);
                if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
                if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
                if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
                if (responseType != null) request.responseType = responseType;
                if (callback != null) xhr.on("error", callback).on("load", function(request) {
                    callback(null, request);
                });
                dispatch.beforesend.call(xhr, request);
                request.send(data == null ? null : data);
                return xhr;
            };
            xhr.abort = function() {
                request.abort();
                return xhr;
            };
            d3.rebind(xhr, dispatch, "on");
            return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
        }
        function d3_xhr_fixCallback(callback) {
            return callback.length === 1 ? function(error, request) {
                callback(error == null ? request : null);
            } : callback;
        }
        function d3_xhrHasResponse(request) {
            var type = request.responseType;
            return type && type !== "text" ? request.response : request.responseText;
        }
        d3.dsv = function(delimiter, mimeType) {
            var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
            function dsv(url, row, callback) {
                if (arguments.length < 3) callback = row, row = null;
                var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
                xhr.row = function(_) {
                    return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
                };
                return xhr;
            }
            function response(request) {
                return dsv.parse(request.responseText);
            }
            function typedResponse(f) {
                return function(request) {
                    return dsv.parse(request.responseText, f);
                };
            }
            dsv.parse = function(text, f) {
                var o;
                return dsv.parseRows(text, function(row, i) {
                    if (o) return o(row, i - 1);
                    var a = new Function("d", "return {" + row.map(function(name, i) {
                        return JSON.stringify(name) + ": d[" + i + "]";
                    }).join(",") + "}");
                    o = f ? function(row, i) {
                        return f(a(row), i);
                    } : a;
                });
            };
            dsv.parseRows = function(text, f) {
                var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
                function token() {
                    if (I >= N) return EOF;
                    if (eol) return eol = false, EOL;
                    var j = I;
                    if (text.charCodeAt(j) === 34) {
                        var i = j;
                        while (i++ < N) {
                            if (text.charCodeAt(i) === 34) {
                                if (text.charCodeAt(i + 1) !== 34) break;
                                ++i;
                            }
                        }
                        I = i + 2;
                        var c = text.charCodeAt(i + 1);
                        if (c === 13) {
                            eol = true;
                            if (text.charCodeAt(i + 2) === 10) ++I;
                        } else if (c === 10) {
                            eol = true;
                        }
                        return text.slice(j + 1, i).replace(/""/g, '"');
                    }
                    while (I < N) {
                        var c = text.charCodeAt(I++), k = 1;
                        if (c === 10) eol = true; else if (c === 13) {
                            eol = true;
                            if (text.charCodeAt(I) === 10) ++I, ++k;
                        } else if (c !== delimiterCode) continue;
                        return text.slice(j, I - k);
                    }
                    return text.slice(j);
                }
                while ((t = token()) !== EOF) {
                    var a = [];
                    while (t !== EOL && t !== EOF) {
                        a.push(t);
                        t = token();
                    }
                    if (f && (a = f(a, n++)) == null) continue;
                    rows.push(a);
                }
                return rows;
            };
            dsv.format = function(rows) {
                if (Array.isArray(rows[0])) return dsv.formatRows(rows);
                var fieldSet = new d3_Set(), fields = [];
                rows.forEach(function(row) {
                    for (var field in row) {
                        if (!fieldSet.has(field)) {
                            fields.push(fieldSet.add(field));
                        }
                    }
                });
                return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
                    return fields.map(function(field) {
                        return formatValue(row[field]);
                    }).join(delimiter);
                })).join("\n");
            };
            dsv.formatRows = function(rows) {
                return rows.map(formatRow).join("\n");
            };
            function formatRow(row) {
                return row.map(formatValue).join(delimiter);
            }
            function formatValue(text) {
                return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
            }
            return dsv;
        };
        d3.csv = d3.dsv(",", "text/csv");
        d3.tsv = d3.dsv("	", "text/tab-separated-values");
        var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
            setTimeout(callback, 17);
        };
        d3.timer = function() {
            d3_timer.apply(this, arguments);
        };
        function d3_timer(callback, delay, then) {
            var n = arguments.length;
            if (n < 2) delay = 0;
            if (n < 3) then = Date.now();
            var time = then + delay, timer = {
                c: callback,
                t: time,
                n: null
            };
            if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
            d3_timer_queueTail = timer;
            if (!d3_timer_interval) {
                d3_timer_timeout = clearTimeout(d3_timer_timeout);
                d3_timer_interval = 1;
                d3_timer_frame(d3_timer_step);
            }
            return timer;
        }
        function d3_timer_step() {
            var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
            if (delay > 24) {
                if (isFinite(delay)) {
                    clearTimeout(d3_timer_timeout);
                    d3_timer_timeout = setTimeout(d3_timer_step, delay);
                }
                d3_timer_interval = 0;
            } else {
                d3_timer_interval = 1;
                d3_timer_frame(d3_timer_step);
            }
        }
        d3.timer.flush = function() {
            d3_timer_mark();
            d3_timer_sweep();
        };
        function d3_timer_mark() {
            var now = Date.now(), timer = d3_timer_queueHead;
            while (timer) {
                if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
                timer = timer.n;
            }
            return now;
        }
        function d3_timer_sweep() {
            var t0, t1 = d3_timer_queueHead, time = Infinity;
            while (t1) {
                if (t1.c) {
                    if (t1.t < time) time = t1.t;
                    t1 = (t0 = t1).n;
                } else {
                    t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
                }
            }
            d3_timer_queueTail = t0;
            return time;
        }
        function d3_format_precision(x, p) {
            return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
        }
        d3.round = function(x, n) {
            return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
        };
        var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
        d3.formatPrefix = function(value, precision) {
            var i = 0;
            if (value = +value) {
                if (value < 0) value *= -1;
                if (precision) value = d3.round(value, d3_format_precision(value, precision));
                i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
                i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
            }
            return d3_formatPrefixes[8 + i / 3];
        };
        function d3_formatPrefix(d, i) {
            var k = Math.pow(10, abs(8 - i) * 3);
            return {
                scale: i > 8 ? function(d) {
                    return d / k;
                } : function(d) {
                    return d * k;
                },
                symbol: d
            };
        }
        function d3_locale_numberFormat(locale) {
            var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
                var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
                while (i > 0 && g > 0) {
                    if (length + g + 1 > width) g = Math.max(1, width - length);
                    t.push(value.substring(i -= g, i + g));
                    if ((length += g + 1) > width) break;
                    g = locale_grouping[j = (j + 1) % locale_grouping.length];
                }
                return t.reverse().join(locale_thousands);
            } : d3_identity;
            return function(specifier) {
                var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
                if (precision) precision = +precision.substring(1);
                if (zfill || fill === "0" && align === "=") {
                    zfill = fill = "0";
                    align = "=";
                }
                switch (type) {
                    case "n":
                        comma = true;
                        type = "g";
                        break;

                    case "%":
                        scale = 100;
                        suffix = "%";
                        type = "f";
                        break;

                    case "p":
                        scale = 100;
                        suffix = "%";
                        type = "r";
                        break;

                    case "b":
                    case "o":
                    case "x":
                    case "X":
                        if (symbol === "#") prefix = "0" + type.toLowerCase();

                    case "c":
                        exponent = false;

                    case "d":
                        integer = true;
                        precision = 0;
                        break;

                    case "s":
                        scale = -1;
                        type = "r";
                        break;
                }
                if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
                if (type == "r" && !precision) type = "g";
                if (precision != null) {
                    if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
                }
                type = d3_format_types.get(type) || d3_format_typeDefault;
                var zcomma = zfill && comma;
                return function(value) {
                    var fullSuffix = suffix;
                    if (integer && value % 1) return "";
                    var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                    if (scale < 0) {
                        var unit = d3.formatPrefix(value, precision);
                        value = unit.scale(value);
                        fullSuffix = unit.symbol + suffix;
                    } else {
                        value *= scale;
                    }
                    value = type(value, precision);
                    var i = value.lastIndexOf("."), before, after;
                    if (i < 0) {
                        var j = exponent ? value.lastIndexOf("e") : -1;
                        if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
                    } else {
                        before = value.substring(0, i);
                        after = locale_decimal + value.substring(i + 1);
                    }
                    if (!zfill && comma) before = formatGroup(before, Infinity);
                    var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                    if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                    negative += prefix;
                    value = before + after;
                    return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
                };
            };
        }
        var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
        var d3_format_types = d3.map({
            b: function(x) {
                return x.toString(2);
            },
            c: function(x) {
                return String.fromCharCode(x);
            },
            o: function(x) {
                return x.toString(8);
            },
            x: function(x) {
                return x.toString(16);
            },
            X: function(x) {
                return x.toString(16).toUpperCase();
            },
            g: function(x, p) {
                return x.toPrecision(p);
            },
            e: function(x, p) {
                return x.toExponential(p);
            },
            f: function(x, p) {
                return x.toFixed(p);
            },
            r: function(x, p) {
                return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
            }
        });
        function d3_format_typeDefault(x) {
            return x + "";
        }
        var d3_time = d3.time = {}, d3_date = Date;
        function d3_date_utc() {
            this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
        }
        d3_date_utc.prototype = {
            getDate: function() {
                return this._.getUTCDate();
            },
            getDay: function() {
                return this._.getUTCDay();
            },
            getFullYear: function() {
                return this._.getUTCFullYear();
            },
            getHours: function() {
                return this._.getUTCHours();
            },
            getMilliseconds: function() {
                return this._.getUTCMilliseconds();
            },
            getMinutes: function() {
                return this._.getUTCMinutes();
            },
            getMonth: function() {
                return this._.getUTCMonth();
            },
            getSeconds: function() {
                return this._.getUTCSeconds();
            },
            getTime: function() {
                return this._.getTime();
            },
            getTimezoneOffset: function() {
                return 0;
            },
            valueOf: function() {
                return this._.valueOf();
            },
            setDate: function() {
                d3_time_prototype.setUTCDate.apply(this._, arguments);
            },
            setDay: function() {
                d3_time_prototype.setUTCDay.apply(this._, arguments);
            },
            setFullYear: function() {
                d3_time_prototype.setUTCFullYear.apply(this._, arguments);
            },
            setHours: function() {
                d3_time_prototype.setUTCHours.apply(this._, arguments);
            },
            setMilliseconds: function() {
                d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
            },
            setMinutes: function() {
                d3_time_prototype.setUTCMinutes.apply(this._, arguments);
            },
            setMonth: function() {
                d3_time_prototype.setUTCMonth.apply(this._, arguments);
            },
            setSeconds: function() {
                d3_time_prototype.setUTCSeconds.apply(this._, arguments);
            },
            setTime: function() {
                d3_time_prototype.setTime.apply(this._, arguments);
            }
        };
        var d3_time_prototype = Date.prototype;
        function d3_time_interval(local, step, number) {
            function round(date) {
                var d0 = local(date), d1 = offset(d0, 1);
                return date - d0 < d1 - date ? d0 : d1;
            }
            function ceil(date) {
                step(date = local(new d3_date(date - 1)), 1);
                return date;
            }
            function offset(date, k) {
                step(date = new d3_date(+date), k);
                return date;
            }
            function range(t0, t1, dt) {
                var time = ceil(t0), times = [];
                if (dt > 1) {
                    while (time < t1) {
                        if (!(number(time) % dt)) times.push(new Date(+time));
                        step(time, 1);
                    }
                } else {
                    while (time < t1) times.push(new Date(+time)), step(time, 1);
                }
                return times;
            }
            function range_utc(t0, t1, dt) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date_utc();
                    utc._ = t0;
                    return range(utc, t1, dt);
                } finally {
                    d3_date = Date;
                }
            }
            local.floor = local;
            local.round = round;
            local.ceil = ceil;
            local.offset = offset;
            local.range = range;
            var utc = local.utc = d3_time_interval_utc(local);
            utc.floor = utc;
            utc.round = d3_time_interval_utc(round);
            utc.ceil = d3_time_interval_utc(ceil);
            utc.offset = d3_time_interval_utc(offset);
            utc.range = range_utc;
            return local;
        }
        function d3_time_interval_utc(method) {
            return function(date, k) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date_utc();
                    utc._ = date;
                    return method(utc, k)._;
                } finally {
                    d3_date = Date;
                }
            };
        }
        d3_time.year = d3_time_interval(function(date) {
            date = d3_time.day(date);
            date.setMonth(0, 1);
            return date;
        }, function(date, offset) {
            date.setFullYear(date.getFullYear() + offset);
        }, function(date) {
            return date.getFullYear();
        });
        d3_time.years = d3_time.year.range;
        d3_time.years.utc = d3_time.year.utc.range;
        d3_time.day = d3_time_interval(function(date) {
            var day = new d3_date(2e3, 0);
            day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
            return day;
        }, function(date, offset) {
            date.setDate(date.getDate() + offset);
        }, function(date) {
            return date.getDate() - 1;
        });
        d3_time.days = d3_time.day.range;
        d3_time.days.utc = d3_time.day.utc.range;
        d3_time.dayOfYear = function(date) {
            var year = d3_time.year(date);
            return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
        };
        [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
            i = 7 - i;
            var interval = d3_time[day] = d3_time_interval(function(date) {
                (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
                return date;
            }, function(date, offset) {
                date.setDate(date.getDate() + Math.floor(offset) * 7);
            }, function(date) {
                var day = d3_time.year(date).getDay();
                return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
            });
            d3_time[day + "s"] = interval.range;
            d3_time[day + "s"].utc = interval.utc.range;
            d3_time[day + "OfYear"] = function(date) {
                var day = d3_time.year(date).getDay();
                return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
            };
        });
        d3_time.week = d3_time.sunday;
        d3_time.weeks = d3_time.sunday.range;
        d3_time.weeks.utc = d3_time.sunday.utc.range;
        d3_time.weekOfYear = d3_time.sundayOfYear;
        function d3_locale_timeFormat(locale) {
            var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
            function d3_time_format(template) {
                var n = template.length;
                function format(date) {
                    var string = [], i = -1, j = 0, c, p, f;
                    while (++i < n) {
                        if (template.charCodeAt(i) === 37) {
                            string.push(template.slice(j, i));
                            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
                            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
                            string.push(c);
                            j = i + 1;
                        }
                    }
                    string.push(template.slice(j, i));
                    return string.join("");
                }
                format.parse = function(string) {
                    var d = {
                        y: 1900,
                        m: 0,
                        d: 1,
                        H: 0,
                        M: 0,
                        S: 0,
                        L: 0,
                        Z: null
                    }, i = d3_time_parse(d, template, string, 0);
                    if (i != string.length) return null;
                    if ("p" in d) d.H = d.H % 12 + d.p * 12;
                    var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                    if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
                        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
                        date.setFullYear(d.y, 0, 1);
                        date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                    } else date.setFullYear(d.y, d.m, d.d);
                    date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                    return localZ ? date._ : date;
                };
                format.toString = function() {
                    return template;
                };
                return format;
            }
            function d3_time_parse(date, template, string, j) {
                var c, p, t, i = 0, n = template.length, m = string.length;
                while (i < n) {
                    if (j >= m) return -1;
                    c = template.charCodeAt(i++);
                    if (c === 37) {
                        t = template.charAt(i++);
                        p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                        if (!p || (j = p(date, string, j)) < 0) return -1;
                    } else if (c != string.charCodeAt(j++)) {
                        return -1;
                    }
                }
                return j;
            }
            d3_time_format.utc = function(template) {
                var local = d3_time_format(template);
                function format(date) {
                    try {
                        d3_date = d3_date_utc;
                        var utc = new d3_date();
                        utc._ = date;
                        return local(utc);
                    } finally {
                        d3_date = Date;
                    }
                }
                format.parse = function(string) {
                    try {
                        d3_date = d3_date_utc;
                        var date = local.parse(string);
                        return date && date._;
                    } finally {
                        d3_date = Date;
                    }
                };
                format.toString = local.toString;
                return format;
            };
            d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
            var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
            locale_periods.forEach(function(p, i) {
                d3_time_periodLookup.set(p.toLowerCase(), i);
            });
            var d3_time_formats = {
                a: function(d) {
                    return locale_shortDays[d.getDay()];
                },
                A: function(d) {
                    return locale_days[d.getDay()];
                },
                b: function(d) {
                    return locale_shortMonths[d.getMonth()];
                },
                B: function(d) {
                    return locale_months[d.getMonth()];
                },
                c: d3_time_format(locale_dateTime),
                d: function(d, p) {
                    return d3_time_formatPad(d.getDate(), p, 2);
                },
                e: function(d, p) {
                    return d3_time_formatPad(d.getDate(), p, 2);
                },
                H: function(d, p) {
                    return d3_time_formatPad(d.getHours(), p, 2);
                },
                I: function(d, p) {
                    return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
                },
                j: function(d, p) {
                    return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
                },
                L: function(d, p) {
                    return d3_time_formatPad(d.getMilliseconds(), p, 3);
                },
                m: function(d, p) {
                    return d3_time_formatPad(d.getMonth() + 1, p, 2);
                },
                M: function(d, p) {
                    return d3_time_formatPad(d.getMinutes(), p, 2);
                },
                p: function(d) {
                    return locale_periods[+(d.getHours() >= 12)];
                },
                S: function(d, p) {
                    return d3_time_formatPad(d.getSeconds(), p, 2);
                },
                U: function(d, p) {
                    return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
                },
                w: function(d) {
                    return d.getDay();
                },
                W: function(d, p) {
                    return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
                },
                x: d3_time_format(locale_date),
                X: d3_time_format(locale_time),
                y: function(d, p) {
                    return d3_time_formatPad(d.getFullYear() % 100, p, 2);
                },
                Y: function(d, p) {
                    return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
                },
                Z: d3_time_zone,
                "%": function() {
                    return "%";
                }
            };
            var d3_time_parsers = {
                a: d3_time_parseWeekdayAbbrev,
                A: d3_time_parseWeekday,
                b: d3_time_parseMonthAbbrev,
                B: d3_time_parseMonth,
                c: d3_time_parseLocaleFull,
                d: d3_time_parseDay,
                e: d3_time_parseDay,
                H: d3_time_parseHour24,
                I: d3_time_parseHour24,
                j: d3_time_parseDayOfYear,
                L: d3_time_parseMilliseconds,
                m: d3_time_parseMonthNumber,
                M: d3_time_parseMinutes,
                p: d3_time_parseAmPm,
                S: d3_time_parseSeconds,
                U: d3_time_parseWeekNumberSunday,
                w: d3_time_parseWeekdayNumber,
                W: d3_time_parseWeekNumberMonday,
                x: d3_time_parseLocaleDate,
                X: d3_time_parseLocaleTime,
                y: d3_time_parseYear,
                Y: d3_time_parseFullYear,
                Z: d3_time_parseZone,
                "%": d3_time_parseLiteralPercent
            };
            function d3_time_parseWeekdayAbbrev(date, string, i) {
                d3_time_dayAbbrevRe.lastIndex = 0;
                var n = d3_time_dayAbbrevRe.exec(string.slice(i));
                return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
            }
            function d3_time_parseWeekday(date, string, i) {
                d3_time_dayRe.lastIndex = 0;
                var n = d3_time_dayRe.exec(string.slice(i));
                return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
            }
            function d3_time_parseMonthAbbrev(date, string, i) {
                d3_time_monthAbbrevRe.lastIndex = 0;
                var n = d3_time_monthAbbrevRe.exec(string.slice(i));
                return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
            }
            function d3_time_parseMonth(date, string, i) {
                d3_time_monthRe.lastIndex = 0;
                var n = d3_time_monthRe.exec(string.slice(i));
                return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
            }
            function d3_time_parseLocaleFull(date, string, i) {
                return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
            }
            function d3_time_parseLocaleDate(date, string, i) {
                return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
            }
            function d3_time_parseLocaleTime(date, string, i) {
                return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
            }
            function d3_time_parseAmPm(date, string, i) {
                var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
                return n == null ? -1 : (date.p = n, i);
            }
            return d3_time_format;
        }
        var d3_time_formatPads = {
            "-": "",
            _: " ",
            "0": "0"
        }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
        function d3_time_formatPad(value, fill, width) {
            var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
            return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
        }
        function d3_time_formatRe(names) {
            return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
        }
        function d3_time_formatLookup(names) {
            var map = new d3_Map(), i = -1, n = names.length;
            while (++i < n) map.set(names[i].toLowerCase(), i);
            return map;
        }
        function d3_time_parseWeekdayNumber(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 1));
            return n ? (date.w = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseWeekNumberSunday(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i));
            return n ? (date.U = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseWeekNumberMonday(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i));
            return n ? (date.W = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseFullYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 4));
            return n ? (date.y = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
        }
        function d3_time_parseZone(date, string, i) {
            return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string,
            i + 5) : -1;
        }
        function d3_time_expandYear(d) {
            return d + (d > 68 ? 1900 : 2e3);
        }
        function d3_time_parseMonthNumber(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
        }
        function d3_time_parseDay(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.d = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseDayOfYear(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 3));
            return n ? (date.j = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseHour24(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.H = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseMinutes(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.M = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseSeconds(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 2));
            return n ? (date.S = +n[0], i + n[0].length) : -1;
        }
        function d3_time_parseMilliseconds(date, string, i) {
            d3_time_numberRe.lastIndex = 0;
            var n = d3_time_numberRe.exec(string.slice(i, i + 3));
            return n ? (date.L = +n[0], i + n[0].length) : -1;
        }
        function d3_time_zone(d) {
            var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
            return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
        }
        function d3_time_parseLiteralPercent(date, string, i) {
            d3_time_percentRe.lastIndex = 0;
            var n = d3_time_percentRe.exec(string.slice(i, i + 1));
            return n ? i + n[0].length : -1;
        }
        function d3_time_formatMulti(formats) {
            var n = formats.length, i = -1;
            while (++i < n) formats[i][0] = this(formats[i][0]);
            return function(date) {
                var i = 0, f = formats[i];
                while (!f[1](date)) f = formats[++i];
                return f[0](date);
            };
        }
        d3.locale = function(locale) {
            return {
                numberFormat: d3_locale_numberFormat(locale),
                timeFormat: d3_locale_timeFormat(locale)
            };
        };
        var d3_locale_enUS = d3.locale({
            decimal: ".",
            thousands: ",",
            grouping: [ 3 ],
            currency: [ "$", "" ],
            dateTime: "%a %b %e %X %Y",
            date: "%m/%d/%Y",
            time: "%H:%M:%S",
            periods: [ "AM", "PM" ],
            days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
        });
        d3.format = d3_locale_enUS.numberFormat;
        d3.geo = {};
        function d3_adder() {}
        d3_adder.prototype = {
            s: 0,
            t: 0,
            add: function(y) {
                d3_adderSum(y, this.t, d3_adderTemp);
                d3_adderSum(d3_adderTemp.s, this.s, this);
                if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
            },
            reset: function() {
                this.s = this.t = 0;
            },
            valueOf: function() {
                return this.s;
            }
        };
        var d3_adderTemp = new d3_adder();
        function d3_adderSum(a, b, o) {
            var x = o.s = a + b, bv = x - a, av = x - bv;
            o.t = a - av + (b - bv);
        }
        d3.geo.stream = function(object, listener) {
            if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
                d3_geo_streamObjectType[object.type](object, listener);
            } else {
                d3_geo_streamGeometry(object, listener);
            }
        };
        function d3_geo_streamGeometry(geometry, listener) {
            if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
                d3_geo_streamGeometryType[geometry.type](geometry, listener);
            }
        }
        var d3_geo_streamObjectType = {
            Feature: function(feature, listener) {
                d3_geo_streamGeometry(feature.geometry, listener);
            },
            FeatureCollection: function(object, listener) {
                var features = object.features, i = -1, n = features.length;
                while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
            }
        };
        var d3_geo_streamGeometryType = {
            Sphere: function(object, listener) {
                listener.sphere();
            },
            Point: function(object, listener) {
                object = object.coordinates;
                listener.point(object[0], object[1], object[2]);
            },
            MultiPoint: function(object, listener) {
                var coordinates = object.coordinates, i = -1, n = coordinates.length;
                while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
            },
            LineString: function(object, listener) {
                d3_geo_streamLine(object.coordinates, listener, 0);
            },
            MultiLineString: function(object, listener) {
                var coordinates = object.coordinates, i = -1, n = coordinates.length;
                while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
            },
            Polygon: function(object, listener) {
                d3_geo_streamPolygon(object.coordinates, listener);
            },
            MultiPolygon: function(object, listener) {
                var coordinates = object.coordinates, i = -1, n = coordinates.length;
                while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
            },
            GeometryCollection: function(object, listener) {
                var geometries = object.geometries, i = -1, n = geometries.length;
                while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
            }
        };
        function d3_geo_streamLine(coordinates, listener, closed) {
            var i = -1, n = coordinates.length - closed, coordinate;
            listener.lineStart();
            while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
            listener.lineEnd();
        }
        function d3_geo_streamPolygon(coordinates, listener) {
            var i = -1, n = coordinates.length;
            listener.polygonStart();
            while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
            listener.polygonEnd();
        }
        d3.geo.area = function(object) {
            d3_geo_areaSum = 0;
            d3.geo.stream(object, d3_geo_area);
            return d3_geo_areaSum;
        };
        var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
        var d3_geo_area = {
            sphere: function() {
                d3_geo_areaSum += 4 * π;
            },
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
                d3_geo_areaRingSum.reset();
                d3_geo_area.lineStart = d3_geo_areaRingStart;
            },
            polygonEnd: function() {
                var area = 2 * d3_geo_areaRingSum;
                d3_geo_areaSum += area < 0 ? 4 * π + area : area;
                d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
            }
        };
        function d3_geo_areaRingStart() {
            var λ00, φ00, λ0, cosφ0, sinφ0;
            d3_geo_area.point = function(λ, φ) {
                d3_geo_area.point = nextPoint;
                λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4),
                    sinφ0 = Math.sin(φ);
            };
            function nextPoint(λ, φ) {
                λ *= d3_radians;
                φ = φ * d3_radians / 2 + π / 4;
                var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
                d3_geo_areaRingSum.add(Math.atan2(v, u));
                λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
            }
            d3_geo_area.lineEnd = function() {
                nextPoint(λ00, φ00);
            };
        }
        function d3_geo_cartesian(spherical) {
            var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
            return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
        }
        function d3_geo_cartesianDot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }
        function d3_geo_cartesianCross(a, b) {
            return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
        }
        function d3_geo_cartesianAdd(a, b) {
            a[0] += b[0];
            a[1] += b[1];
            a[2] += b[2];
        }
        function d3_geo_cartesianScale(vector, k) {
            return [ vector[0] * k, vector[1] * k, vector[2] * k ];
        }
        function d3_geo_cartesianNormalize(d) {
            var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
            d[0] /= l;
            d[1] /= l;
            d[2] /= l;
        }
        function d3_geo_spherical(cartesian) {
            return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
        }
        function d3_geo_sphericalEqual(a, b) {
            return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
        }
        d3.geo.bounds = function() {
            var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
            var bound = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    bound.point = ringPoint;
                    bound.lineStart = ringStart;
                    bound.lineEnd = ringEnd;
                    dλSum = 0;
                    d3_geo_area.polygonStart();
                },
                polygonEnd: function() {
                    d3_geo_area.polygonEnd();
                    bound.point = point;
                    bound.lineStart = lineStart;
                    bound.lineEnd = lineEnd;
                    if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
                    range[0] = λ0, range[1] = λ1;
                }
            };
            function point(λ, φ) {
                ranges.push(range = [ λ0 = λ, λ1 = λ ]);
                if (φ < φ0) φ0 = φ;
                if (φ > φ1) φ1 = φ;
            }
            function linePoint(λ, φ) {
                var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
                if (p0) {
                    var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
                    d3_geo_cartesianNormalize(inflection);
                    inflection = d3_geo_spherical(inflection);
                    var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                    if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                        var φi = inflection[1] * d3_degrees;
                        if (φi > φ1) φ1 = φi;
                    } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                        var φi = -inflection[1] * d3_degrees;
                        if (φi < φ0) φ0 = φi;
                    } else {
                        if (φ < φ0) φ0 = φ;
                        if (φ > φ1) φ1 = φ;
                    }
                    if (antimeridian) {
                        if (λ < λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                        }
                    } else {
                        if (λ1 >= λ0) {
                            if (λ < λ0) λ0 = λ;
                            if (λ > λ1) λ1 = λ;
                        } else {
                            if (λ > λ_) {
                                if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
                            } else {
                                if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
                            }
                        }
                    }
                } else {
                    point(λ, φ);
                }
                p0 = p, λ_ = λ;
            }
            function lineStart() {
                bound.point = linePoint;
            }
            function lineEnd() {
                range[0] = λ0, range[1] = λ1;
                bound.point = point;
                p0 = null;
            }
            function ringPoint(λ, φ) {
                if (p0) {
                    var dλ = λ - λ_;
                    dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
                } else λ__ = λ, φ__ = φ;
                d3_geo_area.point(λ, φ);
                linePoint(λ, φ);
            }
            function ringStart() {
                d3_geo_area.lineStart();
            }
            function ringEnd() {
                ringPoint(λ__, φ__);
                d3_geo_area.lineEnd();
                if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
                range[0] = λ0, range[1] = λ1;
                p0 = null;
            }
            function angle(λ0, λ1) {
                return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
            }
            function compareRanges(a, b) {
                return a[0] - b[0];
            }
            function withinRange(x, range) {
                return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
            }
            return function(feature) {
                φ1 = λ1 = -(λ0 = φ0 = Infinity);
                ranges = [];
                d3.geo.stream(feature, bound);
                var n = ranges.length;
                if (n) {
                    ranges.sort(compareRanges);
                    for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
                        b = ranges[i];
                        if (withinRange(b[0], a) || withinRange(b[1], a)) {
                            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                        } else {
                            merged.push(a = b);
                        }
                    }
                    var best = -Infinity, dλ;
                    for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                        b = merged[i];
                        if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
                    }
                }
                ranges = range = null;
                return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
            };
        }();
        d3.geo.centroid = function(object) {
            d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, d3_geo_centroid);
            var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
            if (m < ε2) {
                x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
                if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
                m = x * x + y * y + z * z;
                if (m < ε2) return [ NaN, NaN ];
            }
            return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
        };
        var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
        var d3_geo_centroid = {
            sphere: d3_noop,
            point: d3_geo_centroidPoint,
            lineStart: d3_geo_centroidLineStart,
            lineEnd: d3_geo_centroidLineEnd,
            polygonStart: function() {
                d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
            },
            polygonEnd: function() {
                d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
            }
        };
        function d3_geo_centroidPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
        }
        function d3_geo_centroidPointXYZ(x, y, z) {
            ++d3_geo_centroidW0;
            d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
            d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
            d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
        }
        function d3_geo_centroidLineStart() {
            var x0, y0, z0;
            d3_geo_centroid.point = function(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians);
                x0 = cosφ * Math.cos(λ);
                y0 = cosφ * Math.sin(λ);
                z0 = Math.sin(φ);
                d3_geo_centroid.point = nextPoint;
                d3_geo_centroidPointXYZ(x0, y0, z0);
            };
            function nextPoint(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
                d3_geo_centroidW1 += w;
                d3_geo_centroidX1 += w * (x0 + (x0 = x));
                d3_geo_centroidY1 += w * (y0 + (y0 = y));
                d3_geo_centroidZ1 += w * (z0 + (z0 = z));
                d3_geo_centroidPointXYZ(x0, y0, z0);
            }
        }
        function d3_geo_centroidLineEnd() {
            d3_geo_centroid.point = d3_geo_centroidPoint;
        }
        function d3_geo_centroidRingStart() {
            var λ00, φ00, x0, y0, z0;
            d3_geo_centroid.point = function(λ, φ) {
                λ00 = λ, φ00 = φ;
                d3_geo_centroid.point = nextPoint;
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians);
                x0 = cosφ * Math.cos(λ);
                y0 = cosφ * Math.sin(λ);
                z0 = Math.sin(φ);
                d3_geo_centroidPointXYZ(x0, y0, z0);
            };
            d3_geo_centroid.lineEnd = function() {
                nextPoint(λ00, φ00);
                d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
                d3_geo_centroid.point = d3_geo_centroidPoint;
            };
            function nextPoint(λ, φ) {
                λ *= d3_radians;
                var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
                d3_geo_centroidX2 += v * cx;
                d3_geo_centroidY2 += v * cy;
                d3_geo_centroidZ2 += v * cz;
                d3_geo_centroidW1 += w;
                d3_geo_centroidX1 += w * (x0 + (x0 = x));
                d3_geo_centroidY1 += w * (y0 + (y0 = y));
                d3_geo_centroidZ1 += w * (z0 + (z0 = z));
                d3_geo_centroidPointXYZ(x0, y0, z0);
            }
        }
        function d3_geo_compose(a, b) {
            function compose(x, y) {
                return x = a(x, y), b(x[0], x[1]);
            }
            if (a.invert && b.invert) compose.invert = function(x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
            return compose;
        }
        function d3_true() {
            return true;
        }
        function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
            var subject = [], clip = [];
            segments.forEach(function(segment) {
                if ((n = segment.length - 1) <= 0) return;
                var n, p0 = segment[0], p1 = segment[n];
                if (d3_geo_sphericalEqual(p0, p1)) {
                    listener.lineStart();
                    for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
                    listener.lineEnd();
                    return;
                }
                var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
                a.o = b;
                subject.push(a);
                clip.push(b);
                a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
                b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
                a.o = b;
                subject.push(a);
                clip.push(b);
            });
            clip.sort(compare);
            d3_geo_clipPolygonLinkCircular(subject);
            d3_geo_clipPolygonLinkCircular(clip);
            if (!subject.length) return;
            for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
                clip[i].e = entry = !entry;
            }
            var start = subject[0], points, point;
            while (1) {
                var current = start, isSubject = true;
                while (current.v) if ((current = current.n) === start) return;
                points = current.z;
                listener.lineStart();
                do {
                    current.v = current.o.v = true;
                    if (current.e) {
                        if (isSubject) {
                            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
                        } else {
                            interpolate(current.x, current.n.x, 1, listener);
                        }
                        current = current.n;
                    } else {
                        if (isSubject) {
                            points = current.p.z;
                            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
                        } else {
                            interpolate(current.x, current.p.x, -1, listener);
                        }
                        current = current.p;
                    }
                    current = current.o;
                    points = current.z;
                    isSubject = !isSubject;
                } while (!current.v);
                listener.lineEnd();
            }
        }
        function d3_geo_clipPolygonLinkCircular(array) {
            if (!(n = array.length)) return;
            var n, i = 0, a = array[0], b;
            while (++i < n) {
                a.n = b = array[i];
                b.p = a;
                a = b;
            }
            a.n = b = array[0];
            b.p = a;
        }
        function d3_geo_clipPolygonIntersection(point, points, other, entry) {
            this.x = point;
            this.z = points;
            this.o = other;
            this.e = entry;
            this.v = false;
            this.n = this.p = null;
        }
        function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
            return function(rotate, listener) {
                var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
                var clip = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        clip.point = pointRing;
                        clip.lineStart = ringStart;
                        clip.lineEnd = ringEnd;
                        segments = [];
                        polygon = [];
                    },
                    polygonEnd: function() {
                        clip.point = point;
                        clip.lineStart = lineStart;
                        clip.lineEnd = lineEnd;
                        segments = d3.merge(segments);
                        var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                        if (segments.length) {
                            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                        } else if (clipStartInside) {
                            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
                        segments = polygon = null;
                    },
                    sphere: function() {
                        listener.polygonStart();
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                        listener.polygonEnd();
                    }
                };
                function point(λ, φ) {
                    var point = rotate(λ, φ);
                    if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
                }
                function pointLine(λ, φ) {
                    var point = rotate(λ, φ);
                    line.point(point[0], point[1]);
                }
                function lineStart() {
                    clip.point = pointLine;
                    line.lineStart();
                }
                function lineEnd() {
                    clip.point = point;
                    line.lineEnd();
                }
                var segments;
                var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
                function pointRing(λ, φ) {
                    ring.push([ λ, φ ]);
                    var point = rotate(λ, φ);
                    ringListener.point(point[0], point[1]);
                }
                function ringStart() {
                    ringListener.lineStart();
                    ring = [];
                }
                function ringEnd() {
                    pointRing(ring[0][0], ring[0][1]);
                    ringListener.lineEnd();
                    var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                    ring.pop();
                    polygon.push(ring);
                    ring = null;
                    if (!n) return;
                    if (clean & 1) {
                        segment = ringSegments[0];
                        var n = segment.length - 1, i = -1, point;
                        if (n > 0) {
                            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
                            listener.lineStart();
                            while (++i < n) listener.point((point = segment[i])[0], point[1]);
                            listener.lineEnd();
                        }
                        return;
                    }
                    if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                    segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
                }
                return clip;
            };
        }
        function d3_geo_clipSegmentLength1(segment) {
            return segment.length > 1;
        }
        function d3_geo_clipBufferListener() {
            var lines = [], line;
            return {
                lineStart: function() {
                    lines.push(line = []);
                },
                point: function(λ, φ) {
                    line.push([ λ, φ ]);
                },
                lineEnd: d3_noop,
                buffer: function() {
                    var buffer = lines;
                    lines = [];
                    line = null;
                    return buffer;
                },
                rejoin: function() {
                    if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
                }
            };
        }
        function d3_geo_clipSort(a, b) {
            return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
        }
        var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
        function d3_geo_clipAntimeridianLine(listener) {
            var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
            return {
                lineStart: function() {
                    listener.lineStart();
                    clean = 1;
                },
                point: function(λ1, φ1) {
                    var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                    if (abs(dλ - π) < ε) {
                        listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                        listener.point(sλ0, φ0);
                        listener.lineEnd();
                        listener.lineStart();
                        listener.point(sλ1, φ0);
                        listener.point(λ1, φ0);
                        clean = 0;
                    } else if (sλ0 !== sλ1 && dλ >= π) {
                        if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
                        if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
                        φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                        listener.point(sλ0, φ0);
                        listener.lineEnd();
                        listener.lineStart();
                        listener.point(sλ1, φ0);
                        clean = 0;
                    }
                    listener.point(λ0 = λ1, φ0 = φ1);
                    sλ0 = sλ1;
                },
                lineEnd: function() {
                    listener.lineEnd();
                    λ0 = φ0 = NaN;
                },
                clean: function() {
                    return 2 - clean;
                }
            };
        }
        function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
            var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
            return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
        }
        function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
            var φ;
            if (from == null) {
                φ = direction * halfπ;
                listener.point(-π, φ);
                listener.point(0, φ);
                listener.point(π, φ);
                listener.point(π, 0);
                listener.point(π, -φ);
                listener.point(0, -φ);
                listener.point(-π, -φ);
                listener.point(-π, 0);
                listener.point(-π, φ);
            } else if (abs(from[0] - to[0]) > ε) {
                var s = from[0] < to[0] ? π : -π;
                φ = direction * s / 2;
                listener.point(-s, φ);
                listener.point(0, φ);
                listener.point(s, φ);
            } else {
                listener.point(to[0], to[1]);
            }
        }
        function d3_geo_pointInPolygon(point, polygon) {
            var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
            d3_geo_areaRingSum.reset();
            for (var i = 0, n = polygon.length; i < n; ++i) {
                var ring = polygon[i], m = ring.length;
                if (!m) continue;
                var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
                while (true) {
                    if (j === m) j = 0;
                    point = ring[j];
                    var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                    d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                    polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                    if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                        var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                        d3_geo_cartesianNormalize(arc);
                        var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                        d3_geo_cartesianNormalize(intersection);
                        var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                        if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                        }
                    }
                    if (!j++) break;
                    λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
                }
            }
            return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
        }
        function d3_geo_clipCircle(radius) {
            var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
            return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
            function visible(λ, φ) {
                return Math.cos(λ) * Math.cos(φ) > cr;
            }
            function clipLine(listener) {
                var point0, c0, v0, v00, clean;
                return {
                    lineStart: function() {
                        v00 = v0 = false;
                        clean = 1;
                    },
                    point: function(λ, φ) {
                        var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                        if (!point0 && (v00 = v0 = v)) listener.lineStart();
                        if (v !== v0) {
                            point2 = intersect(point0, point1);
                            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                                point1[0] += ε;
                                point1[1] += ε;
                                v = visible(point1[0], point1[1]);
                            }
                        }
                        if (v !== v0) {
                            clean = 0;
                            if (v) {
                                listener.lineStart();
                                point2 = intersect(point1, point0);
                                listener.point(point2[0], point2[1]);
                            } else {
                                point2 = intersect(point0, point1);
                                listener.point(point2[0], point2[1]);
                                listener.lineEnd();
                            }
                            point0 = point2;
                        } else if (notHemisphere && point0 && smallRadius ^ v) {
                            var t;
                            if (!(c & c0) && (t = intersect(point1, point0, true))) {
                                clean = 0;
                                if (smallRadius) {
                                    listener.lineStart();
                                    listener.point(t[0][0], t[0][1]);
                                    listener.point(t[1][0], t[1][1]);
                                    listener.lineEnd();
                                } else {
                                    listener.point(t[1][0], t[1][1]);
                                    listener.lineEnd();
                                    listener.lineStart();
                                    listener.point(t[0][0], t[0][1]);
                                }
                            }
                        }
                        if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                            listener.point(point1[0], point1[1]);
                        }
                        point0 = point1, v0 = v, c0 = c;
                    },
                    lineEnd: function() {
                        if (v0) listener.lineEnd();
                        point0 = null;
                    },
                    clean: function() {
                        return clean | (v00 && v0) << 1;
                    }
                };
            }
            function intersect(a, b, two) {
                var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
                var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
                if (!determinant) return !two && a;
                var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
                d3_geo_cartesianAdd(A, B);
                var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
                if (t2 < 0) return;
                var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
                d3_geo_cartesianAdd(q, A);
                q = d3_geo_spherical(q);
                if (!two) return q;
                var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
                if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
                var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
                if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
                if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                    var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                    d3_geo_cartesianAdd(q1, A);
                    return [ q, d3_geo_spherical(q1) ];
                }
            }
            function code(λ, φ) {
                var r = smallRadius ? radius : π - radius, code = 0;
                if (λ < -r) code |= 1; else if (λ > r) code |= 2;
                if (φ < -r) code |= 4; else if (φ > r) code |= 8;
                return code;
            }
        }
        function d3_geom_clipLine(x0, y0, x1, y1) {
            return function(line) {
                var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
                r = x0 - ax;
                if (!dx && r > 0) return;
                r /= dx;
                if (dx < 0) {
                    if (r < t0) return;
                    if (r < t1) t1 = r;
                } else if (dx > 0) {
                    if (r > t1) return;
                    if (r > t0) t0 = r;
                }
                r = x1 - ax;
                if (!dx && r < 0) return;
                r /= dx;
                if (dx < 0) {
                    if (r > t1) return;
                    if (r > t0) t0 = r;
                } else if (dx > 0) {
                    if (r < t0) return;
                    if (r < t1) t1 = r;
                }
                r = y0 - ay;
                if (!dy && r > 0) return;
                r /= dy;
                if (dy < 0) {
                    if (r < t0) return;
                    if (r < t1) t1 = r;
                } else if (dy > 0) {
                    if (r > t1) return;
                    if (r > t0) t0 = r;
                }
                r = y1 - ay;
                if (!dy && r < 0) return;
                r /= dy;
                if (dy < 0) {
                    if (r > t1) return;
                    if (r > t0) t0 = r;
                } else if (dy > 0) {
                    if (r < t0) return;
                    if (r < t1) t1 = r;
                }
                if (t0 > 0) line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
                if (t1 < 1) line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
                return line;
            };
        }
        var d3_geo_clipExtentMAX = 1e9;
        d3.geo.clipExtent = function() {
            var x0, y0, x1, y1, stream, clip, clipExtent = {
                stream: function(output) {
                    if (stream) stream.valid = false;
                    stream = clip(output);
                    stream.valid = true;
                    return stream;
                },
                extent: function(_) {
                    if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                    clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                    if (stream) stream.valid = false, stream = null;
                    return clipExtent;
                }
            };
            return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
        };
        function d3_geo_clipExtent(x0, y0, x1, y1) {
            return function(listener) {
                var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
                var clip = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        listener = bufferListener;
                        segments = [];
                        polygon = [];
                        clean = true;
                    },
                    polygonEnd: function() {
                        listener = listener_;
                        segments = d3.merge(segments);
                        var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
                        if (inside || visible) {
                            listener.polygonStart();
                            if (inside) {
                                listener.lineStart();
                                interpolate(null, null, 1, listener);
                                listener.lineEnd();
                            }
                            if (visible) {
                                d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                            }
                            listener.polygonEnd();
                        }
                        segments = polygon = ring = null;
                    }
                };
                function insidePolygon(p) {
                    var wn = 0, n = polygon.length, y = p[1];
                    for (var i = 0; i < n; ++i) {
                        for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                            b = v[j];
                            if (a[1] <= y) {
                                if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
                            } else {
                                if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
                            }
                            a = b;
                        }
                    }
                    return wn !== 0;
                }
                function interpolate(from, to, direction, listener) {
                    var a = 0, a1 = 0;
                    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                        do {
                            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                        } while ((a = (a + direction + 4) % 4) !== a1);
                    } else {
                        listener.point(to[0], to[1]);
                    }
                }
                function pointVisible(x, y) {
                    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
                }
                function point(x, y) {
                    if (pointVisible(x, y)) listener.point(x, y);
                }
                var x__, y__, v__, x_, y_, v_, first, clean;
                function lineStart() {
                    clip.point = linePoint;
                    if (polygon) polygon.push(ring = []);
                    first = true;
                    v_ = false;
                    x_ = y_ = NaN;
                }
                function lineEnd() {
                    if (segments) {
                        linePoint(x__, y__);
                        if (v__ && v_) bufferListener.rejoin();
                        segments.push(bufferListener.buffer());
                    }
                    clip.point = point;
                    if (v_) listener.lineEnd();
                }
                function linePoint(x, y) {
                    x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                    y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                    var v = pointVisible(x, y);
                    if (polygon) ring.push([ x, y ]);
                    if (first) {
                        x__ = x, y__ = y, v__ = v;
                        first = false;
                        if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                        }
                    } else {
                        if (v && v_) listener.point(x, y); else {
                            var l = {
                                a: {
                                    x: x_,
                                    y: y_
                                },
                                b: {
                                    x: x,
                                    y: y
                                }
                            };
                            if (clipLine(l)) {
                                if (!v_) {
                                    listener.lineStart();
                                    listener.point(l.a.x, l.a.y);
                                }
                                listener.point(l.b.x, l.b.y);
                                if (!v) listener.lineEnd();
                                clean = false;
                            } else if (v) {
                                listener.lineStart();
                                listener.point(x, y);
                                clean = false;
                            }
                        }
                    }
                    x_ = x, y_ = y, v_ = v;
                }
                return clip;
            };
            function corner(p, direction) {
                return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
            }
            function compare(a, b) {
                return comparePoints(a.x, b.x);
            }
            function comparePoints(a, b) {
                var ca = corner(a, 1), cb = corner(b, 1);
                return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
            }
        }
        function d3_geo_conic(projectAt) {
            var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
            p.parallels = function(_) {
                if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
                return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
            };
            return p;
        }
        function d3_geo_conicEqualArea(φ0, φ1) {
            var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
            function forward(λ, φ) {
                var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
                return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
            }
            forward.invert = function(x, y) {
                var ρ0_y = ρ0 - y;
                return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
            };
            return forward;
        }
        (d3.geo.conicEqualArea = function() {
            return d3_geo_conic(d3_geo_conicEqualArea);
        }).raw = d3_geo_conicEqualArea;
        d3.geo.albers = function() {
            return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
        };
        d3.geo.albersUsa = function() {
            var lower48 = d3.geo.albers();
            var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
            var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
            var point, pointStream = {
                point: function(x, y) {
                    point = [ x, y ];
                }
            }, lower48Point, alaskaPoint, hawaiiPoint;
            function albersUsa(coordinates) {
                var x = coordinates[0], y = coordinates[1];
                point = null;
                (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
                return point;
            }
            albersUsa.invert = function(coordinates) {
                var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
                return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
            };
            albersUsa.stream = function(stream) {
                var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
                return {
                    point: function(x, y) {
                        lower48Stream.point(x, y);
                        alaskaStream.point(x, y);
                        hawaiiStream.point(x, y);
                    },
                    sphere: function() {
                        lower48Stream.sphere();
                        alaskaStream.sphere();
                        hawaiiStream.sphere();
                    },
                    lineStart: function() {
                        lower48Stream.lineStart();
                        alaskaStream.lineStart();
                        hawaiiStream.lineStart();
                    },
                    lineEnd: function() {
                        lower48Stream.lineEnd();
                        alaskaStream.lineEnd();
                        hawaiiStream.lineEnd();
                    },
                    polygonStart: function() {
                        lower48Stream.polygonStart();
                        alaskaStream.polygonStart();
                        hawaiiStream.polygonStart();
                    },
                    polygonEnd: function() {
                        lower48Stream.polygonEnd();
                        alaskaStream.polygonEnd();
                        hawaiiStream.polygonEnd();
                    }
                };
            };
            albersUsa.precision = function(_) {
                if (!arguments.length) return lower48.precision();
                lower48.precision(_);
                alaska.precision(_);
                hawaii.precision(_);
                return albersUsa;
            };
            albersUsa.scale = function(_) {
                if (!arguments.length) return lower48.scale();
                lower48.scale(_);
                alaska.scale(_ * .35);
                hawaii.scale(_);
                return albersUsa.translate(lower48.translate());
            };
            albersUsa.translate = function(_) {
                if (!arguments.length) return lower48.translate();
                var k = lower48.scale(), x = +_[0], y = +_[1];
                lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
                alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
                hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
                return albersUsa;
            };
            return albersUsa.scale(1070);
        };
        var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function() {
                d3_geo_pathAreaPolygon = 0;
                d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function() {
                d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
                d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
        };
        function d3_geo_pathAreaRingStart() {
            var x00, y00, x0, y0;
            d3_geo_pathArea.point = function(x, y) {
                d3_geo_pathArea.point = nextPoint;
                x00 = x0 = x, y00 = y0 = y;
            };
            function nextPoint(x, y) {
                d3_geo_pathAreaPolygon += y0 * x - x0 * y;
                x0 = x, y0 = y;
            }
            d3_geo_pathArea.lineEnd = function() {
                nextPoint(x00, y00);
            };
        }
        var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
        var d3_geo_pathBounds = {
            point: d3_geo_pathBoundsPoint,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: d3_noop,
            polygonEnd: d3_noop
        };
        function d3_geo_pathBoundsPoint(x, y) {
            if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
            if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
            if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
            if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
        }
        function d3_geo_pathBuffer() {
            var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
            var stream = {
                point: point,
                lineStart: function() {
                    stream.point = pointLineStart;
                },
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.lineEnd = lineEndPolygon;
                },
                polygonEnd: function() {
                    stream.lineEnd = lineEnd;
                    stream.point = point;
                },
                pointRadius: function(_) {
                    pointCircle = d3_geo_pathBufferCircle(_);
                    return stream;
                },
                result: function() {
                    if (buffer.length) {
                        var result = buffer.join("");
                        buffer = [];
                        return result;
                    }
                }
            };
            function point(x, y) {
                buffer.push("M", x, ",", y, pointCircle);
            }
            function pointLineStart(x, y) {
                buffer.push("M", x, ",", y);
                stream.point = pointLine;
            }
            function pointLine(x, y) {
                buffer.push("L", x, ",", y);
            }
            function lineEnd() {
                stream.point = point;
            }
            function lineEndPolygon() {
                buffer.push("Z");
            }
            return stream;
        }
        function d3_geo_pathBufferCircle(radius) {
            return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
        }
        var d3_geo_pathCentroid = {
            point: d3_geo_pathCentroidPoint,
            lineStart: d3_geo_pathCentroidLineStart,
            lineEnd: d3_geo_pathCentroidLineEnd,
            polygonStart: function() {
                d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
            },
            polygonEnd: function() {
                d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
                d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
                d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
            }
        };
        function d3_geo_pathCentroidPoint(x, y) {
            d3_geo_centroidX0 += x;
            d3_geo_centroidY0 += y;
            ++d3_geo_centroidZ0;
        }
        function d3_geo_pathCentroidLineStart() {
            var x0, y0;
            d3_geo_pathCentroid.point = function(x, y) {
                d3_geo_pathCentroid.point = nextPoint;
                d3_geo_pathCentroidPoint(x0 = x, y0 = y);
            };
            function nextPoint(x, y) {
                var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
                d3_geo_centroidX1 += z * (x0 + x) / 2;
                d3_geo_centroidY1 += z * (y0 + y) / 2;
                d3_geo_centroidZ1 += z;
                d3_geo_pathCentroidPoint(x0 = x, y0 = y);
            }
        }
        function d3_geo_pathCentroidLineEnd() {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
        }
        function d3_geo_pathCentroidRingStart() {
            var x00, y00, x0, y0;
            d3_geo_pathCentroid.point = function(x, y) {
                d3_geo_pathCentroid.point = nextPoint;
                d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
            };
            function nextPoint(x, y) {
                var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
                d3_geo_centroidX1 += z * (x0 + x) / 2;
                d3_geo_centroidY1 += z * (y0 + y) / 2;
                d3_geo_centroidZ1 += z;
                z = y0 * x - x0 * y;
                d3_geo_centroidX2 += z * (x0 + x);
                d3_geo_centroidY2 += z * (y0 + y);
                d3_geo_centroidZ2 += z * 3;
                d3_geo_pathCentroidPoint(x0 = x, y0 = y);
            }
            d3_geo_pathCentroid.lineEnd = function() {
                nextPoint(x00, y00);
            };
        }
        function d3_geo_pathContext(context) {
            var pointRadius = 4.5;
            var stream = {
                point: point,
                lineStart: function() {
                    stream.point = pointLineStart;
                },
                lineEnd: lineEnd,
                polygonStart: function() {
                    stream.lineEnd = lineEndPolygon;
                },
                polygonEnd: function() {
                    stream.lineEnd = lineEnd;
                    stream.point = point;
                },
                pointRadius: function(_) {
                    pointRadius = _;
                    return stream;
                },
                result: d3_noop
            };
            function point(x, y) {
                context.moveTo(x + pointRadius, y);
                context.arc(x, y, pointRadius, 0, τ);
            }
            function pointLineStart(x, y) {
                context.moveTo(x, y);
                stream.point = pointLine;
            }
            function pointLine(x, y) {
                context.lineTo(x, y);
            }
            function lineEnd() {
                stream.point = point;
            }
            function lineEndPolygon() {
                context.closePath();
            }
            return stream;
        }
        function d3_geo_resample(project) {
            var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
            function resample(stream) {
                return (maxDepth ? resampleRecursive : resampleNone)(stream);
            }
            function resampleNone(stream) {
                return d3_geo_transformPoint(stream, function(x, y) {
                    x = project(x, y);
                    stream.point(x[0], x[1]);
                });
            }
            function resampleRecursive(stream) {
                var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
                var resample = {
                    point: point,
                    lineStart: lineStart,
                    lineEnd: lineEnd,
                    polygonStart: function() {
                        stream.polygonStart();
                        resample.lineStart = ringStart;
                    },
                    polygonEnd: function() {
                        stream.polygonEnd();
                        resample.lineStart = lineStart;
                    }
                };
                function point(x, y) {
                    x = project(x, y);
                    stream.point(x[0], x[1]);
                }
                function lineStart() {
                    x0 = NaN;
                    resample.point = linePoint;
                    stream.lineStart();
                }
                function linePoint(λ, φ) {
                    var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                    stream.point(x0, y0);
                }
                function lineEnd() {
                    resample.point = point;
                    stream.lineEnd();
                }
                function ringStart() {
                    lineStart();
                    resample.point = ringPoint;
                    resample.lineEnd = ringEnd;
                }
                function ringPoint(λ, φ) {
                    linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                    resample.point = linePoint;
                }
                function ringEnd() {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                    resample.lineEnd = lineEnd;
                    lineEnd();
                }
                return resample;
            }
            function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
                var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
                if (d2 > 4 * δ2 && depth--) {
                    var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                    if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                        resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                        stream.point(x2, y2);
                        resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                    }
                }
            }
            resample.precision = function(_) {
                if (!arguments.length) return Math.sqrt(δ2);
                maxDepth = (δ2 = _ * _) > 0 && 16;
                return resample;
            };
            return resample;
        }
        d3.geo.path = function() {
            var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
            function path(object) {
                if (object) {
                    if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                    if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
                    d3.geo.stream(object, cacheStream);
                }
                return contextStream.result();
            }
            path.area = function(object) {
                d3_geo_pathAreaSum = 0;
                d3.geo.stream(object, projectStream(d3_geo_pathArea));
                return d3_geo_pathAreaSum;
            };
            path.centroid = function(object) {
                d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
                d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
                return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
            };
            path.bounds = function(object) {
                d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
                d3.geo.stream(object, projectStream(d3_geo_pathBounds));
                return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
            };
            path.projection = function(_) {
                if (!arguments.length) return projection;
                projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
                return reset();
            };
            path.context = function(_) {
                if (!arguments.length) return context;
                contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
                if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
                return reset();
            };
            path.pointRadius = function(_) {
                if (!arguments.length) return pointRadius;
                pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
                return path;
            };
            function reset() {
                cacheStream = null;
                return path;
            }
            return path.projection(d3.geo.albersUsa()).context(null);
        };
        function d3_geo_pathProjectStream(project) {
            var resample = d3_geo_resample(function(x, y) {
                return project([ x * d3_degrees, y * d3_degrees ]);
            });
            return function(stream) {
                return d3_geo_projectionRadians(resample(stream));
            };
        }
        d3.geo.transform = function(methods) {
            return {
                stream: function(stream) {
                    var transform = new d3_geo_transform(stream);
                    for (var k in methods) transform[k] = methods[k];
                    return transform;
                }
            };
        };
        function d3_geo_transform(stream) {
            this.stream = stream;
        }
        d3_geo_transform.prototype = {
            point: function(x, y) {
                this.stream.point(x, y);
            },
            sphere: function() {
                this.stream.sphere();
            },
            lineStart: function() {
                this.stream.lineStart();
            },
            lineEnd: function() {
                this.stream.lineEnd();
            },
            polygonStart: function() {
                this.stream.polygonStart();
            },
            polygonEnd: function() {
                this.stream.polygonEnd();
            }
        };
        function d3_geo_transformPoint(stream, point) {
            return {
                point: point,
                sphere: function() {
                    stream.sphere();
                },
                lineStart: function() {
                    stream.lineStart();
                },
                lineEnd: function() {
                    stream.lineEnd();
                },
                polygonStart: function() {
                    stream.polygonStart();
                },
                polygonEnd: function() {
                    stream.polygonEnd();
                }
            };
        }
        d3.geo.projection = d3_geo_projection;
        d3.geo.projectionMutator = d3_geo_projectionMutator;
        function d3_geo_projection(project) {
            return d3_geo_projectionMutator(function() {
                return project;
            })();
        }
        function d3_geo_projectionMutator(projectAt) {
            var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
                x = project(x, y);
                return [ x[0] * k + δx, δy - x[1] * k ];
            }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
            function projection(point) {
                point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
                return [ point[0] * k + δx, δy - point[1] * k ];
            }
            function invert(point) {
                point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
                return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
            }
            projection.stream = function(output) {
                if (stream) stream.valid = false;
                stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
                stream.valid = true;
                return stream;
            };
            projection.clipAngle = function(_) {
                if (!arguments.length) return clipAngle;
                preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
                return invalidate();
            };
            projection.clipExtent = function(_) {
                if (!arguments.length) return clipExtent;
                clipExtent = _;
                postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
                return invalidate();
            };
            projection.scale = function(_) {
                if (!arguments.length) return k;
                k = +_;
                return reset();
            };
            projection.translate = function(_) {
                if (!arguments.length) return [ x, y ];
                x = +_[0];
                y = +_[1];
                return reset();
            };
            projection.center = function(_) {
                if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
                λ = _[0] % 360 * d3_radians;
                φ = _[1] % 360 * d3_radians;
                return reset();
            };
            projection.rotate = function(_) {
                if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
                δλ = _[0] % 360 * d3_radians;
                δφ = _[1] % 360 * d3_radians;
                δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
                return reset();
            };
            d3.rebind(projection, projectResample, "precision");
            function reset() {
                projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
                var center = project(λ, φ);
                δx = x - center[0] * k;
                δy = y + center[1] * k;
                return invalidate();
            }
            function invalidate() {
                if (stream) stream.valid = false, stream = null;
                return projection;
            }
            return function() {
                project = projectAt.apply(this, arguments);
                projection.invert = project.invert && invert;
                return reset();
            };
        }
        function d3_geo_projectionRadians(stream) {
            return d3_geo_transformPoint(stream, function(x, y) {
                stream.point(x * d3_radians, y * d3_radians);
            });
        }
        function d3_geo_equirectangular(λ, φ) {
            return [ λ, φ ];
        }
        (d3.geo.equirectangular = function() {
            return d3_geo_projection(d3_geo_equirectangular);
        }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
        d3.geo.rotation = function(rotate) {
            rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
            function forward(coordinates) {
                coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
                return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
            }
            forward.invert = function(coordinates) {
                coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
                return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
            };
            return forward;
        };
        function d3_geo_identityRotation(λ, φ) {
            return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
        }
        d3_geo_identityRotation.invert = d3_geo_equirectangular;
        function d3_geo_rotation(δλ, δφ, δγ) {
            return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
        }
        function d3_geo_forwardRotationλ(δλ) {
            return function(λ, φ) {
                return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
            };
        }
        function d3_geo_rotationλ(δλ) {
            var rotation = d3_geo_forwardRotationλ(δλ);
            rotation.invert = d3_geo_forwardRotationλ(-δλ);
            return rotation;
        }
        function d3_geo_rotationφγ(δφ, δγ) {
            var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
            function rotation(λ, φ) {
                var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
                return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
            }
            rotation.invert = function(λ, φ) {
                var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
                return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
            };
            return rotation;
        }
        d3.geo.circle = function() {
            var origin = [ 0, 0 ], angle, precision = 6, interpolate;
            function circle() {
                var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
                interpolate(null, null, 1, {
                    point: function(x, y) {
                        ring.push(x = rotate(x, y));
                        x[0] *= d3_degrees, x[1] *= d3_degrees;
                    }
                });
                return {
                    type: "Polygon",
                    coordinates: [ ring ]
                };
            }
            circle.origin = function(x) {
                if (!arguments.length) return origin;
                origin = x;
                return circle;
            };
            circle.angle = function(x) {
                if (!arguments.length) return angle;
                interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
                return circle;
            };
            circle.precision = function(_) {
                if (!arguments.length) return precision;
                interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
                return circle;
            };
            return circle.angle(90);
        };
        function d3_geo_circleInterpolate(radius, precision) {
            var cr = Math.cos(radius), sr = Math.sin(radius);
            return function(from, to, direction, listener) {
                var step = direction * precision;
                if (from != null) {
                    from = d3_geo_circleAngle(cr, from);
                    to = d3_geo_circleAngle(cr, to);
                    if (direction > 0 ? from < to : from > to) from += direction * τ;
                } else {
                    from = radius + direction * τ;
                    to = radius - .5 * step;
                }
                for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                    listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
                }
            };
        }
        function d3_geo_circleAngle(cr, point) {
            var a = d3_geo_cartesian(point);
            a[0] -= cr;
            d3_geo_cartesianNormalize(a);
            var angle = d3_acos(-a[1]);
            return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
        }
        d3.geo.distance = function(a, b) {
            var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
            return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
        };
        d3.geo.graticule = function() {
            var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
            function graticule() {
                return {
                    type: "MultiLineString",
                    coordinates: lines()
                };
            }
            function lines() {
                return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
                    return abs(x % DX) > ε;
                }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
                    return abs(y % DY) > ε;
                }).map(y));
            }
            graticule.lines = function() {
                return lines().map(function(coordinates) {
                    return {
                        type: "LineString",
                        coordinates: coordinates
                    };
                });
            };
            graticule.outline = function() {
                return {
                    type: "Polygon",
                    coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
                };
            };
            graticule.extent = function(_) {
                if (!arguments.length) return graticule.minorExtent();
                return graticule.majorExtent(_).minorExtent(_);
            };
            graticule.majorExtent = function(_) {
                if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
                X0 = +_[0][0], X1 = +_[1][0];
                Y0 = +_[0][1], Y1 = +_[1][1];
                if (X0 > X1) _ = X0, X0 = X1, X1 = _;
                if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
                return graticule.precision(precision);
            };
            graticule.minorExtent = function(_) {
                if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
                x0 = +_[0][0], x1 = +_[1][0];
                y0 = +_[0][1], y1 = +_[1][1];
                if (x0 > x1) _ = x0, x0 = x1, x1 = _;
                if (y0 > y1) _ = y0, y0 = y1, y1 = _;
                return graticule.precision(precision);
            };
            graticule.step = function(_) {
                if (!arguments.length) return graticule.minorStep();
                return graticule.majorStep(_).minorStep(_);
            };
            graticule.majorStep = function(_) {
                if (!arguments.length) return [ DX, DY ];
                DX = +_[0], DY = +_[1];
                return graticule;
            };
            graticule.minorStep = function(_) {
                if (!arguments.length) return [ dx, dy ];
                dx = +_[0], dy = +_[1];
                return graticule;
            };
            graticule.precision = function(_) {
                if (!arguments.length) return precision;
                precision = +_;
                x = d3_geo_graticuleX(y0, y1, 90);
                y = d3_geo_graticuleY(x0, x1, precision);
                X = d3_geo_graticuleX(Y0, Y1, 90);
                Y = d3_geo_graticuleY(X0, X1, precision);
                return graticule;
            };
            return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
        };
        function d3_geo_graticuleX(y0, y1, dy) {
            var y = d3.range(y0, y1 - ε, dy).concat(y1);
            return function(x) {
                return y.map(function(y) {
                    return [ x, y ];
                });
            };
        }
        function d3_geo_graticuleY(x0, x1, dx) {
            var x = d3.range(x0, x1 - ε, dx).concat(x1);
            return function(y) {
                return x.map(function(x) {
                    return [ x, y ];
                });
            };
        }
        function d3_source(d) {
            return d.source;
        }
        function d3_target(d) {
            return d.target;
        }
        d3.geo.greatArc = function() {
            var source = d3_source, source_, target = d3_target, target_;
            function greatArc() {
                return {
                    type: "LineString",
                    coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
                };
            }
            greatArc.distance = function() {
                return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
            };
            greatArc.source = function(_) {
                if (!arguments.length) return source;
                source = _, source_ = typeof _ === "function" ? null : _;
                return greatArc;
            };
            greatArc.target = function(_) {
                if (!arguments.length) return target;
                target = _, target_ = typeof _ === "function" ? null : _;
                return greatArc;
            };
            greatArc.precision = function() {
                return arguments.length ? greatArc : 0;
            };
            return greatArc;
        };
        d3.geo.interpolate = function(source, target) {
            return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
        };
        function d3_geo_interpolate(x0, y0, x1, y1) {
            var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
            var interpolate = d ? function(t) {
                var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
                return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
            } : function() {
                return [ x0 * d3_degrees, y0 * d3_degrees ];
            };
            interpolate.distance = d;
            return interpolate;
        }
        d3.geo.length = function(object) {
            d3_geo_lengthSum = 0;
            d3.geo.stream(object, d3_geo_length);
            return d3_geo_lengthSum;
        };
        var d3_geo_lengthSum;
        var d3_geo_length = {
            sphere: d3_noop,
            point: d3_noop,
            lineStart: d3_geo_lengthLineStart,
            lineEnd: d3_noop,
            polygonStart: d3_noop,
            polygonEnd: d3_noop
        };
        function d3_geo_lengthLineStart() {
            var λ0, sinφ0, cosφ0;
            d3_geo_length.point = function(λ, φ) {
                λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
                d3_geo_length.point = nextPoint;
            };
            d3_geo_length.lineEnd = function() {
                d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
            };
            function nextPoint(λ, φ) {
                var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
                d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
                λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
            }
        }
        function d3_geo_azimuthal(scale, angle) {
            function azimuthal(λ, φ) {
                var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
                return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
            }
            azimuthal.invert = function(x, y) {
                var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
                return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
            };
            return azimuthal;
        }
        var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
            return Math.sqrt(2 / (1 + cosλcosφ));
        }, function(ρ) {
            return 2 * Math.asin(ρ / 2);
        });
        (d3.geo.azimuthalEqualArea = function() {
            return d3_geo_projection(d3_geo_azimuthalEqualArea);
        }).raw = d3_geo_azimuthalEqualArea;
        var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
            var c = Math.acos(cosλcosφ);
            return c && c / Math.sin(c);
        }, d3_identity);
        (d3.geo.azimuthalEquidistant = function() {
            return d3_geo_projection(d3_geo_azimuthalEquidistant);
        }).raw = d3_geo_azimuthalEquidistant;
        function d3_geo_conicConformal(φ0, φ1) {
            var cosφ0 = Math.cos(φ0), t = function(φ) {
                return Math.tan(π / 4 + φ / 2);
            }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
            if (!n) return d3_geo_mercator;
            function forward(λ, φ) {
                if (F > 0) {
                    if (φ < -halfπ + ε) φ = -halfπ + ε;
                } else {
                    if (φ > halfπ - ε) φ = halfπ - ε;
                }
                var ρ = F / Math.pow(t(φ), n);
                return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
            }
            forward.invert = function(x, y) {
                var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
                return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
            };
            return forward;
        }
        (d3.geo.conicConformal = function() {
            return d3_geo_conic(d3_geo_conicConformal);
        }).raw = d3_geo_conicConformal;
        function d3_geo_conicEquidistant(φ0, φ1) {
            var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
            if (abs(n) < ε) return d3_geo_equirectangular;
            function forward(λ, φ) {
                var ρ = G - φ;
                return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
            }
            forward.invert = function(x, y) {
                var ρ0_y = G - y;
                return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
            };
            return forward;
        }
        (d3.geo.conicEquidistant = function() {
            return d3_geo_conic(d3_geo_conicEquidistant);
        }).raw = d3_geo_conicEquidistant;
        var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
            return 1 / cosλcosφ;
        }, Math.atan);
        (d3.geo.gnomonic = function() {
            return d3_geo_projection(d3_geo_gnomonic);
        }).raw = d3_geo_gnomonic;
        function d3_geo_mercator(λ, φ) {
            return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
        }
        d3_geo_mercator.invert = function(x, y) {
            return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
        };
        function d3_geo_mercatorProjection(project) {
            var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
            m.scale = function() {
                var v = scale.apply(m, arguments);
                return v === m ? clipAuto ? m.clipExtent(null) : m : v;
            };
            m.translate = function() {
                var v = translate.apply(m, arguments);
                return v === m ? clipAuto ? m.clipExtent(null) : m : v;
            };
            m.clipExtent = function(_) {
                var v = clipExtent.apply(m, arguments);
                if (v === m) {
                    if (clipAuto = _ == null) {
                        var k = π * scale(), t = translate();
                        clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
                    }
                } else if (clipAuto) {
                    v = null;
                }
                return v;
            };
            return m.clipExtent(null);
        }
        (d3.geo.mercator = function() {
            return d3_geo_mercatorProjection(d3_geo_mercator);
        }).raw = d3_geo_mercator;
        var d3_geo_orthographic = d3_geo_azimuthal(function() {
            return 1;
        }, Math.asin);
        (d3.geo.orthographic = function() {
            return d3_geo_projection(d3_geo_orthographic);
        }).raw = d3_geo_orthographic;
        var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
            return 1 / (1 + cosλcosφ);
        }, function(ρ) {
            return 2 * Math.atan(ρ);
        });
        (d3.geo.stereographic = function() {
            return d3_geo_projection(d3_geo_stereographic);
        }).raw = d3_geo_stereographic;
        function d3_geo_transverseMercator(λ, φ) {
            return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
        }
        d3_geo_transverseMercator.invert = function(x, y) {
            return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
        };
        (d3.geo.transverseMercator = function() {
            var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
            projection.center = function(_) {
                return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
            };
            projection.rotate = function(_) {
                return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(),
                    [ _[0], _[1], _[2] - 90 ]);
            };
            return rotate([ 0, 0, 90 ]);
        }).raw = d3_geo_transverseMercator;
        d3.geom = {};
        function d3_geom_pointX(d) {
            return d[0];
        }
        function d3_geom_pointY(d) {
            return d[1];
        }
        d3.geom.hull = function(vertices) {
            var x = d3_geom_pointX, y = d3_geom_pointY;
            if (arguments.length) return hull(vertices);
            function hull(data) {
                if (data.length < 3) return [];
                var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
                for (i = 0; i < n; i++) {
                    points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
                }
                points.sort(d3_geom_hullOrder);
                for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
                var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
                var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
                for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
                for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
                return polygon;
            }
            hull.x = function(_) {
                return arguments.length ? (x = _, hull) : x;
            };
            hull.y = function(_) {
                return arguments.length ? (y = _, hull) : y;
            };
            return hull;
        };
        function d3_geom_hullUpper(points) {
            var n = points.length, hull = [ 0, 1 ], hs = 2;
            for (var i = 2; i < n; i++) {
                while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
                hull[hs++] = i;
            }
            return hull.slice(0, hs);
        }
        function d3_geom_hullOrder(a, b) {
            return a[0] - b[0] || a[1] - b[1];
        }
        d3.geom.polygon = function(coordinates) {
            d3_subclass(coordinates, d3_geom_polygonPrototype);
            return coordinates;
        };
        var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
        d3_geom_polygonPrototype.area = function() {
            var i = -1, n = this.length, a, b = this[n - 1], area = 0;
            while (++i < n) {
                a = b;
                b = this[i];
                area += a[1] * b[0] - a[0] * b[1];
            }
            return area * .5;
        };
        d3_geom_polygonPrototype.centroid = function(k) {
            var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
            if (!arguments.length) k = -1 / (6 * this.area());
            while (++i < n) {
                a = b;
                b = this[i];
                c = a[0] * b[1] - b[0] * a[1];
                x += (a[0] + b[0]) * c;
                y += (a[1] + b[1]) * c;
            }
            return [ x * k, y * k ];
        };
        d3_geom_polygonPrototype.clip = function(subject) {
            var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
            while (++i < n) {
                input = subject.slice();
                subject.length = 0;
                b = this[i];
                c = input[(m = input.length - closed) - 1];
                j = -1;
                while (++j < m) {
                    d = input[j];
                    if (d3_geom_polygonInside(d, a, b)) {
                        if (!d3_geom_polygonInside(c, a, b)) {
                            subject.push(d3_geom_polygonIntersect(c, d, a, b));
                        }
                        subject.push(d);
                    } else if (d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    c = d;
                }
                if (closed) subject.push(subject[0]);
                a = b;
            }
            return subject;
        };
        function d3_geom_polygonInside(p, a, b) {
            return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
        }
        function d3_geom_polygonIntersect(c, d, a, b) {
            var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
            return [ x1 + ua * x21, y1 + ua * y21 ];
        }
        function d3_geom_polygonClosed(coordinates) {
            var a = coordinates[0], b = coordinates[coordinates.length - 1];
            return !(a[0] - b[0] || a[1] - b[1]);
        }
        var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
        function d3_geom_voronoiBeach() {
            d3_geom_voronoiRedBlackNode(this);
            this.edge = this.site = this.circle = null;
        }
        function d3_geom_voronoiCreateBeach(site) {
            var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
            beach.site = site;
            return beach;
        }
        function d3_geom_voronoiDetachBeach(beach) {
            d3_geom_voronoiDetachCircle(beach);
            d3_geom_voronoiBeaches.remove(beach);
            d3_geom_voronoiBeachPool.push(beach);
            d3_geom_voronoiRedBlackNode(beach);
        }
        function d3_geom_voronoiRemoveBeach(beach) {
            var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
                x: x,
                y: y
            }, previous = beach.P, next = beach.N, disappearing = [ beach ];
            d3_geom_voronoiDetachBeach(beach);
            var lArc = previous;
            while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
                previous = lArc.P;
                disappearing.unshift(lArc);
                d3_geom_voronoiDetachBeach(lArc);
                lArc = previous;
            }
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachCircle(lArc);
            var rArc = next;
            while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
                next = rArc.N;
                disappearing.push(rArc);
                d3_geom_voronoiDetachBeach(rArc);
                rArc = next;
            }
            disappearing.push(rArc);
            d3_geom_voronoiDetachCircle(rArc);
            var nArcs = disappearing.length, iArc;
            for (iArc = 1; iArc < nArcs; ++iArc) {
                rArc = disappearing[iArc];
                lArc = disappearing[iArc - 1];
                d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
            }
            lArc = disappearing[0];
            rArc = disappearing[nArcs - 1];
            rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiAddBeach(site) {
            var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
            while (node) {
                dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
                if (dxl > ε) node = node.L; else {
                    dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                    if (dxr > ε) {
                        if (!node.R) {
                            lArc = node;
                            break;
                        }
                        node = node.R;
                    } else {
                        if (dxl > -ε) {
                            lArc = node.P;
                            rArc = node;
                        } else if (dxr > -ε) {
                            lArc = node;
                            rArc = node.N;
                        } else {
                            lArc = rArc = node;
                        }
                        break;
                    }
                }
            }
            var newArc = d3_geom_voronoiCreateBeach(site);
            d3_geom_voronoiBeaches.insert(lArc, newArc);
            if (!lArc && !rArc) return;
            if (lArc === rArc) {
                d3_geom_voronoiDetachCircle(lArc);
                rArc = d3_geom_voronoiCreateBeach(lArc.site);
                d3_geom_voronoiBeaches.insert(newArc, rArc);
                newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
                d3_geom_voronoiAttachCircle(lArc);
                d3_geom_voronoiAttachCircle(rArc);
                return;
            }
            if (!rArc) {
                newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
                return;
            }
            d3_geom_voronoiDetachCircle(lArc);
            d3_geom_voronoiDetachCircle(rArc);
            var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
                x: (cy * hb - by * hc) / d + ax,
                y: (bx * hc - cx * hb) / d + ay
            };
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
            newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
            rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
        }
        function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
            var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
            if (!pby2) return rfocx;
            var lArc = arc.P;
            if (!lArc) return -Infinity;
            site = lArc.site;
            var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
            if (!plby2) return lfocx;
            var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
            if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
            return (rfocx + lfocx) / 2;
        }
        function d3_geom_voronoiRightBreakPoint(arc, directrix) {
            var rArc = arc.N;
            if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
            var site = arc.site;
            return site.y === directrix ? site.x : Infinity;
        }
        function d3_geom_voronoiCell(site) {
            this.site = site;
            this.edges = [];
        }
        d3_geom_voronoiCell.prototype.prepare = function() {
            var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
            while (iHalfEdge--) {
                edge = halfEdges[iHalfEdge].edge;
                if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
            }
            halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
            return halfEdges.length;
        };
        function d3_geom_voronoiCloseCells(extent) {
            var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
            while (iCell--) {
                cell = cells[iCell];
                if (!cell || !cell.prepare()) continue;
                halfEdges = cell.edges;
                nHalfEdges = halfEdges.length;
                iHalfEdge = 0;
                while (iHalfEdge < nHalfEdges) {
                    end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                    start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                    if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                        halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                            x: x0,
                            y: abs(x2 - x0) < ε ? y2 : y1
                        } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                            x: abs(y2 - y1) < ε ? x2 : x1,
                            y: y1
                        } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                            x: x1,
                            y: abs(x2 - x1) < ε ? y2 : y0
                        } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                            x: abs(y2 - y0) < ε ? x2 : x0,
                            y: y0
                        } : null), cell.site, null));
                        ++nHalfEdges;
                    }
                }
            }
        }
        function d3_geom_voronoiHalfEdgeOrder(a, b) {
            return b.angle - a.angle;
        }
        function d3_geom_voronoiCircle() {
            d3_geom_voronoiRedBlackNode(this);
            this.x = this.y = this.arc = this.site = this.cy = null;
        }
        function d3_geom_voronoiAttachCircle(arc) {
            var lArc = arc.P, rArc = arc.N;
            if (!lArc || !rArc) return;
            var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
            if (lSite === rSite) return;
            var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
            var d = 2 * (ax * cy - ay * cx);
            if (d >= -ε2) return;
            var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
            var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
            circle.arc = arc;
            circle.site = cSite;
            circle.x = x + bx;
            circle.y = cy + Math.sqrt(x * x + y * y);
            circle.cy = cy;
            arc.circle = circle;
            var before = null, node = d3_geom_voronoiCircles._;
            while (node) {
                if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                    if (node.L) node = node.L; else {
                        before = node.P;
                        break;
                    }
                } else {
                    if (node.R) node = node.R; else {
                        before = node;
                        break;
                    }
                }
            }
            d3_geom_voronoiCircles.insert(before, circle);
            if (!before) d3_geom_voronoiFirstCircle = circle;
        }
        function d3_geom_voronoiDetachCircle(arc) {
            var circle = arc.circle;
            if (circle) {
                if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
                d3_geom_voronoiCircles.remove(circle);
                d3_geom_voronoiCirclePool.push(circle);
                d3_geom_voronoiRedBlackNode(circle);
                arc.circle = null;
            }
        }
        function d3_geom_voronoiClipEdges(extent) {
            var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
            while (i--) {
                e = edges[i];
                if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                    e.a = e.b = null;
                    edges.splice(i, 1);
                }
            }
        }
        function d3_geom_voronoiConnectEdge(edge, extent) {
            var vb = edge.b;
            if (vb) return true;
            var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
            if (ry === ly) {
                if (fx < x0 || fx >= x1) return;
                if (lx > rx) {
                    if (!va) va = {
                        x: fx,
                        y: y0
                    }; else if (va.y >= y1) return;
                    vb = {
                        x: fx,
                        y: y1
                    };
                } else {
                    if (!va) va = {
                        x: fx,
                        y: y1
                    }; else if (va.y < y0) return;
                    vb = {
                        x: fx,
                        y: y0
                    };
                }
            } else {
                fm = (lx - rx) / (ry - ly);
                fb = fy - fm * fx;
                if (fm < -1 || fm > 1) {
                    if (lx > rx) {
                        if (!va) va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        }; else if (va.y >= y1) return;
                        vb = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    } else {
                        if (!va) va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        }; else if (va.y < y0) return;
                        vb = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    }
                } else {
                    if (ly < ry) {
                        if (!va) va = {
                            x: x0,
                            y: fm * x0 + fb
                        }; else if (va.x >= x1) return;
                        vb = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    } else {
                        if (!va) va = {
                            x: x1,
                            y: fm * x1 + fb
                        }; else if (va.x < x0) return;
                        vb = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    }
                }
            }
            edge.a = va;
            edge.b = vb;
            return true;
        }
        function d3_geom_voronoiEdge(lSite, rSite) {
            this.l = lSite;
            this.r = rSite;
            this.a = this.b = null;
        }
        function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
            var edge = new d3_geom_voronoiEdge(lSite, rSite);
            d3_geom_voronoiEdges.push(edge);
            if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
            if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
            d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
            d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
            return edge;
        }
        function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
            var edge = new d3_geom_voronoiEdge(lSite, null);
            edge.a = va;
            edge.b = vb;
            d3_geom_voronoiEdges.push(edge);
            return edge;
        }
        function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
            if (!edge.a && !edge.b) {
                edge.a = vertex;
                edge.l = lSite;
                edge.r = rSite;
            } else if (edge.l === rSite) {
                edge.b = vertex;
            } else {
                edge.a = vertex;
            }
        }
        function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
            var va = edge.a, vb = edge.b;
            this.edge = edge;
            this.site = lSite;
            this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
        }
        d3_geom_voronoiHalfEdge.prototype = {
            start: function() {
                return this.edge.l === this.site ? this.edge.a : this.edge.b;
            },
            end: function() {
                return this.edge.l === this.site ? this.edge.b : this.edge.a;
            }
        };
        function d3_geom_voronoiRedBlackTree() {
            this._ = null;
        }
        function d3_geom_voronoiRedBlackNode(node) {
            node.U = node.C = node.L = node.R = node.P = node.N = null;
        }
        d3_geom_voronoiRedBlackTree.prototype = {
            insert: function(after, node) {
                var parent, grandpa, uncle;
                if (after) {
                    node.P = after;
                    node.N = after.N;
                    if (after.N) after.N.P = node;
                    after.N = node;
                    if (after.R) {
                        after = after.R;
                        while (after.L) after = after.L;
                        after.L = node;
                    } else {
                        after.R = node;
                    }
                    parent = after;
                } else if (this._) {
                    after = d3_geom_voronoiRedBlackFirst(this._);
                    node.P = null;
                    node.N = after;
                    after.P = after.L = node;
                    parent = after;
                } else {
                    node.P = node.N = null;
                    this._ = node;
                    parent = null;
                }
                node.L = node.R = null;
                node.U = parent;
                node.C = true;
                after = node;
                while (parent && parent.C) {
                    grandpa = parent.U;
                    if (parent === grandpa.L) {
                        uncle = grandpa.R;
                        if (uncle && uncle.C) {
                            parent.C = uncle.C = false;
                            grandpa.C = true;
                            after = grandpa;
                        } else {
                            if (after === parent.R) {
                                d3_geom_voronoiRedBlackRotateLeft(this, parent);
                                after = parent;
                                parent = after.U;
                            }
                            parent.C = false;
                            grandpa.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                        }
                    } else {
                        uncle = grandpa.L;
                        if (uncle && uncle.C) {
                            parent.C = uncle.C = false;
                            grandpa.C = true;
                            after = grandpa;
                        } else {
                            if (after === parent.L) {
                                d3_geom_voronoiRedBlackRotateRight(this, parent);
                                after = parent;
                                parent = after.U;
                            }
                            parent.C = false;
                            grandpa.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                        }
                    }
                    parent = after.U;
                }
                this._.C = false;
            },
            remove: function(node) {
                if (node.N) node.N.P = node.P;
                if (node.P) node.P.N = node.N;
                node.N = node.P = null;
                var parent = node.U, sibling, left = node.L, right = node.R, next, red;
                if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
                if (parent) {
                    if (parent.L === node) parent.L = next; else parent.R = next;
                } else {
                    this._ = next;
                }
                if (left && right) {
                    red = next.C;
                    next.C = node.C;
                    next.L = left;
                    left.U = next;
                    if (next !== right) {
                        parent = next.U;
                        next.U = node.U;
                        node = next.R;
                        parent.L = node;
                        next.R = right;
                        right.U = next;
                    } else {
                        next.U = parent;
                        parent = next;
                        node = next.R;
                    }
                } else {
                    red = node.C;
                    node = next;
                }
                if (node) node.U = parent;
                if (red) return;
                if (node && node.C) {
                    node.C = false;
                    return;
                }
                do {
                    if (node === this._) break;
                    if (node === parent.L) {
                        sibling = parent.R;
                        if (sibling.C) {
                            sibling.C = false;
                            parent.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            sibling = parent.R;
                        }
                        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                            if (!sibling.R || !sibling.R.C) {
                                sibling.L.C = false;
                                sibling.C = true;
                                d3_geom_voronoiRedBlackRotateRight(this, sibling);
                                sibling = parent.R;
                            }
                            sibling.C = parent.C;
                            parent.C = sibling.R.C = false;
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            node = this._;
                            break;
                        }
                    } else {
                        sibling = parent.L;
                        if (sibling.C) {
                            sibling.C = false;
                            parent.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            sibling = parent.L;
                        }
                        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                            if (!sibling.L || !sibling.L.C) {
                                sibling.R.C = false;
                                sibling.C = true;
                                d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                                sibling = parent.L;
                            }
                            sibling.C = parent.C;
                            parent.C = sibling.L.C = false;
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            node = this._;
                            break;
                        }
                    }
                    sibling.C = true;
                    node = parent;
                    parent = parent.U;
                } while (!node.C);
                if (node) node.C = false;
            }
        };
        function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
            var p = node, q = node.R, parent = p.U;
            if (parent) {
                if (parent.L === p) parent.L = q; else parent.R = q;
            } else {
                tree._ = q;
            }
            q.U = parent;
            p.U = q;
            p.R = q.L;
            if (p.R) p.R.U = p;
            q.L = p;
        }
        function d3_geom_voronoiRedBlackRotateRight(tree, node) {
            var p = node, q = node.L, parent = p.U;
            if (parent) {
                if (parent.L === p) parent.L = q; else parent.R = q;
            } else {
                tree._ = q;
            }
            q.U = parent;
            p.U = q;
            p.L = q.R;
            if (p.L) p.L.U = p;
            q.R = p;
        }
        function d3_geom_voronoiRedBlackFirst(node) {
            while (node.L) node = node.L;
            return node;
        }
        function d3_geom_voronoi(sites, bbox) {
            var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
            d3_geom_voronoiEdges = [];
            d3_geom_voronoiCells = new Array(sites.length);
            d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
            d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
            while (true) {
                circle = d3_geom_voronoiFirstCircle;
                if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                    if (site.x !== x0 || site.y !== y0) {
                        d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                        d3_geom_voronoiAddBeach(site);
                        x0 = site.x, y0 = site.y;
                    }
                    site = sites.pop();
                } else if (circle) {
                    d3_geom_voronoiRemoveBeach(circle.arc);
                } else {
                    break;
                }
            }
            if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
            var diagram = {
                cells: d3_geom_voronoiCells,
                edges: d3_geom_voronoiEdges
            };
            d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
            return diagram;
        }
        function d3_geom_voronoiVertexOrder(a, b) {
            return b.y - a.y || b.x - a.x;
        }
        d3.geom.voronoi = function(points) {
            var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
            if (points) return voronoi(points);
            function voronoi(data) {
                var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
                d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
                    var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
                        var s = e.start();
                        return [ s.x, s.y ];
                    }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
                    polygon.point = data[i];
                });
                return polygons;
            }
            function sites(data) {
                return data.map(function(d, i) {
                    return {
                        x: Math.round(fx(d, i) / ε) * ε,
                        y: Math.round(fy(d, i) / ε) * ε,
                        i: i
                    };
                });
            }
            voronoi.links = function(data) {
                return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
                    return edge.l && edge.r;
                }).map(function(edge) {
                    return {
                        source: data[edge.l.i],
                        target: data[edge.r.i]
                    };
                });
            };
            voronoi.triangles = function(data) {
                var triangles = [];
                d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
                    var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                    while (++j < m) {
                        e0 = e1;
                        s0 = s1;
                        e1 = edges[j].edge;
                        s1 = e1.l === site ? e1.r : e1.l;
                        if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
                        }
                    }
                });
                return triangles;
            };
            voronoi.x = function(_) {
                return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
            };
            voronoi.y = function(_) {
                return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
            };
            voronoi.clipExtent = function(_) {
                if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
                clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
                return voronoi;
            };
            voronoi.size = function(_) {
                if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
                return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
            };
            return voronoi;
        };
        var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
        function d3_geom_voronoiTriangleArea(a, b, c) {
            return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
        }
        d3.geom.delaunay = function(vertices) {
            return d3.geom.voronoi().triangles(vertices);
        };
        d3.geom.quadtree = function(points, x1, y1, x2, y2) {
            var x = d3_geom_pointX, y = d3_geom_pointY, compat;
            if (compat = arguments.length) {
                x = d3_geom_quadtreeCompatX;
                y = d3_geom_quadtreeCompatY;
                if (compat === 3) {
                    y2 = y1;
                    x2 = x1;
                    y1 = x1 = 0;
                }
                return quadtree(points);
            }
            function quadtree(data) {
                var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
                if (x1 != null) {
                    x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
                } else {
                    x2_ = y2_ = -(x1_ = y1_ = Infinity);
                    xs = [], ys = [];
                    n = data.length;
                    if (compat) for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_) x1_ = d.x;
                        if (d.y < y1_) y1_ = d.y;
                        if (d.x > x2_) x2_ = d.x;
                        if (d.y > y2_) y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    } else for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                        if (x_ < x1_) x1_ = x_;
                        if (y_ < y1_) y1_ = y_;
                        if (x_ > x2_) x2_ = x_;
                        if (y_ > y2_) y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
                }
                var dx = x2_ - x1_, dy = y2_ - y1_;
                if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
                function insert(n, d, x, y, x1, y1, x2, y2) {
                    if (isNaN(x) || isNaN(y)) return;
                    if (n.leaf) {
                        var nx = n.x, ny = n.y;
                        if (nx != null) {
                            if (abs(nx - x) + abs(ny - y) < .01) {
                                insertChild(n, d, x, y, x1, y1, x2, y2);
                            } else {
                                var nPoint = n.point;
                                n.x = n.y = n.point = null;
                                insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                                insertChild(n, d, x, y, x1, y1, x2, y2);
                            }
                        } else {
                            n.x = x, n.y = y, n.point = d;
                        }
                    } else {
                        insertChild(n, d, x, y, x1, y1, x2, y2);
                    }
                }
                function insertChild(n, d, x, y, x1, y1, x2, y2) {
                    var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                    n.leaf = false;
                    n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                    if (right) x1 = xm; else x2 = xm;
                    if (below) y1 = ym; else y2 = ym;
                    insert(n, d, x, y, x1, y1, x2, y2);
                }
                var root = d3_geom_quadtreeNode();
                root.add = function(d) {
                    insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
                };
                root.visit = function(f) {
                    d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
                };
                root.find = function(point) {
                    return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
                };
                i = -1;
                if (x1 == null) {
                    while (++i < n) {
                        insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                    }
                    --i;
                } else data.forEach(root.add);
                xs = ys = data = d = null;
                return root;
            }
            quadtree.x = function(_) {
                return arguments.length ? (x = _, quadtree) : x;
            };
            quadtree.y = function(_) {
                return arguments.length ? (y = _, quadtree) : y;
            };
            quadtree.extent = function(_) {
                if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
                if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0],
                    y2 = +_[1][1];
                return quadtree;
            };
            quadtree.size = function(_) {
                if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
                if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
                return quadtree;
            };
            return quadtree;
        };
        function d3_geom_quadtreeCompatX(d) {
            return d.x;
        }
        function d3_geom_quadtreeCompatY(d) {
            return d.y;
        }
        function d3_geom_quadtreeNode() {
            return {
                leaf: true,
                nodes: [],
                point: null,
                x: null,
                y: null
            };
        }
        function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
            if (!f(node, x1, y1, x2, y2)) {
                var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
                if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
                if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
                if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
                if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
            }
        }
        function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
            var minDistance2 = Infinity, closestPoint;
            (function find(node, x1, y1, x2, y2) {
                if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
                if (point = node.point) {
                    var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                    if (distance2 < minDistance2) {
                        var distance = Math.sqrt(minDistance2 = distance2);
                        x0 = x - distance, y0 = y - distance;
                        x3 = x + distance, y3 = y + distance;
                        closestPoint = point;
                    }
                }
                var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
                for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                    if (node = children[i & 3]) switch (i & 3) {
                        case 0:
                            find(node, x1, y1, xm, ym);
                            break;

                        case 1:
                            find(node, xm, y1, x2, ym);
                            break;

                        case 2:
                            find(node, x1, ym, xm, y2);
                            break;

                        case 3:
                            find(node, xm, ym, x2, y2);
                            break;
                    }
                }
            })(root, x0, y0, x3, y3);
            return closestPoint;
        }
        d3.interpolateRgb = d3_interpolateRgb;
        function d3_interpolateRgb(a, b) {
            a = d3.rgb(a);
            b = d3.rgb(b);
            var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
            return function(t) {
                return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
            };
        }
        d3.interpolateObject = d3_interpolateObject;
        function d3_interpolateObject(a, b) {
            var i = {}, c = {}, k;
            for (k in a) {
                if (k in b) {
                    i[k] = d3_interpolate(a[k], b[k]);
                } else {
                    c[k] = a[k];
                }
            }
            for (k in b) {
                if (!(k in a)) {
                    c[k] = b[k];
                }
            }
            return function(t) {
                for (k in i) c[k] = i[k](t);
                return c;
            };
        }
        d3.interpolateNumber = d3_interpolateNumber;
        function d3_interpolateNumber(a, b) {
            a = +a, b = +b;
            return function(t) {
                return a * (1 - t) + b * t;
            };
        }
        d3.interpolateString = d3_interpolateString;
        function d3_interpolateString(a, b) {
            var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
            a = a + "", b = b + "";
            while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
                if ((bs = bm.index) > bi) {
                    bs = b.slice(bi, bs);
                    if (s[i]) s[i] += bs; else s[++i] = bs;
                }
                if ((am = am[0]) === (bm = bm[0])) {
                    if (s[i]) s[i] += bm; else s[++i] = bm;
                } else {
                    s[++i] = null;
                    q.push({
                        i: i,
                        x: d3_interpolateNumber(am, bm)
                    });
                }
                bi = d3_interpolate_numberB.lastIndex;
            }
            if (bi < b.length) {
                bs = b.slice(bi);
                if (s[i]) s[i] += bs; else s[++i] = bs;
            }
            return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
                return b(t) + "";
            }) : function() {
                return b;
            } : (b = q.length, function(t) {
                for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
        }
        var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
        d3.interpolate = d3_interpolate;
        function d3_interpolate(a, b) {
            var i = d3.interpolators.length, f;
            while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
            return f;
        }
        d3.interpolators = [ function(a, b) {
            var t = typeof b;
            return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        } ];
        d3.interpolateArray = d3_interpolateArray;
        function d3_interpolateArray(a, b) {
            var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
            for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
            for (;i < na; ++i) c[i] = a[i];
            for (;i < nb; ++i) c[i] = b[i];
            return function(t) {
                for (i = 0; i < n0; ++i) c[i] = x[i](t);
                return c;
            };
        }
        var d3_ease_default = function() {
            return d3_identity;
        };
        var d3_ease = d3.map({
            linear: d3_ease_default,
            poly: d3_ease_poly,
            quad: function() {
                return d3_ease_quad;
            },
            cubic: function() {
                return d3_ease_cubic;
            },
            sin: function() {
                return d3_ease_sin;
            },
            exp: function() {
                return d3_ease_exp;
            },
            circle: function() {
                return d3_ease_circle;
            },
            elastic: d3_ease_elastic,
            back: d3_ease_back,
            bounce: function() {
                return d3_ease_bounce;
            }
        });
        var d3_ease_mode = d3.map({
            "in": d3_identity,
            out: d3_ease_reverse,
            "in-out": d3_ease_reflect,
            "out-in": function(f) {
                return d3_ease_reflect(d3_ease_reverse(f));
            }
        });
        d3.ease = function(name) {
            var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
            t = d3_ease.get(t) || d3_ease_default;
            m = d3_ease_mode.get(m) || d3_identity;
            return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
        };
        function d3_ease_clamp(f) {
            return function(t) {
                return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
            };
        }
        function d3_ease_reverse(f) {
            return function(t) {
                return 1 - f(1 - t);
            };
        }
        function d3_ease_reflect(f) {
            return function(t) {
                return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
            };
        }
        function d3_ease_quad(t) {
            return t * t;
        }
        function d3_ease_cubic(t) {
            return t * t * t;
        }
        function d3_ease_cubicInOut(t) {
            if (t <= 0) return 0;
            if (t >= 1) return 1;
            var t2 = t * t, t3 = t2 * t;
            return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
        }
        function d3_ease_poly(e) {
            return function(t) {
                return Math.pow(t, e);
            };
        }
        function d3_ease_sin(t) {
            return 1 - Math.cos(t * halfπ);
        }
        function d3_ease_exp(t) {
            return Math.pow(2, 10 * (t - 1));
        }
        function d3_ease_circle(t) {
            return 1 - Math.sqrt(1 - t * t);
        }
        function d3_ease_elastic(a, p) {
            var s;
            if (arguments.length < 2) p = .45;
            if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
            return function(t) {
                return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
            };
        }
        function d3_ease_back(s) {
            if (!s) s = 1.70158;
            return function(t) {
                return t * t * ((s + 1) * t - s);
            };
        }
        function d3_ease_bounce(t) {
            return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
        }
        d3.interpolateHcl = d3_interpolateHcl;
        function d3_interpolateHcl(a, b) {
            a = d3.hcl(a);
            b = d3.hcl(b);
            var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
            if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
            if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
            return function(t) {
                return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
            };
        }
        d3.interpolateHsl = d3_interpolateHsl;
        function d3_interpolateHsl(a, b) {
            a = d3.hsl(a);
            b = d3.hsl(b);
            var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
            if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
            if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
            return function(t) {
                return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
            };
        }
        d3.interpolateLab = d3_interpolateLab;
        function d3_interpolateLab(a, b) {
            a = d3.lab(a);
            b = d3.lab(b);
            var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
            return function(t) {
                return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
            };
        }
        d3.interpolateRound = d3_interpolateRound;
        function d3_interpolateRound(a, b) {
            b -= a;
            return function(t) {
                return Math.round(a + b * t);
            };
        }
        d3.transform = function(string) {
            var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
            return (d3.transform = function(string) {
                if (string != null) {
                    g.setAttribute("transform", string);
                    var t = g.transform.baseVal.consolidate();
                }
                return new d3_transform(t ? t.matrix : d3_transformIdentity);
            })(string);
        };
        function d3_transform(m) {
            var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
            if (r0[0] * r1[1] < r1[0] * r0[1]) {
                r0[0] *= -1;
                r0[1] *= -1;
                kx *= -1;
                kz *= -1;
            }
            this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
            this.translate = [ m.e, m.f ];
            this.scale = [ kx, ky ];
            this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
        }
        d3_transform.prototype.toString = function() {
            return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
        };
        function d3_transformDot(a, b) {
            return a[0] * b[0] + a[1] * b[1];
        }
        function d3_transformNormalize(a) {
            var k = Math.sqrt(d3_transformDot(a, a));
            if (k) {
                a[0] /= k;
                a[1] /= k;
            }
            return k;
        }
        function d3_transformCombine(a, b, k) {
            a[0] += k * b[0];
            a[1] += k * b[1];
            return a;
        }
        var d3_transformIdentity = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        };
        d3.interpolateTransform = d3_interpolateTransform;
        function d3_interpolateTransformPop(s) {
            return s.length ? s.pop() + "," : "";
        }
        function d3_interpolateTranslate(ta, tb, s, q) {
            if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
                var i = s.push("translate(", null, ",", null, ")");
                q.push({
                    i: i - 4,
                    x: d3_interpolateNumber(ta[0], tb[0])
                }, {
                    i: i - 2,
                    x: d3_interpolateNumber(ta[1], tb[1])
                });
            } else if (tb[0] || tb[1]) {
                s.push("translate(" + tb + ")");
            }
        }
        function d3_interpolateRotate(ra, rb, s, q) {
            if (ra !== rb) {
                if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
                q.push({
                    i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
                    x: d3_interpolateNumber(ra, rb)
                });
            } else if (rb) {
                s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
            }
        }
        function d3_interpolateSkew(wa, wb, s, q) {
            if (wa !== wb) {
                q.push({
                    i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
                    x: d3_interpolateNumber(wa, wb)
                });
            } else if (wb) {
                s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
            }
        }
        function d3_interpolateScale(ka, kb, s, q) {
            if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
                var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
                q.push({
                    i: i - 4,
                    x: d3_interpolateNumber(ka[0], kb[0])
                }, {
                    i: i - 2,
                    x: d3_interpolateNumber(ka[1], kb[1])
                });
            } else if (kb[0] !== 1 || kb[1] !== 1) {
                s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
            }
        }
        function d3_interpolateTransform(a, b) {
            var s = [], q = [];
            a = d3.transform(a), b = d3.transform(b);
            d3_interpolateTranslate(a.translate, b.translate, s, q);
            d3_interpolateRotate(a.rotate, b.rotate, s, q);
            d3_interpolateSkew(a.skew, b.skew, s, q);
            d3_interpolateScale(a.scale, b.scale, s, q);
            a = b = null;
            return function(t) {
                var i = -1, n = q.length, o;
                while (++i < n) s[(o = q[i]).i] = o.x(t);
                return s.join("");
            };
        }
        function d3_uninterpolateNumber(a, b) {
            b = (b -= a = +a) || 1 / b;
            return function(x) {
                return (x - a) / b;
            };
        }
        function d3_uninterpolateClamp(a, b) {
            b = (b -= a = +a) || 1 / b;
            return function(x) {
                return Math.max(0, Math.min(1, (x - a) / b));
            };
        }
        d3.layout = {};
        d3.layout.bundle = function() {
            return function(links) {
                var paths = [], i = -1, n = links.length;
                while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
                return paths;
            };
        };
        function d3_layout_bundlePath(link) {
            var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
            while (start !== lca) {
                start = start.parent;
                points.push(start);
            }
            var k = points.length;
            while (end !== lca) {
                points.splice(k, 0, end);
                end = end.parent;
            }
            return points;
        }
        function d3_layout_bundleAncestors(node) {
            var ancestors = [], parent = node.parent;
            while (parent != null) {
                ancestors.push(node);
                node = parent;
                parent = parent.parent;
            }
            ancestors.push(node);
            return ancestors;
        }
        function d3_layout_bundleLeastCommonAncestor(a, b) {
            if (a === b) return a;
            var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
            while (aNode === bNode) {
                sharedNode = aNode;
                aNode = aNodes.pop();
                bNode = bNodes.pop();
            }
            return sharedNode;
        }
        d3.layout.chord = function() {
            var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
            function relayout() {
                var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
                chords = [];
                groups = [];
                k = 0, i = -1;
                while (++i < n) {
                    x = 0, j = -1;
                    while (++j < n) {
                        x += matrix[i][j];
                    }
                    groupSums.push(x);
                    subgroupIndex.push(d3.range(n));
                    k += x;
                }
                if (sortGroups) {
                    groupIndex.sort(function(a, b) {
                        return sortGroups(groupSums[a], groupSums[b]);
                    });
                }
                if (sortSubgroups) {
                    subgroupIndex.forEach(function(d, i) {
                        d.sort(function(a, b) {
                            return sortSubgroups(matrix[i][a], matrix[i][b]);
                        });
                    });
                }
                k = (τ - padding * n) / k;
                x = 0, i = -1;
                while (++i < n) {
                    x0 = x, j = -1;
                    while (++j < n) {
                        var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                        subgroups[di + "-" + dj] = {
                            index: di,
                            subindex: dj,
                            startAngle: a0,
                            endAngle: a1,
                            value: v
                        };
                    }
                    groups[di] = {
                        index: di,
                        startAngle: x0,
                        endAngle: x,
                        value: groupSums[di]
                    };
                    x += padding;
                }
                i = -1;
                while (++i < n) {
                    j = i - 1;
                    while (++j < n) {
                        var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                        if (source.value || target.value) {
                            chords.push(source.value < target.value ? {
                                source: target,
                                target: source
                            } : {
                                source: source,
                                target: target
                            });
                        }
                    }
                }
                if (sortChords) resort();
            }
            function resort() {
                chords.sort(function(a, b) {
                    return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
                });
            }
            chord.matrix = function(x) {
                if (!arguments.length) return matrix;
                n = (matrix = x) && matrix.length;
                chords = groups = null;
                return chord;
            };
            chord.padding = function(x) {
                if (!arguments.length) return padding;
                padding = x;
                chords = groups = null;
                return chord;
            };
            chord.sortGroups = function(x) {
                if (!arguments.length) return sortGroups;
                sortGroups = x;
                chords = groups = null;
                return chord;
            };
            chord.sortSubgroups = function(x) {
                if (!arguments.length) return sortSubgroups;
                sortSubgroups = x;
                chords = null;
                return chord;
            };
            chord.sortChords = function(x) {
                if (!arguments.length) return sortChords;
                sortChords = x;
                if (chords) resort();
                return chord;
            };
            chord.chords = function() {
                if (!chords) relayout();
                return chords;
            };
            chord.groups = function() {
                if (!groups) relayout();
                return groups;
            };
            return chord;
        };
        d3.layout.force = function() {
            var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
            function repulse(node) {
                return function(quad, x1, _, x2) {
                    if (quad.point !== node) {
                        var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                        if (dw * dw / theta2 < dn) {
                            if (dn < chargeDistance2) {
                                var k = quad.charge / dn;
                                node.px -= dx * k;
                                node.py -= dy * k;
                            }
                            return true;
                        }
                        if (quad.point && dn && dn < chargeDistance2) {
                            var k = quad.pointCharge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                    }
                    return !quad.charge;
                };
            }
            force.tick = function() {
                if ((alpha *= .99) < .005) {
                    timer = null;
                    event.end({
                        type: "end",
                        alpha: alpha = 0
                    });
                    return true;
                }
                var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
                for (i = 0; i < m; ++i) {
                    o = links[i];
                    s = o.source;
                    t = o.target;
                    x = t.x - s.x;
                    y = t.y - s.y;
                    if (l = x * x + y * y) {
                        l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                        x *= l;
                        y *= l;
                        t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
                        t.y -= y * k;
                        s.x += x * (k = 1 - k);
                        s.y += y * k;
                    }
                }
                if (k = alpha * gravity) {
                    x = size[0] / 2;
                    y = size[1] / 2;
                    i = -1;
                    if (k) while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
                }
                if (charge) {
                    d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                    i = -1;
                    while (++i < n) {
                        if (!(o = nodes[i]).fixed) {
                            q.visit(repulse(o));
                        }
                    }
                }
                i = -1;
                while (++i < n) {
                    o = nodes[i];
                    if (o.fixed) {
                        o.x = o.px;
                        o.y = o.py;
                    } else {
                        o.x -= (o.px - (o.px = o.x)) * friction;
                        o.y -= (o.py - (o.py = o.y)) * friction;
                    }
                }
                event.tick({
                    type: "tick",
                    alpha: alpha
                });
            };
            force.nodes = function(x) {
                if (!arguments.length) return nodes;
                nodes = x;
                return force;
            };
            force.links = function(x) {
                if (!arguments.length) return links;
                links = x;
                return force;
            };
            force.size = function(x) {
                if (!arguments.length) return size;
                size = x;
                return force;
            };
            force.linkDistance = function(x) {
                if (!arguments.length) return linkDistance;
                linkDistance = typeof x === "function" ? x : +x;
                return force;
            };
            force.distance = force.linkDistance;
            force.linkStrength = function(x) {
                if (!arguments.length) return linkStrength;
                linkStrength = typeof x === "function" ? x : +x;
                return force;
            };
            force.friction = function(x) {
                if (!arguments.length) return friction;
                friction = +x;
                return force;
            };
            force.charge = function(x) {
                if (!arguments.length) return charge;
                charge = typeof x === "function" ? x : +x;
                return force;
            };
            force.chargeDistance = function(x) {
                if (!arguments.length) return Math.sqrt(chargeDistance2);
                chargeDistance2 = x * x;
                return force;
            };
            force.gravity = function(x) {
                if (!arguments.length) return gravity;
                gravity = +x;
                return force;
            };
            force.theta = function(x) {
                if (!arguments.length) return Math.sqrt(theta2);
                theta2 = x * x;
                return force;
            };
            force.alpha = function(x) {
                if (!arguments.length) return alpha;
                x = +x;
                if (alpha) {
                    if (x > 0) {
                        alpha = x;
                    } else {
                        timer.c = null, timer.t = NaN, timer = null;
                        event.end({
                            type: "end",
                            alpha: alpha = 0
                        });
                    }
                } else if (x > 0) {
                    event.start({
                        type: "start",
                        alpha: alpha = x
                    });
                    timer = d3_timer(force.tick);
                }
                return force;
            };
            force.start = function() {
                var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
                for (i = 0; i < n; ++i) {
                    (o = nodes[i]).index = i;
                    o.weight = 0;
                }
                for (i = 0; i < m; ++i) {
                    o = links[i];
                    if (typeof o.source == "number") o.source = nodes[o.source];
                    if (typeof o.target == "number") o.target = nodes[o.target];
                    ++o.source.weight;
                    ++o.target.weight;
                }
                for (i = 0; i < n; ++i) {
                    o = nodes[i];
                    if (isNaN(o.x)) o.x = position("x", w);
                    if (isNaN(o.y)) o.y = position("y", h);
                    if (isNaN(o.px)) o.px = o.x;
                    if (isNaN(o.py)) o.py = o.y;
                }
                distances = [];
                if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
                strengths = [];
                if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
                charges = [];
                if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
                function position(dimension, size) {
                    if (!neighbors) {
                        neighbors = new Array(n);
                        for (j = 0; j < n; ++j) {
                            neighbors[j] = [];
                        }
                        for (j = 0; j < m; ++j) {
                            var o = links[j];
                            neighbors[o.source.index].push(o.target);
                            neighbors[o.target.index].push(o.source);
                        }
                    }
                    var candidates = neighbors[i], j = -1, l = candidates.length, x;
                    while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
                    return Math.random() * size;
                }
                return force.resume();
            };
            force.resume = function() {
                return force.alpha(.1);
            };
            force.stop = function() {
                return force.alpha(0);
            };
            force.drag = function() {
                if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
                if (!arguments.length) return drag;
                this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
            };
            function dragmove(d) {
                d.px = d3.event.x, d.py = d3.event.y;
                force.resume();
            }
            return d3.rebind(force, event, "on");
        };
        function d3_layout_forceDragstart(d) {
            d.fixed |= 2;
        }
        function d3_layout_forceDragend(d) {
            d.fixed &= ~6;
        }
        function d3_layout_forceMouseover(d) {
            d.fixed |= 4;
            d.px = d.x, d.py = d.y;
        }
        function d3_layout_forceMouseout(d) {
            d.fixed &= ~4;
        }
        function d3_layout_forceAccumulate(quad, alpha, charges) {
            var cx = 0, cy = 0;
            quad.charge = 0;
            if (!quad.leaf) {
                var nodes = quad.nodes, n = nodes.length, i = -1, c;
                while (++i < n) {
                    c = nodes[i];
                    if (c == null) continue;
                    d3_layout_forceAccumulate(c, alpha, charges);
                    quad.charge += c.charge;
                    cx += c.charge * c.cx;
                    cy += c.charge * c.cy;
                }
            }
            if (quad.point) {
                if (!quad.leaf) {
                    quad.point.x += Math.random() - .5;
                    quad.point.y += Math.random() - .5;
                }
                var k = alpha * charges[quad.point.index];
                quad.charge += quad.pointCharge = k;
                cx += k * quad.point.x;
                cy += k * quad.point.y;
            }
            quad.cx = cx / quad.charge;
            quad.cy = cy / quad.charge;
        }
        var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
        d3.layout.hierarchy = function() {
            var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
            function hierarchy(root) {
                var stack = [ root ], nodes = [], node;
                root.depth = 0;
                while ((node = stack.pop()) != null) {
                    nodes.push(node);
                    if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                        var n, childs, child;
                        while (--n >= 0) {
                            stack.push(child = childs[n]);
                            child.parent = node;
                            child.depth = node.depth + 1;
                        }
                        if (value) node.value = 0;
                        node.children = childs;
                    } else {
                        if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
                        delete node.children;
                    }
                }
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var childs, parent;
                    if (sort && (childs = node.children)) childs.sort(sort);
                    if (value && (parent = node.parent)) parent.value += node.value;
                });
                return nodes;
            }
            hierarchy.sort = function(x) {
                if (!arguments.length) return sort;
                sort = x;
                return hierarchy;
            };
            hierarchy.children = function(x) {
                if (!arguments.length) return children;
                children = x;
                return hierarchy;
            };
            hierarchy.value = function(x) {
                if (!arguments.length) return value;
                value = x;
                return hierarchy;
            };
            hierarchy.revalue = function(root) {
                if (value) {
                    d3_layout_hierarchyVisitBefore(root, function(node) {
                        if (node.children) node.value = 0;
                    });
                    d3_layout_hierarchyVisitAfter(root, function(node) {
                        var parent;
                        if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
                        if (parent = node.parent) parent.value += node.value;
                    });
                }
                return root;
            };
            return hierarchy;
        };
        function d3_layout_hierarchyRebind(object, hierarchy) {
            d3.rebind(object, hierarchy, "sort", "children", "value");
            object.nodes = object;
            object.links = d3_layout_hierarchyLinks;
            return object;
        }
        function d3_layout_hierarchyVisitBefore(node, callback) {
            var nodes = [ node ];
            while ((node = nodes.pop()) != null) {
                callback(node);
                if ((children = node.children) && (n = children.length)) {
                    var n, children;
                    while (--n >= 0) nodes.push(children[n]);
                }
            }
        }
        function d3_layout_hierarchyVisitAfter(node, callback) {
            var nodes = [ node ], nodes2 = [];
            while ((node = nodes.pop()) != null) {
                nodes2.push(node);
                if ((children = node.children) && (n = children.length)) {
                    var i = -1, n, children;
                    while (++i < n) nodes.push(children[i]);
                }
            }
            while ((node = nodes2.pop()) != null) {
                callback(node);
            }
        }
        function d3_layout_hierarchyChildren(d) {
            return d.children;
        }
        function d3_layout_hierarchyValue(d) {
            return d.value;
        }
        function d3_layout_hierarchySort(a, b) {
            return b.value - a.value;
        }
        function d3_layout_hierarchyLinks(nodes) {
            return d3.merge(nodes.map(function(parent) {
                return (parent.children || []).map(function(child) {
                    return {
                        source: parent,
                        target: child
                    };
                });
            }));
        }
        d3.layout.partition = function() {
            var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
            function position(node, x, dx, dy) {
                var children = node.children;
                node.x = x;
                node.y = node.depth * dy;
                node.dx = dx;
                node.dy = dy;
                if (children && (n = children.length)) {
                    var i = -1, n, c, d;
                    dx = node.value ? dx / node.value : 0;
                    while (++i < n) {
                        position(c = children[i], x, d = c.value * dx, dy);
                        x += d;
                    }
                }
            }
            function depth(node) {
                var children = node.children, d = 0;
                if (children && (n = children.length)) {
                    var i = -1, n;
                    while (++i < n) d = Math.max(d, depth(children[i]));
                }
                return 1 + d;
            }
            function partition(d, i) {
                var nodes = hierarchy.call(this, d, i);
                position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
                return nodes;
            }
            partition.size = function(x) {
                if (!arguments.length) return size;
                size = x;
                return partition;
            };
            return d3_layout_hierarchyRebind(partition, hierarchy);
        };
        d3.layout.pie = function() {
            var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
            function pie(data) {
                var n = data.length, values = data.map(function(d, i) {
                    return +value.call(pie, d, i);
                }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
                if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
                    return values[j] - values[i];
                } : function(i, j) {
                    return sort(data[i], data[j]);
                });
                index.forEach(function(i) {
                    arcs[i] = {
                        data: data[i],
                        value: v = values[i],
                        startAngle: a,
                        endAngle: a += v * k + pa,
                        padAngle: p
                    };
                });
                return arcs;
            }
            pie.value = function(_) {
                if (!arguments.length) return value;
                value = _;
                return pie;
            };
            pie.sort = function(_) {
                if (!arguments.length) return sort;
                sort = _;
                return pie;
            };
            pie.startAngle = function(_) {
                if (!arguments.length) return startAngle;
                startAngle = _;
                return pie;
            };
            pie.endAngle = function(_) {
                if (!arguments.length) return endAngle;
                endAngle = _;
                return pie;
            };
            pie.padAngle = function(_) {
                if (!arguments.length) return padAngle;
                padAngle = _;
                return pie;
            };
            return pie;
        };
        var d3_layout_pieSortByValue = {};
        d3.layout.stack = function() {
            var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
            function stack(data, index) {
                if (!(n = data.length)) return data;
                var series = data.map(function(d, i) {
                    return values.call(stack, d, i);
                });
                var points = series.map(function(d) {
                    return d.map(function(v, i) {
                        return [ x.call(stack, v, i), y.call(stack, v, i) ];
                    });
                });
                var orders = order.call(stack, points, index);
                series = d3.permute(series, orders);
                points = d3.permute(points, orders);
                var offsets = offset.call(stack, points, index);
                var m = series[0].length, n, i, j, o;
                for (j = 0; j < m; ++j) {
                    out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                    for (i = 1; i < n; ++i) {
                        out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                    }
                }
                return data;
            }
            stack.values = function(x) {
                if (!arguments.length) return values;
                values = x;
                return stack;
            };
            stack.order = function(x) {
                if (!arguments.length) return order;
                order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
                return stack;
            };
            stack.offset = function(x) {
                if (!arguments.length) return offset;
                offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
                return stack;
            };
            stack.x = function(z) {
                if (!arguments.length) return x;
                x = z;
                return stack;
            };
            stack.y = function(z) {
                if (!arguments.length) return y;
                y = z;
                return stack;
            };
            stack.out = function(z) {
                if (!arguments.length) return out;
                out = z;
                return stack;
            };
            return stack;
        };
        function d3_layout_stackX(d) {
            return d.x;
        }
        function d3_layout_stackY(d) {
            return d.y;
        }
        function d3_layout_stackOut(d, y0, y) {
            d.y0 = y0;
            d.y = y;
        }
        var d3_layout_stackOrders = d3.map({
            "inside-out": function(data) {
                var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
                    return max[a] - max[b];
                }), top = 0, bottom = 0, tops = [], bottoms = [];
                for (i = 0; i < n; ++i) {
                    j = index[i];
                    if (top < bottom) {
                        top += sums[j];
                        tops.push(j);
                    } else {
                        bottom += sums[j];
                        bottoms.push(j);
                    }
                }
                return bottoms.reverse().concat(tops);
            },
            reverse: function(data) {
                return d3.range(data.length).reverse();
            },
            "default": d3_layout_stackOrderDefault
        });
        var d3_layout_stackOffsets = d3.map({
            silhouette: function(data) {
                var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
                for (j = 0; j < m; ++j) {
                    for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                    if (o > max) max = o;
                    sums.push(o);
                }
                for (j = 0; j < m; ++j) {
                    y0[j] = (max - sums[j]) / 2;
                }
                return y0;
            },
            wiggle: function(data) {
                var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
                y0[0] = o = o0 = 0;
                for (j = 1; j < m; ++j) {
                    for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
                    for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                        for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                        }
                        s2 += s3 * data[i][j][1];
                    }
                    y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                    if (o < o0) o0 = o;
                }
                for (j = 0; j < m; ++j) y0[j] -= o0;
                return y0;
            },
            expand: function(data) {
                var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
                for (j = 0; j < m; ++j) {
                    for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
                    if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
                }
                for (j = 0; j < m; ++j) y0[j] = 0;
                return y0;
            },
            zero: d3_layout_stackOffsetZero
        });
        function d3_layout_stackOrderDefault(data) {
            return d3.range(data.length);
        }
        function d3_layout_stackOffsetZero(data) {
            var j = -1, m = data[0].length, y0 = [];
            while (++j < m) y0[j] = 0;
            return y0;
        }
        function d3_layout_stackMaxIndex(array) {
            var i = 1, j = 0, v = array[0][1], k, n = array.length;
            for (;i < n; ++i) {
                if ((k = array[i][1]) > v) {
                    j = i;
                    v = k;
                }
            }
            return j;
        }
        function d3_layout_stackReduceSum(d) {
            return d.reduce(d3_layout_stackSum, 0);
        }
        function d3_layout_stackSum(p, d) {
            return p + d[1];
        }
        d3.layout.histogram = function() {
            var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
            function histogram(data, i) {
                var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
                while (++i < m) {
                    bin = bins[i] = [];
                    bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                    bin.y = 0;
                }
                if (m > 0) {
                    i = -1;
                    while (++i < n) {
                        x = values[i];
                        if (x >= range[0] && x <= range[1]) {
                            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                            bin.y += k;
                            bin.push(data[i]);
                        }
                    }
                }
                return bins;
            }
            histogram.value = function(x) {
                if (!arguments.length) return valuer;
                valuer = x;
                return histogram;
            };
            histogram.range = function(x) {
                if (!arguments.length) return ranger;
                ranger = d3_functor(x);
                return histogram;
            };
            histogram.bins = function(x) {
                if (!arguments.length) return binner;
                binner = typeof x === "number" ? function(range) {
                    return d3_layout_histogramBinFixed(range, x);
                } : d3_functor(x);
                return histogram;
            };
            histogram.frequency = function(x) {
                if (!arguments.length) return frequency;
                frequency = !!x;
                return histogram;
            };
            return histogram;
        };
        function d3_layout_histogramBinSturges(range, values) {
            return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
        }
        function d3_layout_histogramBinFixed(range, n) {
            var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
            while (++x <= n) f[x] = m * x + b;
            return f;
        }
        function d3_layout_histogramRange(values) {
            return [ d3.min(values), d3.max(values) ];
        }
        d3.layout.pack = function() {
            var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
            function pack(d, i) {
                var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
                    return radius;
                };
                root.x = root.y = 0;
                d3_layout_hierarchyVisitAfter(root, function(d) {
                    d.r = +r(d.value);
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                if (padding) {
                    var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                    d3_layout_hierarchyVisitAfter(root, function(d) {
                        d.r += dr;
                    });
                    d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                    d3_layout_hierarchyVisitAfter(root, function(d) {
                        d.r -= dr;
                    });
                }
                d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
                return nodes;
            }
            pack.size = function(_) {
                if (!arguments.length) return size;
                size = _;
                return pack;
            };
            pack.radius = function(_) {
                if (!arguments.length) return radius;
                radius = _ == null || typeof _ === "function" ? _ : +_;
                return pack;
            };
            pack.padding = function(_) {
                if (!arguments.length) return padding;
                padding = +_;
                return pack;
            };
            return d3_layout_hierarchyRebind(pack, hierarchy);
        };
        function d3_layout_packSort(a, b) {
            return a.value - b.value;
        }
        function d3_layout_packInsert(a, b) {
            var c = a._pack_next;
            a._pack_next = b;
            b._pack_prev = a;
            b._pack_next = c;
            c._pack_prev = b;
        }
        function d3_layout_packSplice(a, b) {
            a._pack_next = b;
            b._pack_prev = a;
        }
        function d3_layout_packIntersects(a, b) {
            var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
            return .999 * dr * dr > dx * dx + dy * dy;
        }
        function d3_layout_packSiblings(node) {
            if (!(nodes = node.children) || !(n = nodes.length)) return;
            var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
            function bound(node) {
                xMin = Math.min(node.x - node.r, xMin);
                xMax = Math.max(node.x + node.r, xMax);
                yMin = Math.min(node.y - node.r, yMin);
                yMax = Math.max(node.y + node.r, yMax);
            }
            nodes.forEach(d3_layout_packLink);
            a = nodes[0];
            a.x = -a.r;
            a.y = 0;
            bound(a);
            if (n > 1) {
                b = nodes[1];
                b.x = b.r;
                b.y = 0;
                bound(b);
                if (n > 2) {
                    c = nodes[2];
                    d3_layout_packPlace(a, b, c);
                    bound(c);
                    d3_layout_packInsert(a, c);
                    a._pack_prev = c;
                    d3_layout_packInsert(c, b);
                    b = a._pack_next;
                    for (i = 3; i < n; i++) {
                        d3_layout_packPlace(a, b, c = nodes[i]);
                        var isect = 0, s1 = 1, s2 = 1;
                        for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                            if (d3_layout_packIntersects(j, c)) {
                                isect = 1;
                                break;
                            }
                        }
                        if (isect == 1) {
                            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                                if (d3_layout_packIntersects(k, c)) {
                                    break;
                                }
                            }
                        }
                        if (isect) {
                            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
                            i--;
                        } else {
                            d3_layout_packInsert(a, c);
                            b = c;
                            bound(c);
                        }
                    }
                }
            }
            var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
            for (i = 0; i < n; i++) {
                c = nodes[i];
                c.x -= cx;
                c.y -= cy;
                cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
            }
            node.r = cr;
            nodes.forEach(d3_layout_packUnlink);
        }
        function d3_layout_packLink(node) {
            node._pack_next = node._pack_prev = node;
        }
        function d3_layout_packUnlink(node) {
            delete node._pack_next;
            delete node._pack_prev;
        }
        function d3_layout_packTransform(node, x, y, k) {
            var children = node.children;
            node.x = x += k * node.x;
            node.y = y += k * node.y;
            node.r *= k;
            if (children) {
                var i = -1, n = children.length;
                while (++i < n) d3_layout_packTransform(children[i], x, y, k);
            }
        }
        function d3_layout_packPlace(a, b, c) {
            var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
            if (db && (dx || dy)) {
                var da = b.r + c.r, dc = dx * dx + dy * dy;
                da *= da;
                db *= db;
                var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
                c.x = a.x + x * dx + y * dy;
                c.y = a.y + x * dy - y * dx;
            } else {
                c.x = a.x + db;
                c.y = a.y;
            }
        }
        d3.layout.tree = function() {
            var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
            function tree(d, i) {
                var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
                d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
                d3_layout_hierarchyVisitBefore(root1, secondWalk);
                if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
                    var left = root0, right = root0, bottom = root0;
                    d3_layout_hierarchyVisitBefore(root0, function(node) {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                        if (node.depth > bottom.depth) bottom = node;
                    });
                    var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                    d3_layout_hierarchyVisitBefore(root0, function(node) {
                        node.x = (node.x + tx) * kx;
                        node.y = node.depth * ky;
                    });
                }
                return nodes;
            }
            function wrapTree(root0) {
                var root1 = {
                    A: null,
                    children: [ root0 ]
                }, queue = [ root1 ], node1;
                while ((node1 = queue.pop()) != null) {
                    for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                        queue.push((children[i] = child = {
                            _: children[i],
                            parent: node1,
                            children: (child = children[i].children) && child.slice() || [],
                            A: null,
                            a: null,
                            z: 0,
                            m: 0,
                            c: 0,
                            s: 0,
                            t: null,
                            i: i
                        }).a = child);
                    }
                }
                return root1.children[0];
            }
            function firstWalk(v) {
                var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
                if (children.length) {
                    d3_layout_treeShift(v);
                    var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                    if (w) {
                        v.z = w.z + separation(v._, w._);
                        v.m = v.z - midpoint;
                    } else {
                        v.z = midpoint;
                    }
                } else if (w) {
                    v.z = w.z + separation(v._, w._);
                }
                v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
            }
            function secondWalk(v) {
                v._.x = v.z + v.parent.m;
                v.m += v.parent.m;
            }
            function apportion(v, w, ancestor) {
                if (w) {
                    var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                    while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                        vom = d3_layout_treeLeft(vom);
                        vop = d3_layout_treeRight(vop);
                        vop.a = v;
                        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                        if (shift > 0) {
                            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                            sip += shift;
                            sop += shift;
                        }
                        sim += vim.m;
                        sip += vip.m;
                        som += vom.m;
                        sop += vop.m;
                    }
                    if (vim && !d3_layout_treeRight(vop)) {
                        vop.t = vim;
                        vop.m += sim - sop;
                    }
                    if (vip && !d3_layout_treeLeft(vom)) {
                        vom.t = vip;
                        vom.m += sip - som;
                        ancestor = v;
                    }
                }
                return ancestor;
            }
            function sizeNode(node) {
                node.x *= size[0];
                node.y = node.depth * size[1];
            }
            tree.separation = function(x) {
                if (!arguments.length) return separation;
                separation = x;
                return tree;
            };
            tree.size = function(x) {
                if (!arguments.length) return nodeSize ? null : size;
                nodeSize = (size = x) == null ? sizeNode : null;
                return tree;
            };
            tree.nodeSize = function(x) {
                if (!arguments.length) return nodeSize ? size : null;
                nodeSize = (size = x) == null ? null : sizeNode;
                return tree;
            };
            return d3_layout_hierarchyRebind(tree, hierarchy);
        };
        function d3_layout_treeSeparation(a, b) {
            return a.parent == b.parent ? 1 : 2;
        }
        function d3_layout_treeLeft(v) {
            var children = v.children;
            return children.length ? children[0] : v.t;
        }
        function d3_layout_treeRight(v) {
            var children = v.children, n;
            return (n = children.length) ? children[n - 1] : v.t;
        }
        function d3_layout_treeMove(wm, wp, shift) {
            var change = shift / (wp.i - wm.i);
            wp.c -= change;
            wp.s += shift;
            wm.c += change;
            wp.z += shift;
            wp.m += shift;
        }
        function d3_layout_treeShift(v) {
            var shift = 0, change = 0, children = v.children, i = children.length, w;
            while (--i >= 0) {
                w = children[i];
                w.z += shift;
                w.m += shift;
                shift += w.s + (change += w.c);
            }
        }
        function d3_layout_treeAncestor(vim, v, ancestor) {
            return vim.a.parent === v.parent ? vim.a : ancestor;
        }
        d3.layout.cluster = function() {
            var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
            function cluster(d, i) {
                var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
                d3_layout_hierarchyVisitAfter(root, function(node) {
                    var children = node.children;
                    if (children && children.length) {
                        node.x = d3_layout_clusterX(children);
                        node.y = d3_layout_clusterY(children);
                    } else {
                        node.x = previousNode ? x += separation(node, previousNode) : 0;
                        node.y = 0;
                        previousNode = node;
                    }
                });
                var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
                d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
                    node.x = (node.x - root.x) * size[0];
                    node.y = (root.y - node.y) * size[1];
                } : function(node) {
                    node.x = (node.x - x0) / (x1 - x0) * size[0];
                    node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
                });
                return nodes;
            }
            cluster.separation = function(x) {
                if (!arguments.length) return separation;
                separation = x;
                return cluster;
            };
            cluster.size = function(x) {
                if (!arguments.length) return nodeSize ? null : size;
                nodeSize = (size = x) == null;
                return cluster;
            };
            cluster.nodeSize = function(x) {
                if (!arguments.length) return nodeSize ? size : null;
                nodeSize = (size = x) != null;
                return cluster;
            };
            return d3_layout_hierarchyRebind(cluster, hierarchy);
        };
        function d3_layout_clusterY(children) {
            return 1 + d3.max(children, function(child) {
                return child.y;
            });
        }
        function d3_layout_clusterX(children) {
            return children.reduce(function(x, child) {
                return x + child.x;
            }, 0) / children.length;
        }
        function d3_layout_clusterLeft(node) {
            var children = node.children;
            return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
        }
        function d3_layout_clusterRight(node) {
            var children = node.children, n;
            return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
        }
        d3.layout.treemap = function() {
            var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
            function scale(children, k) {
                var i = -1, n = children.length, child, area;
                while (++i < n) {
                    area = (child = children[i]).value * (k < 0 ? 0 : k);
                    child.area = isNaN(area) || area <= 0 ? 0 : area;
                }
            }
            function squarify(node) {
                var children = node.children;
                if (children && children.length) {
                    var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                    scale(remaining, rect.dx * rect.dy / node.value);
                    row.area = 0;
                    while ((n = remaining.length) > 0) {
                        row.push(child = remaining[n - 1]);
                        row.area += child.area;
                        if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                            remaining.pop();
                            best = score;
                        } else {
                            row.area -= row.pop().area;
                            position(row, u, rect, false);
                            u = Math.min(rect.dx, rect.dy);
                            row.length = row.area = 0;
                            best = Infinity;
                        }
                    }
                    if (row.length) {
                        position(row, u, rect, true);
                        row.length = row.area = 0;
                    }
                    children.forEach(squarify);
                }
            }
            function stickify(node) {
                var children = node.children;
                if (children && children.length) {
                    var rect = pad(node), remaining = children.slice(), child, row = [];
                    scale(remaining, rect.dx * rect.dy / node.value);
                    row.area = 0;
                    while (child = remaining.pop()) {
                        row.push(child);
                        row.area += child.area;
                        if (child.z != null) {
                            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                            row.length = row.area = 0;
                        }
                    }
                    children.forEach(stickify);
                }
            }
            function worst(row, u) {
                var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
                while (++i < n) {
                    if (!(r = row[i].area)) continue;
                    if (r < rmin) rmin = r;
                    if (r > rmax) rmax = r;
                }
                s *= s;
                u *= u;
                return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
            }
            function position(row, u, rect, flush) {
                var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
                if (u == rect.dx) {
                    if (flush || v > rect.dy) v = rect.dy;
                    while (++i < n) {
                        o = row[i];
                        o.x = x;
                        o.y = y;
                        o.dy = v;
                        x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                    }
                    o.z = true;
                    o.dx += rect.x + rect.dx - x;
                    rect.y += v;
                    rect.dy -= v;
                } else {
                    if (flush || v > rect.dx) v = rect.dx;
                    while (++i < n) {
                        o = row[i];
                        o.x = x;
                        o.y = y;
                        o.dx = v;
                        y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                    }
                    o.z = false;
                    o.dy += rect.y + rect.dy - y;
                    rect.x += v;
                    rect.dx -= v;
                }
            }
            function treemap(d) {
                var nodes = stickies || hierarchy(d), root = nodes[0];
                root.x = root.y = 0;
                if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
                if (stickies) hierarchy.revalue(root);
                scale([ root ], root.dx * root.dy / root.value);
                (stickies ? stickify : squarify)(root);
                if (sticky) stickies = nodes;
                return nodes;
            }
            treemap.size = function(x) {
                if (!arguments.length) return size;
                size = x;
                return treemap;
            };
            treemap.padding = function(x) {
                if (!arguments.length) return padding;
                function padFunction(node) {
                    var p = x.call(treemap, node, node.depth);
                    return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
                }
                function padConstant(node) {
                    return d3_layout_treemapPad(node, x);
                }
                var type;
                pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ],
                    padConstant) : padConstant;
                return treemap;
            };
            treemap.round = function(x) {
                if (!arguments.length) return round != Number;
                round = x ? Math.round : Number;
                return treemap;
            };
            treemap.sticky = function(x) {
                if (!arguments.length) return sticky;
                sticky = x;
                stickies = null;
                return treemap;
            };
            treemap.ratio = function(x) {
                if (!arguments.length) return ratio;
                ratio = x;
                return treemap;
            };
            treemap.mode = function(x) {
                if (!arguments.length) return mode;
                mode = x + "";
                return treemap;
            };
            return d3_layout_hierarchyRebind(treemap, hierarchy);
        };
        function d3_layout_treemapPadNull(node) {
            return {
                x: node.x,
                y: node.y,
                dx: node.dx,
                dy: node.dy
            };
        }
        function d3_layout_treemapPad(node, padding) {
            var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
            if (dx < 0) {
                x += dx / 2;
                dx = 0;
            }
            if (dy < 0) {
                y += dy / 2;
                dy = 0;
            }
            return {
                x: x,
                y: y,
                dx: dx,
                dy: dy
            };
        }
        d3.random = {
            normal: function(µ, σ) {
                var n = arguments.length;
                if (n < 2) σ = 1;
                if (n < 1) µ = 0;
                return function() {
                    var x, y, r;
                    do {
                        x = Math.random() * 2 - 1;
                        y = Math.random() * 2 - 1;
                        r = x * x + y * y;
                    } while (!r || r > 1);
                    return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
                };
            },
            logNormal: function() {
                var random = d3.random.normal.apply(d3, arguments);
                return function() {
                    return Math.exp(random());
                };
            },
            bates: function(m) {
                var random = d3.random.irwinHall(m);
                return function() {
                    return random() / m;
                };
            },
            irwinHall: function(m) {
                return function() {
                    for (var s = 0, j = 0; j < m; j++) s += Math.random();
                    return s;
                };
            }
        };
        d3.scale = {};
        function d3_scaleExtent(domain) {
            var start = domain[0], stop = domain[domain.length - 1];
            return start < stop ? [ start, stop ] : [ stop, start ];
        }
        function d3_scaleRange(scale) {
            return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
        }
        function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
            var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
            return function(x) {
                return i(u(x));
            };
        }
        function d3_scale_nice(domain, nice) {
            var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
            if (x1 < x0) {
                dx = i0, i0 = i1, i1 = dx;
                dx = x0, x0 = x1, x1 = dx;
            }
            domain[i0] = nice.floor(x0);
            domain[i1] = nice.ceil(x1);
            return domain;
        }
        function d3_scale_niceStep(step) {
            return step ? {
                floor: function(x) {
                    return Math.floor(x / step) * step;
                },
                ceil: function(x) {
                    return Math.ceil(x / step) * step;
                }
            } : d3_scale_niceIdentity;
        }
        var d3_scale_niceIdentity = {
            floor: d3_identity,
            ceil: d3_identity
        };
        function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
            var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
            if (domain[k] < domain[0]) {
                domain = domain.slice().reverse();
                range = range.slice().reverse();
            }
            while (++j <= k) {
                u.push(uninterpolate(domain[j - 1], domain[j]));
                i.push(interpolate(range[j - 1], range[j]));
            }
            return function(x) {
                var j = d3.bisect(domain, x, 1, k) - 1;
                return i[j](u[j](x));
            };
        }
        d3.scale.linear = function() {
            return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
        };
        function d3_scale_linear(domain, range, interpolate, clamp) {
            var output, input;
            function rescale() {
                var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
                output = linear(domain, range, uninterpolate, interpolate);
                input = linear(range, domain, uninterpolate, d3_interpolate);
                return scale;
            }
            function scale(x) {
                return output(x);
            }
            scale.invert = function(y) {
                return input(y);
            };
            scale.domain = function(x) {
                if (!arguments.length) return domain;
                domain = x.map(Number);
                return rescale();
            };
            scale.range = function(x) {
                if (!arguments.length) return range;
                range = x;
                return rescale();
            };
            scale.rangeRound = function(x) {
                return scale.range(x).interpolate(d3_interpolateRound);
            };
            scale.clamp = function(x) {
                if (!arguments.length) return clamp;
                clamp = x;
                return rescale();
            };
            scale.interpolate = function(x) {
                if (!arguments.length) return interpolate;
                interpolate = x;
                return rescale();
            };
            scale.ticks = function(m) {
                return d3_scale_linearTicks(domain, m);
            };
            scale.tickFormat = function(m, format) {
                return d3_scale_linearTickFormat(domain, m, format);
            };
            scale.nice = function(m) {
                d3_scale_linearNice(domain, m);
                return rescale();
            };
            scale.copy = function() {
                return d3_scale_linear(domain, range, interpolate, clamp);
            };
            return rescale();
        }
        function d3_scale_linearRebind(scale, linear) {
            return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
        }
        function d3_scale_linearNice(domain, m) {
            d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
            d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
            return domain;
        }
        function d3_scale_linearTickRange(domain, m) {
            if (m == null) m = 10;
            var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
            if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
            extent[0] = Math.ceil(extent[0] / step) * step;
            extent[1] = Math.floor(extent[1] / step) * step + step * .5;
            extent[2] = step;
            return extent;
        }
        function d3_scale_linearTicks(domain, m) {
            return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
        }
        function d3_scale_linearTickFormat(domain, m, format) {
            var range = d3_scale_linearTickRange(domain, m);
            if (format) {
                var match = d3_format_re.exec(format);
                match.shift();
                if (match[8] === "s") {
                    var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                    if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                    match[8] = "f";
                    format = d3.format(match.join(""));
                    return function(d) {
                        return format(prefix.scale(d)) + prefix.symbol;
                    };
                }
                if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
                format = match.join("");
            } else {
                format = ",." + d3_scale_linearPrecision(range[2]) + "f";
            }
            return d3.format(format);
        }
        var d3_scale_linearFormatSignificant = {
            s: 1,
            g: 1,
            p: 1,
            r: 1,
            e: 1
        };
        function d3_scale_linearPrecision(value) {
            return -Math.floor(Math.log(value) / Math.LN10 + .01);
        }
        function d3_scale_linearFormatPrecision(type, range) {
            var p = d3_scale_linearPrecision(range[2]);
            return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
        }
        d3.scale.log = function() {
            return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
        };
        function d3_scale_log(linear, base, positive, domain) {
            function log(x) {
                return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
            }
            function pow(x) {
                return positive ? Math.pow(base, x) : -Math.pow(base, -x);
            }
            function scale(x) {
                return linear(log(x));
            }
            scale.invert = function(x) {
                return pow(linear.invert(x));
            };
            scale.domain = function(x) {
                if (!arguments.length) return domain;
                positive = x[0] >= 0;
                linear.domain((domain = x.map(Number)).map(log));
                return scale;
            };
            scale.base = function(_) {
                if (!arguments.length) return base;
                base = +_;
                linear.domain(domain.map(log));
                return scale;
            };
            scale.nice = function() {
                var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
                linear.domain(niced);
                domain = niced.map(pow);
                return scale;
            };
            scale.ticks = function() {
                var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
                if (isFinite(j - i)) {
                    if (positive) {
                        for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
                        ticks.push(pow(i));
                    } else {
                        ticks.push(pow(i));
                        for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
                    }
                    for (i = 0; ticks[i] < u; i++) {}
                    for (j = ticks.length; ticks[j - 1] > v; j--) {}
                    ticks = ticks.slice(i, j);
                }
                return ticks;
            };
            scale.tickFormat = function(n, format) {
                if (!arguments.length) return d3_scale_logFormat;
                if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
                var k = Math.max(1, base * n / scale.ticks().length);
                return function(d) {
                    var i = d / pow(Math.round(log(d)));
                    if (i * base < base - .5) i *= base;
                    return i <= k ? format(d) : "";
                };
            };
            scale.copy = function() {
                return d3_scale_log(linear.copy(), base, positive, domain);
            };
            return d3_scale_linearRebind(scale, linear);
        }
        var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
            floor: function(x) {
                return -Math.ceil(-x);
            },
            ceil: function(x) {
                return -Math.floor(-x);
            }
        };
        d3.scale.pow = function() {
            return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
        };
        function d3_scale_pow(linear, exponent, domain) {
            var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
            function scale(x) {
                return linear(powp(x));
            }
            scale.invert = function(x) {
                return powb(linear.invert(x));
            };
            scale.domain = function(x) {
                if (!arguments.length) return domain;
                linear.domain((domain = x.map(Number)).map(powp));
                return scale;
            };
            scale.ticks = function(m) {
                return d3_scale_linearTicks(domain, m);
            };
            scale.tickFormat = function(m, format) {
                return d3_scale_linearTickFormat(domain, m, format);
            };
            scale.nice = function(m) {
                return scale.domain(d3_scale_linearNice(domain, m));
            };
            scale.exponent = function(x) {
                if (!arguments.length) return exponent;
                powp = d3_scale_powPow(exponent = x);
                powb = d3_scale_powPow(1 / exponent);
                linear.domain(domain.map(powp));
                return scale;
            };
            scale.copy = function() {
                return d3_scale_pow(linear.copy(), exponent, domain);
            };
            return d3_scale_linearRebind(scale, linear);
        }
        function d3_scale_powPow(e) {
            return function(x) {
                return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
            };
        }
        d3.scale.sqrt = function() {
            return d3.scale.pow().exponent(.5);
        };
        d3.scale.ordinal = function() {
            return d3_scale_ordinal([], {
                t: "range",
                a: [ [] ]
            });
        };
        function d3_scale_ordinal(domain, ranger) {
            var index, range, rangeBand;
            function scale(x) {
                return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
            }
            function steps(start, step) {
                return d3.range(domain.length).map(function(i) {
                    return start + step * i;
                });
            }
            scale.domain = function(x) {
                if (!arguments.length) return domain;
                domain = [];
                index = new d3_Map();
                var i = -1, n = x.length, xi;
                while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
                return scale[ranger.t].apply(scale, ranger.a);
            };
            scale.range = function(x) {
                if (!arguments.length) return range;
                range = x;
                rangeBand = 0;
                ranger = {
                    t: "range",
                    a: arguments
                };
                return scale;
            };
            scale.rangePoints = function(x, padding) {
                if (arguments.length < 2) padding = 0;
                var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2,
                    0) : (stop - start) / (domain.length - 1 + padding);
                range = steps(start + step * padding / 2, step);
                rangeBand = 0;
                ranger = {
                    t: "rangePoints",
                    a: arguments
                };
                return scale;
            };
            scale.rangeRoundPoints = function(x, padding) {
                if (arguments.length < 2) padding = 0;
                var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2),
                    0) : (stop - start) / (domain.length - 1 + padding) | 0;
                range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
                rangeBand = 0;
                ranger = {
                    t: "rangeRoundPoints",
                    a: arguments
                };
                return scale;
            };
            scale.rangeBands = function(x, padding, outerPadding) {
                if (arguments.length < 2) padding = 0;
                if (arguments.length < 3) outerPadding = padding;
                var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
                range = steps(start + step * outerPadding, step);
                if (reverse) range.reverse();
                rangeBand = step * (1 - padding);
                ranger = {
                    t: "rangeBands",
                    a: arguments
                };
                return scale;
            };
            scale.rangeRoundBands = function(x, padding, outerPadding) {
                if (arguments.length < 2) padding = 0;
                if (arguments.length < 3) outerPadding = padding;
                var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
                range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
                if (reverse) range.reverse();
                rangeBand = Math.round(step * (1 - padding));
                ranger = {
                    t: "rangeRoundBands",
                    a: arguments
                };
                return scale;
            };
            scale.rangeBand = function() {
                return rangeBand;
            };
            scale.rangeExtent = function() {
                return d3_scaleExtent(ranger.a[0]);
            };
            scale.copy = function() {
                return d3_scale_ordinal(domain, ranger);
            };
            return scale.domain(domain);
        }
        d3.scale.category10 = function() {
            return d3.scale.ordinal().range(d3_category10);
        };
        d3.scale.category20 = function() {
            return d3.scale.ordinal().range(d3_category20);
        };
        d3.scale.category20b = function() {
            return d3.scale.ordinal().range(d3_category20b);
        };
        d3.scale.category20c = function() {
            return d3.scale.ordinal().range(d3_category20c);
        };
        var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
        var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
        var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
        var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
        d3.scale.quantile = function() {
            return d3_scale_quantile([], []);
        };
        function d3_scale_quantile(domain, range) {
            var thresholds;
            function rescale() {
                var k = 0, q = range.length;
                thresholds = [];
                while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
                return scale;
            }
            function scale(x) {
                if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
            }
            scale.domain = function(x) {
                if (!arguments.length) return domain;
                domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
                return rescale();
            };
            scale.range = function(x) {
                if (!arguments.length) return range;
                range = x;
                return rescale();
            };
            scale.quantiles = function() {
                return thresholds;
            };
            scale.invertExtent = function(y) {
                y = range.indexOf(y);
                return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
            };
            scale.copy = function() {
                return d3_scale_quantile(domain, range);
            };
            return rescale();
        }
        d3.scale.quantize = function() {
            return d3_scale_quantize(0, 1, [ 0, 1 ]);
        };
        function d3_scale_quantize(x0, x1, range) {
            var kx, i;
            function scale(x) {
                return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
            }
            function rescale() {
                kx = range.length / (x1 - x0);
                i = range.length - 1;
                return scale;
            }
            scale.domain = function(x) {
                if (!arguments.length) return [ x0, x1 ];
                x0 = +x[0];
                x1 = +x[x.length - 1];
                return rescale();
            };
            scale.range = function(x) {
                if (!arguments.length) return range;
                range = x;
                return rescale();
            };
            scale.invertExtent = function(y) {
                y = range.indexOf(y);
                y = y < 0 ? NaN : y / kx + x0;
                return [ y, y + 1 / kx ];
            };
            scale.copy = function() {
                return d3_scale_quantize(x0, x1, range);
            };
            return rescale();
        }
        d3.scale.threshold = function() {
            return d3_scale_threshold([ .5 ], [ 0, 1 ]);
        };
        function d3_scale_threshold(domain, range) {
            function scale(x) {
                if (x <= x) return range[d3.bisect(domain, x)];
            }
            scale.domain = function(_) {
                if (!arguments.length) return domain;
                domain = _;
                return scale;
            };
            scale.range = function(_) {
                if (!arguments.length) return range;
                range = _;
                return scale;
            };
            scale.invertExtent = function(y) {
                y = range.indexOf(y);
                return [ domain[y - 1], domain[y] ];
            };
            scale.copy = function() {
                return d3_scale_threshold(domain, range);
            };
            return scale;
        }
        d3.scale.identity = function() {
            return d3_scale_identity([ 0, 1 ]);
        };
        function d3_scale_identity(domain) {
            function identity(x) {
                return +x;
            }
            identity.invert = identity;
            identity.domain = identity.range = function(x) {
                if (!arguments.length) return domain;
                domain = x.map(identity);
                return identity;
            };
            identity.ticks = function(m) {
                return d3_scale_linearTicks(domain, m);
            };
            identity.tickFormat = function(m, format) {
                return d3_scale_linearTickFormat(domain, m, format);
            };
            identity.copy = function() {
                return d3_scale_identity(domain);
            };
            return identity;
        }
        d3.svg = {};
        function d3_zero() {
            return 0;
        }
        d3.svg.arc = function() {
            var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
            function arc() {
                var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
                if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
                if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
                var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
                if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                    rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                    if (!cw) p1 *= -1;
                    if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
                    if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
                }
                if (r1) {
                    x0 = r1 * Math.cos(a0 + p1);
                    y0 = r1 * Math.sin(a0 + p1);
                    x1 = r1 * Math.cos(a1 - p1);
                    y1 = r1 * Math.sin(a1 - p1);
                    var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                    if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                        var h1 = (a0 + a1) / 2;
                        x0 = r1 * Math.cos(h1);
                        y0 = r1 * Math.sin(h1);
                        x1 = y1 = null;
                    }
                } else {
                    x0 = y0 = 0;
                }
                if (r0) {
                    x2 = r0 * Math.cos(a1 - p0);
                    y2 = r0 * Math.sin(a1 - p0);
                    x3 = r0 * Math.cos(a0 + p0);
                    y3 = r0 * Math.sin(a0 + p0);
                    var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                    if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                        var h0 = (a0 + a1) / 2;
                        x2 = r0 * Math.cos(h0);
                        y2 = r0 * Math.sin(h0);
                        x3 = y3 = null;
                    }
                } else {
                    x2 = y2 = 0;
                }
                if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                    cr = r0 < r1 ^ cw ? 0 : 1;
                    var rc1 = rc, rc0 = rc;
                    if (da < π) {
                        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                        rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                        rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                    }
                    if (x1 != null) {
                        var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
                        if (rc === rc1) {
                            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                        } else {
                            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                        }
                    } else {
                        path.push("M", x0, ",", y0);
                    }
                    if (x3 != null) {
                        var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
                        if (rc === rc0) {
                            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                        } else {
                            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                        }
                    } else {
                        path.push("L", x2, ",", y2);
                    }
                } else {
                    path.push("M", x0, ",", y0);
                    if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                    path.push("L", x2, ",", y2);
                    if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
                }
                path.push("Z");
                return path.join("");
            }
            function circleSegment(r1, cw) {
                return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
            }
            arc.innerRadius = function(v) {
                if (!arguments.length) return innerRadius;
                innerRadius = d3_functor(v);
                return arc;
            };
            arc.outerRadius = function(v) {
                if (!arguments.length) return outerRadius;
                outerRadius = d3_functor(v);
                return arc;
            };
            arc.cornerRadius = function(v) {
                if (!arguments.length) return cornerRadius;
                cornerRadius = d3_functor(v);
                return arc;
            };
            arc.padRadius = function(v) {
                if (!arguments.length) return padRadius;
                padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
                return arc;
            };
            arc.startAngle = function(v) {
                if (!arguments.length) return startAngle;
                startAngle = d3_functor(v);
                return arc;
            };
            arc.endAngle = function(v) {
                if (!arguments.length) return endAngle;
                endAngle = d3_functor(v);
                return arc;
            };
            arc.padAngle = function(v) {
                if (!arguments.length) return padAngle;
                padAngle = d3_functor(v);
                return arc;
            };
            arc.centroid = function() {
                var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
                return [ Math.cos(a) * r, Math.sin(a) * r ];
            };
            return arc;
        };
        var d3_svg_arcAuto = "auto";
        function d3_svg_arcInnerRadius(d) {
            return d.innerRadius;
        }
        function d3_svg_arcOuterRadius(d) {
            return d.outerRadius;
        }
        function d3_svg_arcStartAngle(d) {
            return d.startAngle;
        }
        function d3_svg_arcEndAngle(d) {
            return d.endAngle;
        }
        function d3_svg_arcPadAngle(d) {
            return d && d.padAngle;
        }
        function d3_svg_arcSweep(x0, y0, x1, y1) {
            return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
        }
        function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
            var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
            if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
            return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
        }
        function d3_svg_line(projection) {
            var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
            function line(data) {
                var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
                function segment() {
                    segments.push("M", interpolate(projection(points), tension));
                }
                while (++i < n) {
                    if (defined.call(this, d = data[i], i)) {
                        points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
                    } else if (points.length) {
                        segment();
                        points = [];
                    }
                }
                if (points.length) segment();
                return segments.length ? segments.join("") : null;
            }
            line.x = function(_) {
                if (!arguments.length) return x;
                x = _;
                return line;
            };
            line.y = function(_) {
                if (!arguments.length) return y;
                y = _;
                return line;
            };
            line.defined = function(_) {
                if (!arguments.length) return defined;
                defined = _;
                return line;
            };
            line.interpolate = function(_) {
                if (!arguments.length) return interpolateKey;
                if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
                return line;
            };
            line.tension = function(_) {
                if (!arguments.length) return tension;
                tension = _;
                return line;
            };
            return line;
        }
        d3.svg.line = function() {
            return d3_svg_line(d3_identity);
        };
        var d3_svg_lineInterpolators = d3.map({
            linear: d3_svg_lineLinear,
            "linear-closed": d3_svg_lineLinearClosed,
            step: d3_svg_lineStep,
            "step-before": d3_svg_lineStepBefore,
            "step-after": d3_svg_lineStepAfter,
            basis: d3_svg_lineBasis,
            "basis-open": d3_svg_lineBasisOpen,
            "basis-closed": d3_svg_lineBasisClosed,
            bundle: d3_svg_lineBundle,
            cardinal: d3_svg_lineCardinal,
            "cardinal-open": d3_svg_lineCardinalOpen,
            "cardinal-closed": d3_svg_lineCardinalClosed,
            monotone: d3_svg_lineMonotone
        });
        d3_svg_lineInterpolators.forEach(function(key, value) {
            value.key = key;
            value.closed = /-closed$/.test(key);
        });
        function d3_svg_lineLinear(points) {
            return points.length > 1 ? points.join("L") : points + "Z";
        }
        function d3_svg_lineLinearClosed(points) {
            return points.join("L") + "Z";
        }
        function d3_svg_lineStep(points) {
            var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
            while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
            if (n > 1) path.push("H", p[0]);
            return path.join("");
        }
        function d3_svg_lineStepBefore(points) {
            var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
            while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
            return path.join("");
        }
        function d3_svg_lineStepAfter(points) {
            var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
            while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
            return path.join("");
        }
        function d3_svg_lineCardinalOpen(points, tension) {
            return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineCardinalClosed(points, tension) {
            return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
                points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
        }
        function d3_svg_lineCardinal(points, tension) {
            return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
        }
        function d3_svg_lineHermite(points, tangents) {
            if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
                return d3_svg_lineLinear(points);
            }
            var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
            if (quad) {
                path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
                p0 = points[1];
                pi = 2;
            }
            if (tangents.length > 1) {
                t = tangents[1];
                p = points[pi];
                pi++;
                path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
                for (var i = 2; i < tangents.length; i++, pi++) {
                    p = points[pi];
                    t = tangents[i];
                    path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
                }
            }
            if (quad) {
                var lp = points[pi];
                path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
            }
            return path;
        }
        function d3_svg_lineCardinalTangents(points, tension) {
            var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
            while (++i < n) {
                p0 = p1;
                p1 = p2;
                p2 = points[i];
                tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
            }
            return tangents;
        }
        function d3_svg_lineBasis(points) {
            if (points.length < 3) return d3_svg_lineLinear(points);
            var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
            points.push(points[n - 1]);
            while (++i <= n) {
                pi = points[i];
                px.shift();
                px.push(pi[0]);
                py.shift();
                py.push(pi[1]);
                d3_svg_lineBasisBezier(path, px, py);
            }
            points.pop();
            path.push("L", pi);
            return path.join("");
        }
        function d3_svg_lineBasisOpen(points) {
            if (points.length < 4) return d3_svg_lineLinear(points);
            var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
            while (++i < 3) {
                pi = points[i];
                px.push(pi[0]);
                py.push(pi[1]);
            }
            path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
            --i;
            while (++i < n) {
                pi = points[i];
                px.shift();
                px.push(pi[0]);
                py.shift();
                py.push(pi[1]);
                d3_svg_lineBasisBezier(path, px, py);
            }
            return path.join("");
        }
        function d3_svg_lineBasisClosed(points) {
            var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
            while (++i < 4) {
                pi = points[i % n];
                px.push(pi[0]);
                py.push(pi[1]);
            }
            path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
            --i;
            while (++i < m) {
                pi = points[i % n];
                px.shift();
                px.push(pi[0]);
                py.shift();
                py.push(pi[1]);
                d3_svg_lineBasisBezier(path, px, py);
            }
            return path.join("");
        }
        function d3_svg_lineBundle(points, tension) {
            var n = points.length - 1;
            if (n) {
                var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
                while (++i <= n) {
                    p = points[i];
                    t = i / n;
                    p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                    p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
                }
            }
            return d3_svg_lineBasis(points);
        }
        function d3_svg_lineDot4(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        }
        var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
        function d3_svg_lineBasisBezier(path, x, y) {
            path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
        }
        function d3_svg_lineSlope(p0, p1) {
            return (p1[1] - p0[1]) / (p1[0] - p0[0]);
        }
        function d3_svg_lineFiniteDifferences(points) {
            var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
            while (++i < j) {
                m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
            }
            m[i] = d;
            return m;
        }
        function d3_svg_lineMonotoneTangents(points) {
            var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
            while (++i < j) {
                d = d3_svg_lineSlope(points[i], points[i + 1]);
                if (abs(d) < ε) {
                    m[i] = m[i + 1] = 0;
                } else {
                    a = m[i] / d;
                    b = m[i + 1] / d;
                    s = a * a + b * b;
                    if (s > 9) {
                        s = d * 3 / Math.sqrt(s);
                        m[i] = s * a;
                        m[i + 1] = s * b;
                    }
                }
            }
            i = -1;
            while (++i <= j) {
                s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
                tangents.push([ s || 0, m[i] * s || 0 ]);
            }
            return tangents;
        }
        function d3_svg_lineMonotone(points) {
            return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
        }
        d3.svg.line.radial = function() {
            var line = d3_svg_line(d3_svg_lineRadial);
            line.radius = line.x, delete line.x;
            line.angle = line.y, delete line.y;
            return line;
        };
        function d3_svg_lineRadial(points) {
            var point, i = -1, n = points.length, r, a;
            while (++i < n) {
                point = points[i];
                r = point[0];
                a = point[1] - halfπ;
                point[0] = r * Math.cos(a);
                point[1] = r * Math.sin(a);
            }
            return points;
        }
        function d3_svg_area(projection) {
            var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
            function area(data) {
                var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
                    return x;
                } : d3_functor(x1), fy1 = y0 === y1 ? function() {
                    return y;
                } : d3_functor(y1), x, y;
                function segment() {
                    segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
                }
                while (++i < n) {
                    if (defined.call(this, d = data[i], i)) {
                        points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
                        points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
                    } else if (points0.length) {
                        segment();
                        points0 = [];
                        points1 = [];
                    }
                }
                if (points0.length) segment();
                return segments.length ? segments.join("") : null;
            }
            area.x = function(_) {
                if (!arguments.length) return x1;
                x0 = x1 = _;
                return area;
            };
            area.x0 = function(_) {
                if (!arguments.length) return x0;
                x0 = _;
                return area;
            };
            area.x1 = function(_) {
                if (!arguments.length) return x1;
                x1 = _;
                return area;
            };
            area.y = function(_) {
                if (!arguments.length) return y1;
                y0 = y1 = _;
                return area;
            };
            area.y0 = function(_) {
                if (!arguments.length) return y0;
                y0 = _;
                return area;
            };
            area.y1 = function(_) {
                if (!arguments.length) return y1;
                y1 = _;
                return area;
            };
            area.defined = function(_) {
                if (!arguments.length) return defined;
                defined = _;
                return area;
            };
            area.interpolate = function(_) {
                if (!arguments.length) return interpolateKey;
                if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
                interpolateReverse = interpolate.reverse || interpolate;
                L = interpolate.closed ? "M" : "L";
                return area;
            };
            area.tension = function(_) {
                if (!arguments.length) return tension;
                tension = _;
                return area;
            };
            return area;
        }
        d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
        d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
        d3.svg.area = function() {
            return d3_svg_area(d3_identity);
        };
        d3.svg.area.radial = function() {
            var area = d3_svg_area(d3_svg_lineRadial);
            area.radius = area.x, delete area.x;
            area.innerRadius = area.x0, delete area.x0;
            area.outerRadius = area.x1, delete area.x1;
            area.angle = area.y, delete area.y;
            area.startAngle = area.y0, delete area.y0;
            area.endAngle = area.y1, delete area.y1;
            return area;
        };
        d3.svg.chord = function() {
            var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
            function chord(d, i) {
                var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
                return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
            }
            function subgroup(self, f, d, i) {
                var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
                return {
                    r: r,
                    a0: a0,
                    a1: a1,
                    p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
                    p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
                };
            }
            function equals(a, b) {
                return a.a0 == b.a0 && a.a1 == b.a1;
            }
            function arc(r, p, a) {
                return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
            }
            function curve(r0, p0, r1, p1) {
                return "Q 0,0 " + p1;
            }
            chord.radius = function(v) {
                if (!arguments.length) return radius;
                radius = d3_functor(v);
                return chord;
            };
            chord.source = function(v) {
                if (!arguments.length) return source;
                source = d3_functor(v);
                return chord;
            };
            chord.target = function(v) {
                if (!arguments.length) return target;
                target = d3_functor(v);
                return chord;
            };
            chord.startAngle = function(v) {
                if (!arguments.length) return startAngle;
                startAngle = d3_functor(v);
                return chord;
            };
            chord.endAngle = function(v) {
                if (!arguments.length) return endAngle;
                endAngle = d3_functor(v);
                return chord;
            };
            return chord;
        };
        function d3_svg_chordRadius(d) {
            return d.radius;
        }
        d3.svg.diagonal = function() {
            var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
            function diagonal(d, i) {
                var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
                    x: p0.x,
                    y: m
                }, {
                    x: p3.x,
                    y: m
                }, p3 ];
                p = p.map(projection);
                return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
            }
            diagonal.source = function(x) {
                if (!arguments.length) return source;
                source = d3_functor(x);
                return diagonal;
            };
            diagonal.target = function(x) {
                if (!arguments.length) return target;
                target = d3_functor(x);
                return diagonal;
            };
            diagonal.projection = function(x) {
                if (!arguments.length) return projection;
                projection = x;
                return diagonal;
            };
            return diagonal;
        };
        function d3_svg_diagonalProjection(d) {
            return [ d.x, d.y ];
        }
        d3.svg.diagonal.radial = function() {
            var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
            diagonal.projection = function(x) {
                return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
            };
            return diagonal;
        };
        function d3_svg_diagonalRadialProjection(projection) {
            return function() {
                var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
                return [ r * Math.cos(a), r * Math.sin(a) ];
            };
        }
        d3.svg.symbol = function() {
            var type = d3_svg_symbolType, size = d3_svg_symbolSize;
            function symbol(d, i) {
                return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
            }
            symbol.type = function(x) {
                if (!arguments.length) return type;
                type = d3_functor(x);
                return symbol;
            };
            symbol.size = function(x) {
                if (!arguments.length) return size;
                size = d3_functor(x);
                return symbol;
            };
            return symbol;
        };
        function d3_svg_symbolSize() {
            return 64;
        }
        function d3_svg_symbolType() {
            return "circle";
        }
        function d3_svg_symbolCircle(size) {
            var r = Math.sqrt(size / π);
            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        }
        var d3_svg_symbols = d3.map({
            circle: d3_svg_symbolCircle,
            cross: function(size) {
                var r = Math.sqrt(size / 5) / 2;
                return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
            },
            diamond: function(size) {
                var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
                return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
            },
            square: function(size) {
                var r = Math.sqrt(size) / 2;
                return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
            },
            "triangle-down": function(size) {
                var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
                return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
            },
            "triangle-up": function(size) {
                var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
                return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
            }
        });
        d3.svg.symbolTypes = d3_svg_symbols.keys();
        var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
        d3_selectionPrototype.transition = function(name) {
            var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                time: Date.now(),
                ease: d3_ease_cubicInOut,
                delay: 0,
                duration: 250
            };
            for (var j = -1, m = this.length; ++j < m; ) {
                subgroups.push(subgroup = []);
                for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                    if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
                    subgroup.push(node);
                }
            }
            return d3_transition(subgroups, ns, id);
        };
        d3_selectionPrototype.interrupt = function(name) {
            return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
        };
        var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
        function d3_selection_interruptNS(ns) {
            return function() {
                var lock, activeId, active;
                if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                    active.timer.c = null;
                    active.timer.t = NaN;
                    if (--lock.count) delete lock[activeId]; else delete this[ns];
                    lock.active += .5;
                    active.event && active.event.interrupt.call(this, this.__data__, active.index);
                }
            };
        }
        function d3_transition(groups, ns, id) {
            d3_subclass(groups, d3_transitionPrototype);
            groups.namespace = ns;
            groups.id = id;
            return groups;
        }
        var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
        d3_transitionPrototype.call = d3_selectionPrototype.call;
        d3_transitionPrototype.empty = d3_selectionPrototype.empty;
        d3_transitionPrototype.node = d3_selectionPrototype.node;
        d3_transitionPrototype.size = d3_selectionPrototype.size;
        d3.transition = function(selection, name) {
            return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
        };
        d3.transition.prototype = d3_transitionPrototype;
        d3_transitionPrototype.select = function(selector) {
            var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
            selector = d3_selection_selector(selector);
            for (var j = -1, m = this.length; ++j < m; ) {
                subgroups.push(subgroup = []);
                for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                    if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                        if ("__data__" in node) subnode.__data__ = node.__data__;
                        d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                        subgroup.push(subnode);
                    } else {
                        subgroup.push(null);
                    }
                }
            }
            return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.selectAll = function(selector) {
            var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
            selector = d3_selection_selectorAll(selector);
            for (var j = -1, m = this.length; ++j < m; ) {
                for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
                    if (node = group[i]) {
                        transition = node[ns][id];
                        subnodes = selector.call(node, node.__data__, i, j);
                        subgroups.push(subgroup = []);
                        for (var k = -1, o = subnodes.length; ++k < o; ) {
                            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
                            subgroup.push(subnode);
                        }
                    }
                }
            }
            return d3_transition(subgroups, ns, id);
        };
        d3_transitionPrototype.filter = function(filter) {
            var subgroups = [], subgroup, group, node;
            if (typeof filter !== "function") filter = d3_selection_filter(filter);
            for (var j = 0, m = this.length; j < m; j++) {
                subgroups.push(subgroup = []);
                for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                    if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                        subgroup.push(node);
                    }
                }
            }
            return d3_transition(subgroups, this.namespace, this.id);
        };
        d3_transitionPrototype.tween = function(name, tween) {
            var id = this.id, ns = this.namespace;
            if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
            return d3_selection_each(this, tween == null ? function(node) {
                node[ns][id].tween.remove(name);
            } : function(node) {
                node[ns][id].tween.set(name, tween);
            });
        };
        function d3_transition_tween(groups, name, value, tween) {
            var id = groups.id, ns = groups.namespace;
            return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
                node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
            } : (value = tween(value), function(node) {
                node[ns][id].tween.set(name, value);
            }));
        }
        d3_transitionPrototype.attr = function(nameNS, value) {
            if (arguments.length < 2) {
                for (value in nameNS) this.attr(value, nameNS[value]);
                return this;
            }
            var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
            function attrNull() {
                this.removeAttribute(name);
            }
            function attrNullNS() {
                this.removeAttributeNS(name.space, name.local);
            }
            function attrTween(b) {
                return b == null ? attrNull : (b += "", function() {
                    var a = this.getAttribute(name), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                        this.setAttribute(name, i(t));
                    });
                });
            }
            function attrTweenNS(b) {
                return b == null ? attrNullNS : (b += "", function() {
                    var a = this.getAttributeNS(name.space, name.local), i;
                    return a !== b && (i = interpolate(a, b), function(t) {
                        this.setAttributeNS(name.space, name.local, i(t));
                    });
                });
            }
            return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.attrTween = function(nameNS, tween) {
            var name = d3.ns.qualify(nameNS);
            function attrTween(d, i) {
                var f = tween.call(this, d, i, this.getAttribute(name));
                return f && function(t) {
                    this.setAttribute(name, f(t));
                };
            }
            function attrTweenNS(d, i) {
                var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
                return f && function(t) {
                    this.setAttributeNS(name.space, name.local, f(t));
                };
            }
            return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
        };
        d3_transitionPrototype.style = function(name, value, priority) {
            var n = arguments.length;
            if (n < 3) {
                if (typeof name !== "string") {
                    if (n < 2) value = "";
                    for (priority in name) this.style(priority, name[priority], value);
                    return this;
                }
                priority = "";
            }
            function styleNull() {
                this.style.removeProperty(name);
            }
            function styleString(b) {
                return b == null ? styleNull : (b += "", function() {
                    var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                    return a !== b && (i = d3_interpolate(a, b), function(t) {
                        this.style.setProperty(name, i(t), priority);
                    });
                });
            }
            return d3_transition_tween(this, "style." + name, value, styleString);
        };
        d3_transitionPrototype.styleTween = function(name, tween, priority) {
            if (arguments.length < 3) priority = "";
            function styleTween(d, i) {
                var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
                return f && function(t) {
                    this.style.setProperty(name, f(t), priority);
                };
            }
            return this.tween("style." + name, styleTween);
        };
        d3_transitionPrototype.text = function(value) {
            return d3_transition_tween(this, "text", value, d3_transition_text);
        };
        function d3_transition_text(b) {
            if (b == null) b = "";
            return function() {
                this.textContent = b;
            };
        }
        d3_transitionPrototype.remove = function() {
            var ns = this.namespace;
            return this.each("end.transition", function() {
                var p;
                if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
            });
        };
        d3_transitionPrototype.ease = function(value) {
            var id = this.id, ns = this.namespace;
            if (arguments.length < 1) return this.node()[ns][id].ease;
            if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
            return d3_selection_each(this, function(node) {
                node[ns][id].ease = value;
            });
        };
        d3_transitionPrototype.delay = function(value) {
            var id = this.id, ns = this.namespace;
            if (arguments.length < 1) return this.node()[ns][id].delay;
            return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
                node[ns][id].delay = +value.call(node, node.__data__, i, j);
            } : (value = +value, function(node) {
                node[ns][id].delay = value;
            }));
        };
        d3_transitionPrototype.duration = function(value) {
            var id = this.id, ns = this.namespace;
            if (arguments.length < 1) return this.node()[ns][id].duration;
            return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
                node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
            } : (value = Math.max(1, value), function(node) {
                node[ns][id].duration = value;
            }));
        };
        d3_transitionPrototype.each = function(type, listener) {
            var id = this.id, ns = this.namespace;
            if (arguments.length < 2) {
                var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
                try {
                    d3_transitionInheritId = id;
                    d3_selection_each(this, function(node, i, j) {
                        d3_transitionInherit = node[ns][id];
                        type.call(node, node.__data__, i, j);
                    });
                } finally {
                    d3_transitionInherit = inherit;
                    d3_transitionInheritId = inheritId;
                }
            } else {
                d3_selection_each(this, function(node) {
                    var transition = node[ns][id];
                    (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
                });
            }
            return this;
        };
        d3_transitionPrototype.transition = function() {
            var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
            for (var j = 0, m = this.length; j < m; j++) {
                subgroups.push(subgroup = []);
                for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                    if (node = group[i]) {
                        transition = node[ns][id0];
                        d3_transitionNode(node, i, ns, id1, {
                            time: transition.time,
                            ease: transition.ease,
                            delay: transition.delay + transition.duration,
                            duration: transition.duration
                        });
                    }
                    subgroup.push(node);
                }
            }
            return d3_transition(subgroups, ns, id1);
        };
        function d3_transitionNamespace(name) {
            return name == null ? "__transition__" : "__transition_" + name + "__";
        }
        function d3_transitionNode(node, i, ns, id, inherit) {
            var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id], time, timer, duration, ease, tweens;
            function schedule(elapsed) {
                var delay = transition.delay;
                timer.t = delay + time;
                if (delay <= elapsed) return start(elapsed - delay);
                timer.c = start;
            }
            function start(elapsed) {
                var activeId = lock.active, active = lock[activeId];
                if (active) {
                    active.timer.c = null;
                    active.timer.t = NaN;
                    --lock.count;
                    delete lock[activeId];
                    active.event && active.event.interrupt.call(node, node.__data__, active.index);
                }
                for (var cancelId in lock) {
                    if (+cancelId < id) {
                        var cancel = lock[cancelId];
                        cancel.timer.c = null;
                        cancel.timer.t = NaN;
                        --lock.count;
                        delete lock[cancelId];
                    }
                }
                timer.c = tick;
                d3_timer(function() {
                    if (timer.c && tick(elapsed || 1)) {
                        timer.c = null;
                        timer.t = NaN;
                    }
                    return 1;
                }, 0, time);
                lock.active = id;
                transition.event && transition.event.start.call(node, node.__data__, i);
                tweens = [];
                transition.tween.forEach(function(key, value) {
                    if (value = value.call(node, node.__data__, i)) {
                        tweens.push(value);
                    }
                });
                ease = transition.ease;
                duration = transition.duration;
            }
            function tick(elapsed) {
                var t = elapsed / duration, e = ease(t), n = tweens.length;
                while (n > 0) {
                    tweens[--n].call(node, e);
                }
                if (t >= 1) {
                    transition.event && transition.event.end.call(node, node.__data__, i);
                    if (--lock.count) delete lock[id]; else delete node[ns];
                    return 1;
                }
            }
            if (!transition) {
                time = inherit.time;
                timer = d3_timer(schedule, 0, time);
                transition = lock[id] = {
                    tween: new d3_Map(),
                    time: time,
                    timer: timer,
                    delay: inherit.delay,
                    duration: inherit.duration,
                    ease: inherit.ease,
                    index: i
                };
                inherit = null;
                ++lock.count;
            }
        }
        d3.svg.axis = function() {
            var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
            function axis(g) {
                g.each(function() {
                    var g = d3.select(this);
                    var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                    var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                    var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"),
                        d3.transition(path));
                    tickEnter.append("line");
                    tickEnter.append("text");
                    var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                    if (orient === "bottom" || orient === "top") {
                        tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                        text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                        pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                    } else {
                        tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                        text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                        pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                    }
                    lineEnter.attr(y2, sign * innerTickSize);
                    textEnter.attr(y1, sign * tickSpacing);
                    lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                    textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                    if (scale1.rangeBand) {
                        var x = scale1, dx = x.rangeBand() / 2;
                        scale0 = scale1 = function(d) {
                            return x(d) + dx;
                        };
                    } else if (scale0.rangeBand) {
                        scale0 = scale1;
                    } else {
                        tickExit.call(tickTransform, scale1, scale0);
                    }
                    tickEnter.call(tickTransform, scale0, scale1);
                    tickUpdate.call(tickTransform, scale1, scale1);
                });
            }
            axis.scale = function(x) {
                if (!arguments.length) return scale;
                scale = x;
                return axis;
            };
            axis.orient = function(x) {
                if (!arguments.length) return orient;
                orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
                return axis;
            };
            axis.ticks = function() {
                if (!arguments.length) return tickArguments_;
                tickArguments_ = d3_array(arguments);
                return axis;
            };
            axis.tickValues = function(x) {
                if (!arguments.length) return tickValues;
                tickValues = x;
                return axis;
            };
            axis.tickFormat = function(x) {
                if (!arguments.length) return tickFormat_;
                tickFormat_ = x;
                return axis;
            };
            axis.tickSize = function(x) {
                var n = arguments.length;
                if (!n) return innerTickSize;
                innerTickSize = +x;
                outerTickSize = +arguments[n - 1];
                return axis;
            };
            axis.innerTickSize = function(x) {
                if (!arguments.length) return innerTickSize;
                innerTickSize = +x;
                return axis;
            };
            axis.outerTickSize = function(x) {
                if (!arguments.length) return outerTickSize;
                outerTickSize = +x;
                return axis;
            };
            axis.tickPadding = function(x) {
                if (!arguments.length) return tickPadding;
                tickPadding = +x;
                return axis;
            };
            axis.tickSubdivide = function() {
                return arguments.length && axis;
            };
            return axis;
        };
        var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        };
        function d3_svg_axisX(selection, x0, x1) {
            selection.attr("transform", function(d) {
                var v0 = x0(d);
                return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
            });
        }
        function d3_svg_axisY(selection, y0, y1) {
            selection.attr("transform", function(d) {
                var v0 = y0(d);
                return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
            });
        }
        d3.svg.brush = function() {
            var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
            function brush(g) {
                g.each(function() {
                    var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                    var background = g.selectAll(".background").data([ 0 ]);
                    background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                    g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                    var resize = g.selectAll(".resize").data(resizes, d3_identity);
                    resize.exit().remove();
                    resize.enter().append("g").attr("class", function(d) {
                        return "resize " + d;
                    }).style("cursor", function(d) {
                        return d3_svg_brushCursor[d];
                    }).append("rect").attr("x", function(d) {
                        return /[ew]$/.test(d) ? -3 : null;
                    }).attr("y", function(d) {
                        return /^[ns]/.test(d) ? -3 : null;
                    }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                    resize.style("display", brush.empty() ? "none" : null);
                    var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                    if (x) {
                        range = d3_scaleRange(x);
                        backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                        redrawX(gUpdate);
                    }
                    if (y) {
                        range = d3_scaleRange(y);
                        backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                        redrawY(gUpdate);
                    }
                    redraw(gUpdate);
                });
            }
            brush.event = function(g) {
                g.each(function() {
                    var event_ = event.of(this, arguments), extent1 = {
                        x: xExtent,
                        y: yExtent,
                        i: xExtentDomain,
                        j: yExtentDomain
                    }, extent0 = this.__chart__ || extent1;
                    this.__chart__ = extent1;
                    if (d3_transitionInheritId) {
                        d3.select(this).transition().each("start.brush", function() {
                            xExtentDomain = extent0.i;
                            yExtentDomain = extent0.j;
                            xExtent = extent0.x;
                            yExtent = extent0.y;
                            event_({
                                type: "brushstart"
                            });
                        }).tween("brush:brush", function() {
                            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                            xExtentDomain = yExtentDomain = null;
                            return function(t) {
                                xExtent = extent1.x = xi(t);
                                yExtent = extent1.y = yi(t);
                                event_({
                                    type: "brush",
                                    mode: "resize"
                                });
                            };
                        }).each("end.brush", function() {
                            xExtentDomain = extent1.i;
                            yExtentDomain = extent1.j;
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                            event_({
                                type: "brushend"
                            });
                        });
                    } else {
                        event_({
                            type: "brushstart"
                        });
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    }
                });
            };
            function redraw(g) {
                g.selectAll(".resize").attr("transform", function(d) {
                    return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
                });
            }
            function redrawX(g) {
                g.select(".extent").attr("x", xExtent[0]);
                g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
            }
            function redrawY(g) {
                g.select(".extent").attr("y", yExtent[0]);
                g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
            }
            function brushstart() {
                var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
                var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
                if (d3.event.changedTouches) {
                    w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
                } else {
                    w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
                }
                g.interrupt().selectAll("*").interrupt();
                if (dragging) {
                    origin[0] = xExtent[0] - origin[0];
                    origin[1] = yExtent[0] - origin[1];
                } else if (resizing) {
                    var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                    offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
                    origin[0] = xExtent[ex];
                    origin[1] = yExtent[ey];
                } else if (d3.event.altKey) center = origin.slice();
                g.style("pointer-events", "none").selectAll(".resize").style("display", null);
                d3.select("body").style("cursor", eventTarget.style("cursor"));
                event_({
                    type: "brushstart"
                });
                brushmove();
                function keydown() {
                    if (d3.event.keyCode == 32) {
                        if (!dragging) {
                            center = null;
                            origin[0] -= xExtent[1];
                            origin[1] -= yExtent[1];
                            dragging = 2;
                        }
                        d3_eventPreventDefault();
                    }
                }
                function keyup() {
                    if (d3.event.keyCode == 32 && dragging == 2) {
                        origin[0] += xExtent[1];
                        origin[1] += yExtent[1];
                        dragging = 0;
                        d3_eventPreventDefault();
                    }
                }
                function brushmove() {
                    var point = d3.mouse(target), moved = false;
                    if (offset) {
                        point[0] += offset[0];
                        point[1] += offset[1];
                    }
                    if (!dragging) {
                        if (d3.event.altKey) {
                            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
                            origin[0] = xExtent[+(point[0] < center[0])];
                            origin[1] = yExtent[+(point[1] < center[1])];
                        } else center = null;
                    }
                    if (resizingX && move1(point, x, 0)) {
                        redrawX(g);
                        moved = true;
                    }
                    if (resizingY && move1(point, y, 1)) {
                        redrawY(g);
                        moved = true;
                    }
                    if (moved) {
                        redraw(g);
                        event_({
                            type: "brush",
                            mode: dragging ? "move" : "resize"
                        });
                    }
                }
                function move1(point, scale, i) {
                    var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                    if (dragging) {
                        r0 -= position;
                        r1 -= size + position;
                    }
                    min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                    if (dragging) {
                        max = (min += position) + size;
                    } else {
                        if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                        if (position < min) {
                            max = min;
                            min = position;
                        } else {
                            max = position;
                        }
                    }
                    if (extent[0] != min || extent[1] != max) {
                        if (i) yExtentDomain = null; else xExtentDomain = null;
                        extent[0] = min;
                        extent[1] = max;
                        return true;
                    }
                }
                function brushend() {
                    brushmove();
                    g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                    d3.select("body").style("cursor", null);
                    w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                    dragRestore();
                    event_({
                        type: "brushend"
                    });
                }
            }
            brush.x = function(z) {
                if (!arguments.length) return x;
                x = z;
                resizes = d3_svg_brushResizes[!x << 1 | !y];
                return brush;
            };
            brush.y = function(z) {
                if (!arguments.length) return y;
                y = z;
                resizes = d3_svg_brushResizes[!x << 1 | !y];
                return brush;
            };
            brush.clamp = function(z) {
                if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
                if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
                return brush;
            };
            brush.extent = function(z) {
                var x0, x1, y0, y1, t;
                if (!arguments.length) {
                    if (x) {
                        if (xExtentDomain) {
                            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                        } else {
                            x0 = xExtent[0], x1 = xExtent[1];
                            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
                            if (x1 < x0) t = x0, x0 = x1, x1 = t;
                        }
                    }
                    if (y) {
                        if (yExtentDomain) {
                            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                        } else {
                            y0 = yExtent[0], y1 = yExtent[1];
                            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
                            if (y1 < y0) t = y0, y0 = y1, y1 = t;
                        }
                    }
                    return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
                }
                if (x) {
                    x0 = z[0], x1 = z[1];
                    if (y) x0 = x0[0], x1 = x1[0];
                    xExtentDomain = [ x0, x1 ];
                    if (x.invert) x0 = x(x0), x1 = x(x1);
                    if (x1 < x0) t = x0, x0 = x1, x1 = t;
                    if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
                }
                if (y) {
                    y0 = z[0], y1 = z[1];
                    if (x) y0 = y0[1], y1 = y1[1];
                    yExtentDomain = [ y0, y1 ];
                    if (y.invert) y0 = y(y0), y1 = y(y1);
                    if (y1 < y0) t = y0, y0 = y1, y1 = t;
                    if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
                }
                return brush;
            };
            brush.clear = function() {
                if (!brush.empty()) {
                    xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
                    xExtentDomain = yExtentDomain = null;
                }
                return brush;
            };
            brush.empty = function() {
                return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
            };
            return d3.rebind(brush, event, "on");
        };
        var d3_svg_brushCursor = {
            n: "ns-resize",
            e: "ew-resize",
            s: "ns-resize",
            w: "ew-resize",
            nw: "nwse-resize",
            ne: "nesw-resize",
            se: "nwse-resize",
            sw: "nesw-resize"
        };
        var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
        var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
        var d3_time_formatUtc = d3_time_format.utc;
        var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
        d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
        function d3_time_formatIsoNative(date) {
            return date.toISOString();
        }
        d3_time_formatIsoNative.parse = function(string) {
            var date = new Date(string);
            return isNaN(date) ? null : date;
        };
        d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
        d3_time.second = d3_time_interval(function(date) {
            return new d3_date(Math.floor(date / 1e3) * 1e3);
        }, function(date, offset) {
            date.setTime(date.getTime() + Math.floor(offset) * 1e3);
        }, function(date) {
            return date.getSeconds();
        });
        d3_time.seconds = d3_time.second.range;
        d3_time.seconds.utc = d3_time.second.utc.range;
        d3_time.minute = d3_time_interval(function(date) {
            return new d3_date(Math.floor(date / 6e4) * 6e4);
        }, function(date, offset) {
            date.setTime(date.getTime() + Math.floor(offset) * 6e4);
        }, function(date) {
            return date.getMinutes();
        });
        d3_time.minutes = d3_time.minute.range;
        d3_time.minutes.utc = d3_time.minute.utc.range;
        d3_time.hour = d3_time_interval(function(date) {
            var timezone = date.getTimezoneOffset() / 60;
            return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
        }, function(date, offset) {
            date.setTime(date.getTime() + Math.floor(offset) * 36e5);
        }, function(date) {
            return date.getHours();
        });
        d3_time.hours = d3_time.hour.range;
        d3_time.hours.utc = d3_time.hour.utc.range;
        d3_time.month = d3_time_interval(function(date) {
            date = d3_time.day(date);
            date.setDate(1);
            return date;
        }, function(date, offset) {
            date.setMonth(date.getMonth() + offset);
        }, function(date) {
            return date.getMonth();
        });
        d3_time.months = d3_time.month.range;
        d3_time.months.utc = d3_time.month.utc.range;
        function d3_time_scale(linear, methods, format) {
            function scale(x) {
                return linear(x);
            }
            scale.invert = function(x) {
                return d3_time_scaleDate(linear.invert(x));
            };
            scale.domain = function(x) {
                if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
                linear.domain(x);
                return scale;
            };
            function tickMethod(extent, count) {
                var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
                return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
                    return d / 31536e6;
                }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
            }
            scale.nice = function(interval, skip) {
                var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
                if (method) interval = method[0], skip = method[1];
                function skipped(date) {
                    return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
                }
                return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                    floor: function(date) {
                        while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
                        return date;
                    },
                    ceil: function(date) {
                        while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
                        return date;
                    }
                } : interval));
            };
            scale.ticks = function(interval, skip) {
                var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
                    range: interval
                }, skip ];
                if (method) interval = method[0], skip = method[1];
                return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
            };
            scale.tickFormat = function() {
                return format;
            };
            scale.copy = function() {
                return d3_time_scale(linear.copy(), methods, format);
            };
            return d3_scale_linearRebind(scale, linear);
        }
        function d3_time_scaleDate(t) {
            return new Date(t);
        }
        var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
        var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
        var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
            return d.getMilliseconds();
        } ], [ ":%S", function(d) {
            return d.getSeconds();
        } ], [ "%I:%M", function(d) {
            return d.getMinutes();
        } ], [ "%I %p", function(d) {
            return d.getHours();
        } ], [ "%a %d", function(d) {
            return d.getDay() && d.getDate() != 1;
        } ], [ "%b %d", function(d) {
            return d.getDate() != 1;
        } ], [ "%B", function(d) {
            return d.getMonth();
        } ], [ "%Y", d3_true ] ]);
        var d3_time_scaleMilliseconds = {
            range: function(start, stop, step) {
                return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
            },
            floor: d3_identity,
            ceil: d3_identity
        };
        d3_time_scaleLocalMethods.year = d3_time.year;
        d3_time.scale = function() {
            return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
        };
        var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
            return [ m[0].utc, m[1] ];
        });
        var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
            return d.getUTCMilliseconds();
        } ], [ ":%S", function(d) {
            return d.getUTCSeconds();
        } ], [ "%I:%M", function(d) {
            return d.getUTCMinutes();
        } ], [ "%I %p", function(d) {
            return d.getUTCHours();
        } ], [ "%a %d", function(d) {
            return d.getUTCDay() && d.getUTCDate() != 1;
        } ], [ "%b %d", function(d) {
            return d.getUTCDate() != 1;
        } ], [ "%B", function(d) {
            return d.getUTCMonth();
        } ], [ "%Y", d3_true ] ]);
        d3_time_scaleUtcMethods.year = d3_time.year.utc;
        d3_time.scale.utc = function() {
            return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
        };
        d3.text = d3_xhrType(function(request) {
            return request.responseText;
        });
        d3.json = function(url, callback) {
            return d3_xhr(url, "application/json", d3_json, callback);
        };
        function d3_json(request) {
            return JSON.parse(request.responseText);
        }
        d3.html = function(url, callback) {
            return d3_xhr(url, "text/html", d3_html, callback);
        };
        function d3_html(request) {
            var range = d3_document.createRange();
            range.selectNode(d3_document.body);
            return range.createContextualFragment(request.responseText);
        }
        d3.xml = d3_xhrType(function(request) {
            return request.responseXML;
        });
        if (typeof define === "function" && define.amd) this.d3 = d3, define(d3); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
    }();
},{}],6:[function(require,module,exports){
    module.exports = require('./lib/heap');

},{"./lib/heap":7}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
    (function() {
        var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

        floor = Math.floor, min = Math.min;


        /*
  Default comparison function to be used
   */

        defaultCmp = function(x, y) {
            if (x < y) {
                return -1;
            }
            if (x > y) {
                return 1;
            }
            return 0;
        };


        /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

        insort = function(a, x, lo, hi, cmp) {
            var mid;
            if (lo == null) {
                lo = 0;
            }
            if (cmp == null) {
                cmp = defaultCmp;
            }
            if (lo < 0) {
                throw new Error('lo must be non-negative');
            }
            if (hi == null) {
                hi = a.length;
            }
            while (lo < hi) {
                mid = floor((lo + hi) / 2);
                if (cmp(x, a[mid]) < 0) {
                    hi = mid;
                } else {
                    lo = mid + 1;
                }
            }
            return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
        };


        /*
  Push item onto heap, maintaining the heap invariant.
   */

        heappush = function(array, item, cmp) {
            if (cmp == null) {
                cmp = defaultCmp;
            }
            array.push(item);
            return _siftdown(array, 0, array.length - 1, cmp);
        };


        /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

        heappop = function(array, cmp) {
            var lastelt, returnitem;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            lastelt = array.pop();
            if (array.length) {
                returnitem = array[0];
                array[0] = lastelt;
                _siftup(array, 0, cmp);
            } else {
                returnitem = lastelt;
            }
            return returnitem;
        };


        /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

        heapreplace = function(array, item, cmp) {
            var returnitem;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            returnitem = array[0];
            array[0] = item;
            _siftup(array, 0, cmp);
            return returnitem;
        };


        /*
  Fast version of a heappush followed by a heappop.
   */

        heappushpop = function(array, item, cmp) {
            var _ref;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            if (array.length && cmp(array[0], item) < 0) {
                _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
                _siftup(array, 0, cmp);
            }
            return item;
        };


        /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

        heapify = function(array, cmp) {
            var i, _i, _j, _len, _ref, _ref1, _results, _results1;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            _ref1 = (function() {
                _results1 = [];
                for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
                return _results1;
            }).apply(this).reverse();
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                i = _ref1[_i];
                _results.push(_siftup(array, i, cmp));
            }
            return _results;
        };


        /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

        updateItem = function(array, item, cmp) {
            var pos;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            pos = array.indexOf(item);
            if (pos === -1) {
                return;
            }
            _siftdown(array, 0, pos, cmp);
            return _siftup(array, pos, cmp);
        };


        /*
  Find the n largest elements in a dataset.
   */

        nlargest = function(array, n, cmp) {
            var elem, result, _i, _len, _ref;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            result = array.slice(0, n);
            if (!result.length) {
                return result;
            }
            heapify(result, cmp);
            _ref = array.slice(n);
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                elem = _ref[_i];
                heappushpop(result, elem, cmp);
            }
            return result.sort(cmp).reverse();
        };


        /*
  Find the n smallest elements in a dataset.
   */

        nsmallest = function(array, n, cmp) {
            var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            if (n * 10 <= array.length) {
                result = array.slice(0, n).sort(cmp);
                if (!result.length) {
                    return result;
                }
                los = result[result.length - 1];
                _ref = array.slice(n);
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                    elem = _ref[_i];
                    if (cmp(elem, los) < 0) {
                        insort(result, elem, 0, null, cmp);
                        result.pop();
                        los = result[result.length - 1];
                    }
                }
                return result;
            }
            heapify(array, cmp);
            _results = [];
            for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
                _results.push(heappop(array, cmp));
            }
            return _results;
        };

        _siftdown = function(array, startpos, pos, cmp) {
            var newitem, parent, parentpos;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            newitem = array[pos];
            while (pos > startpos) {
                parentpos = (pos - 1) >> 1;
                parent = array[parentpos];
                if (cmp(newitem, parent) < 0) {
                    array[pos] = parent;
                    pos = parentpos;
                    continue;
                }
                break;
            }
            return array[pos] = newitem;
        };

        _siftup = function(array, pos, cmp) {
            var childpos, endpos, newitem, rightpos, startpos;
            if (cmp == null) {
                cmp = defaultCmp;
            }
            endpos = array.length;
            startpos = pos;
            newitem = array[pos];
            childpos = 2 * pos + 1;
            while (childpos < endpos) {
                rightpos = childpos + 1;
                if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
                    childpos = rightpos;
                }
                array[pos] = array[childpos];
                pos = childpos;
                childpos = 2 * pos + 1;
            }
            array[pos] = newitem;
            return _siftdown(array, startpos, pos, cmp);
        };

        Heap = (function() {
            Heap.push = heappush;

            Heap.pop = heappop;

            Heap.replace = heapreplace;

            Heap.pushpop = heappushpop;

            Heap.heapify = heapify;

            Heap.updateItem = updateItem;

            Heap.nlargest = nlargest;

            Heap.nsmallest = nsmallest;

            function Heap(cmp) {
                this.cmp = cmp != null ? cmp : defaultCmp;
                this.nodes = [];
            }

            Heap.prototype.push = function(x) {
                return heappush(this.nodes, x, this.cmp);
            };

            Heap.prototype.pop = function() {
                return heappop(this.nodes, this.cmp);
            };

            Heap.prototype.peek = function() {
                return this.nodes[0];
            };

            Heap.prototype.contains = function(x) {
                return this.nodes.indexOf(x) !== -1;
            };

            Heap.prototype.replace = function(x) {
                return heapreplace(this.nodes, x, this.cmp);
            };

            Heap.prototype.pushpop = function(x) {
                return heappushpop(this.nodes, x, this.cmp);
            };

            Heap.prototype.heapify = function() {
                return heapify(this.nodes, this.cmp);
            };

            Heap.prototype.updateItem = function(x) {
                return updateItem(this.nodes, x, this.cmp);
            };

            Heap.prototype.clear = function() {
                return this.nodes = [];
            };

            Heap.prototype.empty = function() {
                return this.nodes.length === 0;
            };

            Heap.prototype.size = function() {
                return this.nodes.length;
            };

            Heap.prototype.clone = function() {
                var heap;
                heap = new Heap();
                heap.nodes = this.nodes.slice(0);
                return heap;
            };

            Heap.prototype.toArray = function() {
                return this.nodes.slice(0);
            };

            Heap.prototype.insert = Heap.prototype.push;

            Heap.prototype.top = Heap.prototype.peek;

            Heap.prototype.front = Heap.prototype.peek;

            Heap.prototype.has = Heap.prototype.contains;

            Heap.prototype.copy = Heap.prototype.clone;

            return Heap;

        })();

        (function(root, factory) {
            if (typeof define === 'function' && define.amd) {
                return define([], factory);
            } else if (typeof exports === 'object') {
                return module.exports = factory();
            } else {
                return root.Heap = factory();
            }
        })(this, function() {
            return Heap;
        });

    }).call(this);

},{}],8:[function(require,module,exports){
    (function (global){
        "use strict";

        var numeric = (typeof exports === "undefined")?(function numeric() {}):(exports);
        if(typeof global !== "undefined") { global.numeric = numeric; }

        numeric.version = "1.2.6";

// 1. Utility functions
        numeric.bench = function bench (f,interval) {
            var t1,t2,n,i;
            if(typeof interval === "undefined") { interval = 15; }
            n = 0.5;
            t1 = new Date();
            while(1) {
                n*=2;
                for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
                while(i>0) { f(); i--; }
                t2 = new Date();
                if(t2-t1 > interval) break;
            }
            for(i=n;i>3;i-=4) { f(); f(); f(); f(); }
            while(i>0) { f(); i--; }
            t2 = new Date();
            return 1000*(3*n-1)/(t2-t1);
        }

        numeric._myIndexOf = (function _myIndexOf(w) {
            var n = this.length,k;
            for(k=0;k<n;++k) if(this[k]===w) return k;
            return -1;
        });
        numeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;

        numeric.Function = Function;
        numeric.precision = 4;
        numeric.largeArray = 50;

        numeric.prettyPrint = function prettyPrint(x) {
            function fmtnum(x) {
                if(x === 0) { return '0'; }
                if(isNaN(x)) { return 'NaN'; }
                if(x<0) { return '-'+fmtnum(-x); }
                if(isFinite(x)) {
                    var scale = Math.floor(Math.log(x) / Math.log(10));
                    var normalized = x / Math.pow(10,scale);
                    var basic = normalized.toPrecision(numeric.precision);
                    if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }
                    return parseFloat(basic).toString()+'e'+scale.toString();
                }
                return 'Infinity';
            }
            var ret = [];
            function foo(x) {
                var k;
                if(typeof x === "undefined") { ret.push(Array(numeric.precision+8).join(' ')); return false; }
                if(typeof x === "string") { ret.push('"'+x+'"'); return false; }
                if(typeof x === "boolean") { ret.push(x.toString()); return false; }
                if(typeof x === "number") {
                    var a = fmtnum(x);
                    var b = x.toPrecision(numeric.precision);
                    var c = parseFloat(x.toString()).toString();
                    var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];
                    for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }
                    ret.push(Array(numeric.precision+8-a.length).join(' ')+a);
                    return false;
                }
                if(x === null) { ret.push("null"); return false; }
                if(typeof x === "function") {
                    ret.push(x.toString());
                    var flag = false;
                    for(k in x) { if(x.hasOwnProperty(k)) {
                        if(flag) ret.push(',\n');
                        else ret.push('\n{');
                        flag = true;
                        ret.push(k);
                        ret.push(': \n');
                        foo(x[k]);
                    } }
                    if(flag) ret.push('}\n');
                    return true;
                }
                if(x instanceof Array) {
                    if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }
                    var flag = false;
                    ret.push('[');
                    for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\n '); } flag = foo(x[k]); }
                    ret.push(']');
                    return true;
                }
                ret.push('{');
                var flag = false;
                for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\n'); flag = true; ret.push(k); ret.push(': \n'); foo(x[k]); } }
                ret.push('}');
                return true;
            }
            foo(x);
            return ret.join('');
        }

        numeric.parseDate = function parseDate(d) {
            function foo(d) {
                if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }
                if(!(d instanceof Array)) { throw new Error("parseDate: parameter must be arrays of strings"); }
                var ret = [],k;
                for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
                return ret;
            }
            return foo(d);
        }

        numeric.parseFloat = function parseFloat_(d) {
            function foo(d) {
                if(typeof d === 'string') { return parseFloat(d); }
                if(!(d instanceof Array)) { throw new Error("parseFloat: parameter must be arrays of strings"); }
                var ret = [],k;
                for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }
                return ret;
            }
            return foo(d);
        }

        numeric.parseCSV = function parseCSV(t) {
            var foo = t.split('\n');
            var j,k;
            var ret = [];
            var pat = /(([^'",]*)|('[^']*')|("[^"]*")),/g;
            var patnum = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/;
            var stripper = function(n) { return n.substr(0,n.length-1); }
            var count = 0;
            for(k=0;k<foo.length;k++) {
                var bar = (foo[k]+",").match(pat),baz;
                if(bar.length>0) {
                    ret[count] = [];
                    for(j=0;j<bar.length;j++) {
                        baz = stripper(bar[j]);
                        if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }
                        else ret[count][j] = baz;
                    }
                    count++;
                }
            }
            return ret;
        }

        numeric.toCSV = function toCSV(A) {
            var s = numeric.dim(A);
            var i,j,m,n,row,ret;
            m = s[0];
            n = s[1];
            ret = [];
            for(i=0;i<m;i++) {
                row = [];
                for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }
                ret[i] = row.join(', ');
            }
            return ret.join('\n')+'\n';
        }

        numeric.getURL = function getURL(url) {
            var client = new XMLHttpRequest();
            client.open("GET",url,false);
            client.send();
            return client;
        }

        numeric.imageURL = function imageURL(img) {
            function base64(A) {
                var n = A.length, i,x,y,z,p,q,r,s;
                var key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                var ret = "";
                for(i=0;i<n;i+=3) {
                    x = A[i];
                    y = A[i+1];
                    z = A[i+2];
                    p = x >> 2;
                    q = ((x & 3) << 4) + (y >> 4);
                    r = ((y & 15) << 2) + (z >> 6);
                    s = z & 63;
                    if(i+1>=n) { r = s = 64; }
                    else if(i+2>=n) { s = 64; }
                    ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);
                }
                return ret;
            }
            function crc32Array (a,from,to) {
                if(typeof from === "undefined") { from = 0; }
                if(typeof to === "undefined") { to = a.length; }
                var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
                    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
                    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
                    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
                    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
                    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
                    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
                    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
                    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
                    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
                    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
                    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
                    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
                    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
                    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
                    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
                    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
                    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
                    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
                    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
                    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
                    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
                    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
                    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
                    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
                    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
                    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
                    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
                    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
                    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
                    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
                    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

                var crc = -1, y = 0, n = a.length,i;

                for (i = from; i < to; i++) {
                    y = (crc ^ a[i]) & 0xFF;
                    crc = (crc >>> 8) ^ table[y];
                }

                return crc ^ (-1);
            }

            var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;
            var stream = [
                137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature
                0,0,0,13,                                                  //  8: IHDR Chunk length
                73, 72, 68, 82,                                            // 12: "IHDR"
                (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width
                (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height
                8,                                                         // 24: bit depth
                2,                                                         // 25: RGB
                0,                                                         // 26: deflate
                0,                                                         // 27: no filter
                0,                                                         // 28: no interlace
                -1,-2,-3,-4,                                               // 29: CRC
                -5,-6,-7,-8,                                               // 33: IDAT Chunk length
                73, 68, 65, 84,                                            // 37: "IDAT"
                // RFC 1950 header starts here
                8,                                                         // 41: RFC1950 CMF
                29                                                         // 42: RFC1950 FLG
            ];
            crc32 = crc32Array(stream,12,29);
            stream[29] = (crc32>>24)&255;
            stream[30] = (crc32>>16)&255;
            stream[31] = (crc32>>8)&255;
            stream[32] = (crc32)&255;
            s1 = 1;
            s2 = 0;
            for(i=0;i<h;i++) {
                if(i<h-1) { stream.push(0); }
                else { stream.push(1); }
                a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;
                stream.push(a); stream.push(b);
                stream.push((~a)&255); stream.push((~b)&255);
                if(i===0) stream.push(0);
                for(j=0;j<w;j++) {
                    for(k=0;k<3;k++) {
                        a = img[k][i][j];
                        if(a>255) a = 255;
                        else if(a<0) a=0;
                        else a = Math.round(a);
                        s1 = (s1 + a )%65521;
                        s2 = (s2 + s1)%65521;
                        stream.push(a);
                    }
                }
                stream.push(0);
            }
            adler32 = (s2<<16)+s1;
            stream.push((adler32>>24)&255);
            stream.push((adler32>>16)&255);
            stream.push((adler32>>8)&255);
            stream.push((adler32)&255);
            length = stream.length - 41;
            stream[33] = (length>>24)&255;
            stream[34] = (length>>16)&255;
            stream[35] = (length>>8)&255;
            stream[36] = (length)&255;
            crc32 = crc32Array(stream,37);
            stream.push((crc32>>24)&255);
            stream.push((crc32>>16)&255);
            stream.push((crc32>>8)&255);
            stream.push((crc32)&255);
            stream.push(0);
            stream.push(0);
            stream.push(0);
            stream.push(0);
//    a = stream.length;
            stream.push(73);  // I
            stream.push(69);  // E
            stream.push(78);  // N
            stream.push(68);  // D
            stream.push(174); // CRC1
            stream.push(66);  // CRC2
            stream.push(96);  // CRC3
            stream.push(130); // CRC4
            return 'data:image/png;base64,'+base64(stream);
        }

// 2. Linear algebra with Arrays.
        numeric._dim = function _dim(x) {
            var ret = [];
            while(typeof x === "object") { ret.push(x.length); x = x[0]; }
            return ret;
        }

        numeric.dim = function dim(x) {
            var y,z;
            if(typeof x === "object") {
                y = x[0];
                if(typeof y === "object") {
                    z = y[0];
                    if(typeof z === "object") {
                        return numeric._dim(x);
                    }
                    return [x.length,y.length];
                }
                return [x.length];
            }
            return [];
        }

        numeric.mapreduce = function mapreduce(body,init) {
            return Function('x','accum','_s','_k',
                'if(typeof accum === "undefined") accum = '+init+';\n'+
                'if(typeof x === "number") { var xi = x; '+body+'; return accum; }\n'+
                'if(typeof _s === "undefined") _s = numeric.dim(x);\n'+
                'if(typeof _k === "undefined") _k = 0;\n'+
                'var _n = _s[_k];\n'+
                'var i,xi;\n'+
                'if(_k < _s.length-1) {\n'+
                '    for(i=_n-1;i>=0;i--) {\n'+
                '        accum = arguments.callee(x[i],accum,_s,_k+1);\n'+
                '    }'+
                '    return accum;\n'+
                '}\n'+
                'for(i=_n-1;i>=1;i-=2) { \n'+
                '    xi = x[i];\n'+
                '    '+body+';\n'+
                '    xi = x[i-1];\n'+
                '    '+body+';\n'+
                '}\n'+
                'if(i === 0) {\n'+
                '    xi = x[i];\n'+
                '    '+body+'\n'+
                '}\n'+
                'return accum;'
            );
        }
        numeric.mapreduce2 = function mapreduce2(body,setup) {
            return Function('x',
                'var n = x.length;\n'+
                'var i,xi;\n'+setup+';\n'+
                'for(i=n-1;i!==-1;--i) { \n'+
                '    xi = x[i];\n'+
                '    '+body+';\n'+
                '}\n'+
                'return accum;'
            );
        }


        numeric.same = function same(x,y) {
            var i,n;
            if(!(x instanceof Array) || !(y instanceof Array)) { return false; }
            n = x.length;
            if(n !== y.length) { return false; }
            for(i=0;i<n;i++) {
                if(x[i] === y[i]) { continue; }
                if(typeof x[i] === "object") { if(!same(x[i],y[i])) return false; }
                else { return false; }
            }
            return true;
        }

        numeric.rep = function rep(s,v,k) {
            if(typeof k === "undefined") { k=0; }
            var n = s[k], ret = Array(n), i;
            if(k === s.length-1) {
                for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }
                if(i===-1) { ret[0] = v; }
                return ret;
            }
            for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }
            return ret;
        }


        numeric.dotMMsmall = function dotMMsmall(x,y) {
            var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;
            p = x.length; q = y.length; r = y[0].length;
            ret = Array(p);
            for(i=p-1;i>=0;i--) {
                foo = Array(r);
                bar = x[i];
                for(k=r-1;k>=0;k--) {
                    woo = bar[q-1]*y[q-1][k];
                    for(j=q-2;j>=1;j-=2) {
                        i0 = j-1;
                        woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];
                    }
                    if(j===0) { woo += bar[0]*y[0][k]; }
                    foo[k] = woo;
                }
                ret[i] = foo;
            }
            return ret;
        }
        numeric._getCol = function _getCol(A,j,x) {
            var n = A.length, i;
            for(i=n-1;i>0;--i) {
                x[i] = A[i][j];
                --i;
                x[i] = A[i][j];
            }
            if(i===0) x[0] = A[0][j];
        }
        numeric.dotMMbig = function dotMMbig(x,y){
            var gc = numeric._getCol, p = y.length, v = Array(p);
            var m = x.length, n = y[0].length, A = new Array(m), xj;
            var VV = numeric.dotVV;
            var i,j,k,z;
            --p;
            --m;
            for(i=m;i!==-1;--i) A[i] = Array(n);
            --n;
            for(i=n;i!==-1;--i) {
                gc(y,i,v);
                for(j=m;j!==-1;--j) {
                    z=0;
                    xj = x[j];
                    A[j][i] = VV(xj,v);
                }
            }
            return A;
        }

        numeric.dotMV = function dotMV(x,y) {
            var p = x.length, q = y.length,i;
            var ret = Array(p), dotVV = numeric.dotVV;
            for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }
            return ret;
        }

        numeric.dotVM = function dotVM(x,y) {
            var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;
            p = x.length; q = y[0].length;
            ret = Array(q);
            for(k=q-1;k>=0;k--) {
                woo = x[p-1]*y[p-1][k];
                for(j=p-2;j>=1;j-=2) {
                    i0 = j-1;
                    woo += x[j]*y[j][k] + x[i0]*y[i0][k];
                }
                if(j===0) { woo += x[0]*y[0][k]; }
                ret[k] = woo;
            }
            return ret;
        }

        numeric.dotVV = function dotVV(x,y) {
            var i,n=x.length,i1,ret = x[n-1]*y[n-1];
            for(i=n-2;i>=1;i-=2) {
                i1 = i-1;
                ret += x[i]*y[i] + x[i1]*y[i1];
            }
            if(i===0) { ret += x[0]*y[0]; }
            return ret;
        }

        numeric.dot = function dot(x,y) {
            var d = numeric.dim;
            switch(d(x).length*1000+d(y).length) {
                case 2002:
                    if(y.length < 10) return numeric.dotMMsmall(x,y);
                    else return numeric.dotMMbig(x,y);
                case 2001: return numeric.dotMV(x,y);
                case 1002: return numeric.dotVM(x,y);
                case 1001: return numeric.dotVV(x,y);
                case 1000: return numeric.mulVS(x,y);
                case 1: return numeric.mulSV(x,y);
                case 0: return x*y;
                default: throw new Error('numeric.dot only works on vectors and matrices');
            }
        }

        numeric.diag = function diag(d) {
            var i,i1,j,n = d.length, A = Array(n), Ai;
            for(i=n-1;i>=0;i--) {
                Ai = Array(n);
                i1 = i+2;
                for(j=n-1;j>=i1;j-=2) {
                    Ai[j] = 0;
                    Ai[j-1] = 0;
                }
                if(j>i) { Ai[j] = 0; }
                Ai[i] = d[i];
                for(j=i-1;j>=1;j-=2) {
                    Ai[j] = 0;
                    Ai[j-1] = 0;
                }
                if(j===0) { Ai[0] = 0; }
                A[i] = Ai;
            }
            return A;
        }
        numeric.getDiag = function(A) {
            var n = Math.min(A.length,A[0].length),i,ret = Array(n);
            for(i=n-1;i>=1;--i) {
                ret[i] = A[i][i];
                --i;
                ret[i] = A[i][i];
            }
            if(i===0) {
                ret[0] = A[0][0];
            }
            return ret;
        }

        numeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }
        numeric.pointwise = function pointwise(params,body,setup) {
            if(typeof setup === "undefined") { setup = ""; }
            var fun = [];
            var k;
            var avec = /\[i\]$/,p,thevec = '';
            var haveret = false;
            for(k=0;k<params.length;k++) {
                if(avec.test(params[k])) {
                    p = params[k].substring(0,params[k].length-3);
                    thevec = p;
                } else { p = params[k]; }
                if(p==='ret') haveret = true;
                fun.push(p);
            }
            fun[params.length] = '_s';
            fun[params.length+1] = '_k';
            fun[params.length+2] = (
                'if(typeof _s === "undefined") _s = numeric.dim('+thevec+');\n'+
                'if(typeof _k === "undefined") _k = 0;\n'+
                'var _n = _s[_k];\n'+
                'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
                'if(_k < _s.length-1) {\n'+
                '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\n'+
                '    return ret;\n'+
                '}\n'+
                setup+'\n'+
                'for(i=_n-1;i!==-1;--i) {\n'+
                '    '+body+'\n'+
                '}\n'+
                'return ret;'
            );
            return Function.apply(null,fun);
        }
        numeric.pointwise2 = function pointwise2(params,body,setup) {
            if(typeof setup === "undefined") { setup = ""; }
            var fun = [];
            var k;
            var avec = /\[i\]$/,p,thevec = '';
            var haveret = false;
            for(k=0;k<params.length;k++) {
                if(avec.test(params[k])) {
                    p = params[k].substring(0,params[k].length-3);
                    thevec = p;
                } else { p = params[k]; }
                if(p==='ret') haveret = true;
                fun.push(p);
            }
            fun[params.length] = (
                'var _n = '+thevec+'.length;\n'+
                'var i'+(haveret?'':', ret = Array(_n)')+';\n'+
                setup+'\n'+
                'for(i=_n-1;i!==-1;--i) {\n'+
                body+'\n'+
                '}\n'+
                'return ret;'
            );
            return Function.apply(null,fun);
        }
        numeric._biforeach = (function _biforeach(x,y,s,k,f) {
            if(k === s.length-1) { f(x,y); return; }
            var i,n=s[k];
            for(i=n-1;i>=0;i--) { _biforeach(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
        });
        numeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {
            if(k === s.length-1) { return f(x,y); }
            var i,n=s[k],ret = Array(n);
            for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x==="object"?x[i]:x,typeof y==="object"?y[i]:y,s,k+1,f); }
            return ret;
        });
        numeric._foreach = (function _foreach(x,s,k,f) {
            if(k === s.length-1) { f(x); return; }
            var i,n=s[k];
            for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }
        });
        numeric._foreach2 = (function _foreach2(x,s,k,f) {
            if(k === s.length-1) { return f(x); }
            var i,n=s[k], ret = Array(n);
            for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }
            return ret;
        });

        /*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');
numeric.allV = numeric.mapreduce('if(!xi) return false;','true');
numeric.any = function(x) { if(typeof x.length === "undefined") return x; return numeric.anyV(x); }
numeric.all = function(x) { if(typeof x.length === "undefined") return x; return numeric.allV(x); }*/

        numeric.ops2 = {
            add: '+',
            sub: '-',
            mul: '*',
            div: '/',
            mod: '%',
            and: '&&',
            or:  '||',
            eq:  '===',
            neq: '!==',
            lt:  '<',
            gt:  '>',
            leq: '<=',
            geq: '>=',
            band: '&',
            bor: '|',
            bxor: '^',
            lshift: '<<',
            rshift: '>>',
            rrshift: '>>>'
        };
        numeric.opseq = {
            addeq: '+=',
            subeq: '-=',
            muleq: '*=',
            diveq: '/=',
            modeq: '%=',
            lshifteq: '<<=',
            rshifteq: '>>=',
            rrshifteq: '>>>=',
            bandeq: '&=',
            boreq: '|=',
            bxoreq: '^='
        };
        numeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',
            'exp','floor','log','round','sin','sqrt','tan',
            'isNaN','isFinite'];
        numeric.mathfuns2 = ['atan2','pow','max','min'];
        numeric.ops1 = {
            neg: '-',
            not: '!',
            bnot: '~',
            clone: ''
        };
        numeric.mapreducers = {
            any: ['if(xi) return true;','var accum = false;'],
            all: ['if(!xi) return false;','var accum = true;'],
            sum: ['accum += xi;','var accum = 0;'],
            prod: ['accum *= xi;','var accum = 1;'],
            norm2Squared: ['accum += xi*xi;','var accum = 0;'],
            norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],
            norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],
            sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],
            inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']
        };

        (function () {
            var i,o;
            for(i=0;i<numeric.mathfuns2.length;++i) {
                o = numeric.mathfuns2[i];
                numeric.ops2[o] = o;
            }
            for(i in numeric.ops2) {
                if(numeric.ops2.hasOwnProperty(i)) {
                    o = numeric.ops2[i];
                    var code, codeeq, setup = '';
                    if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {
                        setup = 'var '+o+' = Math.'+o+';\n';
                        code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };
                        codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };
                    } else {
                        code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };
                        if(numeric.opseq.hasOwnProperty(i+'eq')) {
                            codeeq = function(x,y) { return x+' '+o+'= '+y; };
                        } else {
                            codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };
                        }
                    }
                    numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);
                    numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);
                    numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);
                    numeric[i] = Function(
                        'var n = arguments.length, i, x = arguments[0], y;\n'+
                        'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\n'+
                        'var dim = numeric.dim;\n'+
                        'for(i=1;i!==n;++i) { \n'+
                        '  y = arguments[i];\n'+
                        '  if(typeof x === "object") {\n'+
                        '      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n'+
                        '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n'+
                        '  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n'+
                        '  else '+codeeq('x','y')+'\n'+
                        '}\nreturn x;\n');
                    numeric[o] = numeric[i];
                    numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);
                    numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);
                    numeric[i+'eq'] = Function(
                        'var n = arguments.length, i, x = arguments[0], y;\n'+
                        'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\n'+
                        'var s = numeric.dim(x);\n'+
                        'for(i=1;i!==n;++i) { \n'+
                        '  y = arguments[i];\n'+
                        '  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n'+
                        '  else numeric._biforeach(x,y,s,0,S);\n'+
                        '}\nreturn x;\n');
                }
            }
            for(i=0;i<numeric.mathfuns2.length;++i) {
                o = numeric.mathfuns2[i];
                delete numeric.ops2[o];
            }
            for(i=0;i<numeric.mathfuns.length;++i) {
                o = numeric.mathfuns[i];
                numeric.ops1[o] = o;
            }
            for(i in numeric.ops1) {
                if(numeric.ops1.hasOwnProperty(i)) {
                    setup = '';
                    o = numeric.ops1[i];
                    if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {
                        if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\n';
                    }
                    numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);
                    numeric[i+'eq'] = Function('x',
                        'if(typeof x !== "object") return '+o+'x\n'+
                        'var i;\n'+
                        'var V = numeric.'+i+'eqV;\n'+
                        'var s = numeric.dim(x);\n'+
                        'numeric._foreach(x,s,0,V);\n'+
                        'return x;\n');
                    numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);
                    numeric[i] = Function('x',
                        'if(typeof x !== "object") return '+o+'(x)\n'+
                        'var i;\n'+
                        'var V = numeric.'+i+'V;\n'+
                        'var s = numeric.dim(x);\n'+
                        'return numeric._foreach2(x,s,0,V);\n');
                }
            }
            for(i=0;i<numeric.mathfuns.length;++i) {
                o = numeric.mathfuns[i];
                delete numeric.ops1[o];
            }
            for(i in numeric.mapreducers) {
                if(numeric.mapreducers.hasOwnProperty(i)) {
                    o = numeric.mapreducers[i];
                    numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);
                    numeric[i] = Function('x','s','k',
                        o[1]+
                        'if(typeof x !== "object") {'+
                        '    xi = x;\n'+
                        o[0]+';\n'+
                        '    return accum;\n'+
                        '}'+
                        'if(typeof s === "undefined") s = numeric.dim(x);\n'+
                        'if(typeof k === "undefined") k = 0;\n'+
                        'if(k === s.length-1) return numeric.'+i+'V(x);\n'+
                        'var xi;\n'+
                        'var n = x.length, i;\n'+
                        'for(i=n-1;i!==-1;--i) {\n'+
                        '   xi = arguments.callee(x[i]);\n'+
                        o[0]+';\n'+
                        '}\n'+
                        'return accum;\n');
                }
            }
        }());

        numeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');
        numeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');
        numeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');
        numeric.trunc = function trunc(x,y) {
            if(typeof x === "object") {
                if(typeof y === "object") return numeric.truncVV(x,y);
                return numeric.truncVS(x,y);
            }
            if (typeof y === "object") return numeric.truncSV(x,y);
            return Math.round(x/y)*y;
        }

        numeric.inv = function inv(x) {
            var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];
            var A = numeric.clone(x), Ai, Aj;
            var I = numeric.identity(m), Ii, Ij;
            var i,j,k,x;
            for(j=0;j<n;++j) {
                var i0 = -1;
                var v0 = -1;
                for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }
                Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;
                Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;
                x = Aj[j];
                for(k=j;k!==n;++k)    Aj[k] /= x;
                for(k=n-1;k!==-1;--k) Ij[k] /= x;
                for(i=m-1;i!==-1;--i) {
                    if(i!==j) {
                        Ai = A[i];
                        Ii = I[i];
                        x = Ai[j];
                        for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;
                        for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }
                        if(k===0) Ii[0] -= Ij[0]*x;
                    }
                }
            }
            return I;
        }

        numeric.det = function det(x) {
            var s = numeric.dim(x);
            if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }
            var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;
            for(j=0;j<n-1;j++) {
                k=j;
                for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }
                if(k !== j) {
                    temp = A[k]; A[k] = A[j]; A[j] = temp;
                    ret *= -1;
                }
                Aj = A[j];
                for(i=j+1;i<n;i++) {
                    Ai = A[i];
                    alpha = Ai[j]/Aj[j];
                    for(k=j+1;k<n-1;k+=2) {
                        k1 = k+1;
                        Ai[k] -= Aj[k]*alpha;
                        Ai[k1] -= Aj[k1]*alpha;
                    }
                    if(k!==n) { Ai[k] -= Aj[k]*alpha; }
                }
                if(Aj[j] === 0) { return 0; }
                ret *= Aj[j];
            }
            return ret*A[j][j];
        }

        numeric.transpose = function transpose(x) {
            var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
            for(j=0;j<n;j++) ret[j] = Array(m);
            for(i=m-1;i>=1;i-=2) {
                A1 = x[i];
                A0 = x[i-1];
                for(j=n-1;j>=1;--j) {
                    Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
                    --j;
                    Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];
                }
                if(j===0) {
                    Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];
                }
            }
            if(i===0) {
                A0 = x[0];
                for(j=n-1;j>=1;--j) {
                    ret[j][0] = A0[j];
                    --j;
                    ret[j][0] = A0[j];
                }
                if(j===0) { ret[0][0] = A0[0]; }
            }
            return ret;
        }
        numeric.negtranspose = function negtranspose(x) {
            var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;
            for(j=0;j<n;j++) ret[j] = Array(m);
            for(i=m-1;i>=1;i-=2) {
                A1 = x[i];
                A0 = x[i-1];
                for(j=n-1;j>=1;--j) {
                    Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
                    --j;
                    Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];
                }
                if(j===0) {
                    Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];
                }
            }
            if(i===0) {
                A0 = x[0];
                for(j=n-1;j>=1;--j) {
                    ret[j][0] = -A0[j];
                    --j;
                    ret[j][0] = -A0[j];
                }
                if(j===0) { ret[0][0] = -A0[0]; }
            }
            return ret;
        }

        numeric._random = function _random(s,k) {
            var i,n=s[k],ret=Array(n), rnd;
            if(k === s.length-1) {
                rnd = Math.random;
                for(i=n-1;i>=1;i-=2) {
                    ret[i] = rnd();
                    ret[i-1] = rnd();
                }
                if(i===0) { ret[0] = rnd(); }
                return ret;
            }
            for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);
            return ret;
        }
        numeric.random = function random(s) { return numeric._random(s,0); }

        numeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }

        numeric.linspace = function linspace(a,b,n) {
            if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
            if(n<2) { return n===1?[a]:[]; }
            var i,ret = Array(n);
            n--;
            for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
            return ret;
        }

        numeric.getBlock = function getBlock(x,from,to) {
            var s = numeric.dim(x);
            function foo(x,k) {
                var i,a = from[k], n = to[k]-a, ret = Array(n);
                if(k === s.length-1) {
                    for(i=n;i>=0;i--) { ret[i] = x[i+a]; }
                    return ret;
                }
                for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }
                return ret;
            }
            return foo(x,0);
        }

        numeric.setBlock = function setBlock(x,from,to,B) {
            var s = numeric.dim(x);
            function foo(x,y,k) {
                var i,a = from[k], n = to[k]-a;
                if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }
                for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }
            }
            foo(x,B,0);
            return x;
        }

        numeric.getRange = function getRange(A,I,J) {
            var m = I.length, n = J.length;
            var i,j;
            var B = Array(m), Bi, AI;
            for(i=m-1;i!==-1;--i) {
                B[i] = Array(n);
                Bi = B[i];
                AI = A[I[i]];
                for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];
            }
            return B;
        }

        numeric.blockMatrix = function blockMatrix(X) {
            var s = numeric.dim(X);
            if(s.length<4) return numeric.blockMatrix([X]);
            var m=s[0],n=s[1],M,N,i,j,Xij;
            M = 0; N = 0;
            for(i=0;i<m;++i) M+=X[i][0].length;
            for(j=0;j<n;++j) N+=X[0][j][0].length;
            var Z = Array(M);
            for(i=0;i<M;++i) Z[i] = Array(N);
            var I=0,J,ZI,k,l,Xijk;
            for(i=0;i<m;++i) {
                J=N;
                for(j=n-1;j!==-1;--j) {
                    Xij = X[i][j];
                    J -= Xij[0].length;
                    for(k=Xij.length-1;k!==-1;--k) {
                        Xijk = Xij[k];
                        ZI = Z[I+k];
                        for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];
                    }
                }
                I += X[i][0].length;
            }
            return Z;
        }

        numeric.tensor = function tensor(x,y) {
            if(typeof x === "number" || typeof y === "number") return numeric.mul(x,y);
            var s1 = numeric.dim(x), s2 = numeric.dim(y);
            if(s1.length !== 1 || s2.length !== 1) {
                throw new Error('numeric: tensor product is only defined for vectors');
            }
            var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;
            for(i=m-1;i>=0;i--) {
                Ai = Array(n);
                xi = x[i];
                for(j=n-1;j>=3;--j) {
                    Ai[j] = xi * y[j];
                    --j;
                    Ai[j] = xi * y[j];
                    --j;
                    Ai[j] = xi * y[j];
                    --j;
                    Ai[j] = xi * y[j];
                }
                while(j>=0) { Ai[j] = xi * y[j]; --j; }
                A[i] = Ai;
            }
            return A;
        }

// 3. The Tensor type T
        numeric.T = function T(x,y) { this.x = x; this.y = y; }
        numeric.t = function t(x,y) { return new numeric.T(x,y); }

        numeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {
            var io = numeric.indexOf;
            if(typeof setup !== "string") {
                var k;
                setup = '';
                for(k in numeric) {
                    if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {
                        setup += 'var '+k+' = numeric.'+k+';\n';
                    }
                }
            }
            return Function(['y'],
                'var x = this;\n'+
                'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n'+
                setup+'\n'+
                'if(x.y) {'+
                '  if(y.y) {'+
                '    return new numeric.T('+cc+');\n'+
                '  }\n'+
                '  return new numeric.T('+cr+');\n'+
                '}\n'+
                'if(y.y) {\n'+
                '  return new numeric.T('+rc+');\n'+
                '}\n'+
                'return new numeric.T('+rr+');\n'
            );
        }

        numeric.T.prototype.add = numeric.Tbinop(
            'add(x.x,y.x)',
            'add(x.x,y.x),y.y',
            'add(x.x,y.x),x.y',
            'add(x.x,y.x),add(x.y,y.y)');
        numeric.T.prototype.sub = numeric.Tbinop(
            'sub(x.x,y.x)',
            'sub(x.x,y.x),neg(y.y)',
            'sub(x.x,y.x),x.y',
            'sub(x.x,y.x),sub(x.y,y.y)');
        numeric.T.prototype.mul = numeric.Tbinop(
            'mul(x.x,y.x)',
            'mul(x.x,y.x),mul(x.x,y.y)',
            'mul(x.x,y.x),mul(x.y,y.x)',
            'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');

        numeric.T.prototype.reciprocal = function reciprocal() {
            var mul = numeric.mul, div = numeric.div;
            if(this.y) {
                var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));
                return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));
            }
            return new T(div(1,this.x));
        }
        numeric.T.prototype.div = function div(y) {
            if(!(y instanceof numeric.T)) y = new numeric.T(y);
            if(y.y) { return this.mul(y.reciprocal()); }
            var div = numeric.div;
            if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }
            return new numeric.T(div(this.x,y.x));
        }
        numeric.T.prototype.dot = numeric.Tbinop(
            'dot(x.x,y.x)',
            'dot(x.x,y.x),dot(x.x,y.y)',
            'dot(x.x,y.x),dot(x.y,y.x)',
            'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'
        );
        numeric.T.prototype.transpose = function transpose() {
            var t = numeric.transpose, x = this.x, y = this.y;
            if(y) { return new numeric.T(t(x),t(y)); }
            return new numeric.T(t(x));
        }
        numeric.T.prototype.transjugate = function transjugate() {
            var t = numeric.transpose, x = this.x, y = this.y;
            if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }
            return new numeric.T(t(x));
        }
        numeric.Tunop = function Tunop(r,c,s) {
            if(typeof s !== "string") { s = ''; }
            return Function(
                'var x = this;\n'+
                s+'\n'+
                'if(x.y) {'+
                '  '+c+';\n'+
                '}\n'+
                r+';\n'
            );
        }

        numeric.T.prototype.exp = numeric.Tunop(
            'return new numeric.T(ex)',
            'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',
            'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');
        numeric.T.prototype.conj = numeric.Tunop(
            'return new numeric.T(x.x);',
            'return new numeric.T(x.x,numeric.neg(x.y));');
        numeric.T.prototype.neg = numeric.Tunop(
            'return new numeric.T(neg(x.x));',
            'return new numeric.T(neg(x.x),neg(x.y));',
            'var neg = numeric.neg;');
        numeric.T.prototype.sin = numeric.Tunop(
            'return new numeric.T(numeric.sin(x.x))',
            'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');
        numeric.T.prototype.cos = numeric.Tunop(
            'return new numeric.T(numeric.cos(x.x))',
            'return x.exp().add(x.neg().exp()).div(2);');
        numeric.T.prototype.abs = numeric.Tunop(
            'return new numeric.T(numeric.abs(x.x));',
            'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',
            'var mul = numeric.mul;');
        numeric.T.prototype.log = numeric.Tunop(
            'return new numeric.T(numeric.log(x.x));',
            'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\n'+
            'return new numeric.T(numeric.log(r.x),theta.x);');
        numeric.T.prototype.norm2 = numeric.Tunop(
            'return numeric.norm2(x.x);',
            'var f = numeric.norm2Squared;\n'+
            'return Math.sqrt(f(x.x)+f(x.y));');
        numeric.T.prototype.inv = function inv() {
            var A = this;
            if(typeof A.y === "undefined") { return new numeric.T(numeric.inv(A.x)); }
            var n = A.x.length, i, j, k;
            var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);
            var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);
            var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;
            var i,j,k,d,d1,ax,ay,bx,by,temp;
            for(i=0;i<n;i++) {
                ax = Ax[i][i]; ay = Ay[i][i];
                d = ax*ax+ay*ay;
                k = i;
                for(j=i+1;j<n;j++) {
                    ax = Ax[j][i]; ay = Ay[j][i];
                    d1 = ax*ax+ay*ay;
                    if(d1 > d) { k=j; d = d1; }
                }
                if(k!==i) {
                    temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;
                    temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;
                    temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;
                    temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;
                }
                Aix = Ax[i]; Aiy = Ay[i];
                Rix = Rx[i]; Riy = Ry[i];
                ax = Aix[i]; ay = Aiy[i];
                for(j=i+1;j<n;j++) {
                    bx = Aix[j]; by = Aiy[j];
                    Aix[j] = (bx*ax+by*ay)/d;
                    Aiy[j] = (by*ax-bx*ay)/d;
                }
                for(j=0;j<n;j++) {
                    bx = Rix[j]; by = Riy[j];
                    Rix[j] = (bx*ax+by*ay)/d;
                    Riy[j] = (by*ax-bx*ay)/d;
                }
                for(j=i+1;j<n;j++) {
                    Ajx = Ax[j]; Ajy = Ay[j];
                    Rjx = Rx[j]; Rjy = Ry[j];
                    ax = Ajx[i]; ay = Ajy[i];
                    for(k=i+1;k<n;k++) {
                        bx = Aix[k]; by = Aiy[k];
                        Ajx[k] -= bx*ax-by*ay;
                        Ajy[k] -= by*ax+bx*ay;
                    }
                    for(k=0;k<n;k++) {
                        bx = Rix[k]; by = Riy[k];
                        Rjx[k] -= bx*ax-by*ay;
                        Rjy[k] -= by*ax+bx*ay;
                    }
                }
            }
            for(i=n-1;i>0;i--) {
                Rix = Rx[i]; Riy = Ry[i];
                for(j=i-1;j>=0;j--) {
                    Rjx = Rx[j]; Rjy = Ry[j];
                    ax = Ax[j][i]; ay = Ay[j][i];
                    for(k=n-1;k>=0;k--) {
                        bx = Rix[k]; by = Riy[k];
                        Rjx[k] -= ax*bx - ay*by;
                        Rjy[k] -= ax*by + ay*bx;
                    }
                }
            }
            return new numeric.T(Rx,Ry);
        }
        numeric.T.prototype.get = function get(i) {
            var x = this.x, y = this.y, k = 0, ik, n = i.length;
            if(y) {
                while(k<n) {
                    ik = i[k];
                    x = x[ik];
                    y = y[ik];
                    k++;
                }
                return new numeric.T(x,y);
            }
            while(k<n) {
                ik = i[k];
                x = x[ik];
                k++;
            }
            return new numeric.T(x);
        }
        numeric.T.prototype.set = function set(i,v) {
            var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;
            if(n===0) {
                if(vy) { this.y = vy; }
                else if(y) { this.y = undefined; }
                this.x = x;
                return this;
            }
            if(vy) {
                if(y) { /* ok */ }
                else {
                    y = numeric.rep(numeric.dim(x),0);
                    this.y = y;
                }
                while(k<n-1) {
                    ik = i[k];
                    x = x[ik];
                    y = y[ik];
                    k++;
                }
                ik = i[k];
                x[ik] = vx;
                y[ik] = vy;
                return this;
            }
            if(y) {
                while(k<n-1) {
                    ik = i[k];
                    x = x[ik];
                    y = y[ik];
                    k++;
                }
                ik = i[k];
                x[ik] = vx;
                if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);
                else y[ik] = 0;
                return this;
            }
            while(k<n-1) {
                ik = i[k];
                x = x[ik];
                k++;
            }
            ik = i[k];
            x[ik] = vx;
            return this;
        }
        numeric.T.prototype.getRows = function getRows(i0,i1) {
            var n = i1-i0+1, j;
            var rx = Array(n), ry, x = this.x, y = this.y;
            for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }
            if(y) {
                ry = Array(n);
                for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }
                return new numeric.T(rx,ry);
            }
            return new numeric.T(rx);
        }
        numeric.T.prototype.setRows = function setRows(i0,i1,A) {
            var j;
            var rx = this.x, ry = this.y, x = A.x, y = A.y;
            for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }
            if(y) {
                if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
                for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }
            } else if(ry) {
                for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }
            }
            return this;
        }
        numeric.T.prototype.getRow = function getRow(k) {
            var x = this.x, y = this.y;
            if(y) { return new numeric.T(x[k],y[k]); }
            return new numeric.T(x[k]);
        }
        numeric.T.prototype.setRow = function setRow(i,v) {
            var rx = this.x, ry = this.y, x = v.x, y = v.y;
            rx[i] = x;
            if(y) {
                if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }
                ry[i] = y;
            } else if(ry) {
                ry = numeric.rep([x.length],0);
            }
            return this;
        }

        numeric.T.prototype.getBlock = function getBlock(from,to) {
            var x = this.x, y = this.y, b = numeric.getBlock;
            if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }
            return new numeric.T(b(x,from,to));
        }
        numeric.T.prototype.setBlock = function setBlock(from,to,A) {
            if(!(A instanceof numeric.T)) A = new numeric.T(A);
            var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;
            if(Ay) {
                if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }
                b(x,from,to,Ax);
                b(y,from,to,Ay);
                return this;
            }
            b(x,from,to,Ax);
            if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));
        }
        numeric.T.rep = function rep(s,v) {
            var T = numeric.T;
            if(!(v instanceof T)) v = new T(v);
            var x = v.x, y = v.y, r = numeric.rep;
            if(y) return new T(r(s,x),r(s,y));
            return new T(r(s,x));
        }
        numeric.T.diag = function diag(d) {
            if(!(d instanceof numeric.T)) d = new numeric.T(d);
            var x = d.x, y = d.y, diag = numeric.diag;
            if(y) return new numeric.T(diag(x),diag(y));
            return new numeric.T(diag(x));
        }
        numeric.T.eig = function eig() {
            if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }
            return numeric.eig(this.x);
        }
        numeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }
        numeric.T.prototype.getDiag = function getDiag() {
            var n = numeric;
            var x = this.x, y = this.y;
            if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }
            return new n.T(n.getDiag(x));
        }

// 4. Eigenvalues of real matrices

        numeric.house = function house(x) {
            var v = numeric.clone(x);
            var s = x[0] >= 0 ? 1 : -1;
            var alpha = s*numeric.norm2(x);
            v[0] += alpha;
            var foo = numeric.norm2(v);
            if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }
            return numeric.div(v,foo);
        }

        numeric.toUpperHessenberg = function toUpperHessenberg(me) {
            var s = numeric.dim(me);
            if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }
            var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;
            for(j=0;j<m-2;j++) {
                x = Array(m-j-1);
                for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }
                if(numeric.norm2(x)>0) {
                    v = numeric.house(x);
                    B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);
                    C = numeric.tensor(v,numeric.dot(v,B));
                    for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }
                    B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);
                    C = numeric.tensor(numeric.dot(B,v),v);
                    for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }
                    B = Array(m-j-1);
                    for(i=j+1;i<m;i++) B[i-j-1] = Q[i];
                    C = numeric.tensor(v,numeric.dot(v,B));
                    for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
                }
            }
            return {H:A, Q:Q};
        }

        numeric.epsilon = 2.220446049250313e-16;

        numeric.QRFrancis = function(H,maxiter) {
            if(typeof maxiter === "undefined") { maxiter = 10000; }
            H = numeric.clone(H);
            var H0 = numeric.clone(H);
            var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;
            if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }
            var epsilon = numeric.epsilon;
            for(iter=0;iter<maxiter;iter++) {
                for(j=0;j<m-1;j++) {
                    if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {
                        var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);
                        var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);
                        B = Array(j+1);
                        for(i=0;i<=j;i++) { B[i] = Q[i]; }
                        C = numeric.dot(QH1.Q,B);
                        for(i=0;i<=j;i++) { Q[i] = C[i]; }
                        B = Array(m-j-1);
                        for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }
                        C = numeric.dot(QH2.Q,B);
                        for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }
                        return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};
                    }
                }
                a = H[m-2][m-2]; b = H[m-2][m-1];
                c = H[m-1][m-2]; d = H[m-1][m-1];
                tr = a+d;
                det = (a*d-b*c);
                Hloc = numeric.getBlock(H, [0,0], [2,2]);
                if(tr*tr>=4*det) {
                    var s1,s2;
                    s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));
                    s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));
                    Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                        numeric.mul(Hloc,s1+s2)),
                        numeric.diag(numeric.rep([3],s1*s2)));
                } else {
                    Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),
                        numeric.mul(Hloc,tr)),
                        numeric.diag(numeric.rep([3],det)));
                }
                x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];
                v = numeric.house(x);
                B = [H[0],H[1],H[2]];
                C = numeric.tensor(v,numeric.dot(v,B));
                for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }
                B = numeric.getBlock(H, [0,0],[m-1,2]);
                C = numeric.tensor(numeric.dot(B,v),v);
                for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }
                B = [Q[0],Q[1],Q[2]];
                C = numeric.tensor(v,numeric.dot(v,B));
                for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
                var J;
                for(j=0;j<m-2;j++) {
                    for(k=j;k<=j+1;k++) {
                        if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {
                            var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);
                            var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);
                            B = Array(k+1);
                            for(i=0;i<=k;i++) { B[i] = Q[i]; }
                            C = numeric.dot(QH1.Q,B);
                            for(i=0;i<=k;i++) { Q[i] = C[i]; }
                            B = Array(m-k-1);
                            for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }
                            C = numeric.dot(QH2.Q,B);
                            for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }
                            return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};
                        }
                    }
                    J = Math.min(m-1,j+3);
                    x = Array(J-j);
                    for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }
                    v = numeric.house(x);
                    B = numeric.getBlock(H, [j+1,j],[J,m-1]);
                    C = numeric.tensor(v,numeric.dot(v,B));
                    for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }
                    B = numeric.getBlock(H, [0,j+1],[m-1,J]);
                    C = numeric.tensor(numeric.dot(B,v),v);
                    for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }
                    B = Array(J-j);
                    for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];
                    C = numeric.tensor(v,numeric.dot(v,B));
                    for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }
                }
            }
            throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');
        }

        numeric.eig = function eig(A,maxiter) {
            var QH = numeric.toUpperHessenberg(A);
            var QB = numeric.QRFrancis(QH.H,maxiter);
            var T = numeric.T;
            var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));
            var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;
            var m = B.length,j;
            var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;
            var sqrt = Math.sqrt;
            for(k=0;k<m;k++) {
                i = B[k][0];
                if(i === B[k][1]) {
                    // nothing
                } else {
                    j = i+1;
                    a = H[i][i];
                    b = H[i][j];
                    c = H[j][i];
                    d = H[j][j];
                    if(b === 0 && c === 0) continue;
                    p1 = -a-d;
                    p2 = a*d-b*c;
                    disc = p1*p1-4*p2;
                    if(disc>=0) {
                        if(p1<0) x = -0.5*(p1-sqrt(disc));
                        else     x = -0.5*(p1+sqrt(disc));
                        n1 = (a-x)*(a-x)+b*b;
                        n2 = c*c+(d-x)*(d-x);
                        if(n1>n2) {
                            n1 = sqrt(n1);
                            p = (a-x)/n1;
                            q = b/n1;
                        } else {
                            n2 = sqrt(n2);
                            p = c/n2;
                            q = (d-x)/n2;
                        }
                        Q0 = new T([[q,-p],[p,q]]);
                        Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
                    } else {
                        x = -0.5*p1;
                        y = 0.5*sqrt(-disc);
                        n1 = (a-x)*(a-x)+b*b;
                        n2 = c*c+(d-x)*(d-x);
                        if(n1>n2) {
                            n1 = sqrt(n1+y*y);
                            p = (a-x)/n1;
                            q = b/n1;
                            x = 0;
                            y /= n1;
                        } else {
                            n2 = sqrt(n2+y*y);
                            p = c/n2;
                            q = (d-x)/n2;
                            x = y/n2;
                            y = 0;
                        }
                        Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);
                        Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));
                    }
                }
            }
            var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);
            for(j=0;j<n;j++) {
                if(j>0) {
                    for(k=j-1;k>=0;k--) {
                        var Rk = R.get([k,k]), Rj = R.get([j,j]);
                        if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {
                            x = R.getRow(k).getBlock([k],[j-1]);
                            y = E.getRow(j).getBlock([k],[j-1]);
                            E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));
                        } else {
                            E.setRow(j,E.getRow(k));
                            continue;
                        }
                    }
                }
            }
            for(j=0;j<n;j++) {
                x = E.getRow(j);
                E.setRow(j,x.div(x.norm2()));
            }
            E = E.transpose();
            E = Q.transjugate().dot(E);
            return { lambda:R.getDiag(), E:E };
        };

// 5. Compressed Column Storage matrices
        numeric.ccsSparse = function ccsSparse(A) {
            var m = A.length,n,foo, i,j, counts = [];
            for(i=m-1;i!==-1;--i) {
                foo = A[i];
                for(j in foo) {
                    j = parseInt(j);
                    while(j>=counts.length) counts[counts.length] = 0;
                    if(foo[j]!==0) counts[j]++;
                }
            }
            var n = counts.length;
            var Ai = Array(n+1);
            Ai[0] = 0;
            for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];
            var Aj = Array(Ai[n]), Av = Array(Ai[n]);
            for(i=m-1;i!==-1;--i) {
                foo = A[i];
                for(j in foo) {
                    if(foo[j]!==0) {
                        counts[j]--;
                        Aj[Ai[j]+counts[j]] = i;
                        Av[Ai[j]+counts[j]] = foo[j];
                    }
                }
            }
            return [Ai,Aj,Av];
        }
        numeric.ccsFull = function ccsFull(A) {
            var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;
            var B = numeric.rep([m,n],0);
            for(i=0;i<n;i++) {
                j0 = Ai[i];
                j1 = Ai[i+1];
                for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }
            }
            return B;
        }
        numeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {
            var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;
            if(typeof bj === "undefined") x = numeric.rep([m],0);
            if(typeof bj === "undefined") bj = numeric.linspace(0,x.length-1);
            if(typeof xj === "undefined") xj = [];
            function dfs(j) {
                var k;
                if(x[j] !== 0) return;
                x[j] = 1;
                for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);
                xj[n] = j;
                ++n;
            }
            var i,j,j0,j1,k,l,l0,l1,a;
            for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }
            xj.length = n;
            for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
            for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }
            for(i=xj.length-1;i!==-1;--i) {
                j = xj[i];
                j0 = Ai[j];
                j1 = max(Ai[j+1],j0);
                for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }
                a = x[j];
                for(k=j0;k!==j1;++k) {
                    l = Aj[k];
                    if(l !== j) x[l] -= a*Av[k];
                }
            }
            return x;
        }
        numeric.ccsDFS = function ccsDFS(n) {
            this.k = Array(n);
            this.k1 = Array(n);
            this.j = Array(n);
        }
        numeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {
            var m = 0,foo,n=xj.length;
            var k = this.k, k1 = this.k1, j = this.j,km,k11;
            if(x[J]!==0) return;
            x[J] = 1;
            j[0] = J;
            k[0] = km = Ai[J];
            k1[0] = k11 = Ai[J+1];
            while(1) {
                if(km >= k11) {
                    xj[n] = j[m];
                    if(m===0) return;
                    ++n;
                    --m;
                    km = k[m];
                    k11 = k1[m];
                } else {
                    foo = Pinv[Aj[km]];
                    if(x[foo] === 0) {
                        x[foo] = 1;
                        k[m] = km;
                        ++m;
                        j[m] = foo;
                        km = Ai[foo];
                        k1[m] = k11 = Ai[foo+1];
                    } else ++km;
                }
            }
        }
        numeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {
            var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
            var Bi = B[0], Bj = B[1], Bv = B[2];

            var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
            i0 = Bi[I];
            i1 = Bi[I+1];
            xj.length = 0;
            for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }
            for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }
            for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }
            for(i=xj.length-1;i!==-1;--i) {
                j = xj[i];
                j0 = Ai[j];
                j1 = Ai[j+1];
                for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }
                a = x[j];
                for(k=j0;k<j1;++k) {
                    l = Pinv[Aj[k]];
                    if(l !== j) x[l] -= a*Av[k];
                }
            }
            return x;
        }
        numeric.ccsLUP1 = function ccsLUP1(A,threshold) {
            var m = A[0].length-1;
            var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
            var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
            var x = numeric.rep([m],0), xj = numeric.rep([m],0);
            var i,j,k,j0,j1,a,e,c,d,K;
            var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;
            var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
            var dfs = new numeric.ccsDFS(m);
            if(typeof threshold === "undefined") { threshold = 1; }
            for(i=0;i<m;++i) {
                sol(L,A,x,xj,i,Pinv,dfs);
                a = -1;
                e = -1;
                for(j=xj.length-1;j!==-1;--j) {
                    k = xj[j];
                    if(k <= i) continue;
                    c = abs(x[k]);
                    if(c > a) { e = k; a = c; }
                }
                if(abs(x[i])<threshold*a) {
                    j = P[i];
                    a = P[e];
                    P[i] = a; Pinv[a] = i;
                    P[e] = j; Pinv[j] = e;
                    a = x[i]; x[i] = x[e]; x[e] = a;
                }
                a = Li[i];
                e = Ui[i];
                d = x[i];
                Lj[a] = P[i];
                Lv[a] = 1;
                ++a;
                for(j=xj.length-1;j!==-1;--j) {
                    k = xj[j];
                    c = x[k];
                    xj[j] = 0;
                    x[k] = 0;
                    if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
                    else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
                }
                Li[i+1] = a;
                Ui[i+1] = e;
            }
            for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
            return {L:L, U:U, P:P, Pinv:Pinv};
        }
        numeric.ccsDFS0 = function ccsDFS0(n) {
            this.k = Array(n);
            this.k1 = Array(n);
            this.j = Array(n);
        }
        numeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {
            var m = 0,foo,n=xj.length;
            var k = this.k, k1 = this.k1, j = this.j,km,k11;
            if(x[J]!==0) return;
            x[J] = 1;
            j[0] = J;
            k[0] = km = Ai[Pinv[J]];
            k1[0] = k11 = Ai[Pinv[J]+1];
            while(1) {
                if(isNaN(km)) throw new Error("Ow!");
                if(km >= k11) {
                    xj[n] = Pinv[j[m]];
                    if(m===0) return;
                    ++n;
                    --m;
                    km = k[m];
                    k11 = k1[m];
                } else {
                    foo = Aj[km];
                    if(x[foo] === 0) {
                        x[foo] = 1;
                        k[m] = km;
                        ++m;
                        j[m] = foo;
                        foo = Pinv[foo];
                        km = Ai[foo];
                        k1[m] = k11 = Ai[foo+1];
                    } else ++km;
                }
            }
        }
        numeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {
            var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;
            var Bi = B[0], Bj = B[1], Bv = B[2];

            var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;
            i0 = Bi[I];
            i1 = Bi[I+1];
            xj.length = 0;
            for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }
            for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }
            for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }
            for(i=xj.length-1;i!==-1;--i) {
                j = xj[i];
                l = P[j];
                j0 = Ai[j];
                j1 = Ai[j+1];
                for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }
                a = y[l];
                for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];
                y[l] = a;
            }
        }
        numeric.ccsLUP0 = function ccsLUP0(A,threshold) {
            var m = A[0].length-1;
            var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];
            var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];
            var y = numeric.rep([m],0), xj = numeric.rep([m],0);
            var i,j,k,j0,j1,a,e,c,d,K;
            var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;
            var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);
            var dfs = new numeric.ccsDFS0(m);
            if(typeof threshold === "undefined") { threshold = 1; }
            for(i=0;i<m;++i) {
                sol(L,A,y,xj,i,Pinv,P,dfs);
                a = -1;
                e = -1;
                for(j=xj.length-1;j!==-1;--j) {
                    k = xj[j];
                    if(k <= i) continue;
                    c = abs(y[P[k]]);
                    if(c > a) { e = k; a = c; }
                }
                if(abs(y[P[i]])<threshold*a) {
                    j = P[i];
                    a = P[e];
                    P[i] = a; Pinv[a] = i;
                    P[e] = j; Pinv[j] = e;
                }
                a = Li[i];
                e = Ui[i];
                d = y[P[i]];
                Lj[a] = P[i];
                Lv[a] = 1;
                ++a;
                for(j=xj.length-1;j!==-1;--j) {
                    k = xj[j];
                    c = y[P[k]];
                    xj[j] = 0;
                    y[P[k]] = 0;
                    if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }
                    else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }
                }
                Li[i+1] = a;
                Ui[i+1] = e;
            }
            for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }
            return {L:L, U:U, P:P, Pinv:Pinv};
        }
        numeric.ccsLUP = numeric.ccsLUP0;

        numeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }
        numeric.ccsGetBlock = function ccsGetBlock(A,i,j) {
            var s = numeric.ccsDim(A),m=s[0],n=s[1];
            if(typeof i === "undefined") { i = numeric.linspace(0,m-1); }
            else if(typeof i === "number") { i = [i]; }
            if(typeof j === "undefined") { j = numeric.linspace(0,n-1); }
            else if(typeof j === "number") { j = [j]; }
            var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;
            var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];
            var Ai = A[0], Aj = A[1], Av = A[2];
            var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);
            for(q=0;q<Q;++q) {
                jq = j[q];
                var q0 = Ai[jq];
                var q1 = Ai[jq+1];
                for(p=q0;p<q1;++p) {
                    r = Aj[p];
                    flags[r] = 1;
                    x[r] = Av[p];
                }
                for(p=0;p<P;++p) {
                    ip = i[p];
                    if(flags[ip]) {
                        Bj[count] = p;
                        Bv[count] = x[i[p]];
                        ++count;
                    }
                }
                for(p=q0;p<q1;++p) {
                    r = Aj[p];
                    flags[r] = 0;
                }
                Bi[q+1] = count;
            }
            return B;
        }

        numeric.ccsDot = function ccsDot(A,B) {
            var Ai = A[0], Aj = A[1], Av = A[2];
            var Bi = B[0], Bj = B[1], Bv = B[2];
            var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);
            var m = sA[0], n = sA[1], o = sB[1];
            var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);
            var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];
            var i,j,k,j0,j1,i0,i1,l,p,a,b;
            for(k=0;k!==o;++k) {
                j0 = Bi[k];
                j1 = Bi[k+1];
                p = 0;
                for(j=j0;j<j1;++j) {
                    a = Bj[j];
                    b = Bv[j];
                    i0 = Ai[a];
                    i1 = Ai[a+1];
                    for(i=i0;i<i1;++i) {
                        l = Aj[i];
                        if(flags[l]===0) {
                            xj[p] = l;
                            flags[l] = 1;
                            p = p+1;
                        }
                        x[l] = x[l] + Av[i]*b;
                    }
                }
                j0 = Ci[k];
                j1 = j0+p;
                Ci[k+1] = j1;
                for(j=p-1;j!==-1;--j) {
                    b = j0+j;
                    i = xj[j];
                    Cj[b] = i;
                    Cv[b] = x[i];
                    flags[i] = 0;
                    x[i] = 0;
                }
                Ci[k+1] = Ci[k]+p;
            }
            return C;
        }

        numeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {
            var L = LUP.L, U = LUP.U, P = LUP.P;
            var Bi = B[0];
            var flag = false;
            if(typeof Bi !== "object") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }
            var Bj = B[1], Bv = B[2];
            var n = L[0].length-1, m = Bi.length-1;
            var x = numeric.rep([n],0), xj = Array(n);
            var b = numeric.rep([n],0), bj = Array(n);
            var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];
            var sol = numeric.ccsTSolve;
            var i,j,j0,j1,k,J,N=0;
            for(i=0;i<m;++i) {
                k = 0;
                j0 = Bi[i];
                j1 = Bi[i+1];
                for(j=j0;j<j1;++j) {
                    J = LUP.Pinv[Bj[j]];
                    bj[k] = J;
                    b[J] = Bv[j];
                    ++k;
                }
                bj.length = k;
                sol(L,b,x,bj,xj);
                for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;
                sol(U,x,b,xj,bj);
                if(flag) return b;
                for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;
                for(j=bj.length-1;j!==-1;--j) {
                    J = bj[j];
                    Xj[N] = J;
                    Xv[N] = b[J];
                    b[J] = 0;
                    ++N;
                }
                Xi[i+1] = N;
            }
            return [Xi,Xj,Xv];
        }

        numeric.ccsbinop = function ccsbinop(body,setup) {
            if(typeof setup === "undefined") setup='';
            return Function('X','Y',
                'var Xi = X[0], Xj = X[1], Xv = X[2];\n'+
                'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\n'+
                'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\n'+
                'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\n'+
                'var x = numeric.rep([m],0),y = numeric.rep([m],0);\n'+
                'var xk,yk,zk;\n'+
                'var i,j,j0,j1,k,p=0;\n'+
                setup+
                'for(i=0;i<n;++i) {\n'+
                '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) {\n'+
                '    k = Xj[j];\n'+
                '    x[k] = 1;\n'+
                '    Zj[p] = k;\n'+
                '    ++p;\n'+
                '  }\n'+
                '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) {\n'+
                '    k = Yj[j];\n'+
                '    y[k] = Yv[j];\n'+
                '    if(x[k] === 0) {\n'+
                '      Zj[p] = k;\n'+
                '      ++p;\n'+
                '    }\n'+
                '  }\n'+
                '  Zi[i+1] = p;\n'+
                '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n'+
                '  j0 = Zi[i]; j1 = Zi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) {\n'+
                '    k = Zj[j];\n'+
                '    xk = x[k];\n'+
                '    yk = y[k];\n'+
                body+'\n'+
                '    Zv[j] = zk;\n'+
                '  }\n'+
                '  j0 = Xi[i]; j1 = Xi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n'+
                '  j0 = Yi[i]; j1 = Yi[i+1];\n'+
                '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n'+
                '}\n'+
                'return [Zi,Zj,Zv];'
            );
        };

        (function() {
            var k,A,B,C;
            for(k in numeric.ops2) {
                if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';
                else A = 'NaN';
                if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';
                else B = 'NaN';
                if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';
                else C = 'NaN';
                numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');
                numeric['ccs'+k] = Function('X','Y',
                    'if(typeof X === "number") return '+A+';\n'+
                    'if(typeof Y === "number") return '+B+';\n'+
                    'return '+C+';\n'
                );
            }
        }());

        numeric.ccsScatter = function ccsScatter(A) {
            var Ai = A[0], Aj = A[1], Av = A[2];
            var n = numeric.sup(Aj)+1,m=Ai.length;
            var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);
            var counts = numeric.rep([n],0),i;
            for(i=0;i<m;++i) counts[Aj[i]]++;
            for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];
            var ptr = Ri.slice(0),k,Aii;
            for(i=0;i<m;++i) {
                Aii = Aj[i];
                k = ptr[Aii];
                Rj[k] = Ai[i];
                Rv[k] = Av[i];
                ptr[Aii]=ptr[Aii]+1;
            }
            return [Ri,Rj,Rv];
        }

        numeric.ccsGather = function ccsGather(A) {
            var Ai = A[0], Aj = A[1], Av = A[2];
            var n = Ai.length-1,m = Aj.length;
            var Ri = Array(m), Rj = Array(m), Rv = Array(m);
            var i,j,j0,j1,p;
            p=0;
            for(i=0;i<n;++i) {
                j0 = Ai[i];
                j1 = Ai[i+1];
                for(j=j0;j!==j1;++j) {
                    Rj[p] = i;
                    Ri[p] = Aj[j];
                    Rv[p] = Av[j];
                    ++p;
                }
            }
            return [Ri,Rj,Rv];
        }

// The following sparse linear algebra routines are deprecated.

        numeric.sdim = function dim(A,ret,k) {
            if(typeof ret === "undefined") { ret = []; }
            if(typeof A !== "object") return ret;
            if(typeof k === "undefined") { k=0; }
            if(!(k in ret)) { ret[k] = 0; }
            if(A.length > ret[k]) ret[k] = A.length;
            var i;
            for(i in A) {
                if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);
            }
            return ret;
        };

        numeric.sclone = function clone(A,k,n) {
            if(typeof k === "undefined") { k=0; }
            if(typeof n === "undefined") { n = numeric.sdim(A).length; }
            var i,ret = Array(A.length);
            if(k === n-1) {
                for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }
                return ret;
            }
            for(i in A) {
                if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);
            }
            return ret;
        }

        numeric.sdiag = function diag(d) {
            var n = d.length,i,ret = Array(n),i1,i2,i3;
            for(i=n-1;i>=1;i-=2) {
                i1 = i-1;
                ret[i] = []; ret[i][i] = d[i];
                ret[i1] = []; ret[i1][i1] = d[i1];
            }
            if(i===0) { ret[0] = []; ret[0][0] = d[i]; }
            return ret;
        }

        numeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }

        numeric.stranspose = function transpose(A) {
            var ret = [], n = A.length, i,j,Ai;
            for(i in A) {
                if(!(A.hasOwnProperty(i))) continue;
                Ai = A[i];
                for(j in Ai) {
                    if(!(Ai.hasOwnProperty(j))) continue;
                    if(typeof ret[j] !== "object") { ret[j] = []; }
                    ret[j][i] = Ai[j];
                }
            }
            return ret;
        }

        numeric.sLUP = function LUP(A,tol) {
            throw new Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
        };

        numeric.sdotMM = function dotMM(A,B) {
            var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;
            var i,j,k,accum;
            var ret = Array(p),reti;
            for(i=p-1;i>=0;i--) {
                reti = [];
                Ai = A[i];
                for(k=r-1;k>=0;k--) {
                    accum = 0;
                    BTk = BT[k];
                    for(j in Ai) {
                        if(!(Ai.hasOwnProperty(j))) continue;
                        if(j in BTk) { accum += Ai[j]*BTk[j]; }
                    }
                    if(accum) reti[k] = accum;
                }
                ret[i] = reti;
            }
            return ret;
        }

        numeric.sdotMV = function dotMV(A,x) {
            var p = A.length, Ai, i,j;
            var ret = Array(p), accum;
            for(i=p-1;i>=0;i--) {
                Ai = A[i];
                accum = 0;
                for(j in Ai) {
                    if(!(Ai.hasOwnProperty(j))) continue;
                    if(x[j]) accum += Ai[j]*x[j];
                }
                if(accum) ret[i] = accum;
            }
            return ret;
        }

        numeric.sdotVM = function dotMV(x,A) {
            var i,j,Ai,alpha;
            var ret = [], accum;
            for(i in x) {
                if(!x.hasOwnProperty(i)) continue;
                Ai = A[i];
                alpha = x[i];
                for(j in Ai) {
                    if(!Ai.hasOwnProperty(j)) continue;
                    if(!ret[j]) { ret[j] = 0; }
                    ret[j] += alpha*Ai[j];
                }
            }
            return ret;
        }

        numeric.sdotVV = function dotVV(x,y) {
            var i,ret=0;
            for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }
            return ret;
        }

        numeric.sdot = function dot(A,B) {
            var m = numeric.sdim(A).length, n = numeric.sdim(B).length;
            var k = m*1000+n;
            switch(k) {
                case 0: return A*B;
                case 1001: return numeric.sdotVV(A,B);
                case 2001: return numeric.sdotMV(A,B);
                case 1002: return numeric.sdotVM(A,B);
                case 2002: return numeric.sdotMM(A,B);
                default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);
            }
        }

        numeric.sscatter = function scatter(V) {
            var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;
            for(i=n-1;i>=0;--i) {
                if(!V[m-1][i]) continue;
                Aj = A;
                for(j=0;j<m-2;j++) {
                    Vij = V[j][i];
                    if(!Aj[Vij]) Aj[Vij] = [];
                    Aj = Aj[Vij];
                }
                Aj[V[j][i]] = V[j+1][i];
            }
            return A;
        }

        numeric.sgather = function gather(A,ret,k) {
            if(typeof ret === "undefined") ret = [];
            if(typeof k === "undefined") k = [];
            var n,i,Ai;
            n = k.length;
            for(i in A) {
                if(A.hasOwnProperty(i)) {
                    k[n] = parseInt(i);
                    Ai = A[i];
                    if(typeof Ai === "number") {
                        if(Ai) {
                            if(ret.length === 0) {
                                for(i=n+1;i>=0;--i) ret[i] = [];
                            }
                            for(i=n;i>=0;--i) ret[i].push(k[i]);
                            ret[n+1].push(Ai);
                        }
                    } else gather(Ai,ret,k);
                }
            }
            if(k.length>n) k.pop();
            return ret;
        }

// 6. Coordinate matrices
        numeric.cLU = function LU(A) {
            var I = A[0], J = A[1], V = A[2];
            var p = I.length, m=0, i,j,k,a,b,c;
            for(i=0;i<p;i++) if(I[i]>m) m=I[i];
            m++;
            var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);
            var Ui, Uj,alpha;
            for(k=0;k<p;k++) {
                i = I[k];
                j = J[k];
                if(j<left[i]) left[i] = j;
                if(j>right[i]) right[i] = j;
            }
            for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }
            for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }
            var countL = 0, countU = 0;
            for(i=0;i<m;i++) {
                U[i] = numeric.rep([right[i]-left[i]+1],0);
                L[i] = numeric.rep([i-left[i]],0);
                countL += i-left[i]+1;
                countU += right[i]-i+1;
            }
            for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }
            for(i=0;i<m-1;i++) {
                a = i-left[i];
                Ui = U[i];
                for(j=i+1;left[j]<=i && j<m;j++) {
                    b = i-left[j];
                    c = right[i]-i;
                    Uj = U[j];
                    alpha = Uj[b]/Ui[a];
                    if(alpha) {
                        for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }
                        L[j][i-left[j]] = alpha;
                    }
                }
            }
            var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];
            var p,q,foo;
            p=0; q=0;
            for(i=0;i<m;i++) {
                a = left[i];
                b = right[i];
                foo = U[i];
                for(j=i;j<=b;j++) {
                    if(foo[j-a]) {
                        Ui[p] = i;
                        Uj[p] = j;
                        Uv[p] = foo[j-a];
                        p++;
                    }
                }
                foo = L[i];
                for(j=a;j<i;j++) {
                    if(foo[j-a]) {
                        Li[q] = i;
                        Lj[q] = j;
                        Lv[q] = foo[j-a];
                        q++;
                    }
                }
                Li[q] = i;
                Lj[q] = i;
                Lv[q] = 1;
                q++;
            }
            return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};
        };

        numeric.cLUsolve = function LUsolve(lu,b) {
            var L = lu.L, U = lu.U, ret = numeric.clone(b);
            var Li = L[0], Lj = L[1], Lv = L[2];
            var Ui = U[0], Uj = U[1], Uv = U[2];
            var p = Ui.length, q = Li.length;
            var m = ret.length,i,j,k;
            k = 0;
            for(i=0;i<m;i++) {
                while(Lj[k] < i) {
                    ret[i] -= Lv[k]*ret[Lj[k]];
                    k++;
                }
                k++;
            }
            k = p-1;
            for(i=m-1;i>=0;i--) {
                while(Uj[k] > i) {
                    ret[i] -= Uv[k]*ret[Uj[k]];
                    k--;
                }
                ret[i] /= Uv[k];
                k--;
            }
            return ret;
        };

        numeric.cgrid = function grid(n,shape) {
            if(typeof n === "number") n = [n,n];
            var ret = numeric.rep(n,-1);
            var i,j,count;
            if(typeof shape !== "function") {
                switch(shape) {
                    case 'L':
                        shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }
                        break;
                    default:
                        shape = function(i,j) { return true; };
                        break;
                }
            }
            count=0;
            for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++)
                if(shape(i,j)) {
                    ret[i][j] = count;
                    count++;
                }
            return ret;
        }

        numeric.cdelsq = function delsq(g) {
            var dir = [[-1,0],[0,-1],[0,1],[1,0]];
            var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;
            var Li = [], Lj = [], Lv = [];
            for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {
                if(g[i][j]<0) continue;
                for(k=0;k<4;k++) {
                    p = i+dir[k][0];
                    q = j+dir[k][1];
                    if(g[p][q]<0) continue;
                    Li.push(g[i][j]);
                    Lj.push(g[p][q]);
                    Lv.push(-1);
                }
                Li.push(g[i][j]);
                Lj.push(g[i][j]);
                Lv.push(4);
            }
            return [Li,Lj,Lv];
        }

        numeric.cdotMV = function dotMV(A,x) {
            var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;
            N=0;
            for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }
            N++;
            ret = numeric.rep([N],0);
            for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }
            return ret;
        }

// 7. Splines

        numeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }
        numeric.Spline.prototype._at = function _at(x1,p) {
            var x = this.x;
            var yl = this.yl;
            var yr = this.yr;
            var kl = this.kl;
            var kr = this.kr;
            var x1,a,b,t;
            var add = numeric.add, sub = numeric.sub, mul = numeric.mul;
            a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));
            b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));
            t = (x1-x[p])/(x[p+1]-x[p]);
            var s = t*(1-t);
            return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));
        }
        numeric.Spline.prototype.at = function at(x0) {
            if(typeof x0 === "number") {
                var x = this.x;
                var n = x.length;
                var p,q,mid,floor = Math.floor,a,b,t;
                p = 0;
                q = n-1;
                while(q-p>1) {
                    mid = floor((p+q)/2);
                    if(x[mid] <= x0) p = mid;
                    else q = mid;
                }
                return this._at(x0,p);
            }
            var n = x0.length, i, ret = Array(n);
            for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);
            return ret;
        }
        numeric.Spline.prototype.diff = function diff() {
            var x = this.x;
            var yl = this.yl;
            var yr = this.yr;
            var kl = this.kl;
            var kr = this.kr;
            var n = yl.length;
            var i,dx,dy;
            var zl = kl, zr = kr, pl = Array(n), pr = Array(n);
            var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;
            for(i=n-1;i!==-1;--i) {
                dx = x[i+1]-x[i];
                dy = sub(yr[i+1],yl[i]);
                pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);
                pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);
            }
            return new numeric.Spline(x,zl,zr,pl,pr);
        }
        numeric.Spline.prototype.roots = function roots() {
            function sqr(x) { return x*x; }
            function heval(y0,y1,k0,k1,x) {
                var A = k0*2-(y1-y0);
                var B = -k1*2+(y1-y0);
                var t = (x+1)*0.5;
                var s = t*(1-t);
                return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;
            }
            var ret = [];
            var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;
            if(typeof yl[0] === "number") {
                yl = [yl];
                yr = [yr];
                kl = [kl];
                kr = [kr];
            }
            var m = yl.length,n=x.length-1,i,j,k,y,s,t;
            var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;
            var sqrt = Math.sqrt;
            for(i=0;i!==m;++i) {
                ai = yl[i];
                bi = yr[i];
                ci = kl[i];
                di = kr[i];
                ri = [];
                for(j=0;j!==n;j++) {
                    if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);
                    dx = (x[j+1]-x[j]);
                    cx = x[j];
                    y0 = ai[j];
                    y1 = bi[j+1];
                    k0 = ci[j]/dx;
                    k1 = di[j+1]/dx;
                    D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;
                    A = k1+3*y0+2*k0-3*y1;
                    B = 3*(k1+k0+2*(y0-y1));
                    if(D<=0) {
                        z0 = A/B;
                        if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];
                        else stops = [x[j],x[j+1]];
                    } else {
                        z0 = (A-sqrt(D))/B;
                        z1 = (A+sqrt(D))/B;
                        stops = [x[j]];
                        if(z0>x[j] && z0<x[j+1]) stops.push(z0);
                        if(z1>x[j] && z1<x[j+1]) stops.push(z1);
                        stops.push(x[j+1]);
                    }
                    t0 = stops[0];
                    z0 = this._at(t0,j);
                    for(k=0;k<stops.length-1;k++) {
                        t1 = stops[k+1];
                        z1 = this._at(t1,j);
                        if(z0 === 0) {
                            ri.push(t0);
                            t0 = t1;
                            z0 = z1;
                            continue;
                        }
                        if(z1 === 0 || z0*z1>0) {
                            t0 = t1;
                            z0 = z1;
                            continue;
                        }
                        var side = 0;
                        while(1) {
                            tm = (z0*t1-z1*t0)/(z0-z1);
                            if(tm <= t0 || tm >= t1) { break; }
                            zm = this._at(tm,j);
                            if(zm*z1>0) {
                                t1 = tm;
                                z1 = zm;
                                if(side === -1) z0*=0.5;
                                side = -1;
                            } else if(zm*z0>0) {
                                t0 = tm;
                                z0 = zm;
                                if(side === 1) z1*=0.5;
                                side = 1;
                            } else break;
                        }
                        ri.push(tm);
                        t0 = stops[k+1];
                        z0 = this._at(t0, j);
                    }
                    if(z1 === 0) ri.push(t1);
                }
                ret[i] = ri;
            }
            if(typeof this.yl[0] === "number") return ret[0];
            return ret;
        }
        numeric.spline = function spline(x,y,k1,kn) {
            var n = x.length, b = [], dx = [], dy = [];
            var i;
            var sub = numeric.sub,mul = numeric.mul,add = numeric.add;
            for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }
            if(typeof k1 === "string" || typeof kn === "string") {
                k1 = kn = "periodic";
            }
            // Build sparse tridiagonal system
            var T = [[],[],[]];
            switch(typeof k1) {
                case "undefined":
                    b[0] = mul(3/(dx[0]*dx[0]),dy[0]);
                    T[0].push(0,0);
                    T[1].push(0,1);
                    T[2].push(2/dx[0],1/dx[0]);
                    break;
                case "string":
                    b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));
                    T[0].push(0,0,0);
                    T[1].push(n-2,0,1);
                    T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);
                    break;
                default:
                    b[0] = k1;
                    T[0].push(0);
                    T[1].push(0);
                    T[2].push(1);
                    break;
            }
            for(i=1;i<n-1;i++) {
                b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));
                T[0].push(i,i,i);
                T[1].push(i-1,i,i+1);
                T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);
            }
            switch(typeof kn) {
                case "undefined":
                    b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);
                    T[0].push(n-1,n-1);
                    T[1].push(n-2,n-1);
                    T[2].push(1/dx[n-2],2/dx[n-2]);
                    break;
                case "string":
                    T[1][T[1].length-1] = 0;
                    break;
                default:
                    b[n-1] = kn;
                    T[0].push(n-1);
                    T[1].push(n-1);
                    T[2].push(1);
                    break;
            }
            if(typeof b[0] !== "number") b = numeric.transpose(b);
            else b = [b];
            var k = Array(b.length);
            if(typeof k1 === "string") {
                for(i=k.length-1;i!==-1;--i) {
                    k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);
                    k[i][n-1] = k[i][0];
                }
            } else {
                for(i=k.length-1;i!==-1;--i) {
                    k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);
                }
            }
            if(typeof y[0] === "number") k = k[0];
            else k = numeric.transpose(k);
            return new numeric.Spline(x,y,y,k,k);
        }

// 8. FFT
        numeric.fftpow2 = function fftpow2(x,y) {
            var n = x.length;
            if(n === 1) return;
            var cos = Math.cos, sin = Math.sin, i,j;
            var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
            j = n/2;
            for(i=n-1;i!==-1;--i) {
                --j;
                xo[j] = x[i];
                yo[j] = y[i];
                --i;
                xe[j] = x[i];
                ye[j] = y[i];
            }
            fftpow2(xe,ye);
            fftpow2(xo,yo);
            j = n/2;
            var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
            for(i=n-1;i!==-1;--i) {
                --j;
                if(j === -1) j = n/2-1;
                t = k*i;
                ci = cos(t);
                si = sin(t);
                x[i] = xe[j] + ci*xo[j] - si*yo[j];
                y[i] = ye[j] + ci*yo[j] + si*xo[j];
            }
        }
        numeric._ifftpow2 = function _ifftpow2(x,y) {
            var n = x.length;
            if(n === 1) return;
            var cos = Math.cos, sin = Math.sin, i,j;
            var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);
            j = n/2;
            for(i=n-1;i!==-1;--i) {
                --j;
                xo[j] = x[i];
                yo[j] = y[i];
                --i;
                xe[j] = x[i];
                ye[j] = y[i];
            }
            _ifftpow2(xe,ye);
            _ifftpow2(xo,yo);
            j = n/2;
            var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;
            for(i=n-1;i!==-1;--i) {
                --j;
                if(j === -1) j = n/2-1;
                t = k*i;
                ci = cos(t);
                si = sin(t);
                x[i] = xe[j] + ci*xo[j] - si*yo[j];
                y[i] = ye[j] + ci*yo[j] + si*xo[j];
            }
        }
        numeric.ifftpow2 = function ifftpow2(x,y) {
            numeric._ifftpow2(x,y);
            numeric.diveq(x,x.length);
            numeric.diveq(y,y.length);
        }
        numeric.convpow2 = function convpow2(ax,ay,bx,by) {
            numeric.fftpow2(ax,ay);
            numeric.fftpow2(bx,by);
            var i,n = ax.length,axi,bxi,ayi,byi;
            for(i=n-1;i!==-1;--i) {
                axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];
                ax[i] = axi*bxi-ayi*byi;
                ay[i] = axi*byi+ayi*bxi;
            }
            numeric.ifftpow2(ax,ay);
        }
        numeric.T.prototype.fft = function fft() {
            var x = this.x, y = this.y;
            var n = x.length, log = Math.log, log2 = log(2),
                p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
            var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
            var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;
            var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
            for(k=0;k<n;k++) a[k] = x[k];
            if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
            cx[0] = 1;
            for(k=1;k<=m/2;k++) {
                t = c*k*k;
                cx[k] = cos(t);
                cy[k] = sin(t);
                cx[m-k] = cos(t);
                cy[m-k] = sin(t)
            }
            var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
            X = X.mul(Y);
            numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
            X = X.mul(Y);
            X.x.length = n;
            X.y.length = n;
            return X;
        }
        numeric.T.prototype.ifft = function ifft() {
            var x = this.x, y = this.y;
            var n = x.length, log = Math.log, log2 = log(2),
                p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);
            var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;
            var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;
            var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);
            for(k=0;k<n;k++) a[k] = x[k];
            if(typeof y !== "undefined") for(k=0;k<n;k++) b[k] = y[k];
            cx[0] = 1;
            for(k=1;k<=m/2;k++) {
                t = c*k*k;
                cx[k] = cos(t);
                cy[k] = sin(t);
                cx[m-k] = cos(t);
                cy[m-k] = sin(t)
            }
            var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);
            X = X.mul(Y);
            numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));
            X = X.mul(Y);
            X.x.length = n;
            X.y.length = n;
            return X.div(n);
        }

//9. Unconstrained optimization
        numeric.gradient = function gradient(f,x) {
            var n = x.length;
            var f0 = f(x);
            if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');
            var max = Math.max;
            var i,x0 = numeric.clone(x),f1,f2, J = Array(n);
            var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;
            var t0,t1,t2,it=0,d1,d2,N;
            for(i=0;i<n;i++) {
                var h = max(1e-6*f0,1e-8);
                while(1) {
                    ++it;
                    if(it>20) { throw new Error("Numerical gradient fails"); }
                    x0[i] = x[i]+h;
                    f1 = f(x0);
                    x0[i] = x[i]-h;
                    f2 = f(x0);
                    x0[i] = x[i];
                    if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }
                    J[i] = (f1-f2)/(2*h);
                    t0 = x[i]-h;
                    t1 = x[i];
                    t2 = x[i]+h;
                    d1 = (f1-f0)/h;
                    d2 = (f0-f2)/h;
                    N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);
                    errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);
                    if(errest>eps) { h/=16; }
                    else break;
                }
            }
            return J;
        }

        numeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {
            var grad = numeric.gradient;
            if(typeof options === "undefined") { options = {}; }
            if(typeof tol === "undefined") { tol = 1e-8; }
            if(typeof gradient === "undefined") { gradient = function(x) { return grad(f,x); }; }
            if(typeof maxit === "undefined") maxit = 1000;
            x0 = numeric.clone(x0);
            var n = x0.length;
            var f0 = f(x0),f1,df0;
            if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');
            var max = Math.max, norm2 = numeric.norm2;
            tol = max(tol,numeric.epsilon);
            var step,g0,g1,H1 = options.Hinv || numeric.identity(n);
            var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;
            var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;
            var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;
            var msg = "";
            g0 = gradient(x0);
            while(it<maxit) {
                if(typeof callback === "function") { if(callback(it,x0,f0,g0,H1)) { msg = "Callback returned true"; break; } }
                if(!all(isfinite(g0))) { msg = "Gradient has Infinity or NaN"; break; }
                step = neg(dot(H1,g0));
                if(!all(isfinite(step))) { msg = "Search direction has Infinity or NaN"; break; }
                nstep = norm2(step);
                if(nstep < tol) { msg="Newton step smaller than tol"; break; }
                t = 1;
                df0 = dot(g0,step);
                // line search
                x1 = x0;
                while(it < maxit) {
                    if(t*nstep < tol) { break; }
                    s = mul(step,t);
                    x1 = add(x0,s);
                    f1 = f(x1);
                    if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {
                        t *= 0.5;
                        ++it;
                        continue;
                    }
                    break;
                }
                if(t*nstep < tol) { msg = "Line search step size smaller than tol"; break; }
                if(it === maxit) { msg = "maxit reached during line search"; break; }
                g1 = gradient(x1);
                y = sub(g1,g0);
                ys = dot(y,s);
                Hy = dot(H1,y);
                H1 = sub(add(H1,
                    mul(
                        (ys+dot(y,Hy))/(ys*ys),
                        ten(s,s)    )),
                    div(add(ten(Hy,s),ten(s,Hy)),ys));
                x0 = x1;
                f0 = f1;
                g0 = g1;
                ++it;
            }
            return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};
        }

// 10. Ode solver (Dormand-Prince)
        numeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {
            this.x = x;
            this.y = y;
            this.f = f;
            this.ymid = ymid;
            this.iterations = iterations;
            this.events = events;
            this.message = msg;
        }
        numeric.Dopri.prototype._at = function _at(xi,j) {
            function sqr(x) { return x*x; }
            var sol = this;
            var xs = sol.x;
            var ys = sol.y;
            var k1 = sol.f;
            var ymid = sol.ymid;
            var n = xs.length;
            var x0,x1,xh,y0,y1,yh,xi;
            var floor = Math.floor,h;
            var c = 0.5;
            var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;
            x0 = xs[j];
            x1 = xs[j+1];
            y0 = ys[j];
            y1 = ys[j+1];
            h  = x1-x0;
            xh = x0+c*h;
            yh = ymid[j];
            p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));
            q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));
            w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),
                sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),
                sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),
                (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),
                (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];
            return add(add(add(add(mul(y0,w[0]),
                mul(yh,w[1])),
                mul(y1,w[2])),
                mul( p,w[3])),
                mul( q,w[4]));
        }
        numeric.Dopri.prototype.at = function at(x) {
            var i,j,k,floor = Math.floor;
            if(typeof x !== "number") {
                var n = x.length, ret = Array(n);
                for(i=n-1;i!==-1;--i) {
                    ret[i] = this.at(x[i]);
                }
                return ret;
            }
            var x0 = this.x;
            i = 0; j = x0.length-1;
            while(j-i>1) {
                k = floor(0.5*(i+j));
                if(x0[k] <= x) i = k;
                else j = k;
            }
            return this._at(x,i);
        }

        numeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {
            if(typeof tol === "undefined") { tol = 1e-6; }
            if(typeof maxit === "undefined") { maxit = 1000; }
            var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];
            var A2 = 1/5;
            var A3 = [3/40,9/40];
            var A4 = [44/45,-56/15,32/9];
            var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];
            var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];
            var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];
            var bm = [0.5*6025192743/30085553152,
                0,
                0.5*51252292925/65400821598,
                0.5*-2691868925/45128329728,
                0.5*187940372067/1594534317056,
                0.5*-1776094331/19743644256,
                0.5*11237099/235043384];
            var c = [1/5,3/10,4/5,8/9,1,1];
            var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];
            var i = 0,er,j;
            var h = (x1-x0)/10;
            var it = 0;
            var add = numeric.add, mul = numeric.mul, y1,erinf;
            var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;
            var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;
            var e0, e1, ev;
            var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,"");
            if(typeof event === "function") e0 = event(x0,y0);
            while(x0<x1 && it<maxit) {
                ++it;
                if(x0+h>x1) h = x1-x0;
                k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));
                k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));
                k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));
                k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));
                k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));
                y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));
                k7 = f(x0+h,y1);
                er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));
                if(typeof er === "number") erinf = abs(er);
                else erinf = norminf(er);
                if(erinf > tol) { // reject
                    h = 0.2*h*pow(tol/erinf,0.25);
                    if(x0+h === x0) {
                        ret.msg = "Step size became too small";
                        break;
                    }
                    continue;
                }
                ymid[i] = add(add(add(add(add(add(y0,
                    mul(k1[i],h*bm[0])),
                    mul(k3   ,h*bm[2])),
                    mul(k4   ,h*bm[3])),
                    mul(k5   ,h*bm[4])),
                    mul(k6   ,h*bm[5])),
                    mul(k7   ,h*bm[6]));
                ++i;
                xs[i] = x0+h;
                ys[i] = y1;
                k1[i] = k7;
                if(typeof event === "function") {
                    var yi,xl = x0,xr = x0+0.5*h,xi;
                    e1 = event(xr,ymid[i-1]);
                    ev = and(lt(e0,0),lt(0,e1));
                    if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }
                    if(any(ev)) {
                        var xc, yc, en,ei;
                        var side=0, sl = 1.0, sr = 1.0;
                        while(1) {
                            if(typeof e0 === "number") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);
                            else {
                                xi = xr;
                                for(j=e0.length-1;j!==-1;--j) {
                                    if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));
                                }
                            }
                            if(xi <= xl || xi >= xr) break;
                            yi = ret._at(xi, i-1);
                            ei = event(xi,yi);
                            en = and(lt(e0,0),lt(0,ei));
                            if(any(en)) {
                                xr = xi;
                                e1 = ei;
                                ev = en;
                                sr = 1.0;
                                if(side === -1) sl *= 0.5;
                                else sl = 1.0;
                                side = -1;
                            } else {
                                xl = xi;
                                e0 = ei;
                                sl = 1.0;
                                if(side === 1) sr *= 0.5;
                                else sr = 1.0;
                                side = 1;
                            }
                        }
                        y1 = ret._at(0.5*(x0+xi),i-1);
                        ret.f[i] = f(xi,yi);
                        ret.x[i] = xi;
                        ret.y[i] = yi;
                        ret.ymid[i-1] = y1;
                        ret.events = ev;
                        ret.iterations = it;
                        return ret;
                    }
                }
                x0 += h;
                y0 = y1;
                e0 = e1;
                h = min(0.8*h*pow(tol/erinf,0.25),4*h);
            }
            ret.iterations = it;
            return ret;
        }

// 11. Ax = b
        numeric.LU = function(A, fast) {
            fast = fast || false;

            var abs = Math.abs;
            var i, j, k, absAjk, Akk, Ak, Pk, Ai;
            var max;
            var n = A.length, n1 = n-1;
            var P = new Array(n);
            if(!fast) A = numeric.clone(A);

            for (k = 0; k < n; ++k) {
                Pk = k;
                Ak = A[k];
                max = abs(Ak[k]);
                for (j = k + 1; j < n; ++j) {
                    absAjk = abs(A[j][k]);
                    if (max < absAjk) {
                        max = absAjk;
                        Pk = j;
                    }
                }
                P[k] = Pk;

                if (Pk != k) {
                    A[k] = A[Pk];
                    A[Pk] = Ak;
                    Ak = A[k];
                }

                Akk = Ak[k];

                for (i = k + 1; i < n; ++i) {
                    A[i][k] /= Akk;
                }

                for (i = k + 1; i < n; ++i) {
                    Ai = A[i];
                    for (j = k + 1; j < n1; ++j) {
                        Ai[j] -= Ai[k] * Ak[j];
                        ++j;
                        Ai[j] -= Ai[k] * Ak[j];
                    }
                    if(j===n1) Ai[j] -= Ai[k] * Ak[j];
                }
            }

            return {
                LU: A,
                P:  P
            };
        }

        numeric.LUsolve = function LUsolve(LUP, b) {
            var i, j;
            var LU = LUP.LU;
            var n   = LU.length;
            var x = numeric.clone(b);
            var P   = LUP.P;
            var Pi, LUi, LUii, tmp;

            for (i=n-1;i!==-1;--i) x[i] = b[i];
            for (i = 0; i < n; ++i) {
                Pi = P[i];
                if (P[i] !== i) {
                    tmp = x[i];
                    x[i] = x[Pi];
                    x[Pi] = tmp;
                }

                LUi = LU[i];
                for (j = 0; j < i; ++j) {
                    x[i] -= x[j] * LUi[j];
                }
            }

            for (i = n - 1; i >= 0; --i) {
                LUi = LU[i];
                for (j = i + 1; j < n; ++j) {
                    x[i] -= x[j] * LUi[j];
                }

                x[i] /= LUi[i];
            }

            return x;
        }

        numeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }

// 12. Linear programming
        numeric.echelonize = function echelonize(A) {
            var s = numeric.dim(A), m = s[0], n = s[1];
            var I = numeric.identity(m);
            var P = Array(m);
            var i,j,k,l,Ai,Ii,Z,a;
            var abs = Math.abs;
            var diveq = numeric.diveq;
            A = numeric.clone(A);
            for(i=0;i<m;++i) {
                k = 0;
                Ai = A[i];
                Ii = I[i];
                for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;
                P[i] = k;
                diveq(Ii,Ai[k]);
                diveq(Ai,Ai[k]);
                for(j=0;j<m;++j) if(j!==i) {
                    Z = A[j]; a = Z[k];
                    for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;
                    Z = I[j];
                    for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;
                }
            }
            return {I:I, A:A, P:P};
        }

        numeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {
            var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
            var m = c.length, n = b.length,y;
            var unbounded = false, cb,i0=0;
            var alpha = 1.0;
            var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;
            var muleq = numeric.muleq;
            var norm = numeric.norminf, any = numeric.any,min = Math.min;
            var all = numeric.all, gt = numeric.gt;
            var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;
            var solve = numeric.solve, z = sub(b,dot(A,x)),count;
            var dotcc = dot(c,c);
            var g;
            for(count=i0;count<maxit;++count) {
                var i,j,d;
                for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);
                var A1 = transpose(A0);
                for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));
                alpha = 0.25*abs(dotcc/dot(c,p));
                var a1 = 100*sqrt(dotcc/dot(p,p));
                if(!isFinite(alpha) || alpha>a1) alpha = a1;
                g = add(c,mul(alpha,p));
                H = dot(A1,A0);
                for(i=m-1;i!==-1;--i) H[i][i] += 1;
                d = solve(H,div(g,alpha),true);
                var t0 = div(z,dot(A,d));
                var t = 1.0;
                for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);
                y = sub(x,mul(d,t));
                z = sub(b,dot(A,y));
                if(!all(gt(z,0))) return { solution: x, message: "", iterations: count };
                x = y;
                if(alpha<tol) return { solution: y, message: "", iterations: count };
                if(flag) {
                    var s = dot(c,g), Ag = dot(A,g);
                    unbounded = true;
                    for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }
                } else {
                    if(x[m-1]>=0) unbounded = false;
                    else unbounded = true;
                }
                if(unbounded) return { solution: y, message: "Unbounded", iterations: count };
            }
            return { solution: x, message: "maximum iteration count exceeded", iterations:count };
        }

        numeric._solveLP = function _solveLP(c,A,b,tol,maxit) {
            var m = c.length, n = b.length,y;
            var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;
            var c0 = numeric.rep([m],0).concat([1]);
            var J = numeric.rep([n,1],-1);
            var A0 = numeric.blockMatrix([[A                   ,   J  ]]);
            var b0 = b;
            var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);
            var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);
            var x = numeric.clone(x0.solution);
            x.length = m;
            var foo = numeric.inf(sub(b,dot(A,x)));
            if(foo<0) { return { solution: NaN, message: "Infeasible", iterations: x0.iterations }; }
            var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);
            ret.iterations += x0.iterations;
            return ret;
        };

        numeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {
            if(typeof maxit === "undefined") maxit = 1000;
            if(typeof tol === "undefined") tol = numeric.epsilon;
            if(typeof Aeq === "undefined") return numeric._solveLP(c,A,b,tol,maxit);
            var m = Aeq.length, n = Aeq[0].length, o = A.length;
            var B = numeric.echelonize(Aeq);
            var flags = numeric.rep([n],0);
            var P = B.P;
            var Q = [];
            var i;
            for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;
            for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);
            var g = numeric.getRange;
            var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);
            var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;
            var A3 = dot(A1,B.I);
            var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));
            var c1 = Array(P.length), c2 = Array(Q.length);
            for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];
            for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];
            var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));
            var S = numeric._solveLP(c4,A4,b4,tol,maxit);
            var x2 = S.solution;
            if(x2!==x2) return S;
            var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));
            var x = Array(c.length);
            for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];
            for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];
            return { solution: x, message:S.message, iterations: S.iterations };
        }

        numeric.MPStoLP = function MPStoLP(MPS) {
            if(MPS instanceof String) { MPS.split('\n'); }
            var state = 0;
            var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];
            var n = MPS.length;
            var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;
            var name;
            var c = [], A = [], b = [];
            function err(e) { throw new Error('MPStoLP: '+e+'\nLine '+i+': '+MPS[i]+'\nCurrent state: '+states[state]+'\n'); }
            for(i=0;i<n;++i) {
                z = MPS[i];
                var w0 = z.match(/\S*/g);
                var w = [];
                for(j=0;j<w0.length;++j) if(w0[j]!=="") w.push(w0[j]);
                if(w.length === 0) continue;
                for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;
                if(j<states.length) {
                    state = j;
                    if(j===1) { name = w[1]; }
                    if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };
                    continue;
                }
                switch(state) {
                    case 0: case 1: err('Unexpected line');
                    case 2:
                        switch(w[0]) {
                            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;
                            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;
                            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;
                            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;
                            default: err('Parse error '+numeric.prettyPrint(w));
                        }
                        break;
                    case 3:
                        if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }
                        var p = vars[w[0]];
                        for(j=1;j<w.length;j+=2) {
                            if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }
                            var q = rows[w[j]];
                            A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);
                        }
                        break;
                    case 4:
                        for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);
                        break;
                    case 5: /*FIXME*/ break;
                    case 6: err('Internal error');
                }
            }
            err('Reached end of file without ENDATA');
        }
// seedrandom.js version 2.0.
// Author: David Bau 4/2/2011
//
// Defines a method Math.seedrandom() that, when called, substitutes
// an explicitly seeded RC4-based algorithm for Math.random().  Also
// supports automatic seeding from local or network sources of entropy.
//
// Usage:
//
//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>
//
//   Math.seedrandom('yipee'); Sets Math.random to a function that is
//                             initialized using the given explicit seed.
//
//   Math.seedrandom();        Sets Math.random to a function that is
//                             seeded using the current time, dom state,
//                             and other accumulated local entropy.
//                             The generated seed string is returned.
//
//   Math.seedrandom('yowza', true);
//                             Seeds using the given explicit seed mixed
//                             together with accumulated entropy.
//
//   <script src="http://bit.ly/srandom-512"></script>
//                             Seeds using physical random bits downloaded
//                             from random.org.
//
//   <script src="https://jsonlib.appspot.com/urandom?callback=Math.seedrandom">
//   </script>                 Seeds using urandom bits from call.jsonlib.com,
//                             which is faster than random.org.
//
// Examples:
//
//   Math.seedrandom("hello");            // Use "hello" as the seed.
//   document.write(Math.random());       // Always 0.5463663768140734
//   document.write(Math.random());       // Always 0.43973793770592234
//   var rng1 = Math.random;              // Remember the current prng.
//
//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.
//   document.write(Math.random());       // Pretty much unpredictable.
//
//   Math.random = rng1;                  // Continue "hello" prng sequence.
//   document.write(Math.random());       // Always 0.554769432473455
//
//   Math.seedrandom(autoseed);           // Restart at the previous seed.
//   document.write(Math.random());       // Repeat the 'unpredictable' value.
//
// Notes:
//
// Each time seedrandom('arg') is called, entropy from the passed seed
// is accumulated in a pool to help generate future seeds for the
// zero-argument form of Math.seedrandom, so entropy can be injected over
// time by calling seedrandom with explicit data repeatedly.
//
// On speed - This javascript implementation of Math.random() is about
// 3-10x slower than the built-in Math.random() because it is not native
// code, but this is typically fast enough anyway.  Seeding is more expensive,
// especially if you use auto-seeding.  Some details (timings on Chrome 4):
//
// Our Math.random()            - avg less than 0.002 milliseconds per call
// seedrandom('explicit')       - avg less than 0.5 milliseconds per call
// seedrandom('explicit', true) - avg less than 2 milliseconds per call
// seedrandom()                 - avg about 38 milliseconds per call
//
// LICENSE (BSD):
//
// Copyright 2010 David Bau, all rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//   1. Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//
//   2. Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in the
//      documentation and/or other materials provided with the distribution.
//
//   3. Neither the name of this module nor the names of its contributors may
//      be used to endorse or promote products derived from this software
//      without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
        /**
         * All code is in an anonymous closure to keep the global namespace clean.
         *
         * @param {number=} overflow
         * @param {number=} startdenom
         */

// Patched by Seb so that seedrandom.js does not pollute the Math object.
// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%
// slower.
        numeric.seedrandom = { pow:Math.pow, random:Math.random };

        (function (pool, math, width, chunks, significance, overflow, startdenom) {


//
// seedrandom()
// This is the seedrandom function described above.
//
            math['seedrandom'] = function seedrandom(seed, use_entropy) {
                var key = [];
                var arc4;

                // Flatten the seed string or build one from local entropy if needed.
                seed = mixkey(flatten(
                    use_entropy ? [seed, pool] :
                        arguments.length ? seed :
                            [new Date().getTime(), pool, window], 3), key);

                // Use the seed to initialize an ARC4 generator.
                arc4 = new ARC4(key);

                // Mix the randomness into accumulated entropy.
                mixkey(arc4.S, pool);

                // Override Math.random

                // This function returns a random double in [0, 1) that contains
                // randomness in every bit of the mantissa of the IEEE 754 value.

                math['random'] = function random() {  // Closure to return a random double:
                    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48
                    var d = startdenom;                 //   and denominator d = 2 ^ 48.
                    var x = 0;                          //   and no 'extra last byte'.
                    while (n < significance) {          // Fill up all significant digits by
                        n = (n + x) * width;              //   shifting numerator and
                        d *= width;                       //   denominator and generating a
                        x = arc4.g(1);                    //   new least-significant-byte.
                    }
                    while (n >= overflow) {             // To avoid rounding up, before adding
                        n /= 2;                           //   last byte, shift everything
                        d /= 2;                           //   right using integer math until
                        x >>>= 1;                         //   we have exactly the desired bits.
                    }
                    return (n + x) / d;                 // Form the number within [0, 1).
                };

                // Return the seed that was used
                return seed;
            };

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
            /** @constructor */
            function ARC4(key) {
                var t, u, me = this, keylen = key.length;
                var i = 0, j = me.i = me.j = me.m = 0;
                me.S = [];
                me.c = [];

                // The empty key [] is treated as [0].
                if (!keylen) { key = [keylen++]; }

                // Set up S using the standard key scheduling algorithm.
                while (i < width) { me.S[i] = i++; }
                for (i = 0; i < width; i++) {
                    t = me.S[i];
                    j = lowbits(j + t + key[i % keylen]);
                    u = me.S[j];
                    me.S[i] = u;
                    me.S[j] = t;
                }

                // The "g" method returns the next (count) outputs as one number.
                me.g = function getnext(count) {
                    var s = me.S;
                    var i = lowbits(me.i + 1); var t = s[i];
                    var j = lowbits(me.j + t); var u = s[j];
                    s[i] = u;
                    s[j] = t;
                    var r = s[lowbits(t + u)];
                    while (--count) {
                        i = lowbits(i + 1); t = s[i];
                        j = lowbits(j + t); u = s[j];
                        s[i] = u;
                        s[j] = t;
                        r = r * width + s[lowbits(t + u)];
                    }
                    me.i = i;
                    me.j = j;
                    return r;
                };
                // For robust unpredictability discard an initial batch of values.
                // See http://www.rsa.com/rsalabs/node.asp?id=2009
                me.g(width);
            }

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
            /** @param {Object=} result
             * @param {string=} prop
             * @param {string=} typ */
            function flatten(obj, depth, result, prop, typ) {
                result = [];
                typ = typeof(obj);
                if (depth && typ == 'object') {
                    for (prop in obj) {
                        if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)
                            try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
                        }
                    }
                }
                return (result.length ? result : obj + (typ != 'string' ? '\0' : ''));
            }

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
            /** @param {number=} smear
             * @param {number=} j */
            function mixkey(seed, key, smear, j) {
                seed += '';                         // Ensure the seed is a string
                smear = 0;
                for (j = 0; j < seed.length; j++) {
                    key[lowbits(j)] =
                        lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));
                }
                seed = '';
                for (j in key) { seed += String.fromCharCode(key[j]); }
                return seed;
            }

//
// lowbits()
// A quick "n mod width" for width a power of 2.
//
            function lowbits(n) { return n & (width - 1); }

//
// The following constants are related to IEEE 754 limits.
//
            startdenom = math.pow(width, chunks);
            significance = math.pow(2, significance);
            overflow = significance * 2;

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to intefere with determinstic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
            mixkey(math.random(), pool);

// End anonymous scope, and pass initial values.
        }(
            [],   // pool: entropy pool starts empty
            numeric.seedrandom, // math: package containing random, pow, and seedrandom
            256,  // width: each RC4 output is 0 <= x < 256
            6,    // chunks: at least six RC4 outputs for each double
            52    // significance: there are 52 significant digits in a double
        ));
        /* This file is a slightly modified version of quadprog.js from Alberto Santini.
 * It has been slightly modified by Sébastien Loisel to make sure that it handles
 * 0-based Arrays instead of 1-based Arrays.
 * License is in resources/LICENSE.quadprog */
        (function(exports) {

            function base0to1(A) {
                if(typeof A !== "object") { return A; }
                var ret = [], i,n=A.length;
                for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);
                return ret;
            }
            function base1to0(A) {
                if(typeof A !== "object") { return A; }
                var ret = [], i,n=A.length;
                for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);
                return ret;
            }

            function dpori(a, lda, n) {
                var i, j, k, kp1, t;

                for (k = 1; k <= n; k = k + 1) {
                    a[k][k] = 1 / a[k][k];
                    t = -a[k][k];
                    //~ dscal(k - 1, t, a[1][k], 1);
                    for (i = 1; i < k; i = i + 1) {
                        a[i][k] = t * a[i][k];
                    }

                    kp1 = k + 1;
                    if (n < kp1) {
                        break;
                    }
                    for (j = kp1; j <= n; j = j + 1) {
                        t = a[k][j];
                        a[k][j] = 0;
                        //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);
                        for (i = 1; i <= k; i = i + 1) {
                            a[i][j] = a[i][j] + (t * a[i][k]);
                        }
                    }
                }

            }

            function dposl(a, lda, n, b) {
                var i, k, kb, t;

                for (k = 1; k <= n; k = k + 1) {
                    //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);
                    t = 0;
                    for (i = 1; i < k; i = i + 1) {
                        t = t + (a[i][k] * b[i]);
                    }

                    b[k] = (b[k] - t) / a[k][k];
                }

                for (kb = 1; kb <= n; kb = kb + 1) {
                    k = n + 1 - kb;
                    b[k] = b[k] / a[k][k];
                    t = -b[k];
                    //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);
                    for (i = 1; i < k; i = i + 1) {
                        b[i] = b[i] + (t * a[i][k]);
                    }
                }
            }

            function dpofa(a, lda, n, info) {
                var i, j, jm1, k, t, s;

                for (j = 1; j <= n; j = j + 1) {
                    info[1] = j;
                    s = 0;
                    jm1 = j - 1;
                    if (jm1 < 1) {
                        s = a[j][j] - s;
                        if (s <= 0) {
                            break;
                        }
                        a[j][j] = Math.sqrt(s);
                    } else {
                        for (k = 1; k <= jm1; k = k + 1) {
                            //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);
                            t = a[k][j];
                            for (i = 1; i < k; i = i + 1) {
                                t = t - (a[i][j] * a[i][k]);
                            }
                            t = t / a[k][k];
                            a[k][j] = t;
                            s = s + t * t;
                        }
                        s = a[j][j] - s;
                        if (s <= 0) {
                            break;
                        }
                        a[j][j] = Math.sqrt(s);
                    }
                    info[1] = 0;
                }
            }

            function qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,
                            bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {

                var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,
                    temp, sum, t1, tt, gc, gs, nu,
                    t1inf, t2min,
                    vsmall, tmpa, tmpb,
                    go;

                r = Math.min(n, q);
                l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;

                vsmall = 1.0e-60;
                do {
                    vsmall = vsmall + vsmall;
                    tmpa = 1 + 0.1 * vsmall;
                    tmpb = 1 + 0.2 * vsmall;
                } while (tmpa <= 1 || tmpb <= 1);

                for (i = 1; i <= n; i = i + 1) {
                    work[i] = dvec[i];
                }
                for (i = n + 1; i <= l; i = i + 1) {
                    work[i] = 0;
                }
                for (i = 1; i <= q; i = i + 1) {
                    iact[i] = 0;
                }

                info = [];

                if (ierr[1] === 0) {
                    dpofa(dmat, fddmat, n, info);
                    if (info[1] !== 0) {
                        ierr[1] = 2;
                        return;
                    }
                    dposl(dmat, fddmat, n, dvec);
                    dpori(dmat, fddmat, n);
                } else {
                    for (j = 1; j <= n; j = j + 1) {
                        sol[j] = 0;
                        for (i = 1; i <= j; i = i + 1) {
                            sol[j] = sol[j] + dmat[i][j] * dvec[i];
                        }
                    }
                    for (j = 1; j <= n; j = j + 1) {
                        dvec[j] = 0;
                        for (i = j; i <= n; i = i + 1) {
                            dvec[j] = dvec[j] + dmat[j][i] * sol[i];
                        }
                    }
                }

                crval[1] = 0;
                for (j = 1; j <= n; j = j + 1) {
                    sol[j] = dvec[j];
                    crval[1] = crval[1] + work[j] * sol[j];
                    work[j] = 0;
                    for (i = j + 1; i <= n; i = i + 1) {
                        dmat[i][j] = 0;
                    }
                }
                crval[1] = -crval[1] / 2;
                ierr[1] = 0;

                iwzv = n;
                iwrv = iwzv + n;
                iwuv = iwrv + r;
                iwrm = iwuv + r + 1;
                iwsv = iwrm + (r * (r + 1)) / 2;
                iwnbv = iwsv + q;

                for (i = 1; i <= q; i = i + 1) {
                    sum = 0;
                    for (j = 1; j <= n; j = j + 1) {
                        sum = sum + amat[j][i] * amat[j][i];
                    }
                    work[iwnbv + i] = Math.sqrt(sum);
                }
                nact = 0;
                iter[1] = 0;
                iter[2] = 0;

                function fn_goto_50() {
                    iter[1] = iter[1] + 1;

                    l = iwsv;
                    for (i = 1; i <= q; i = i + 1) {
                        l = l + 1;
                        sum = -bvec[i];
                        for (j = 1; j <= n; j = j + 1) {
                            sum = sum + amat[j][i] * sol[j];
                        }
                        if (Math.abs(sum) < vsmall) {
                            sum = 0;
                        }
                        if (i > meq) {
                            work[l] = sum;
                        } else {
                            work[l] = -Math.abs(sum);
                            if (sum > 0) {
                                for (j = 1; j <= n; j = j + 1) {
                                    amat[j][i] = -amat[j][i];
                                }
                                bvec[i] = -bvec[i];
                            }
                        }
                    }

                    for (i = 1; i <= nact; i = i + 1) {
                        work[iwsv + iact[i]] = 0;
                    }

                    nvl = 0;
                    temp = 0;
                    for (i = 1; i <= q; i = i + 1) {
                        if (work[iwsv + i] < temp * work[iwnbv + i]) {
                            nvl = i;
                            temp = work[iwsv + i] / work[iwnbv + i];
                        }
                    }
                    if (nvl === 0) {
                        return 999;
                    }

                    return 0;
                }

                function fn_goto_55() {
                    for (i = 1; i <= n; i = i + 1) {
                        sum = 0;
                        for (j = 1; j <= n; j = j + 1) {
                            sum = sum + dmat[j][i] * amat[j][nvl];
                        }
                        work[i] = sum;
                    }

                    l1 = iwzv;
                    for (i = 1; i <= n; i = i + 1) {
                        work[l1 + i] = 0;
                    }
                    for (j = nact + 1; j <= n; j = j + 1) {
                        for (i = 1; i <= n; i = i + 1) {
                            work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];
                        }
                    }

                    t1inf = true;
                    for (i = nact; i >= 1; i = i - 1) {
                        sum = work[i];
                        l = iwrm + (i * (i + 3)) / 2;
                        l1 = l - i;
                        for (j = i + 1; j <= nact; j = j + 1) {
                            sum = sum - work[l] * work[iwrv + j];
                            l = l + j;
                        }
                        sum = sum / work[l1];
                        work[iwrv + i] = sum;
                        if (iact[i] < meq) {
                            // continue;
                            break;
                        }
                        if (sum < 0) {
                            // continue;
                            break;
                        }
                        t1inf = false;
                        it1 = i;
                    }

                    if (!t1inf) {
                        t1 = work[iwuv + it1] / work[iwrv + it1];
                        for (i = 1; i <= nact; i = i + 1) {
                            if (iact[i] < meq) {
                                // continue;
                                break;
                            }
                            if (work[iwrv + i] < 0) {
                                // continue;
                                break;
                            }
                            temp = work[iwuv + i] / work[iwrv + i];
                            if (temp < t1) {
                                t1 = temp;
                                it1 = i;
                            }
                        }
                    }

                    sum = 0;
                    for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {
                        sum = sum + work[i] * work[i];
                    }
                    if (Math.abs(sum) <= vsmall) {
                        if (t1inf) {
                            ierr[1] = 1;
                            // GOTO 999
                            return 999;
                        } else {
                            for (i = 1; i <= nact; i = i + 1) {
                                work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];
                            }
                            work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;
                            // GOTO 700
                            return 700;
                        }
                    } else {
                        sum = 0;
                        for (i = 1; i <= n; i = i + 1) {
                            sum = sum + work[iwzv + i] * amat[i][nvl];
                        }
                        tt = -work[iwsv + nvl] / sum;
                        t2min = true;
                        if (!t1inf) {
                            if (t1 < tt) {
                                tt = t1;
                                t2min = false;
                            }
                        }

                        for (i = 1; i <= n; i = i + 1) {
                            sol[i] = sol[i] + tt * work[iwzv + i];
                            if (Math.abs(sol[i]) < vsmall) {
                                sol[i] = 0;
                            }
                        }

                        crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);
                        for (i = 1; i <= nact; i = i + 1) {
                            work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];
                        }
                        work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;

                        if (t2min) {
                            nact = nact + 1;
                            iact[nact] = nvl;

                            l = iwrm + ((nact - 1) * nact) / 2 + 1;
                            for (i = 1; i <= nact - 1; i = i + 1) {
                                work[l] = work[i];
                                l = l + 1;
                            }

                            if (nact === n) {
                                work[l] = work[n];
                            } else {
                                for (i = n; i >= nact + 1; i = i - 1) {
                                    if (work[i] === 0) {
                                        // continue;
                                        break;
                                    }
                                    gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));
                                    gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));
                                    if (work[i - 1] >= 0) {
                                        temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                                    } else {
                                        temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                                    }
                                    gc = work[i - 1] / temp;
                                    gs = work[i] / temp;

                                    if (gc === 1) {
                                        // continue;
                                        break;
                                    }
                                    if (gc === 0) {
                                        work[i - 1] = gs * temp;
                                        for (j = 1; j <= n; j = j + 1) {
                                            temp = dmat[j][i - 1];
                                            dmat[j][i - 1] = dmat[j][i];
                                            dmat[j][i] = temp;
                                        }
                                    } else {
                                        work[i - 1] = temp;
                                        nu = gs / (1 + gc);
                                        for (j = 1; j <= n; j = j + 1) {
                                            temp = gc * dmat[j][i - 1] + gs * dmat[j][i];
                                            dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];
                                            dmat[j][i - 1] = temp;

                                        }
                                    }
                                }
                                work[l] = work[nact];
                            }
                        } else {
                            sum = -bvec[nvl];
                            for (j = 1; j <= n; j = j + 1) {
                                sum = sum + sol[j] * amat[j][nvl];
                            }
                            if (nvl > meq) {
                                work[iwsv + nvl] = sum;
                            } else {
                                work[iwsv + nvl] = -Math.abs(sum);
                                if (sum > 0) {
                                    for (j = 1; j <= n; j = j + 1) {
                                        amat[j][nvl] = -amat[j][nvl];
                                    }
                                    bvec[nvl] = -bvec[nvl];
                                }
                            }
                            // GOTO 700
                            return 700;
                        }
                    }

                    return 0;
                }

                function fn_goto_797() {
                    l = iwrm + (it1 * (it1 + 1)) / 2 + 1;
                    l1 = l + it1;
                    if (work[l1] === 0) {
                        // GOTO 798
                        return 798;
                    }
                    gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
                    gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));
                    if (work[l1 - 1] >= 0) {
                        temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                    } else {
                        temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));
                    }
                    gc = work[l1 - 1] / temp;
                    gs = work[l1] / temp;

                    if (gc === 1) {
                        // GOTO 798
                        return 798;
                    }
                    if (gc === 0) {
                        for (i = it1 + 1; i <= nact; i = i + 1) {
                            temp = work[l1 - 1];
                            work[l1 - 1] = work[l1];
                            work[l1] = temp;
                            l1 = l1 + i;
                        }
                        for (i = 1; i <= n; i = i + 1) {
                            temp = dmat[i][it1];
                            dmat[i][it1] = dmat[i][it1 + 1];
                            dmat[i][it1 + 1] = temp;
                        }
                    } else {
                        nu = gs / (1 + gc);
                        for (i = it1 + 1; i <= nact; i = i + 1) {
                            temp = gc * work[l1 - 1] + gs * work[l1];
                            work[l1] = nu * (work[l1 - 1] + temp) - work[l1];
                            work[l1 - 1] = temp;
                            l1 = l1 + i;
                        }
                        for (i = 1; i <= n; i = i + 1) {
                            temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];
                            dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];
                            dmat[i][it1] = temp;
                        }
                    }

                    return 0;
                }

                function fn_goto_798() {
                    l1 = l - it1;
                    for (i = 1; i <= it1; i = i + 1) {
                        work[l1] = work[l];
                        l = l + 1;
                        l1 = l1 + 1;
                    }

                    work[iwuv + it1] = work[iwuv + it1 + 1];
                    iact[it1] = iact[it1 + 1];
                    it1 = it1 + 1;
                    if (it1 < nact) {
                        // GOTO 797
                        return 797;
                    }

                    return 0;
                }

                function fn_goto_799() {
                    work[iwuv + nact] = work[iwuv + nact + 1];
                    work[iwuv + nact + 1] = 0;
                    iact[nact] = 0;
                    nact = nact - 1;
                    iter[2] = iter[2] + 1;

                    return 0;
                }

                go = 0;
                while (true) {
                    go = fn_goto_50();
                    if (go === 999) {
                        return;
                    }
                    while (true) {
                        go = fn_goto_55();
                        if (go === 0) {
                            break;
                        }
                        if (go === 999) {
                            return;
                        }
                        if (go === 700) {
                            if (it1 === nact) {
                                fn_goto_799();
                            } else {
                                while (true) {
                                    fn_goto_797();
                                    go = fn_goto_798();
                                    if (go !== 797) {
                                        break;
                                    }
                                }
                                fn_goto_799();
                            }
                        }
                    }
                }

            }

            function solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {
                Dmat = base0to1(Dmat);
                dvec = base0to1(dvec);
                Amat = base0to1(Amat);
                var i, n, q,
                    nact, r,
                    crval = [], iact = [], sol = [], work = [], iter = [],
                    message;

                meq = meq || 0;
                factorized = factorized ? base0to1(factorized) : [undefined, 0];
                bvec = bvec ? base0to1(bvec) : [];

                // In Fortran the array index starts from 1
                n = Dmat.length - 1;
                q = Amat[1].length - 1;

                if (!bvec) {
                    for (i = 1; i <= q; i = i + 1) {
                        bvec[i] = 0;
                    }
                }
                for (i = 1; i <= q; i = i + 1) {
                    iact[i] = 0;
                }
                nact = 0;
                r = Math.min(n, q);
                for (i = 1; i <= n; i = i + 1) {
                    sol[i] = 0;
                }
                crval[1] = 0;
                for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {
                    work[i] = 0;
                }
                for (i = 1; i <= 2; i = i + 1) {
                    iter[i] = 0;
                }

                qpgen2(Dmat, dvec, n, n, sol, crval, Amat,
                    bvec, n, q, meq, iact, nact, iter, work, factorized);

                message = "";
                if (factorized[1] === 1) {
                    message = "constraints are inconsistent, no solution!";
                }
                if (factorized[1] === 2) {
                    message = "matrix D in quadratic function is not positive definite!";
                }

                return {
                    solution: base1to0(sol),
                    value: base1to0(crval),
                    unconstrained_solution: base1to0(dvec),
                    iterations: base1to0(iter),
                    iact: base1to0(iact),
                    message: message
                };
            }
            exports.solveQP = solveQP;
        }(numeric));
        /*
Shanti Rao sent me this routine by private email. I had to modify it
slightly to work on Arrays instead of using a Matrix object.
It is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py
*/

        numeric.svd= function svd(A) {
            var temp;
//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)
            var prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec
            var tolerance= 1.e-64/prec;
            var itmax= 50;
            var c=0;
            var i=0;
            var j=0;
            var k=0;
            var l=0;

            var u= numeric.clone(A);
            var m= u.length;

            var n= u[0].length;

            if (m < n) throw "Need more rows than columns"

            var e = new Array(n);
            var q = new Array(n);
            for (i=0; i<n; i++) e[i] = q[i] = 0.0;
            var v = numeric.rep([n,n],0);
//	v.zero();

            function pythag(a,b)
            {
                a = Math.abs(a)
                b = Math.abs(b)
                if (a > b)
                    return a*Math.sqrt(1.0+(b*b/a/a))
                else if (b == 0.0)
                    return a
                return b*Math.sqrt(1.0+(a*a/b/b))
            }

            //Householder's reduction to bidiagonal form

            var f= 0.0;
            var g= 0.0;
            var h= 0.0;
            var x= 0.0;
            var y= 0.0;
            var z= 0.0;
            var s= 0.0;

            for (i=0; i < n; i++)
            {
                e[i]= g;
                s= 0.0;
                l= i+1;
                for (j=i; j < m; j++)
                    s += (u[j][i]*u[j][i]);
                if (s <= tolerance)
                    g= 0.0;
                else
                {
                    f= u[i][i];
                    g= Math.sqrt(s);
                    if (f >= 0.0) g= -g;
                    h= f*g-s
                    u[i][i]=f-g;
                    for (j=l; j < n; j++)
                    {
                        s= 0.0
                        for (k=i; k < m; k++)
                            s += u[k][i]*u[k][j]
                        f= s/h
                        for (k=i; k < m; k++)
                            u[k][j]+=f*u[k][i]
                    }
                }
                q[i]= g
                s= 0.0
                for (j=l; j < n; j++)
                    s= s + u[i][j]*u[i][j]
                if (s <= tolerance)
                    g= 0.0
                else
                {
                    f= u[i][i+1]
                    g= Math.sqrt(s)
                    if (f >= 0.0) g= -g
                    h= f*g - s
                    u[i][i+1] = f-g;
                    for (j=l; j < n; j++) e[j]= u[i][j]/h
                    for (j=l; j < m; j++)
                    {
                        s=0.0
                        for (k=l; k < n; k++)
                            s += (u[j][k]*u[i][k])
                        for (k=l; k < n; k++)
                            u[j][k]+=s*e[k]
                    }
                }
                y= Math.abs(q[i])+Math.abs(e[i])
                if (y>x)
                    x=y
            }

            // accumulation of right hand gtransformations
            for (i=n-1; i != -1; i+= -1)
            {
                if (g != 0.0)
                {
                    h= g*u[i][i+1]
                    for (j=l; j < n; j++)
                        v[j][i]=u[i][j]/h
                    for (j=l; j < n; j++)
                    {
                        s=0.0
                        for (k=l; k < n; k++)
                            s += u[i][k]*v[k][j]
                        for (k=l; k < n; k++)
                            v[k][j]+=(s*v[k][i])
                    }
                }
                for (j=l; j < n; j++)
                {
                    v[i][j] = 0;
                    v[j][i] = 0;
                }
                v[i][i] = 1;
                g= e[i]
                l= i
            }

            // accumulation of left hand transformations
            for (i=n-1; i != -1; i+= -1)
            {
                l= i+1
                g= q[i]
                for (j=l; j < n; j++)
                    u[i][j] = 0;
                if (g != 0.0)
                {
                    h= u[i][i]*g
                    for (j=l; j < n; j++)
                    {
                        s=0.0
                        for (k=l; k < m; k++) s += u[k][i]*u[k][j];
                        f= s/h
                        for (k=i; k < m; k++) u[k][j]+=f*u[k][i];
                    }
                    for (j=i; j < m; j++) u[j][i] = u[j][i]/g;
                }
                else
                    for (j=i; j < m; j++) u[j][i] = 0;
                u[i][i] += 1;
            }

            // diagonalization of the bidiagonal form
            prec= prec*x
            for (k=n-1; k != -1; k+= -1)
            {
                for (var iteration=0; iteration < itmax; iteration++)
                {	// test f splitting
                    var test_convergence = false
                    for (l=k; l != -1; l+= -1)
                    {
                        if (Math.abs(e[l]) <= prec)
                        {	test_convergence= true
                            break
                        }
                        if (Math.abs(q[l-1]) <= prec)
                            break
                    }
                    if (!test_convergence)
                    {	// cancellation of e[l] if l>0
                        c= 0.0
                        s= 1.0
                        var l1= l-1
                        for (i =l; i<k+1; i++)
                        {
                            f= s*e[i]
                            e[i]= c*e[i]
                            if (Math.abs(f) <= prec)
                                break
                            g= q[i]
                            h= pythag(f,g)
                            q[i]= h
                            c= g/h
                            s= -f/h
                            for (j=0; j < m; j++)
                            {
                                y= u[j][l1]
                                z= u[j][i]
                                u[j][l1] =  y*c+(z*s)
                                u[j][i] = -y*s+(z*c)
                            }
                        }
                    }
                    // test f convergence
                    z= q[k]
                    if (l== k)
                    {	//convergence
                        if (z<0.0)
                        {	//q[k] is made non-negative
                            q[k]= -z
                            for (j=0; j < n; j++)
                                v[j][k] = -v[j][k]
                        }
                        break  //break out of iteration loop and move on to next k value
                    }
                    if (iteration >= itmax-1)
                        throw 'Error: no convergence.'
                    // shift from bottom 2x2 minor
                    x= q[l]
                    y= q[k-1]
                    g= e[k-1]
                    h= e[k]
                    f= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)
                    g= pythag(f,1.0)
                    if (f < 0.0)
                        f= ((x-z)*(x+z)+h*(y/(f-g)-h))/x
                    else
                        f= ((x-z)*(x+z)+h*(y/(f+g)-h))/x
                    // next QR transformation
                    c= 1.0
                    s= 1.0
                    for (i=l+1; i< k+1; i++)
                    {
                        g= e[i]
                        y= q[i]
                        h= s*g
                        g= c*g
                        z= pythag(f,h)
                        e[i-1]= z
                        c= f/z
                        s= h/z
                        f= x*c+g*s
                        g= -x*s+g*c
                        h= y*s
                        y= y*c
                        for (j=0; j < n; j++)
                        {
                            x= v[j][i-1]
                            z= v[j][i]
                            v[j][i-1] = x*c+z*s
                            v[j][i] = -x*s+z*c
                        }
                        z= pythag(f,h)
                        q[i-1]= z
                        c= f/z
                        s= h/z
                        f= c*g+s*y
                        x= -s*g+c*y
                        for (j=0; j < m; j++)
                        {
                            y= u[j][i-1]
                            z= u[j][i]
                            u[j][i-1] = y*c+z*s
                            u[j][i] = -y*s+z*c
                        }
                    }
                    e[l]= 0.0
                    e[k]= f
                    q[k]= x
                }
            }

            //vt= transpose(v)
            //return (u,q,vt)
            for (i=0;i<q.length; i++)
                if (q[i] < prec) q[i] = 0

            //sort eigenvalues
            for (i=0; i< n; i++)
            {
                //writeln(q)
                for (j=i-1; j >= 0; j--)
                {
                    if (q[j] < q[i])
                    {
                        //  writeln(i,'-',j)
                        c = q[j]
                        q[j] = q[i]
                        q[i] = c
                        for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }
                        for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }
//	   u.swapCols(i,j)
//	   v.swapCols(i,j)
                        i = j
                    }
                }
            }

            return {U:u,S:q,V:v}
        };


    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],9:[function(require,module,exports){
    /*
 (c) 2013, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

    (function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
        function getSqDist(p1, p2) {

            var dx = p1.x - p2.x,
                dy = p1.y - p2.y;

            return dx * dx + dy * dy;
        }

// square distance from a point to a segment
        function getSqSegDist(p, p1, p2) {

            var x = p1.x,
                y = p1.y,
                dx = p2.x - x,
                dy = p2.y - y;

            if (dx !== 0 || dy !== 0) {

                var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

                if (t > 1) {
                    x = p2.x;
                    y = p2.y;

                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }

            dx = p.x - x;
            dy = p.y - y;

            return dx * dx + dy * dy;
        }
// rest of the code doesn't care about point format

// basic distance-based simplification
        function simplifyRadialDist(points, sqTolerance) {

            var prevPoint = points[0],
                newPoints = [prevPoint],
                point;

            for (var i = 1, len = points.length; i < len; i++) {
                point = points[i];

                if (getSqDist(point, prevPoint) > sqTolerance) {
                    newPoints.push(point);
                    prevPoint = point;
                }
            }

            if (prevPoint !== point) newPoints.push(point);

            return newPoints;
        }

// simplification using optimized Douglas-Peucker algorithm with recursion elimination
        function simplifyDouglasPeucker(points, sqTolerance) {

            var len = points.length,
                MarkerArray = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
                markers = new MarkerArray(len),
                first = 0,
                last = len - 1,
                stack = [],
                newPoints = [],
                i, maxSqDist, sqDist, index;

            markers[first] = markers[last] = 1;

            while (last) {

                maxSqDist = 0;

                for (i = first + 1; i < last; i++) {
                    sqDist = getSqSegDist(points[i], points[first], points[last]);

                    if (sqDist > maxSqDist) {
                        index = i;
                        maxSqDist = sqDist;
                    }
                }

                if (maxSqDist > sqTolerance) {
                    markers[index] = 1;
                    stack.push(first, index, index, last);
                }

                last = stack.pop();
                first = stack.pop();
            }

            for (i = 0; i < len; i++) {
                if (markers[i]) newPoints.push(points[i]);
            }

            return newPoints;
        }

// both algorithms combined for awesome performance
        function simplify(points, tolerance, highestQuality) {

            var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

            points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
            points = simplifyDouglasPeucker(points, sqTolerance);

            return points;
        }

// export as AMD module / Node module / browser or worker variable
        if (typeof define === 'function' && define.amd) define(function() { return simplify; });
        else if (typeof module !== 'undefined') module.exports = simplify;
        else if (typeof self !== 'undefined') self.simplify = simplify;
        else window.simplify = simplify;

    })();

},{}],10:[function(require,module,exports){
    "use strict"

    module.exports = createKDTree
    module.exports.deserialize = deserializeKDTree

    var ndarray = require("ndarray")
    var ndselect = require("ndarray-select")
    var pack = require("ndarray-pack")
    var ops = require("ndarray-ops")
    var ndscratch = require("ndarray-scratch")
    var pool = require("typedarray-pool")
    var inorderTree = require("inorder-tree-layout")
    var bits = require("bit-twiddle")
    var KDTHeap = require("./lib/heap.js")

    function KDTree(points, ids, n, d) {
        this.points = points
        this.ids = ids
        this.dimension = d
        this.length = n
    }

    var proto = KDTree.prototype

    proto.serialize = function() {
        if(this.length > 0) {
            return {
                p: Array.prototype.slice.call(this.points.data, 0, this.length*this.dimension),
                i: Array.prototype.slice.call(this.ids, 0, this.length)
            }
        } else {
            return { d: this.dimension }
        }
    }

//Range query
    proto.range = function kdtRangeQuery(lo, hi, visit) {
        var n = this.length
        if(n < 1) {
            return
        }

        //Check degenerate case
        var d = this.dimension
        for(var i=0; i<d; ++i) {
            if(hi[i] < lo[i]) {
                return
            }
        }

        var points = this.points
        var ids = this.ids

        //Walk tree in level order, skipping subtrees which do not intersect range
        var visitRange = ndscratch.malloc([n, 2, d])
        var visitIndex = pool.mallocInt32(n)
        var rangeData = visitRange.data
        var pointData = points.data
        var visitCount = 1
        var visitTop = 0
        var retval

        visitIndex[0] = 0
        pack(lo, visitRange.pick(0,0))
        pack(hi, visitRange.pick(0,1))

        while(visitTop < visitCount) {
            var idx = visitIndex[visitTop]
            var k = bits.log2(idx+1)%d
            var loidx = visitRange.index(visitTop, 0, 0)
            var hiidx = visitRange.index(visitTop, 1, 0)
            var pidx = points.index(idx, 0)

            var visitPoint = true
            for(var i=0; i<d; ++i) {
                var pc = pointData[pidx+i]
                if((pc < rangeData[loidx + i]) ||
                    (rangeData[hiidx + i] < pc)) {
                    visitPoint = false
                    break
                }
            }
            if(visitPoint) {
                retval = visit(ids[idx])
                if(retval !== undefined) {
                    break
                }
            }

            //Visit children
            var pk = pointData[pidx+k]
            var hk = rangeData[hiidx+k]
            var lk = rangeData[loidx+k]
            if(lk <= pk) {
                var left = 2 * idx + 1
                if(left < n) {
                    visitIndex[visitCount] = left
                    var y = visitRange.index(visitCount, 0, 0)
                    for(var i=0; i<d; ++i) {
                        rangeData[y+i] = rangeData[loidx+i]
                    }
                    var z = visitRange.index(visitCount, 1, 0)
                    for(var i=0; i<d; ++i) {
                        rangeData[z+i] = rangeData[hiidx+i]
                    }
                    rangeData[z+k] = Math.min(hk, pk)
                    visitCount += 1
                }
            }
            if(pk <= hk) {
                var right = 2 * (idx + 1)
                if(right < n) {
                    visitIndex[visitCount] = right
                    var y = visitRange.index(visitCount, 0, 0)
                    for(var i=0; i<d; ++i) {
                        rangeData[y+i] = rangeData[loidx+i]
                    }
                    var z = visitRange.index(visitCount, 1, 0)
                    for(var i=0; i<d; ++i) {
                        rangeData[z+i] = rangeData[hiidx+i]
                    }
                    rangeData[y+k] = Math.max(lk, pk)
                    visitCount += 1
                }
            }

            //Increment pointer
            visitTop += 1
        }
        ndscratch.free(visitRange)
        pool.free(visitIndex)
        return retval
    }

    proto.rnn = function(point, radius, visit) {
        if(radius < 0) {
            return
        }
        var n = this.length
        if(n < 1) {
            return
        }
        var d = this.dimension
        var points = this.points
        var ids = this.ids

        //Walk tree in level order, skipping subtrees which do not intersect sphere
        var visitDistance = ndscratch.malloc([n, d])
        var visitIndex = pool.mallocInt32(n)
        var distanceData = visitDistance.data
        var pointData = points.data
        var visitCount = 1
        var visitTop = 0
        var r2 = radius*radius
        var retval

        //Initialize top of queue
        visitIndex[0] = 0
        for(var i=0; i<d; ++i) {
            visitDistance.set(0, i, 0)
        }

        //Walk over queue
        while(visitTop < visitCount) {
            var idx = visitIndex[visitTop]
            var pidx = points.index(idx, 0)

            //Check if point in sphere
            var d2 = 0.0
            for(var i=0; i<d; ++i) {
                d2 += Math.pow(point[i] - pointData[pidx+i], 2)
            }
            if(d2 <= r2) {
                retval = visit(ids[idx])
                if(retval !== undefined) {
                    break
                }
            }

            //Visit children
            var k = bits.log2(idx+1)%d
            var ds = 0.0
            var didx = visitDistance.index(visitTop, 0)
            for(var i=0; i<d; ++i) {
                if(i !== k) {
                    ds += distanceData[didx + i]
                }
            }

            //Handle split axis
            var qk = point[k]
            var pk = pointData[pidx+k]
            var dk = distanceData[didx+k]
            var lk = dk
            var hk = dk
            if(qk < pk) {
                hk = Math.max(dk, Math.pow(pk - qk, 2))
            } else {
                lk = Math.max(dk, Math.pow(pk - qk, 2))
            }

            var d2l = lk + ds
            var d2h = hk + ds

            if(d2l <= r2) {
                var left = 2 * idx + 1
                if(left < n) {
                    visitIndex[visitCount] = left
                    var y = visitDistance.index(visitCount, 0)
                    for(var i=0; i<d; ++i) {
                        distanceData[y+i] = distanceData[didx+i]
                    }
                    distanceData[y+k] = lk
                    visitCount += 1
                }
            }
            if(d2h <= r2) {
                var right = 2 * (idx + 1)
                if(right < n) {
                    visitIndex[visitCount] = right
                    var y = visitDistance.index(visitCount, 0)
                    for(var i=0; i<d; ++i) {
                        distanceData[y+i] = distanceData[didx+i]
                    }
                    distanceData[y+k] = hk
                    visitCount += 1
                }
            }

            //Increment pointer
            visitTop += 1
        }

        ndscratch.free(visitDistance)
        pool.free(visitIndex)
        return retval
    }

    proto.nn = function(point, maxDistance) {
        var n = this.length
        if(n < 1) {
            return -1
        }
        if(typeof maxDistance === "number") {
            if(maxDistance < 0) {
                return -1
            }
        } else {
            maxDistance = Infinity
        }
        var d = this.dimension
        var points = this.points
        var pointData = points.data
        var dataVector = pool.mallocFloat64(d)

        var toVisit = new KDTHeap(n, d+1)
        var index = toVisit.index
        var data = toVisit.data
        index[0] = 0
        for(var i=0; i<=d; ++i) {
            data[i] = 0
        }
        toVisit.count += 1

        var nearest = -1
        var nearestD = maxDistance

        while(toVisit.count > 0) {
            if(data[0] >= nearestD) {
                break
            }

            var idx = index[0]
            var pidx = points.index(idx, 0)
            var d2 = 0.0
            for(var i=0; i<d; ++i) {
                d2 += Math.pow(point[i]-pointData[pidx+i], 2)
            }
            if(d2 < nearestD) {
                nearestD = d2
                nearest = idx
            }

            //Compute distance bounds for children
            var k = bits.log2(idx+1)%d
            var ds = 0
            for(var i=0; i<d; ++i) {
                var dd = data[i+1]
                if(i !== k) {
                    ds += dd
                }
                dataVector[i] = dd
            }
            var qk = point[k]
            var pk = pointData[pidx+k]
            var dk = dataVector[k]
            var lk = dk
            var hk = dk
            if(qk < pk) {
                hk = Math.max(dk, Math.pow(pk - qk, 2))
            } else {
                lk = Math.max(dk, Math.pow(pk - qk, 2))
            }
            var d2l = lk + ds
            var d2h = hk + ds

            toVisit.pop()

            if(d2l < nearestD) {
                var left = 2 * idx + 1
                if(left < n) {
                    var vcount = toVisit.count
                    index[vcount] = left
                    var vptr = vcount * (d+1)
                    data[vptr] = d2l
                    for(var i=1; i<=d; ++i) {
                        data[vptr+i] = dataVector[i-1]
                    }
                    data[vptr+k+1] = lk
                    toVisit.push()
                }
            }
            if(d2h < nearestD) {
                var right = 2 * (idx + 1)
                if(right < n) {
                    var vcount = toVisit.count
                    index[vcount] = right
                    var vptr = vcount * (d+1)
                    data[vptr] = d2h
                    for(var i=1; i<=d; ++i) {
                        data[vptr+i] = dataVector[i-1]
                    }
                    data[vptr+k+1] = hk
                    toVisit.push()
                }
            }
        }

        pool.freeFloat64(dataVector)
        toVisit.dispose()

        if(nearest < 0) {
            return -1
        }
        return this.ids[nearest]
    }

    proto.knn = function(point, maxPoints, maxDistance) {
        //Check degenerate cases
        if(typeof maxDistance === "number") {
            if(maxDistance < 0) {
                return []
            }
        } else {
            maxDistance = Infinity
        }
        var n = this.length
        if(n < 1) {
            return []
        }
        if(typeof maxPoints === "number") {
            if(maxPoints <= 0) {
                return []
            }
            maxPoints = Math.min(maxPoints, n)|0
        } else {
            maxPoints = n
        }
        var ids = this.ids

        var d = this.dimension
        var points = this.points
        var pointData = points.data
        var dataVector = pool.mallocFloat64(d)

        //List of closest points
        var closestPoints = new KDTHeap(maxPoints, 1)
        var cl_index = closestPoints.index
        var cl_data = closestPoints.data

        var toVisit = new KDTHeap(n, d+1)
        var index = toVisit.index
        var data = toVisit.data
        index[0] = 0
        for(var i=0; i<=d; ++i) {
            data[i] = 0
        }
        toVisit.count += 1

        var nearest = -1
        var nearestD = maxDistance

        while(toVisit.count > 0) {
            if(data[0] >= nearestD) {
                break
            }

            var idx = index[0]
            var pidx = points.index(idx, 0)
            var d2 = 0.0
            for(var i=0; i<d; ++i) {
                d2 += Math.pow(point[i]-pointData[pidx+i], 2)
            }
            if(d2 < nearestD) {
                if(closestPoints.count >= maxPoints) {
                    closestPoints.pop()
                }
                var pcount = closestPoints.count
                cl_index[pcount] = idx
                cl_data[pcount] = -d2
                closestPoints.push()
                if(closestPoints.count >= maxPoints) {
                    nearestD = -cl_data[0]
                }
            }

            //Compute distance bounds for children
            var k = bits.log2(idx+1)%d
            var ds = 0
            for(var i=0; i<d; ++i) {
                var dd = data[i+1]
                if(i !== k) {
                    ds += dd
                }
                dataVector[i] = dd
            }
            var qk = point[k]
            var pk = pointData[pidx+k]
            var dk = dataVector[k]
            var lk = dk
            var hk = dk
            if(qk < pk) {
                hk = Math.max(dk, Math.pow(pk - qk, 2))
            } else {
                lk = Math.max(dk, Math.pow(pk - qk, 2))
            }
            var d2l = lk + ds
            var d2h = hk + ds

            toVisit.pop()
            if(d2l < nearestD) {
                var left = 2 * idx + 1
                if(left < n) {
                    var vcount = toVisit.count
                    index[vcount] = left
                    var vptr = vcount * (d+1)
                    data[vptr] = d2l
                    for(var i=1; i<=d; ++i) {
                        data[vptr+i] = dataVector[i-1]
                    }
                    data[vptr+k+1] = lk
                    toVisit.push()
                }
            }
            if(d2h < nearestD) {
                var right = 2 * (idx + 1)
                if(right < n) {
                    var vcount = toVisit.count
                    index[vcount] = right
                    var vptr = vcount * (d+1)
                    data[vptr] = d2h
                    for(var i=1; i<=d; ++i) {
                        data[vptr+i] = dataVector[i-1]
                    }
                    data[vptr+k+1] = hk
                    toVisit.push()
                }
            }
        }

        pool.freeFloat64(dataVector)
        toVisit.dispose()

        //Sort result
        var result = new Array(closestPoints.count)
        var ids = this.ids
        for(var i=closestPoints.count-1; i>=0; --i) {
            result[i] = ids[cl_index[0]]
            closestPoints.pop()
        }
        closestPoints.dispose()

        return result
    }

    proto.dispose = function kdtDispose() {
        pool.free(this.points.data)
        pool.freeInt32(this.ids)
        this.points = null
        this.ids = null
        this.length = 0
    }

    function createKDTree(points) {
        var n, d, indexed
        if(Array.isArray(points)) {
            n = points.length
            if(n === 0) {
                return new KDTree(null, null, 0, 0)
            }
            d = points[0].length
            indexed = ndarray(pool.mallocDouble(n*(d+1)), [n, d+1])
            pack(points, indexed.hi(n, d))
        } else {
            n = points.shape[0]
            d = points.shape[1]

            //Round up data type size
            var type = points.dtype
            if(type === "int8" ||
                type === "int16" ||
                type === "int32" ) {
                type = "int32"
            } else if(type === "uint8" ||
                type === "uint8_clamped" ||
                type === "buffer" ||
                type === "uint16" ||
                type === "uint32") {
                type = "uint32"
            } else if(type === "float32") {
                type = "float32"
            } else {
                type = "float64"
            }
            indexed = ndarray(pool.malloc(n*(d+1)), [n, d+1])
            ops.assign(indexed.hi(n,d), points)
        }
        for(var i=0; i<n; ++i) {
            indexed.set(i, d, i)
        }

        var pointArray = ndscratch.malloc([n, d], points.dtype)
        var indexArray = pool.mallocInt32(n)
        var pointer = 0
        var pointData = pointArray.data
        var arrayData = indexed.data
        var l2_n = bits.log2(bits.nextPow2(n))

        var sel_cmp = ndselect.compile(indexed.order, true, indexed.dtype)

        //Walk tree in level order
        var toVisit = [indexed]
        while(pointer < n) {
            var head = toVisit.shift()
            var array = head
            var nn = array.shape[0]|0

            //Find median
            if(nn > 1) {
                var k = bits.log2(pointer+1)%d
                var median
                var n_2 = inorderTree.root(nn)
                median = sel_cmp(array, n_2, function(a,b) {
                    return a.get(k) - b.get(k)
                })

                //Copy into new array
                var pptr = pointArray.index(pointer, 0)
                var mptr = median.offset
                for(var i=0; i<d; ++i) {
                    pointData[pptr++] = arrayData[mptr++]
                }
                indexArray[pointer] = arrayData[mptr]
                pointer += 1

                //Queue new items
                toVisit.push(array.hi(n_2))
                if(nn > 2) {
                    toVisit.push(array.lo(n_2+1))
                }
            } else {
                //Copy into new array
                var mptr = array.offset
                var pptr = pointArray.index(pointer, 0)
                for(var i=0; i<d; ++i) {
                    pointData[pptr+i] = arrayData[mptr++]
                }
                indexArray[pointer] = arrayData[mptr]
                pointer += 1
            }
        }

        //Release indexed
        pool.free(indexed.data)

        return new KDTree(pointArray, indexArray, n, d)
    }

    function deserializeKDTree(data) {
        var points = data.p
        var ids = data.i
        if(points) {
            var nd = points.length
            var pointArray = pool.mallocFloat64(nd)
            for(var i=0; i<nd; ++i) {
                pointArray[i] = points[i]
            }
            var n = ids.length
            var idArray = pool.mallocInt32(n)
            for(var i=0; i<n; ++i) {
                idArray[i] = ids[i]
            }
            var d = (nd/n)|0
            return new KDTree(
                ndarray(pointArray, [n,d]),
                idArray,
                n,
                d)
        } else {
            return new KDTree(null, null, 0, data.d)
        }
    }
},{"./lib/heap.js":11,"bit-twiddle":12,"inorder-tree-layout":13,"ndarray":28,"ndarray-ops":15,"ndarray-pack":20,"ndarray-scratch":26,"ndarray-select":27,"typedarray-pool":32}],11:[function(require,module,exports){
    "use strict"

    module.exports = KDTHeap

    var pool = require("typedarray-pool")

    function heapParent(i) {
        if(i & 1) {
            return (i - 1) >> 1
        }
        return (i >> 1) - 1
    }

    function KDTHeap(n, d) {
        this.count = 0
        this.dataSize = d
        this.index = pool.mallocInt32(n)
        this.data = pool.mallocFloat64(n*d)
    }

    var proto = KDTHeap.prototype

    proto.heapSwap = function(_i,_j) {
        var data = this.data
        var index = this.index
        var d = this.dataSize
        var tmp = index[_i]
        index[_i] = index[_j]
        index[_j] = tmp
        var aptr = d*_i
        var bptr = d*_j
        for(var _k=0; _k<d; ++_k) {
            var t2 = data[aptr]
            data[aptr] = data[bptr]
            data[bptr] = t2
            aptr += 1
            bptr += 1
        }
    }

    proto.heapUp = function(i) {
        var d = this.dataSize
        var index = this.index
        var data = this.data
        var w = data[d*i]
        while(i>0) {
            var parent = heapParent(i)
            if(parent >= 0) {
                var pw = data[d*parent]
                if(w < pw) {
                    this.heapSwap(i, parent)
                    i = parent
                    continue
                }
            }
            break
        }
    }

    proto.heapDown = function(i) {
        var d = this.dataSize
        var index = this.index
        var data = this.data
        var count = this.count
        var w = data[d*i]
        while(true) {
            var tw = w
            var left  = 2*i + 1
            var right = 2*(i + 1)
            var next = i
            if(left < count) {
                var lw = data[d*left]
                if(lw < tw) {
                    next = left
                    tw = lw
                }
            }
            if(right < count) {
                var rw = data[d*right]
                if(rw < tw) {
                    next = right
                }
            }
            if(next === i) {
                break
            }
            this.heapSwap(i, next)
            i = next
        }
    }

//Clear item from top of heap
    proto.pop = function() {
        this.count -= 1
        this.heapSwap(0, this.count)
        this.heapDown(0)
    }

//Assume object already written to data
    proto.push = function() {
        this.heapUp(this.count)
        this.count += 1
    }

    proto.dispose = function() {
        pool.freeInt32(this.index)
        pool.freeFloat64(this.data)
    }
},{"typedarray-pool":32}],12:[function(require,module,exports){
    /**
     * Bit twiddling hacks for JavaScript.
     *
     * Author: Mikola Lysenko
     *
     * Ported from Stanford bit twiddling hack library:
     *    http://graphics.stanford.edu/~seander/bithacks.html
     */

    "use strict"; "use restrict";

//Number of bits in an integer
    var INT_BITS = 32;

//Constants
    exports.INT_BITS  = INT_BITS;
    exports.INT_MAX   =  0x7fffffff;
    exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
    exports.sign = function(v) {
        return (v > 0) - (v < 0);
    }

//Computes absolute value of integer
    exports.abs = function(v) {
        var mask = v >> (INT_BITS-1);
        return (v ^ mask) - mask;
    }

//Computes minimum of integers x and y
    exports.min = function(x, y) {
        return y ^ ((x ^ y) & -(x < y));
    }

//Computes maximum of integers x and y
    exports.max = function(x, y) {
        return x ^ ((x ^ y) & -(x < y));
    }

//Checks if a number is a power of two
    exports.isPow2 = function(v) {
        return !(v & (v-1)) && (!!v);
    }

//Computes log base 2 of v
    exports.log2 = function(v) {
        var r, shift;
        r =     (v > 0xFFFF) << 4; v >>>= r;
        shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
        shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
        shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
        return r | (v >> 1);
    }

//Computes log base 10 of v
    exports.log10 = function(v) {
        return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
            (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
                (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
    }

//Counts number of bits
    exports.popCount = function(v) {
        v = v - ((v >>> 1) & 0x55555555);
        v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
        return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
    }

//Counts number of trailing zeros
    function countTrailingZeros(v) {
        var c = 32;
        v &= -v;
        if (v) c--;
        if (v & 0x0000FFFF) c -= 16;
        if (v & 0x00FF00FF) c -= 8;
        if (v & 0x0F0F0F0F) c -= 4;
        if (v & 0x33333333) c -= 2;
        if (v & 0x55555555) c -= 1;
        return c;
    }
    exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
    exports.nextPow2 = function(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
    }

//Rounds down to previous power of 2
    exports.prevPow2 = function(v) {
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v - (v>>>1);
    }

//Computes parity of word
    exports.parity = function(v) {
        v ^= v >>> 16;
        v ^= v >>> 8;
        v ^= v >>> 4;
        v &= 0xf;
        return (0x6996 >>> v) & 1;
    }

    var REVERSE_TABLE = new Array(256);

    (function(tab) {
        for(var i=0; i<256; ++i) {
            var v = i, r = i, s = 7;
            for (v >>>= 1; v; v >>>= 1) {
                r <<= 1;
                r |= v & 1;
                --s;
            }
            tab[i] = (r << s) & 0xff;
        }
    })(REVERSE_TABLE);

//Reverse bits in a 32 bit word
    exports.reverse = function(v) {
        return  (REVERSE_TABLE[ v         & 0xff] << 24) |
            (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
            (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
            REVERSE_TABLE[(v >>> 24) & 0xff];
    }

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
    exports.interleave2 = function(x, y) {
        x &= 0xFFFF;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;

        y &= 0xFFFF;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;

        return x | (y << 1);
    }

//Extracts the nth interleaved component
    exports.deinterleave2 = function(v, n) {
        v = (v >>> n) & 0x55555555;
        v = (v | (v >>> 1))  & 0x33333333;
        v = (v | (v >>> 2))  & 0x0F0F0F0F;
        v = (v | (v >>> 4))  & 0x00FF00FF;
        v = (v | (v >>> 16)) & 0x000FFFF;
        return (v << 16) >> 16;
    }


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
    exports.interleave3 = function(x, y, z) {
        x &= 0x3FF;
        x  = (x | (x<<16)) & 4278190335;
        x  = (x | (x<<8))  & 251719695;
        x  = (x | (x<<4))  & 3272356035;
        x  = (x | (x<<2))  & 1227133513;

        y &= 0x3FF;
        y  = (y | (y<<16)) & 4278190335;
        y  = (y | (y<<8))  & 251719695;
        y  = (y | (y<<4))  & 3272356035;
        y  = (y | (y<<2))  & 1227133513;
        x |= (y << 1);

        z &= 0x3FF;
        z  = (z | (z<<16)) & 4278190335;
        z  = (z | (z<<8))  & 251719695;
        z  = (z | (z<<4))  & 3272356035;
        z  = (z | (z<<2))  & 1227133513;

        return x | (z << 2);
    }

//Extracts nth interleaved component of a 3-tuple
    exports.deinterleave3 = function(v, n) {
        v = (v >>> n)       & 1227133513;
        v = (v | (v>>>2))   & 3272356035;
        v = (v | (v>>>4))   & 251719695;
        v = (v | (v>>>8))   & 4278190335;
        v = (v | (v>>>16))  & 0x3FF;
        return (v<<22)>>22;
    }

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
    exports.nextCombination = function(v) {
        var t = v | (v - 1);
        return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
    }


},{}],13:[function(require,module,exports){
    "use strict"

    var bits = require("bit-twiddle")

    function rootInorder(n) {
        var ptree = (bits.nextPow2(n+1)>>>1) - 1
        var f     = n - ptree
        if(bits.nextPow2(f)-1 >= ptree) {
            return ptree
        }
        return (ptree>>>1)+f
    }
    exports.root = rootInorder

    function beginInorder(n) {
        return 0
    }
    exports.begin = beginInorder

    function endInorder(n) {
        return n-1
    }
    exports.end = endInorder


//This is really horrible because n is not necessarily a power of 2
// If it was, we could just do:
//
//    height = bits.countTrailingZeros(~x)
//
// Instead, we just binary search because doing the right thing here is way too complicated.
    function heightInorder(n, x) {
        if(n <= 0) {
            return 0
        }
        var r = rootInorder(n)
        if(x > r) {
            return heightInorder(n-r-1, x-r-1)
        } else if(x === r) {
            return bits.log2(n)
        }
        return heightInorder(r, x)
    }
    exports.height = heightInorder

    function prevInorder(n, x) {
        return Math.max(x-1,0)
    }
    exports.prev = prevInorder

    function nextInorder(n, x) {
        return Math.min(x+1,n-1)
    }
    exports.next = nextInorder


//The version for n = (1<<k)-1:
//
//  parent = (x & ~(1<<(h+1))) + (1<<h)
//
    function parentInorder(n, x) {
        if(n <= 0) {
            return -1
        }
        var r = rootInorder(n)
        if(x > r) {
            var q = parentInorder(n-r-1, x-r-1)
            if(q < 0) {
                return r
            } else {
                return q + r + 1
            }
        } else if(x === r) {
            return -1
        }
        var q =  parentInorder(r, x)
        if(q < 0) {
            return r
        }
        return q
    }
    exports.parent = parentInorder


//Again, we get screwed because n is not a power of two -1.  If it was, we could do:
//
//    left = x - (1 << (h-1) )
//
// Where h is the height of the node
//
    function leftInorder(n, x) {
        if(n <= 0) {
            return 0
        }
        var r = rootInorder(n)
        if(x > r) {
            return leftInorder(n-r-1, x-r-1) + r + 1
        } else if(x === r) {
            return rootInorder(x)
        }
        return leftInorder(r, x)

    }
    exports.left = leftInorder

//for power of two minus one:
//
//    right = x + (1<<(h-1))
//
    function rightInorder(n, x) {
        if(n <= 0) {
            return 0
        }
        var r = rootInorder(n)
        if(x > r) {
            return rightInorder(n-r-1, x-r-1) + r + 1
        } else if(x === r) {
            return rootInorder(n-r-1) + r + 1
        }
        return rightInorder(r, x)
    }
    exports.right = rightInorder


    function leafInorder(n, x) {
        return heightInorder(n, x) === 0
    }
    exports.leaf = leafInorder


    function loInorder(n, x) {
        n |= 0
        x |= 0
        var l = 0
        while(n > 1) {
            var r = rootInorder(n)
            if(x > r) {
                l += r + 1
                n -= r + 1
                x -= r + 1
            } else if(x === r) {
                break
            } else {
                n = r
            }
        }
        return l
    }
    exports.lo = loInorder

    function hiInorder(n, x) {
        n |= 0
        x |= 0
        var l = 0
        while(n > 1) {
            var r = rootInorder(n)
            if(x > r) {
                l += r + 1
                n -= r + 1
                x -= r + 1
            } else if(x === r) {
                l += n-1
                break
            } else {
                n = r
            }
        }
        return l
    }
    exports.hi = hiInorder

},{"bit-twiddle":14}],14:[function(require,module,exports){
    arguments[4][12][0].apply(exports,arguments)
},{"dup":12}],15:[function(require,module,exports){
    "use strict"

    var compile = require("cwise-compiler")

    var EmptyProc = {
        body: "",
        args: [],
        thisVars: [],
        localVars: []
    }

    function fixup(x) {
        if(!x) {
            return EmptyProc
        }
        for(var i=0; i<x.args.length; ++i) {
            var a = x.args[i]
            if(i === 0) {
                x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
            } else {
                x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
            }
        }
        if(!x.thisVars) {
            x.thisVars = []
        }
        if(!x.localVars) {
            x.localVars = []
        }
        return x
    }

    function pcompile(user_args) {
        return compile({
            args:     user_args.args,
            pre:      fixup(user_args.pre),
            body:     fixup(user_args.body),
            post:     fixup(user_args.proc),
            funcName: user_args.funcName
        })
    }

    function makeOp(user_args) {
        var args = []
        for(var i=0; i<user_args.args.length; ++i) {
            args.push("a"+i)
        }
        var wrapper = new Function("P", [
            "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
        ].join(""))
        return wrapper(pcompile(user_args))
    }

    var assign_ops = {
            add:  "+",
            sub:  "-",
            mul:  "*",
            div:  "/",
            mod:  "%",
            band: "&",
            bor:  "|",
            bxor: "^",
            lshift: "<<",
            rshift: ">>",
            rrshift: ">>>"
        }
    ;(function(){
        for(var id in assign_ops) {
            var op = assign_ops[id]
            exports[id] = makeOp({
                args: ["array","array","array"],
                body: {args:["a","b","c"],
                    body: "a=b"+op+"c"},
                funcName: id
            })
            exports[id+"eq"] = makeOp({
                args: ["array","array"],
                body: {args:["a","b"],
                    body:"a"+op+"=b"},
                rvalue: true,
                funcName: id+"eq"
            })
            exports[id+"s"] = makeOp({
                args: ["array", "array", "scalar"],
                body: {args:["a","b","s"],
                    body:"a=b"+op+"s"},
                funcName: id+"s"
            })
            exports[id+"seq"] = makeOp({
                args: ["array","scalar"],
                body: {args:["a","s"],
                    body:"a"+op+"=s"},
                rvalue: true,
                funcName: id+"seq"
            })
        }
    })();

    var unary_ops = {
            not: "!",
            bnot: "~",
            neg: "-",
            recip: "1.0/"
        }
    ;(function(){
        for(var id in unary_ops) {
            var op = unary_ops[id]
            exports[id] = makeOp({
                args: ["array", "array"],
                body: {args:["a","b"],
                    body:"a="+op+"b"},
                funcName: id
            })
            exports[id+"eq"] = makeOp({
                args: ["array"],
                body: {args:["a"],
                    body:"a="+op+"a"},
                rvalue: true,
                count: 2,
                funcName: id+"eq"
            })
        }
    })();

    var binary_ops = {
            and: "&&",
            or: "||",
            eq: "===",
            neq: "!==",
            lt: "<",
            gt: ">",
            leq: "<=",
            geq: ">="
        }
    ;(function() {
        for(var id in binary_ops) {
            var op = binary_ops[id]
            exports[id] = makeOp({
                args: ["array","array","array"],
                body: {args:["a", "b", "c"],
                    body:"a=b"+op+"c"},
                funcName: id
            })
            exports[id+"s"] = makeOp({
                args: ["array","array","scalar"],
                body: {args:["a", "b", "s"],
                    body:"a=b"+op+"s"},
                funcName: id+"s"
            })
            exports[id+"eq"] = makeOp({
                args: ["array", "array"],
                body: {args:["a", "b"],
                    body:"a=a"+op+"b"},
                rvalue:true,
                count:2,
                funcName: id+"eq"
            })
            exports[id+"seq"] = makeOp({
                args: ["array", "scalar"],
                body: {args:["a","s"],
                    body:"a=a"+op+"s"},
                rvalue:true,
                count:2,
                funcName: id+"seq"
            })
        }
    })();

    var math_unary = [
            "abs",
            "acos",
            "asin",
            "atan",
            "ceil",
            "cos",
            "exp",
            "floor",
            "log",
            "round",
            "sin",
            "sqrt",
            "tan"
        ]
    ;(function() {
        for(var i=0; i<math_unary.length; ++i) {
            var f = math_unary[i]
            exports[f] = makeOp({
                args: ["array", "array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                funcName: f
            })
            exports[f+"eq"] = makeOp({
                args: ["array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                rvalue: true,
                count: 2,
                funcName: f+"eq"
            })
        }
    })();

    var math_comm = [
            "max",
            "min",
            "atan2",
            "pow"
        ]
    ;(function(){
        for(var i=0; i<math_comm.length; ++i) {
            var f= math_comm[i]
            exports[f] = makeOp({
                args:["array", "array", "array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                funcName: f
            })
            exports[f+"s"] = makeOp({
                args:["array", "array", "scalar"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                funcName: f+"s"
            })
            exports[f+"eq"] = makeOp({ args:["array", "array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                rvalue: true,
                count: 2,
                funcName: f+"eq"
            })
            exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                rvalue:true,
                count:2,
                funcName: f+"seq"
            })
        }
    })();

    var math_noncomm = [
            "atan2",
            "pow"
        ]
    ;(function(){
        for(var i=0; i<math_noncomm.length; ++i) {
            var f= math_noncomm[i]
            exports[f+"op"] = makeOp({
                args:["array", "array", "array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                funcName: f+"op"
            })
            exports[f+"ops"] = makeOp({
                args:["array", "array", "scalar"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                funcName: f+"ops"
            })
            exports[f+"opeq"] = makeOp({ args:["array", "array"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                rvalue: true,
                count: 2,
                funcName: f+"opeq"
            })
            exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                rvalue:true,
                count:2,
                funcName: f+"opseq"
            })
        }
    })();

    exports.any = compile({
        args:["array"],
        pre: EmptyProc,
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
        post: {args:[], localVars:[], thisVars:[], body:"return false"},
        funcName: "any"
    })

    exports.all = compile({
        args:["array"],
        pre: EmptyProc,
        body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
        post: {args:[], localVars:[], thisVars:[], body:"return true"},
        funcName: "all"
    })

    exports.sum = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
        funcName: "sum"
    })

    exports.prod = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
        funcName: "prod"
    })

    exports.norm2squared = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
        funcName: "norm2squared"
    })

    exports.norm2 = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
        funcName: "norm2"
    })


    exports.norminf = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
        funcName: "norminf"
    })

    exports.norm1 = compile({
        args:["array"],
        pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
        body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
        post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
        funcName: "norm1"
    })

    exports.sup = compile({
        args: [ "array" ],
        pre:
            { body: "this_h=-Infinity",
                args: [],
                thisVars: [ "this_h" ],
                localVars: [] },
        body:
            { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
                thisVars: [ "this_h" ],
                localVars: [] },
        post:
            { body: "return this_h",
                args: [],
                thisVars: [ "this_h" ],
                localVars: [] }
    })

    exports.inf = compile({
        args: [ "array" ],
        pre:
            { body: "this_h=Infinity",
                args: [],
                thisVars: [ "this_h" ],
                localVars: [] },
        body:
            { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
                thisVars: [ "this_h" ],
                localVars: [] },
        post:
            { body: "return this_h",
                args: [],
                thisVars: [ "this_h" ],
                localVars: [] }
    })

    exports.argmin = compile({
        args:["index","array","shape"],
        pre:{
            body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
            args:[
                {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
                {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
                {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
            ],
            thisVars:["this_i","this_v"],
            localVars:[]},
        body:{
            body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
            args:[
                {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
                {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
            thisVars:["this_i","this_v"],
            localVars:["_inline_1_k"]},
        post:{
            body:"{return this_i}",
            args:[],
            thisVars:["this_i"],
            localVars:[]}
    })

    exports.argmax = compile({
        args:["index","array","shape"],
        pre:{
            body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
            args:[
                {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
                {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
                {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
            ],
            thisVars:["this_i","this_v"],
            localVars:[]},
        body:{
            body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
            args:[
                {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
                {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
            thisVars:["this_i","this_v"],
            localVars:["_inline_1_k"]},
        post:{
            body:"{return this_i}",
            args:[],
            thisVars:["this_i"],
            localVars:[]}
    })

    exports.random = makeOp({
        args: ["array"],
        pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
        body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
        funcName: "random"
    })

    exports.assign = makeOp({
        args:["array", "array"],
        body: {args:["a", "b"], body:"a=b"},
        funcName: "assign" })

    exports.assigns = makeOp({
        args:["array", "scalar"],
        body: {args:["a", "b"], body:"a=b"},
        funcName: "assigns" })


    exports.equals = compile({
        args:["array", "array"],
        pre: EmptyProc,
        body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
            {name:"y", lvalue:false, rvalue:true, count:1}],
            body: "if(x!==y){return false}",
            localVars: [],
            thisVars: []},
        post: {args:[], localVars:[], thisVars:[], body:"return true"},
        funcName: "equals"
    })



},{"cwise-compiler":16}],16:[function(require,module,exports){
    "use strict"

    var createThunk = require("./lib/thunk.js")

    function Procedure() {
        this.argTypes = []
        this.shimArgs = []
        this.arrayArgs = []
        this.arrayBlockIndices = []
        this.scalarArgs = []
        this.offsetArgs = []
        this.offsetArgIndex = []
        this.indexArgs = []
        this.shapeArgs = []
        this.funcName = ""
        this.pre = null
        this.body = null
        this.post = null
        this.debug = false
    }

    function compileCwise(user_args) {
        //Create procedure
        var proc = new Procedure()

        //Parse blocks
        proc.pre    = user_args.pre
        proc.body   = user_args.body
        proc.post   = user_args.post

        //Parse arguments
        var proc_args = user_args.args.slice(0)
        proc.argTypes = proc_args
        for(var i=0; i<proc_args.length; ++i) {
            var arg_type = proc_args[i]
            if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
                proc.argTypes[i] = "array"
                proc.arrayArgs.push(i)
                proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
                proc.shimArgs.push("array" + i)
                if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
                    throw new Error("cwise: pre() block may not reference array args")
                }
                if(i < proc.post.args.length && proc.post.args[i].count>0) {
                    throw new Error("cwise: post() block may not reference array args")
                }
            } else if(arg_type === "scalar") {
                proc.scalarArgs.push(i)
                proc.shimArgs.push("scalar" + i)
            } else if(arg_type === "index") {
                proc.indexArgs.push(i)
                if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                    throw new Error("cwise: pre() block may not reference array index")
                }
                if(i < proc.body.args.length && proc.body.args[i].lvalue) {
                    throw new Error("cwise: body() block may not write to array index")
                }
                if(i < proc.post.args.length && proc.post.args[i].count > 0) {
                    throw new Error("cwise: post() block may not reference array index")
                }
            } else if(arg_type === "shape") {
                proc.shapeArgs.push(i)
                if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                    throw new Error("cwise: pre() block may not write to array shape")
                }
                if(i < proc.body.args.length && proc.body.args[i].lvalue) {
                    throw new Error("cwise: body() block may not write to array shape")
                }
                if(i < proc.post.args.length && proc.post.args[i].lvalue) {
                    throw new Error("cwise: post() block may not write to array shape")
                }
            } else if(typeof arg_type === "object" && arg_type.offset) {
                proc.argTypes[i] = "offset"
                proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
                proc.offsetArgIndex.push(i)
            } else {
                throw new Error("cwise: Unknown argument type " + proc_args[i])
            }
        }

        //Make sure at least one array argument was specified
        if(proc.arrayArgs.length <= 0) {
            throw new Error("cwise: No array arguments specified")
        }

        //Make sure arguments are correct
        if(proc.pre.args.length > proc_args.length) {
            throw new Error("cwise: Too many arguments in pre() block")
        }
        if(proc.body.args.length > proc_args.length) {
            throw new Error("cwise: Too many arguments in body() block")
        }
        if(proc.post.args.length > proc_args.length) {
            throw new Error("cwise: Too many arguments in post() block")
        }

        //Check debug flag
        proc.debug = !!user_args.printCode || !!user_args.debug

        //Retrieve name
        proc.funcName = user_args.funcName || "cwise"

        //Read in block size
        proc.blockSize = user_args.blockSize || 64

        return createThunk(proc)
    }

    module.exports = compileCwise

},{"./lib/thunk.js":18}],17:[function(require,module,exports){
    "use strict"

    var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
    function innerFill(order, proc, body) {
        var dimension = order.length
            , nargs = proc.arrayArgs.length
            , has_index = proc.indexArgs.length>0
            , code = []
            , vars = []
            , idx=0, pidx=0, i, j
        for(i=0; i<dimension; ++i) { // Iteration variables
            vars.push(["i",i,"=0"].join(""))
        }
        //Compute scan deltas
        for(j=0; j<nargs; ++j) {
            for(i=0; i<dimension; ++i) {
                pidx = idx
                idx = order[i]
                if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
                    vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
                } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
                    vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
                }
            }
        }
        code.push("var " + vars.join(","))
        //Scan loop
        for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
            idx = order[i]
            code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
        }
        //Push body of inner loop
        code.push(body)
        //Advance scan pointers
        for(i=0; i<dimension; ++i) {
            pidx = idx
            idx = order[i]
            for(j=0; j<nargs; ++j) {
                code.push(["p",j,"+=d",j,"s",i].join(""))
            }
            if(has_index) {
                if(i > 0) {
                    code.push(["index[",pidx,"]-=s",pidx].join(""))
                }
                code.push(["++index[",idx,"]"].join(""))
            }
            code.push("}")
        }
        return code.join("\n")
    }

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
    function outerFill(matched, order, proc, body) {
        var dimension = order.length
            , nargs = proc.arrayArgs.length
            , blockSize = proc.blockSize
            , has_index = proc.indexArgs.length > 0
            , code = []
        for(var i=0; i<nargs; ++i) {
            code.push(["var offset",i,"=p",i].join(""))
        }
        //Generate loops for unmatched dimensions
        // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
        // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
        for(var i=matched; i<dimension; ++i) {
            code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
            code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
            code.push(["s",order[i],"=j",i].join(""))
            code.push(["j",i,"=0"].join(""))
            code.push(["}else{s",order[i],"=",blockSize].join(""))
            code.push(["j",i,"-=",blockSize,"}"].join(""))
            if(has_index) {
                code.push(["index[",order[i],"]=j",i].join(""))
            }
        }
        for(var i=0; i<nargs; ++i) {
            var indexStr = ["offset"+i]
            for(var j=matched; j<dimension; ++j) {
                indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
            }
            code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
        }
        code.push(innerFill(order, proc, body))
        for(var i=matched; i<dimension; ++i) {
            code.push("}")
        }
        return code.join("\n")
    }

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
    function countMatches(orders) {
        var matched = 0, dimension = orders[0].length
        while(matched < dimension) {
            for(var j=1; j<orders.length; ++j) {
                if(orders[j][matched] !== orders[0][matched]) {
                    return matched
                }
            }
            ++matched
        }
        return matched
    }

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
    function processBlock(block, proc, dtypes) {
        var code = block.body
        var pre = []
        var post = []
        for(var i=0; i<block.args.length; ++i) {
            var carg = block.args[i]
            if(carg.count <= 0) {
                continue
            }
            var re = new RegExp(carg.name, "g")
            var ptrStr = ""
            var arrNum = proc.arrayArgs.indexOf(i)
            switch(proc.argTypes[i]) {
                case "offset":
                    var offArgIndex = proc.offsetArgIndex.indexOf(i)
                    var offArg = proc.offsetArgs[offArgIndex]
                    arrNum = offArg.array
                    ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                case "array":
                    ptrStr = "p" + arrNum + ptrStr
                    var localStr = "l" + i
                    var arrStr = "a" + arrNum
                    if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
                        if(carg.count === 1) { // Argument/array used only once(?)
                            if(dtypes[arrNum] === "generic") {
                                if(carg.lvalue) {
                                    pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                    code = code.replace(re, localStr)
                                    post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                                } else {
                                    code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
                                }
                            } else {
                                code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
                            }
                        } else if(dtypes[arrNum] === "generic") {
                            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                            code = code.replace(re, localStr)
                            if(carg.lvalue) {
                                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
                            }
                        } else {
                            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                            code = code.replace(re, localStr)
                            if(carg.lvalue) {
                                post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
                            }
                        }
                    } else { // Argument to body is a "block"
                        var reStrArr = [carg.name], ptrStrArr = [ptrStr]
                        for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                            reStrArr.push("\\s*\\[([^\\]]+)\\]")
                            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
                        }
                        re = new RegExp(reStrArr.join(""), "g")
                        ptrStr = ptrStrArr.join("+")
                        if(dtypes[arrNum] === "generic") {
                            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
                            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
                        } else {
                            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
                        }
                    }
                    break
                case "scalar":
                    code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
                    break
                case "index":
                    code = code.replace(re, "index")
                    break
                case "shape":
                    code = code.replace(re, "shape")
                    break
            }
        }
        return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
    }

    function typeSummary(dtypes) {
        var summary = new Array(dtypes.length)
        var allEqual = true
        for(var i=0; i<dtypes.length; ++i) {
            var t = dtypes[i]
            var digits = t.match(/\d+/)
            if(!digits) {
                digits = ""
            } else {
                digits = digits[0]
            }
            if(t.charAt(0) === 0) {
                summary[i] = "u" + t.charAt(1) + digits
            } else {
                summary[i] = t.charAt(0) + digits
            }
            if(i > 0) {
                allEqual = allEqual && summary[i] === summary[i-1]
            }
        }
        if(allEqual) {
            return summary[0]
        }
        return summary.join("")
    }

//Generates a cwise operator
    function generateCWiseOp(proc, typesig) {

        //Compute dimension
        // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
        var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
        var orders = new Array(proc.arrayArgs.length)
        var dtypes = new Array(proc.arrayArgs.length)
        for(var i=0; i<proc.arrayArgs.length; ++i) {
            dtypes[i] = typesig[2*i]
            orders[i] = typesig[2*i+1]
        }

        //Determine where block and loop indices start and end
        var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
        var loopBegin = [], loopEnd = [] // These indices are iterated over
        var loopOrders = [] // orders restricted to the loop indices
        for(var i=0; i<proc.arrayArgs.length; ++i) {
            if (proc.arrayBlockIndices[i]<0) {
                loopBegin.push(0)
                loopEnd.push(dimension)
                blockBegin.push(dimension)
                blockEnd.push(dimension+proc.arrayBlockIndices[i])
            } else {
                loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
                loopEnd.push(proc.arrayBlockIndices[i]+dimension)
                blockBegin.push(0)
                blockEnd.push(proc.arrayBlockIndices[i])
            }
            var newOrder = []
            for(var j=0; j<orders[i].length; j++) {
                if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
                    newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
                }
            }
            loopOrders.push(newOrder)
        }

        //First create arguments for procedure
        var arglist = ["SS"] // SS is the overall shape over which we iterate
        var code = ["'use strict'"]
        var vars = []

        for(var j=0; j<dimension; ++j) {
            vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
        }
        for(var i=0; i<proc.arrayArgs.length; ++i) {
            arglist.push("a"+i) // Actual data array
            arglist.push("t"+i) // Strides
            arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)

            for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
                vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
            }

            for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
                vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
            }
        }
        for(var i=0; i<proc.scalarArgs.length; ++i) {
            arglist.push("Y" + i)
        }
        if(proc.shapeArgs.length > 0) {
            vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
        }
        if(proc.indexArgs.length > 0) {
            // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
            var zeros = new Array(dimension)
            for(var i=0; i<dimension; ++i) {
                zeros[i] = "0"
            }
            vars.push(["index=[", zeros.join(","), "]"].join(""))
        }
        for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
            var off_arg = proc.offsetArgs[i]
            var init_string = []
            for(var j=0; j<off_arg.offset.length; ++j) {
                if(off_arg.offset[j] === 0) {
                    continue
                } else if(off_arg.offset[j] === 1) {
                    init_string.push(["t", off_arg.array, "p", j].join(""))
                } else {
                    init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
                }
            }
            if(init_string.length === 0) {
                vars.push("q" + i + "=0")
            } else {
                vars.push(["q", i, "=", init_string.join("+")].join(""))
            }
        }

        //Prepare this variables
        var thisVars = uniq([].concat(proc.pre.thisVars)
            .concat(proc.body.thisVars)
            .concat(proc.post.thisVars))
        vars = vars.concat(thisVars)
        code.push("var " + vars.join(","))
        for(var i=0; i<proc.arrayArgs.length; ++i) {
            code.push("p"+i+"|=0")
        }

        //Inline prelude
        if(proc.pre.body.length > 3) {
            code.push(processBlock(proc.pre, proc, dtypes))
        }

        //Process body
        var body = processBlock(proc.body, proc, dtypes)
        var matched = countMatches(loopOrders)
        if(matched < dimension) {
            code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
        } else {
            code.push(innerFill(loopOrders[0], proc, body))
        }

        //Inline epilog
        if(proc.post.body.length > 3) {
            code.push(processBlock(proc.post, proc, dtypes))
        }

        if(proc.debug) {
            console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
        }

        var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
        var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
        return f()
    }
    module.exports = generateCWiseOp

},{"uniq":19}],18:[function(require,module,exports){
    "use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

    var compile = require("./compile.js")

    function createThunk(proc) {
        var code = ["'use strict'", "var CACHED={}"]
        var vars = []
        var thunkName = proc.funcName + "_cwise_thunk"

        //Build thunk
        code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
        var typesig = []
        var string_typesig = []
        var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
            Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
        var shapeLengthConditions = [], shapeConditions = []
        // Process array arguments
        for(var i=0; i<proc.arrayArgs.length; ++i) {
            var j = proc.arrayArgs[i]
            vars.push(["t", j, "=array", j, ".dtype,",
                "r", j, "=array", j, ".order"].join(""))
            typesig.push("t" + j)
            typesig.push("r" + j)
            string_typesig.push("t"+j)
            string_typesig.push("r"+j+".join()")
            proc_args.push("array" + j + ".data")
            proc_args.push("array" + j + ".stride")
            proc_args.push("array" + j + ".offset|0")
            if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
                shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
                shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
            }
        }
        // Check for shape equality
        if (proc.arrayArgs.length > 1) {
            code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
            code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
            code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
            code.push("}")
        }
        // Process scalar arguments
        for(var i=0; i<proc.scalarArgs.length; ++i) {
            proc_args.push("scalar" + proc.scalarArgs[i])
        }
        // Check for cached function (and if not present, generate it)
        vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
        vars.push("proc=CACHED[type]")
        code.push("var " + vars.join(","))

        code.push(["if(!proc){",
            "CACHED[type]=proc=compile([", typesig.join(","), "])}",
            "return proc(", proc_args.join(","), ")}"].join(""))

        if(proc.debug) {
            console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
        }

        //Compile thunk
        var thunk = new Function("compile", code.join("\n"))
        return thunk(compile.bind(undefined, proc))
    }

    module.exports = createThunk

},{"./compile.js":17}],19:[function(require,module,exports){
    "use strict"

    function unique_pred(list, compare) {
        var ptr = 1
            , len = list.length
            , a=list[0], b=list[0]
        for(var i=1; i<len; ++i) {
            b = a
            a = list[i]
            if(compare(a, b)) {
                if(i === ptr) {
                    ptr++
                    continue
                }
                list[ptr++] = a
            }
        }
        list.length = ptr
        return list
    }

    function unique_eq(list) {
        var ptr = 1
            , len = list.length
            , a=list[0], b = list[0]
        for(var i=1; i<len; ++i, b=a) {
            b = a
            a = list[i]
            if(a !== b) {
                if(i === ptr) {
                    ptr++
                    continue
                }
                list[ptr++] = a
            }
        }
        list.length = ptr
        return list
    }

    function unique(list, compare, sorted) {
        if(list.length === 0) {
            return list
        }
        if(compare) {
            if(!sorted) {
                list.sort(compare)
            }
            return unique_pred(list, compare)
        }
        if(!sorted) {
            list.sort()
        }
        return unique_eq(list)
    }

    module.exports = unique

},{}],20:[function(require,module,exports){
    "use strict"

    var ndarray = require("ndarray")
    var do_convert = require("./doConvert.js")

    module.exports = function convert(arr, result) {
        var shape = [], c = arr, sz = 1
        while(c instanceof Array) {
            shape.push(c.length)
            sz *= c.length
            c = c[0]
        }
        if(shape.length === 0) {
            return ndarray()
        }
        if(!result) {
            result = ndarray(new Float64Array(sz), shape)
        }
        do_convert(result, arr)
        return result
    }

},{"./doConvert.js":21,"ndarray":28}],21:[function(require,module,exports){
    module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})

},{"cwise-compiler":22}],22:[function(require,module,exports){
    arguments[4][16][0].apply(exports,arguments)
},{"./lib/thunk.js":24,"dup":16}],23:[function(require,module,exports){
    arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"uniq":25}],24:[function(require,module,exports){
    arguments[4][18][0].apply(exports,arguments)
},{"./compile.js":23,"dup":18}],25:[function(require,module,exports){
    arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],26:[function(require,module,exports){
    "use strict"

    var ndarray = require("ndarray")
    var ops = require("ndarray-ops")
    var pool = require("typedarray-pool")

    function clone(array) {
        var dtype = array.dtype
        if(dtype === "generic" || dtype === "array") {
            dtype = "double"
        }
        var data = pool.malloc(array.size, dtype)
        var result = ndarray(data, array.shape)
        ops.assign(result, array)
        return result
    }
    exports.clone = clone

    function malloc(shape, dtype) {
        if(!dtype) {
            dtype = "double"
        }
        var sz = 1
        var stride = new Array(shape.length)
        for(var i=shape.length-1; i>=0; --i) {
            stride[i] = sz
            sz *= shape[i]
        }
        return ndarray(pool.malloc(sz, dtype), shape, stride, 0)
    }
    exports.malloc = malloc

    function free(array) {
        if(array.dtype === "generic" || array.dtype === "array") {
            return
        }
        pool.free(array.data)
    }
    exports.free = free

    function zeros(shape, dtype) {
        if(!dtype) {
            dtype = "double"
        }

        var sz = 1
        var stride = new Array(shape.length)
        for(var i=shape.length-1; i>=0; --i) {
            stride[i] = sz
            sz *= shape[i]
        }
        var buf = pool.malloc(sz, dtype)
        for(var i=0; i<sz; ++i) {
            buf[i] = 0
        }
        return ndarray(buf, shape, stride, 0)
    }
    exports.zeros = zeros

    function ones(shape, dtype) {
        if(!dtype) {
            dtype = "double"
        }

        var sz = 1
        var stride = new Array(shape.length)
        for(var i=shape.length-1; i>=0; --i) {
            stride[i] = sz
            sz *= shape[i]
        }
        var buf = pool.malloc(sz, dtype)
        for(var i=0; i<sz; ++i) {
            buf[i] = 1
        }
        return ndarray(buf, shape, stride, 0)
    }
    exports.ones = ones

    function eye(shape, dtype) {
        var i, offset
        if(!dtype) {
            dtype = "double"
        }

        var sz = 1
        var stride = new Array(shape.length)
        for(i=shape.length-1; i>=0; --i) {
            stride[i] = sz
            sz *= shape[i]
        }
        var buf = pool.malloc(sz, dtype)
        for(i=0; i<sz; ++i) {
            buf[i] = 0
        }
        var mindim = Infinity
        var offsum = 0
        for( i=shape.length-1; i>=0; i--) {
            offsum += stride[i]
            mindim = Math.min(mindim,shape[i])
        }
        for(i=0,offset=0; i<mindim; i++,offset+=offsum) {
            buf[offset] = 1
        }
        return ndarray(buf, shape, stride, 0)
    }
    exports.eye = eye

},{"ndarray":28,"ndarray-ops":15,"typedarray-pool":32}],27:[function(require,module,exports){
    "use strict"

    module.exports = ndSelect
    module.exports.compile = lookupCache

//Macros
    var ARRAY = "a"
    var RANK = "K"
    var CMP = "C"
    var DATA = "d"
    var OFFSET = "o"
    var RND = "R"
    var TMP = "T"
    var LO = "L"
    var HI = "H"
    var PIVOT = "X"
    function SHAPE(i) {
        return "s" + i
    }
    function STRIDE(i) {
        return "t" + i
    }
    function STEP(i) {
        return "u" + i
    }
    function STEP_CMP(i) {
        return "v" + i
    }
    function INDEX(i) {
        return "i" + i
    }
    function PICK(i) {
        return "p" + i
    }
    function PTR(i) {
        return "x" + i
    }

//Create new order where index 0 is slowest index
    function permuteOrder(order) {
        var norder = order.slice()
        norder.splice(order.indexOf(0), 1)
        norder.unshift(0)
        return norder
    }

//Generate quick select procedure
    function compileQuickSelect(order, useCompare, dtype) {
        order = permuteOrder(order)

        var dimension = order.length
        var useGetter = (dtype === "generic")
        var funcName = "ndSelect" + dtype + order.join("_") + "_" + (useCompare ? "cmp" : "lex")

        var code = []

        //Get arguments for code
        var args = [ARRAY, RANK]
        if(useCompare) {
            args.push(CMP)
        }

        //Unpack ndarray variables
        var vars = [
            DATA + "=" + ARRAY + ".data",
            OFFSET + "=" + ARRAY + ".offset|0",
            RND + "=Math.random",
            TMP]
        for(var i=0; i<2; ++i) {
            vars.push(PTR(i) + "=0")
        }
        for(var i=0; i<dimension; ++i) {
            vars.push(
                SHAPE(i) + "=" + ARRAY + ".shape[" + i + "]|0",
                STRIDE(i) + "=" + ARRAY + ".stride[" + i + "]|0",
                INDEX(i) + "=0")
        }
        for(var i=1; i<dimension; ++i) {
            if(i > 1) {
                vars.push(STEP_CMP(i) + "=(" + STRIDE(i) + "-" + SHAPE(i-1) + "*" + STRIDE(i-1) + ")|0",
                    STEP(order[i]) + "=(" + STRIDE(order[i]) + "-" + SHAPE(order[i-1]) + "*" + STRIDE(order[i-1]) + ")|0")
            } else {
                vars.push(STEP_CMP(i) + "=" + STRIDE(i),
                    STEP(order[i]) + "=" + STRIDE(order[i]))
            }
        }
        if(useCompare) {
            for(var i=0; i<2; ++i) {
                vars.push(PICK(i) + "=" + ARRAY + ".pick(0)")
            }
        }
        vars.push(
            PIVOT + "=0",
            LO + "=0",
            HI + "=" + SHAPE(order[0]) + "-1")

        function compare(out, i0, i1) {
            if(useCompare) {
                code.push(
                    PICK(0), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");",
                    PICK(1), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");",
                    out, "=", CMP, "(", PICK(0), ",", PICK(1), ");")
            } else {
                code.push(
                    PTR(0), "=", OFFSET, "+", STRIDE(0), "*(", i0, ");",
                    PTR(1), "=", OFFSET, "+", STRIDE(0), "*(", i1, ");")
                if(dimension > 1) {
                    code.push("_cmp:")
                }
                for(var i=dimension-1; i>0; --i) {
                    code.push("for(", INDEX(i), "=0;",
                        INDEX(i), "<", SHAPE(i), ";",
                        INDEX(i), "++){")
                }
                if(useGetter) {
                    code.push(out, "=", DATA, ".get(", PTR(0), ")-",
                        DATA, ".get(", PTR(1), ");")
                } else {
                    code.push(out, "=", DATA, "[", PTR(0), "]-",
                        DATA, "[", PTR(1), "];")
                }
                if(dimension > 1) {
                    code.push("if(", out, ")break _cmp;")
                }
                for(var i=1; i<dimension; ++i) {
                    code.push(
                        PTR(0), "+=", STEP_CMP(i), ";",
                        PTR(1), "+=", STEP_CMP(i),
                        "}")
                }
            }
        }

        function swap(i0, i1) {
            code.push(
                PTR(0), "=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");",
                PTR(1), "=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");")
            for(var i=dimension-1; i>0; --i) {
                code.push("for(", INDEX(order[i]), "=0;",
                    INDEX(order[i]), "<", SHAPE(order[i]), ";",
                    INDEX(order[i]), "++){")
            }
            if(useGetter) {
                code.push(TMP, "=", DATA, ".get(", PTR(0), ");",
                    DATA, ".set(", PTR(0), ",", DATA, ".get(", PTR(1), "));",
                    DATA, ".set(", PTR(1), ",", TMP, ");")
            } else {
                code.push(TMP, "=", DATA, "[", PTR(0), "];",
                    DATA, "[", PTR(0), "]=", DATA, "[", PTR(1), "];",
                    DATA, "[", PTR(1), "]=", TMP, ";")
            }
            for(var i=1; i<dimension; ++i) {
                code.push(
                    PTR(0), "+=", STEP(order[i]), ";",
                    PTR(1), "+=", STEP(order[i]),
                    "}")
            }
        }

        code.push(
            "while(", LO, "<", HI, "){",
            PIVOT, "=(", RND, "()*(", HI, "-", LO, "+1)+", LO, ")|0;")

        //Partition array by pivot
        swap(PIVOT, HI) // Store pivot temporarily at the end of the array

        code.push(
            PIVOT, "=", LO, ";", // PIVOT will now be used to keep track of the end of the interval of elements less than the pivot
            "for(", INDEX(0), "=", LO, ";",
            INDEX(0), "<", HI, ";",
            INDEX(0), "++){") // Loop over other elements (unequal to the pivot), note that HI now points to the pivot
        compare(TMP, INDEX(0), HI) // Lexicographical compare of element with pivot
        code.push("if(", TMP, "<0){")
        swap(PIVOT, INDEX(0)) // Swap current element with element at index PIVOT if it is less than the pivot
        code.push(PIVOT, "++;")
        code.push("}}")
        swap(PIVOT, HI) // Store pivot right after all elements that are less than the pivot (implying that all elements >= the pivot are behind the pivot)

        //Check pivot bounds
        code.push(
            "if(", PIVOT, "===", RANK, "){",
            LO, "=", PIVOT, ";",
            "break;",
            "}else if(", RANK, "<", PIVOT, "){",
            HI, "=", PIVOT, "-1;",
            "}else{",
            LO, "=", PIVOT, "+1;",
            "}",
            "}")

        if(useCompare) {
            code.push(PICK(0), ".offset=", OFFSET, "+", LO, "*", STRIDE(0), ";",
                "return ", PICK(0), ";")
        } else {
            code.push("return ", ARRAY, ".pick(", LO, ");")
        }

        //Compile and link js together
        var procCode = [
            "'use strict';function ", funcName, "(", args, "){",
            "var ", vars.join(), ";",
            code.join(""),
            "};return ", funcName
        ].join("")

        var proc = new Function(procCode)
        return proc()
    }

    var CACHE = {}

    function lookupCache(order, useCompare, dtype) {
        var typesig = order.join() + useCompare + dtype
        var proc = CACHE[typesig]
        if(proc) {
            return proc
        }
        return CACHE[typesig] = compileQuickSelect(order, useCompare, dtype)
    }

    function ndSelect(array, k, compare) {
        k |= 0
        if((array.dimension === 0) ||
            (array.shape[0] <= k) ||
            (k < 0)) {
            return null
        }
        var useCompare = !!compare
        var proc = lookupCache(array.order, useCompare, array.dtype)
        if(useCompare) {
            return proc(array, k, compare)
        } else {
            return proc(array, k)
        }
    }
},{}],28:[function(require,module,exports){
    var iota = require("iota-array")
    var isBuffer = require("is-buffer")

    var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

    function compare1st(a, b) {
        return a[0] - b[0]
    }

    function order() {
        var stride = this.stride
        var terms = new Array(stride.length)
        var i
        for(i=0; i<terms.length; ++i) {
            terms[i] = [Math.abs(stride[i]), i]
        }
        terms.sort(compare1st)
        var result = new Array(terms.length)
        for(i=0; i<result.length; ++i) {
            result[i] = terms[i][1]
        }
        return result
    }

    function compileConstructor(dtype, dimension) {
        var className = ["View", dimension, "d", dtype].join("")
        if(dimension < 0) {
            className = "View_Nil" + dtype
        }
        var useGetters = (dtype === "generic")

        if(dimension === -1) {
            //Special case for trivial arrays
            var code =
                "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
            var procedure = new Function(code)
            return procedure()
        } else if(dimension === 0) {
            //Special case for 0d arrays
            var code =
                "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
                "};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
            var procedure = new Function("TrivialArray", code)
            return procedure(CACHED_CONSTRUCTORS[dtype][0])
        }

        var code = ["'use strict'"]

        //Create constructor for view
        var indices = iota(dimension)
        var args = indices.map(function(i) { return "i"+i })
        var index_str = "this.offset+" + indices.map(function(i) {
            return "this.stride[" + i + "]*i" + i
        }).join("+")
        var shapeArg = indices.map(function(i) {
            return "b"+i
        }).join(",")
        var strideArg = indices.map(function(i) {
            return "c"+i
        }).join(",")
        code.push(
            "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
            "this.shape=[" + shapeArg + "]",
            "this.stride=[" + strideArg + "]",
            "this.offset=d|0}",
            "var proto="+className+".prototype",
            "proto.dtype='"+dtype+"'",
            "proto.dimension="+dimension)

        //view.size:
        code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
            "}})")

        //view.order:
        if(dimension === 1) {
            code.push("proto.order=[0]")
        } else {
            code.push("Object.defineProperty(proto,'order',{get:")
            if(dimension < 4) {
                code.push("function "+className+"_order(){")
                if(dimension === 2) {
                    code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
                } else if(dimension === 3) {
                    code.push(
                        "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
                }
            } else {
                code.push("ORDER})")
            }
        }

        //view.set(i0, ..., v):
        code.push(
            "proto.set=function "+className+"_set("+args.join(",")+",v){")
        if(useGetters) {
            code.push("return this.data.set("+index_str+",v)}")
        } else {
            code.push("return this.data["+index_str+"]=v}")
        }

        //view.get(i0, ...):
        code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
        if(useGetters) {
            code.push("return this.data.get("+index_str+")}")
        } else {
            code.push("return this.data["+index_str+"]}")
        }

        //view.index:
        code.push(
            "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

        //view.hi():
        code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
            indices.map(function(i) {
                return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
            }).join(",")+","+
            indices.map(function(i) {
                return "this.stride["+i + "]"
            }).join(",")+",this.offset)}")

        //view.lo():
        var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
        var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
        code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
        for(var i=0; i<dimension; ++i) {
            code.push(
                "if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
        }
        code.push("return new "+className+"(this.data,"+
            indices.map(function(i) {
                return "a"+i
            }).join(",")+","+
            indices.map(function(i) {
                return "c"+i
            }).join(",")+",b)}")

        //view.step():
        code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
            indices.map(function(i) {
                return "a"+i+"=this.shape["+i+"]"
            }).join(",")+","+
            indices.map(function(i) {
                return "b"+i+"=this.stride["+i+"]"
            }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
        for(var i=0; i<dimension; ++i) {
            code.push(
                "if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
        }
        code.push("return new "+className+"(this.data,"+
            indices.map(function(i) {
                return "a" + i
            }).join(",")+","+
            indices.map(function(i) {
                return "b" + i
            }).join(",")+",c)}")

        //view.transpose():
        var tShape = new Array(dimension)
        var tStride = new Array(dimension)
        for(var i=0; i<dimension; ++i) {
            tShape[i] = "a[i"+i+"]"
            tStride[i] = "b[i"+i+"]"
        }
        code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
            args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
            "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

        //view.pick():
        code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
        for(var i=0; i<dimension; ++i) {
            code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
        }
        code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

        //Add return statement
        code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
            indices.map(function(i) {
                return "shape["+i+"]"
            }).join(",")+","+
            indices.map(function(i) {
                return "stride["+i+"]"
            }).join(",")+",offset)}")

        //Compile procedure
        var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
        return procedure(CACHED_CONSTRUCTORS[dtype], order)
    }

    function arrayDType(data) {
        if(isBuffer(data)) {
            return "buffer"
        }
        if(hasTypedArrays) {
            switch(Object.prototype.toString.call(data)) {
                case "[object Float64Array]":
                    return "float64"
                case "[object Float32Array]":
                    return "float32"
                case "[object Int8Array]":
                    return "int8"
                case "[object Int16Array]":
                    return "int16"
                case "[object Int32Array]":
                    return "int32"
                case "[object Uint8Array]":
                    return "uint8"
                case "[object Uint16Array]":
                    return "uint16"
                case "[object Uint32Array]":
                    return "uint32"
                case "[object Uint8ClampedArray]":
                    return "uint8_clamped"
            }
        }
        if(Array.isArray(data)) {
            return "array"
        }
        return "generic"
    }

    var CACHED_CONSTRUCTORS = {
            "float32":[],
            "float64":[],
            "int8":[],
            "int16":[],
            "int32":[],
            "uint8":[],
            "uint16":[],
            "uint32":[],
            "array":[],
            "uint8_clamped":[],
            "buffer":[],
            "generic":[]
        }

    ;(function() {
        for(var id in CACHED_CONSTRUCTORS) {
            CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
        }
    });

    function wrappedNDArrayCtor(data, shape, stride, offset) {
        if(data === undefined) {
            var ctor = CACHED_CONSTRUCTORS.array[0]
            return ctor([])
        } else if(typeof data === "number") {
            data = [data]
        }
        if(shape === undefined) {
            shape = [ data.length ]
        }
        var d = shape.length
        if(stride === undefined) {
            stride = new Array(d)
            for(var i=d-1, sz=1; i>=0; --i) {
                stride[i] = sz
                sz *= shape[i]
            }
        }
        if(offset === undefined) {
            offset = 0
            for(var i=0; i<d; ++i) {
                if(stride[i] < 0) {
                    offset -= (shape[i]-1)*stride[i]
                }
            }
        }
        var dtype = arrayDType(data)
        var ctor_list = CACHED_CONSTRUCTORS[dtype]
        while(ctor_list.length <= d+1) {
            ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
        }
        var ctor = ctor_list[d+1]
        return ctor(data, shape, stride, offset)
    }

    module.exports = wrappedNDArrayCtor

},{"iota-array":29,"is-buffer":30}],29:[function(require,module,exports){
    "use strict"

    function iota(n) {
        var result = new Array(n)
        for(var i=0; i<n; ++i) {
            result[i] = i
        }
        return result
    }

    module.exports = iota
},{}],30:[function(require,module,exports){
    /**
     * Determine if an object is Buffer
     *
     * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * License:  MIT
     *
     * `npm install is-buffer`
     */

    module.exports = function (obj) {
        return !!(obj != null &&
            (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)
                (obj.constructor &&
                    typeof obj.constructor.isBuffer === 'function' &&
                    obj.constructor.isBuffer(obj))
            ))
    }

},{}],31:[function(require,module,exports){
    "use strict"

    function dupe_array(count, value, i) {
        var c = count[i]|0
        if(c <= 0) {
            return []
        }
        var result = new Array(c), j
        if(i === count.length-1) {
            for(j=0; j<c; ++j) {
                result[j] = value
            }
        } else {
            for(j=0; j<c; ++j) {
                result[j] = dupe_array(count, value, i+1)
            }
        }
        return result
    }

    function dupe_number(count, value) {
        var result, i
        result = new Array(count)
        for(i=0; i<count; ++i) {
            result[i] = value
        }
        return result
    }

    function dupe(count, value) {
        if(typeof value === "undefined") {
            value = 0
        }
        switch(typeof count) {
            case "number":
                if(count > 0) {
                    return dupe_number(count|0, value)
                }
                break
            case "object":
                if(typeof (count.length) === "number") {
                    return dupe_array(count, value, 0)
                }
                break
        }
        return []
    }

    module.exports = dupe
},{}],32:[function(require,module,exports){
    (function (global,Buffer){
        'use strict'

        var bits = require('bit-twiddle')
        var dup = require('dup')

//Legacy pool support
        if(!global.__TYPEDARRAY_POOL) {
            global.__TYPEDARRAY_POOL = {
                UINT8   : dup([32, 0])
                , UINT16  : dup([32, 0])
                , UINT32  : dup([32, 0])
                , INT8    : dup([32, 0])
                , INT16   : dup([32, 0])
                , INT32   : dup([32, 0])
                , FLOAT   : dup([32, 0])
                , DOUBLE  : dup([32, 0])
                , DATA    : dup([32, 0])
                , UINT8C  : dup([32, 0])
                , BUFFER  : dup([32, 0])
            }
        }

        var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
        var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
        if(!POOL.UINT8C) {
            POOL.UINT8C = dup([32, 0])
        }
        if(!POOL.BUFFER) {
            POOL.BUFFER = dup([32, 0])
        }

//New technique: Only allocate from ArrayBufferView and Buffer
        var DATA    = POOL.DATA
            , BUFFER  = POOL.BUFFER

        exports.free = function free(array) {
            if(Buffer.isBuffer(array)) {
                BUFFER[bits.log2(array.length)].push(array)
            } else {
                if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
                    array = array.buffer
                }
                if(!array) {
                    return
                }
                var n = array.length || array.byteLength
                var log_n = bits.log2(n)|0
                DATA[log_n].push(array)
            }
        }

        function freeArrayBuffer(buffer) {
            if(!buffer) {
                return
            }
            var n = buffer.length || buffer.byteLength
            var log_n = bits.log2(n)
            DATA[log_n].push(buffer)
        }

        function freeTypedArray(array) {
            freeArrayBuffer(array.buffer)
        }

        exports.freeUint8 =
            exports.freeUint16 =
                exports.freeUint32 =
                    exports.freeInt8 =
                        exports.freeInt16 =
                            exports.freeInt32 =
                                exports.freeFloat32 =
                                    exports.freeFloat =
                                        exports.freeFloat64 =
                                            exports.freeDouble =
                                                exports.freeUint8Clamped =
                                                    exports.freeDataView = freeTypedArray

        exports.freeArrayBuffer = freeArrayBuffer

        exports.freeBuffer = function freeBuffer(array) {
            BUFFER[bits.log2(array.length)].push(array)
        }

        exports.malloc = function malloc(n, dtype) {
            if(dtype === undefined || dtype === 'arraybuffer') {
                return mallocArrayBuffer(n)
            } else {
                switch(dtype) {
                    case 'uint8':
                        return mallocUint8(n)
                    case 'uint16':
                        return mallocUint16(n)
                    case 'uint32':
                        return mallocUint32(n)
                    case 'int8':
                        return mallocInt8(n)
                    case 'int16':
                        return mallocInt16(n)
                    case 'int32':
                        return mallocInt32(n)
                    case 'float':
                    case 'float32':
                        return mallocFloat(n)
                    case 'double':
                    case 'float64':
                        return mallocDouble(n)
                    case 'uint8_clamped':
                        return mallocUint8Clamped(n)
                    case 'buffer':
                        return mallocBuffer(n)
                    case 'data':
                    case 'dataview':
                        return mallocDataView(n)

                    default:
                        return null
                }
            }
            return null
        }

        function mallocArrayBuffer(n) {
            var n = bits.nextPow2(n)
            var log_n = bits.log2(n)
            var d = DATA[log_n]
            if(d.length > 0) {
                return d.pop()
            }
            return new ArrayBuffer(n)
        }
        exports.mallocArrayBuffer = mallocArrayBuffer

        function mallocUint8(n) {
            return new Uint8Array(mallocArrayBuffer(n), 0, n)
        }
        exports.mallocUint8 = mallocUint8

        function mallocUint16(n) {
            return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
        }
        exports.mallocUint16 = mallocUint16

        function mallocUint32(n) {
            return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
        }
        exports.mallocUint32 = mallocUint32

        function mallocInt8(n) {
            return new Int8Array(mallocArrayBuffer(n), 0, n)
        }
        exports.mallocInt8 = mallocInt8

        function mallocInt16(n) {
            return new Int16Array(mallocArrayBuffer(2*n), 0, n)
        }
        exports.mallocInt16 = mallocInt16

        function mallocInt32(n) {
            return new Int32Array(mallocArrayBuffer(4*n), 0, n)
        }
        exports.mallocInt32 = mallocInt32

        function mallocFloat(n) {
            return new Float32Array(mallocArrayBuffer(4*n), 0, n)
        }
        exports.mallocFloat32 = exports.mallocFloat = mallocFloat

        function mallocDouble(n) {
            return new Float64Array(mallocArrayBuffer(8*n), 0, n)
        }
        exports.mallocFloat64 = exports.mallocDouble = mallocDouble

        function mallocUint8Clamped(n) {
            if(hasUint8C) {
                return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
            } else {
                return mallocUint8(n)
            }
        }
        exports.mallocUint8Clamped = mallocUint8Clamped

        function mallocDataView(n) {
            return new DataView(mallocArrayBuffer(n), 0, n)
        }
        exports.mallocDataView = mallocDataView

        function mallocBuffer(n) {
            n = bits.nextPow2(n)
            var log_n = bits.log2(n)
            var cache = BUFFER[log_n]
            if(cache.length > 0) {
                return cache.pop()
            }
            return new Buffer(n)
        }
        exports.mallocBuffer = mallocBuffer

        exports.clearCache = function clearCache() {
            for(var i=0; i<32; ++i) {
                POOL.UINT8[i].length = 0
                POOL.UINT16[i].length = 0
                POOL.UINT32[i].length = 0
                POOL.INT8[i].length = 0
                POOL.INT16[i].length = 0
                POOL.INT32[i].length = 0
                POOL.FLOAT[i].length = 0
                POOL.DOUBLE[i].length = 0
                POOL.UINT8C[i].length = 0
                DATA[i].length = 0
                BUFFER[i].length = 0
            }
        }
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"bit-twiddle":12,"buffer":1,"dup":31}],33:[function(require,module,exports){
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
            typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (factory((global.topojson = {})));
    }(this, function (exports) { 'use strict';

        function noop() {}

        function absolute(transform) {
            if (!transform) return noop;
            var x0,
                y0,
                kx = transform.scale[0],
                ky = transform.scale[1],
                dx = transform.translate[0],
                dy = transform.translate[1];
            return function(point, i) {
                if (!i) x0 = y0 = 0;
                point[0] = (x0 += point[0]) * kx + dx;
                point[1] = (y0 += point[1]) * ky + dy;
            };
        }

        function relative(transform) {
            if (!transform) return noop;
            var x0,
                y0,
                kx = transform.scale[0],
                ky = transform.scale[1],
                dx = transform.translate[0],
                dy = transform.translate[1];
            return function(point, i) {
                if (!i) x0 = y0 = 0;
                var x1 = (point[0] - dx) / kx | 0,
                    y1 = (point[1] - dy) / ky | 0;
                point[0] = x1 - x0;
                point[1] = y1 - y0;
                x0 = x1;
                y0 = y1;
            };
        }

        function reverse(array, n) {
            var t, j = array.length, i = j - n;
            while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
        }

        function bisect(a, x) {
            var lo = 0, hi = a.length;
            while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (a[mid] < x) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        }

        function feature(topology, o) {
            return o.type === "GeometryCollection" ? {
                type: "FeatureCollection",
                features: o.geometries.map(function(o) { return feature$1(topology, o); })
            } : feature$1(topology, o);
        }

        function feature$1(topology, o) {
            var f = {
                type: "Feature",
                id: o.id,
                properties: o.properties || {},
                geometry: object(topology, o)
            };
            if (o.id == null) delete f.id;
            return f;
        }

        function object(topology, o) {
            var absolute$$ = absolute(topology.transform),
                arcs = topology.arcs;

            function arc(i, points) {
                if (points.length) points.pop();
                for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
                    points.push(p = a[k].slice());
                    absolute$$(p, k);
                }
                if (i < 0) reverse(points, n);
            }

            function point(p) {
                p = p.slice();
                absolute$$(p, 0);
                return p;
            }

            function line(arcs) {
                var points = [];
                for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
                if (points.length < 2) points.push(points[0].slice());
                return points;
            }

            function ring(arcs) {
                var points = line(arcs);
                while (points.length < 4) points.push(points[0].slice());
                return points;
            }

            function polygon(arcs) {
                return arcs.map(ring);
            }

            function geometry(o) {
                var t = o.type;
                return t === "GeometryCollection" ? {type: t, geometries: o.geometries.map(geometry)}
                    : t in geometryType ? {type: t, coordinates: geometryType[t](o)}
                        : null;
            }

            var geometryType = {
                Point: function(o) { return point(o.coordinates); },
                MultiPoint: function(o) { return o.coordinates.map(point); },
                LineString: function(o) { return line(o.arcs); },
                MultiLineString: function(o) { return o.arcs.map(line); },
                Polygon: function(o) { return polygon(o.arcs); },
                MultiPolygon: function(o) { return o.arcs.map(polygon); }
            };

            return geometry(o);
        }

        function stitchArcs(topology, arcs) {
            var stitchedArcs = {},
                fragmentByStart = {},
                fragmentByEnd = {},
                fragments = [],
                emptyIndex = -1;

            // Stitch empty arcs first, since they may be subsumed by other arcs.
            arcs.forEach(function(i, j) {
                var arc = topology.arcs[i < 0 ? ~i : i], t;
                if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
                    t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
                }
            });

            arcs.forEach(function(i) {
                var e = ends(i),
                    start = e[0],
                    end = e[1],
                    f, g;

                if (f = fragmentByEnd[start]) {
                    delete fragmentByEnd[f.end];
                    f.push(i);
                    f.end = end;
                    if (g = fragmentByStart[end]) {
                        delete fragmentByStart[g.start];
                        var fg = g === f ? f : f.concat(g);
                        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
                    } else {
                        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                    }
                } else if (f = fragmentByStart[end]) {
                    delete fragmentByStart[f.start];
                    f.unshift(i);
                    f.start = start;
                    if (g = fragmentByEnd[start]) {
                        delete fragmentByEnd[g.end];
                        var gf = g === f ? f : g.concat(f);
                        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
                    } else {
                        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                    }
                } else {
                    f = [i];
                    fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
                }
            });

            function ends(i) {
                var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
                if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
                else p1 = arc[arc.length - 1];
                return i < 0 ? [p1, p0] : [p0, p1];
            }

            function flush(fragmentByEnd, fragmentByStart) {
                for (var k in fragmentByEnd) {
                    var f = fragmentByEnd[k];
                    delete fragmentByStart[f.start];
                    delete f.start;
                    delete f.end;
                    f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
                    fragments.push(f);
                }
            }

            flush(fragmentByEnd, fragmentByStart);
            flush(fragmentByStart, fragmentByEnd);
            arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

            return fragments;
        }

        function mesh(topology) {
            return object(topology, meshArcs.apply(this, arguments));
        }

        function meshArcs(topology, o, filter) {
            var arcs = [];

            function arc(i) {
                var j = i < 0 ? ~i : i;
                (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
            }

            function line(arcs) {
                arcs.forEach(arc);
            }

            function polygon(arcs) {
                arcs.forEach(line);
            }

            function geometry(o) {
                if (o.type === "GeometryCollection") o.geometries.forEach(geometry);
                else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
            }

            if (arguments.length > 1) {
                var geomsByArc = [],
                    geom;

                var geometryType = {
                    LineString: line,
                    MultiLineString: polygon,
                    Polygon: polygon,
                    MultiPolygon: function(arcs) { arcs.forEach(polygon); }
                };

                geometry(o);

                geomsByArc.forEach(arguments.length < 3
                    ? function(geoms) { arcs.push(geoms[0].i); }
                    : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });
            } else {
                for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);
            }

            return {type: "MultiLineString", arcs: stitchArcs(topology, arcs)};
        }

        function triangle(triangle) {
            var a = triangle[0], b = triangle[1], c = triangle[2];
            return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
        }

        function ring(ring) {
            var i = -1,
                n = ring.length,
                a,
                b = ring[n - 1],
                area = 0;

            while (++i < n) {
                a = b;
                b = ring[i];
                area += a[0] * b[1] - a[1] * b[0];
            }

            return area / 2;
        }

        function merge(topology) {
            return object(topology, mergeArcs.apply(this, arguments));
        }

        function mergeArcs(topology, objects) {
            var polygonsByArc = {},
                polygons = [],
                components = [];

            objects.forEach(function(o) {
                if (o.type === "Polygon") register(o.arcs);
                else if (o.type === "MultiPolygon") o.arcs.forEach(register);
            });

            function register(polygon) {
                polygon.forEach(function(ring$$) {
                    ring$$.forEach(function(arc) {
                        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
                    });
                });
                polygons.push(polygon);
            }

            function exterior(ring$$) {
                return ring(object(topology, {type: "Polygon", arcs: [ring$$]}).coordinates[0]) > 0; // TODO allow spherical?
            }

            polygons.forEach(function(polygon) {
                if (!polygon._) {
                    var component = [],
                        neighbors = [polygon];
                    polygon._ = 1;
                    components.push(component);
                    while (polygon = neighbors.pop()) {
                        component.push(polygon);
                        polygon.forEach(function(ring$$) {
                            ring$$.forEach(function(arc) {
                                polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                                    if (!polygon._) {
                                        polygon._ = 1;
                                        neighbors.push(polygon);
                                    }
                                });
                            });
                        });
                    }
                }
            });

            polygons.forEach(function(polygon) {
                delete polygon._;
            });

            return {
                type: "MultiPolygon",
                arcs: components.map(function(polygons) {
                    var arcs = [], n;

                    // Extract the exterior (unique) arcs.
                    polygons.forEach(function(polygon) {
                        polygon.forEach(function(ring$$) {
                            ring$$.forEach(function(arc) {
                                if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                                    arcs.push(arc);
                                }
                            });
                        });
                    });

                    // Stitch the arcs into one or more rings.
                    arcs = stitchArcs(topology, arcs);

                    // If more than one ring is returned,
                    // at most one of these rings can be the exterior;
                    // this exterior ring has the same winding order
                    // as any exterior ring in the original polygons.
                    if ((n = arcs.length) > 1) {
                        var sgn = exterior(polygons[0][0]);
                        for (var i = 0, t; i < n; ++i) {
                            if (sgn === exterior(arcs[i])) {
                                t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
                                break;
                            }
                        }
                    }

                    return arcs;
                })
            };
        }

        function neighbors(objects) {
            var indexesByArc = {}, // arc index -> array of object indexes
                neighbors = objects.map(function() { return []; });

            function line(arcs, i) {
                arcs.forEach(function(a) {
                    if (a < 0) a = ~a;
                    var o = indexesByArc[a];
                    if (o) o.push(i);
                    else indexesByArc[a] = [i];
                });
            }

            function polygon(arcs, i) {
                arcs.forEach(function(arc) { line(arc, i); });
            }

            function geometry(o, i) {
                if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
                else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
            }

            var geometryType = {
                LineString: line,
                MultiLineString: polygon,
                Polygon: polygon,
                MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
            };

            objects.forEach(geometry);

            for (var i in indexesByArc) {
                for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
                    for (var k = j + 1; k < m; ++k) {
                        var ij = indexes[j], ik = indexes[k], n;
                        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
                        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
                    }
                }
            }

            return neighbors;
        }

        function compareArea(a, b) {
            return a[1][2] - b[1][2];
        }

        function minAreaHeap() {
            var heap = {},
                array = [],
                size = 0;

            heap.push = function(object) {
                up(array[object._ = size] = object, size++);
                return size;
            };

            heap.pop = function() {
                if (size <= 0) return;
                var removed = array[0], object;
                if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
                return removed;
            };

            heap.remove = function(removed) {
                var i = removed._, object;
                if (array[i] !== removed) return; // invalid request
                if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
                return i;
            };

            function up(object, i) {
                while (i > 0) {
                    var j = ((i + 1) >> 1) - 1,
                        parent = array[j];
                    if (compareArea(object, parent) >= 0) break;
                    array[parent._ = i] = parent;
                    array[object._ = i = j] = object;
                }
            }

            function down(object, i) {
                while (true) {
                    var r = (i + 1) << 1,
                        l = r - 1,
                        j = i,
                        child = array[j];
                    if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
                    if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
                    if (j === i) break;
                    array[child._ = i] = child;
                    array[object._ = i = j] = object;
                }
            }

            return heap;
        }

        function presimplify(topology, triangleArea) {
            var absolute$$ = absolute(topology.transform),
                relative$$ = relative(topology.transform),
                heap = minAreaHeap();

            if (!triangleArea) triangleArea = triangle;

            topology.arcs.forEach(function(arc) {
                var triangles = [],
                    maxArea = 0,
                    triangle,
                    i,
                    n,
                    p;

                // To store each point’s effective area, we create a new array rather than
                // extending the passed-in point to workaround a Chrome/V8 bug (getting
                // stuck in smi mode). For midpoints, the initial effective area of
                // Infinity will be computed in the next step.
                for (i = 0, n = arc.length; i < n; ++i) {
                    p = arc[i];
                    absolute$$(arc[i] = [p[0], p[1], Infinity], i);
                }

                for (i = 1, n = arc.length - 1; i < n; ++i) {
                    triangle = arc.slice(i - 1, i + 2);
                    triangle[1][2] = triangleArea(triangle);
                    triangles.push(triangle);
                    heap.push(triangle);
                }

                for (i = 0, n = triangles.length; i < n; ++i) {
                    triangle = triangles[i];
                    triangle.previous = triangles[i - 1];
                    triangle.next = triangles[i + 1];
                }

                while (triangle = heap.pop()) {
                    var previous = triangle.previous,
                        next = triangle.next;

                    // If the area of the current point is less than that of the previous point
                    // to be eliminated, use the latter's area instead. This ensures that the
                    // current point cannot be eliminated without eliminating previously-
                    // eliminated points.
                    if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;
                    else maxArea = triangle[1][2];

                    if (previous) {
                        previous.next = next;
                        previous[2] = triangle[2];
                        update(previous);
                    }

                    if (next) {
                        next.previous = previous;
                        next[0] = triangle[0];
                        update(next);
                    }
                }

                arc.forEach(relative$$);
            });

            function update(triangle) {
                heap.remove(triangle);
                triangle[1][2] = triangleArea(triangle);
                heap.push(triangle);
            }

            return topology;
        }

        var version = "1.6.24";

        exports.version = version;
        exports.mesh = mesh;
        exports.meshArcs = meshArcs;
        exports.merge = merge;
        exports.mergeArcs = mergeArcs;
        exports.feature = feature;
        exports.neighbors = neighbors;
        exports.presimplify = presimplify;

    }));
},{}],34:[function(require,module,exports){
    var colorSort;

    colorSort = require("../color/sort.coffee");

    module.exports = function(a, b, keys, sort, colors, vars, depth) {
        var i, k, retVal;
        if (!sort) {
            sort = "asc";
        }
        if (!(colors instanceof Array)) {
            colors = [colors];
        }
        if (!(keys instanceof Array)) {
            keys = [keys];
        }
        if (vars && depth !== void 0 && typeof depth !== "number") {
            depth = vars.id.nesting.indexOf(depth);
        }
        retVal = 0;
        i = 0;
        while (i < keys.length) {
            k = keys[i];
            a = vars && a.d3plus && a.d3plus.sortKeys ? a.d3plus.sortKeys[k] : a[k];
            b = vars && b.d3plus && b.d3plus.sortKeys ? b.d3plus.sortKeys[k] : b[k];
            if (vars && colors.indexOf(k) >= 0) {
                retVal = colorSort(a, b);
            } else {
                retVal = a < b ? -1 : 1;
            }
            if (retVal !== 0 || i === keys.length - 1) {
                break;
            }
            i++;
        }
        if (sort === "asc") {
            return retVal;
        } else {
            return -retVal;
        }
    };


},{"../color/sort.coffee":51}],35:[function(require,module,exports){
    module.exports = function(arr, value) {
        var constructor;
        if (arr instanceof Array) {
            constructor = value === void 0 || value === null ? value : value.constructor;
            return arr.indexOf(value) >= 0 || arr.indexOf(constructor) >= 0;
        } else {
            return false;
        }
    };


},{}],36:[function(require,module,exports){
    var comparator, fetchSort;

    comparator = require("./comparator.coffee");

    fetchSort = require("../core/fetch/sort.coffee");

    module.exports = function(arr, keys, sort, colors, vars, depth) {
        var d, data, i, len;
        if (!arr || arr.length <= 1) {
            return arr || [];
        } else {
            if (vars) {
                if (!keys) {
                    keys = vars.order.value || vars.size.value || vars.id.value;
                }
                if (!sort) {
                    sort = vars.order.sort.value;
                }
                if (!colors) {
                    colors = vars.color.value || [];
                }
                for (i = 0, len = arr.length; i < len; i++) {
                    d = arr[i];
                    if (!d.d3plus) {
                        d.d3plus = {};
                    }
                    data = "d3plus" in d && "d3plus" in d.d3plus ? d.d3plus : d;
                    d.d3plus.sortKeys = fetchSort(vars, data, keys, colors, depth);
                }
            }
            return arr.sort(function(a, b) {
                return comparator(a, b, keys, sort, colors, vars, depth);
            });
        }
    };


},{"../core/fetch/sort.coffee":67,"./comparator.coffee":34}],37:[function(require,module,exports){
    module.exports = function(arr, x) {
        if (x === void 0) {
            return arr;
        }
        if (x === false) {
            return [];
        }
        if (x instanceof Array) {
            return x;
        }
        if (!(arr instanceof Array)) {
            arr = [];
        }
        if (arr.indexOf(x) >= 0) {
            arr.splice(arr.indexOf(x), 1);
        } else {
            arr.push(x);
        }
        return arr;
    };


},{}],38:[function(require,module,exports){
    var sheet;

    sheet = function(name) {
        var css, i, returnBoolean, tested;
        tested = sheet.tested;
        if (name in tested) {
            return tested[name];
        }
        i = 0;
        returnBoolean = false;
        while (i < document.styleSheets.length) {
            css = document.styleSheets[i];
            if (css.href && css.href.indexOf(name) >= 0) {
                returnBoolean = true;
                break;
            }
            i++;
        }
        return returnBoolean;
    };

    sheet.tested = {};

    module.exports = sheet;


},{}],39:[function(require,module,exports){
// Determines if the current browser is Internet Explorer.
    module.exports = /(MSIE|Trident\/|Edge\/)/i.test(navigator.userAgent);

},{}],40:[function(require,module,exports){
    var ie, touch;

    ie = require("./ie.js");

    touch = require("./touch.coffee");

    if (touch) {
        module.exports = {
            click: "click",
            down: "touchstart",
            up: "touchend",
            over: ie ? "mouseenter" : "mouseover",
            out: ie ? "mouseleave" : "mouseout",
            move: "mousemove"
        };
    } else {
        module.exports = {
            click: "click",
            down: "mousedown",
            up: "mouseup",
            over: ie ? "mouseenter" : "mouseover",
            out: ie ? "mouseleave" : "mouseout",
            move: "mousemove"
        };
    }


},{"./ie.js":39,"./touch.coffee":45}],41:[function(require,module,exports){
    var prefix;

    prefix = function() {
        var val;
        if ("-webkit-transform" in document.body.style) {
            val = "-webkit-";
        } else if ("-moz-transform" in document.body.style) {
            val = "-moz-";
        } else if ("-ms-transform" in document.body.style) {
            val = "-ms-";
        } else if ("-o-transform" in document.body.style) {
            val = "-o-";
        } else {
            val = "";
        }
        prefix = function() {
            return val;
        };
        return val;
    };

    module.exports = prefix;


},{}],42:[function(require,module,exports){
    module.exports = d3.select("html").attr("dir") === "rtl";


},{}],43:[function(require,module,exports){
    module.exports = {
        "y": function() {
            return (window.pageYOffset !== undefined) ? window.pageYOffset :
                (document.documentElement || document.body.parentNode || document.body).scrollTop
        },
        "x": function() {
            return (window.pageXOffset !== undefined) ? window.pageXOffset :
                (document.documentElement || document.body.parentNode || document.body).scrollLeft
        }
    }

},{}],44:[function(require,module,exports){
    var scrollbar;

    scrollbar = function() {
        var inner, outer, val, w1, w2;
        inner = document.createElement("p");
        inner.style.width = "100%";
        inner.style.height = "200px";
        outer = document.createElement("div");
        outer.style.position = "absolute";
        outer.style.top = "0px";
        outer.style.left = "0px";
        outer.style.visibility = "hidden";
        outer.style.width = "200px";
        outer.style.height = "150px";
        outer.style.overflow = "hidden";
        outer.appendChild(inner);
        document.body.appendChild(outer);
        w1 = inner.offsetWidth;
        outer.style.overflow = "scroll";
        w2 = inner.offsetWidth;
        if (w1 === w2) {
            w2 = outer.clientWidth;
        }
        document.body.removeChild(outer);
        val = w1 - w2;
        scrollbar = function() {
            return val;
        };
        return val;
    };

    module.exports = scrollbar;


},{}],45:[function(require,module,exports){
    module.exports = ("ontouchstart" in window) || window.DocumentTouch && document instanceof DocumentTouch ? true : false;


},{}],46:[function(require,module,exports){
    module.exports = function(color) {
        var hsl;
        hsl = d3.hsl(color);
        if (hsl.l > .45) {
            if (hsl.s > .8) {
                hsl.s = 0.8;
            }
            hsl.l = 0.45;
        }
        return hsl.toString();
    };


},{}],47:[function(require,module,exports){
    module.exports = function(color, increment) {
        var c;
        if (increment === void 0) {
            increment = 0.5;
        }
        c = d3.hsl(color);
        increment = (1 - c.l) * increment;
        c.l += increment;
        c.s -= increment;
        return c.toString();
    };


},{}],48:[function(require,module,exports){
    module.exports = function(c1, c2, o1, o2) {
        var b, g, r;
        if (!o1) {
            o1 = 1;
        }
        if (!o2) {
            o2 = 1;
        }
        c1 = d3.rgb(c1);
        c2 = d3.rgb(c2);
        r = (o1 * c1.r + o2 * c2.r - o1 * o2 * c2.r) / (o1 + o2 - o1 * o2);
        g = (o1 * c1.g + o2 * c2.g - o1 * o2 * c2.g) / (o1 + o2 - o1 * o2);
        b = (o1 * c1.b + o2 * c2.b - o1 * o2 * c2.b) / (o1 + o2 - o1 * o2);
        return d3.rgb(r, g, b).toString();
    };


},{}],49:[function(require,module,exports){
    var defaultScale;

    defaultScale = require("./scale.coffee");

    module.exports = function(x, scale) {
        var rand_int;
        rand_int = x || Math.floor(Math.random() * 20);
        scale = scale || defaultScale;
        return scale(rand_int);
    };


},{"./scale.coffee":50}],50:[function(require,module,exports){
    module.exports = d3.scale.ordinal().range(["#b22200", "#282F6B", "#EACE3F", "#B35C1E", "#224F20", "#5F487C", "#759143", "#419391", "#993F88", "#e89c89", "#ffee8d", "#afd5e8", "#f7ba77", "#a5c697", "#c5b5e5", "#d1d392", "#bbefd0", "#e099cf"]);


},{}],51:[function(require,module,exports){
    module.exports = function(a, b) {
        var aHSL, bHSL;
        aHSL = d3.hsl(a);
        bHSL = d3.hsl(b);
        a = aHSL.s === 0 ? 361 : aHSL.h;
        b = bHSL.s === 0 ? 361 : bHSL.h;
        if (a === b) {
            return aHSL.l - bHSL.l;
        } else {
            return a - b;
        }
    };


},{}],52:[function(require,module,exports){
    module.exports = function(color) {
        var b, g, r, rgbColor, yiq;
        rgbColor = d3.rgb(color);
        r = rgbColor.r;
        g = rgbColor.g;
        b = rgbColor.b;
        yiq = (r * 299 + g * 587 + b * 114) / 1000;
        if (yiq >= 128) {
            return "#444444";
        } else {
            return "#f7f7f7";
        }
    };


},{}],53:[function(require,module,exports){
    module.exports = function(color) {
        var blackColors, testColor, userBlack;
        color = color + "";
        color = color.replace(RegExp(" ", "g"), "");
        if (color.indexOf("rgb") === 0) {
            color = color.split("(")[1].split(")")[0].split(",").slice(0, 3).join(",");
        }
        if (color.indexOf("hsl") === 0) {
            color = color.split(",")[2].split(")")[0];
        }
        testColor = d3.rgb(color).toString();
        blackColors = ["black", "#000", "#000000", "0%", "0,0,0"];
        userBlack = blackColors.indexOf(color) >= 0;
        return testColor !== "#000000" || userBlack;
    };


},{}],54:[function(require,module,exports){
    var ie, print, wiki;

    ie = require("../../client/ie.js");

    wiki = require("./wiki.coffee");

    print = function(type, message, style) {
        style = style || "";
        if (ie || typeof InstallTrigger !== 'undefined') {
            console.log("[ D3plus ] " + message);
        } else if (type.indexOf("group") === 0) {
            console[type]("%c[ D3plus ]%c " + message, "font-weight: 800;" + "color: #b35c1e;" + "margin-left: 0px;", "font-weight:200;" + style);
        } else {
            console[type]("%c" + message, style + "font-weight:200;");
        }
    };

    print.comment = function(message) {
        this("log", message, "color:#aaa;");
    };

    print.error = function(message, url) {
        this("groupCollapsed", "ERROR: " + message, "font-weight:800;color:#D74B03;");
        this.stack();
        this.wiki(url);
        this.groupEnd();
    };

    print.group = function(message) {
        this("group", message, "color:#888;");
    };

    print.groupCollapsed = function(message) {
        this("groupCollapsed", message, "color:#888;");
    };

    print.groupEnd = function() {
        if (!ie) {
            console.groupEnd();
        }
    };

    print.log = function(message) {
        this("log", message, "color:#444444;");
    };

    print.stack = function() {
        var err, line, message, page, splitter, stack, url;
        if (!ie) {
            err = new Error();
            if (err.stack) {
                stack = err.stack.split("\n");
                stack = stack.filter(function(e) {
                    return e.indexOf("Error") !== 0 && e.indexOf("d3plus.js:") < 0 && e.indexOf("d3plus.min.js:") < 0;
                });
                if (stack.length && stack[0].length) {
                    splitter = window.chrome ? "at " : "@";
                    url = stack[0];
                    if (url.indexOf(splitter) >= 0) {
                        url = url.split(splitter)[1];
                    }
                    stack = url.split(":");
                    if (stack.length === 3) {
                        stack.pop();
                    }
                    line = stack.pop();
                    page = stack.join(":").split("/");
                    page = page[page.length - 1];
                    message = "line " + line + " of " + page + ": " + url;
                    this("log", message, "color:#D74B03;");
                }
            }
        }
    };

    print.time = function(message) {
        if (!ie) {
            console.time(message);
        }
    };

    print.timeEnd = function(message) {
        if (!ie) {
            console.timeEnd(message);
        }
    };

    print.warning = function(message, url) {
        this("groupCollapsed", message, "color:#888;");
        this.stack();
        this.wiki(url);
        this.groupEnd();
    };

    print.wiki = function(url) {
        if (url) {
            if (url in wiki) {
                url = d3plus.repo + "wiki/" + wiki[url];
            }
            this("log", "documentation: " + url, "color:#aaa;");
        }
    };

    module.exports = print;


},{"../../client/ie.js":39,"./wiki.coffee":55}],55:[function(require,module,exports){
    module.exports = {
        active: "Visualizations#active",
        aggs: "Visualizations#aggs",
        alt: "Forms#alt",
        attrs: "Visualizations#attrs",
        axes: "Visualizations#axes",
        background: "Visualizations#background",
        color: "Visualizations#color",
        cols: "Visualizations#cols",
        config: "Visualizations#config",
        container: "Visualizations#container",
        coords: "Visualizations#coords",
        csv: "Visualizations#csv",
        data: "Visualizations#data",
        depth: "Visualizations#depth",
        descs: "Visualizations#descs",
        dev: "Visualizations#dev",
        draw: "Visualizations#draw",
        edges: "Visualizations#edges",
        error: "Visualizations#error",
        focus: "Visualizations#focus",
        font: "Visualizations#font",
        footer: "Visualizations#footer",
        format: "Visualizations#format",
        height: "Visualizations#height",
        history: "Visualizations#history",
        hover: "Forms#hover",
        icon: "Visualizations#icon",
        id: "Visualizations#id",
        keywords: "Forms#keywords",
        labels: "Visualizations#labels",
        legend: "Visualizations#legend",
        links: "Visualizations#links",
        margin: "Visualizations#margin",
        messages: "Visualizations#messages",
        method: "Methods",
        mouse: "Visualizations#mouse",
        nodes: "Visualizations#nodes",
        open: "Forms#open",
        order: "Visualizations#order",
        remove: "Forms#remove",
        search: "Forms#search",
        select: "Forms#select",
        selectAll: "Forms#selectAll",
        shape: "Visualizations#shape",
        size: "Visualizations#size",
        temp: "Visualizations#temp",
        text: "Visualizations#text",
        time: "Visualizations#time",
        timeline: "Visualizations#timeline",
        timing: "Visualizations#timing",
        title: "Visualizations#title",
        tooltip: "Visualizations#tooltip",
        total: "Visualizations#total",
        type: "Visualizations#type",
        ui: "Visualizations#ui",
        width: "Visualizations#width",
        x: "Visualizations#x",
        y: "Visualizations#y",
        zoom: "Visualizations#zoom"
    };


},{}],56:[function(require,module,exports){
    var buckets = require("../../util/buckets.coffee"),
        fetchValue = require("../fetch/value.coffee"),
        print      = require("../console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Sets color range of data, if applicable
//-------------------------------------------------------------------
    module.exports = function(vars) {

        if ( vars.dev.value ) print.time("getting color data range")

        var data_range = []
        vars.data.pool.forEach(function(d){
            var val = parseFloat(fetchValue(vars,d,vars.color.value))
            if (typeof val == "number" && !isNaN(val) && data_range.indexOf(val) < 0) data_range.push(val)
        })

        if ( vars.dev.value ) print.timeEnd("getting color data range")

        if (data_range.length > 1) {

            var data_domain = null

            if ( vars.dev.value ) print.time("calculating color scale")

            data_range = d3.extent(data_range)

            if (data_range[0] < 0 && data_range[1] > 0) {
                var color_range = vars.color.range
                if (color_range.length == 3) {
                    data_range.push(data_range[1])
                    data_range[1] = 0
                }
            }
            else if (data_range[1] > 0 && data_range[0] >= 0) {
                var color_range = vars.color.heatmap
                data_range = buckets(data_range,color_range.length)
            }
            else {
                var color_range = vars.color.range.slice(0)
                if (data_range[0] < 0) {
                    color_range.pop()
                }
                else {
                    color_range.shift()
                }
            }

            vars.color.valueScale = d3.scale.sqrt()
                .domain(data_range)
                .range(color_range)
                .interpolate(d3.interpolateRgb)

            if ( vars.dev.value ) print.timeEnd("calculating color scale")

        }
        else {
            vars.color.valueScale = null
        }

    }

},{"../../util/buckets.coffee":206,"../console/print.coffee":54,"../fetch/value.coffee":69}],57:[function(require,module,exports){
    var fetchValue = require("../fetch/value.coffee"),
        print       = require("../console/print.coffee"),
        validObject = require("../../object/validate.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Restricts data based on Solo/Mute filters
//------------------------------------------------------------------------------
    module.exports = function( vars , data ) {

        if ( vars.dev.value ) print.time("filtering data")

        var availableKeys = d3.keys(vars.data.keys || {})

        if ( "attrs" in vars ) {
            availableKeys = availableKeys.concat(d3.keys(vars.attrs.keys || {}))
        }

        data = data.filter(function(d){
            var val = fetchValue(vars, d, vars.id.value);
            return val !== null;
        });

        var typeReqs = vars.types[vars.type.value].requirements || [];

        vars.data.filters.forEach( function( key ) {

            if (availableKeys.indexOf(vars[key].value) >= 0 &&
                typeReqs.indexOf(key) >= 0) {

                data = data.filter( function( d ) {

                    var val = fetchValue(vars,d,vars[key].value);

                    if (key === "y" && vars.y2.value && val === null) {
                        val = fetchValue(vars,d,vars.y2.value);
                    }
                    else if (key === "x" && vars.x2.value && val === null) {
                        val = fetchValue(vars,d,vars.x2.value);
                    }

                    if ( key === "size" ) {
                        return typeof val === "number"
                    }
                    else {
                        return val !== null
                    }

                })

            }

        });

        // if "solo", only check against "solo" (disregard "mute")
        var key = vars.data.solo.length ? "solo" : "mute";

        if (vars.data[key].length) {

            vars.data[key].forEach(function(v) {

                function test_value(val) {

                    var arr = vars[v][key].value;

                    var match = false;
                    arr.forEach(function(f){
                        if (typeof f === "function") {
                            match = f(val);
                        }
                        else if (f === val) {
                            match = true;
                        }

                    })

                    return key === "solo" ? match : !match;

                }

                function filter_data(d, flat) {
                    if (!flat && vars[v].nesting) {
                        var nesting = vars[v].nesting;
                        if (validObject(nesting)) {
                            nesting = d3.values(nesting);
                        }
                        for (var n = 0; n < nesting.length; n++) {
                            var new_data = d.filter(function(dd){
                                return test_value(fetchValue(vars, dd, nesting[n]));
                            });
                            if (new_data.length) d = new_data;
                        }
                    }
                    else {
                        d = d.filter(function(dd){
                            return test_value(fetchValue(vars, dd, vars[v].value));
                        });
                    }
                    return d;
                }

                data = filter_data(data);

                if ( v === "id" ) {

                    if ("nodes" in vars && vars.nodes.value) {
                        if ( vars.dev.value ) print.time("filtering nodes")
                        vars.nodes.restricted = filter_data(vars.nodes.value);
                        if ( vars.dev.value ) print.timeEnd("filtering nodes")
                    }

                    if ("edges" in vars && vars.edges.value) {
                        if ( vars.dev.value ) print.time("filtering edges")
                        vars.edges.restricted = vars.edges.value.filter(function(d){
                            var points = filter_data([d[vars.edges.source], d[vars.edges.target]]);
                            return points.length === 2;
                        })
                        if ( vars.dev.value ) print.timeEnd("filtering edges")
                    }

                }

            })

        }
        else if ("nodes" in vars) {
            vars.nodes.restricted = undefined;
            vars.edges.restricted = undefined;
        }

        if ( vars.dev.value ) print.timeEnd("filtering data")

        return data

    }

},{"../../object/validate.coffee":174,"../console/print.coffee":54,"../fetch/value.coffee":69}],58:[function(require,module,exports){
    var dataNest   = require("./nest.js"),
        fetchValue = require("../fetch/value.coffee"),
        print      = require("../console/print.coffee"),
        uniques    = require("../../util/uniques.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Formats raw data by time and nesting
//------------------------------------------------------------------------------
    module.exports = function( vars ) {

        var timerString;

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Gets all unique time values
        //----------------------------------------------------------------------------
        vars.data.time = {"values": []};
        if (vars.time && vars.time.value) {

            if ( vars.dev.value ) {
                timerString = "analyzing time periods";
                print.time( timerString );
            }

            vars.data.time.values = uniques(vars.data.value, vars.time.value, fetchValue, vars);

            vars.data.time.values.sort(function(a,b){ return a-b; });

            var step = [];
            vars.data.time.values.forEach(function(y,i){
                if (i !== 0) {
                    var prev = vars.data.time.values[i-1];
                    step.push(y-prev);
                    if (i === vars.data.time.values.length - 1) {
                        vars.data.time.total = y - vars.data.time.values[0];
                    }
                }
            });

            step = d3.min(step);
            vars.data.time.step = step;

            var periods = ["Milliseconds","Seconds","Minutes","Hours","Date","Month","FullYear"],
                conversions = [1000,60,60,24,30,12,1];

            vars.data.time.periods = periods;

            var getDiff = function(start,end,i) {

                if (!vars.data.time.stepDivider) {
                    arr = conversions.slice(0,i);
                    if (arr.length) {
                        vars.data.time.stepDivider = arr.reduce(function(a,b){ return a*b; });
                    }
                    else {
                        vars.data.time.stepDivider = 1;
                    }
                }

                return Math.round(Math.floor(end-start)/vars.data.time.stepDivider);

            };

            var total = vars.data.time.total;
            periods.forEach(function(p,i){
                var c = p === "Date" ? 28 : conversions[i];
                if (!vars.data.time.stepType && (i === periods.length-1 || Math.round(step) < c)) {
                    vars.data.time.stepType = p;
                    var start = vars.data.time.values[0],
                        end = vars.data.time.values[vars.data.time.values.length-1];
                    vars.data.time.stepIntervals = getDiff(start,end,i);
                }

                if (!vars.data.time.totalType && (i === periods.length-1 || Math.round(total) < c)) {
                    vars.data.time.totalType = p;
                }

                step = step/c;
                total = total/c;
            });

            vars.data.time.values.forEach(function(y,i){
                if (i !== 0) {
                    var prev = vars.data.time.values[0];
                    vars.data.time.dataSteps.push(getDiff(prev,y,periods.indexOf(vars.data.time.stepType)));
                }
                else {
                    vars.data.time.dataSteps = [0];
                }
            });

            var userFormat = vars.time.format.value,
                locale = vars.format.locale.value,
                functions = [
                    function(d) { return d.getMilliseconds(); },
                    function(d) { return d.getSeconds(); },
                    function(d) { return d.getMinutes(); },
                    function(d) { return d.getHours(); },
                    function(d) { return d.getDate() != 1; },
                    function(d) { return d.getMonth(); },
                    function(d) { return true; }
                ];

            vars.data.time.functions = functions;

            var getFormat = function(s,t,small) {

                if (s === t) {
                    return small && locale.timeFormat[s+"Small"] ? locale.timeFormat[s+"Small"] : locale.timeFormat[s];
                }
                else {
                    if (periods.indexOf(s) >= 4 || periods.indexOf(t) <= 3) {
                        return locale.timeFormat[t+"-"+s];
                    }
                    else {

                        var format;

                        if (t === "Date") {
                            format = locale.timeFormat[t];
                        }
                        else {
                            format = locale.timeFormat[t+"-Date"];
                        }

                        if (s === "Hours") {
                            return format +" "+ locale.timeFormat[s];
                        }
                        else {
                            return format +" "+ locale.timeFormat["Hours-"+s];
                        }

                    }
                }

            };

            vars.data.time.getFormat = getFormat;

            if (userFormat) {

                if (typeof userFormat === "string") {
                    vars.data.time.format = d3.locale(locale.format).timeFormat(userFormat);
                }
                else if (typeof userFormat === "function") {
                    vars.data.time.format = userFormat;
                }
                else if (userFormat instanceof Array) {
                    vars.data.time.format = d3.locale(locale.format).timeFormat.multi(userFormat);
                }
                vars.data.time.multiFormat = vars.data.time.format;

            }
            else {

                var stepType = vars.data.time.stepType,
                    totalType = vars.data.time.totalType;

                var multi = [];

                for (var p = periods.indexOf(stepType); p <= periods.indexOf(totalType); p++) {
                    var prev = p-1 < periods.indexOf(stepType) ? periods[p] : periods[p-1];
                    var small = periods[p] === prev && stepType !== totalType;
                    var format = getFormat(prev,periods[p],small);
                    multi.push([format,functions[p]]);
                }

                vars.data.time.format = d3.locale(locale.format).timeFormat(getFormat(stepType,totalType));
                if (multi.length > 1) {
                    multi[multi.length-1][1] = function (d) { return true; }
                    vars.data.time.multiFormat = d3.locale(locale.format).timeFormat.multi(multi);
                }
                else {
                    vars.data.time.multiFormat = vars.data.time.format;
                }

            }

            vars.data.time.ticks = [];
            var min = d3.min(vars.data.time.values);
            var max = d3.max(vars.data.time.values);
            for (var s = 0; s <= vars.data.time.stepIntervals; s++) {
                var m = new Date(min);
                m["set"+vars.data.time.stepType](m["get"+vars.data.time.stepType]() + s);
                if (m <= max) vars.data.time.ticks.push(m);
            }

            if ( vars.dev.value ) print.timeEnd( timerString );

        }

        if ( vars.dev.value ) {
            timerString = "nesting data by time and depths";
            print.time( timerString );
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Gets all unique time values
        //----------------------------------------------------------------------------
        vars.data.nested = {};
        if (vars.data.time.values.length === 0) {

            vars.data.nested.all = {};
            vars.id.nesting.forEach( function( depth , i ) {

                var nestingDepth = vars.id.nesting.slice( 0 , i + 1 );
                vars.data.nested.all[ depth ] = dataNest(vars, vars.data.value, nestingDepth);

            });

        }
        else {

            var timeData = vars.data.value.reduce(function(o, d){
                var ms = fetchValue(vars, d, vars.time.value).getTime();
                if (!(ms in o)) o[ms] = [];
                o[ms].push(d);
                return o;
            }, {});

            vars.data.time.values.forEach( function( t ) {

                var ms = t.getTime();

                vars.data.nested[ms] = {};

                vars.id.nesting.forEach( function( depth , i ) {
                    var nestingDepth = vars.id.nesting.slice(0, i + 1);
                    vars.data.nested[ ms ][ depth ] = dataNest(vars, timeData[ms], nestingDepth);
                });

            });

        }

        if ( vars.dev.value ) print.timeEnd( timerString );

    };

},{"../../util/uniques.coffee":212,"../console/print.coffee":54,"../fetch/value.coffee":69,"./nest.js":62}],59:[function(require,module,exports){
    var fetchValue;

    fetchValue = require("../fetch/value.coffee");

    module.exports = function(vars, data, nesting) {
        var d, groupedData, i, j, k, len, len1, n, strippedData, val;
        groupedData = d3.nest();
        if (vars.id.grouping.value) {
            if (nesting === void 0) {
                nesting = vars.id.nesting;
            }
            for (i = j = 0, len = nesting.length; j < len; i = ++j) {
                n = nesting[i];
                if (i < vars.depth.value) {
                    (function(n) {
                        return groupedData.key(function(d) {
                            return fetchValue(vars, d.d3plus, n);
                        });
                    })(n);
                }
            }
        }
        strippedData = [];
        for (k = 0, len1 = data.length; k < len1; k++) {
            d = data[k];
            val = vars.size.value ? fetchValue(vars, d, vars.size.value) : 1;
            if (val && typeof val === "number" && val > 0) {
                delete d.d3plus.r;
                delete d.d3plus.x;
                delete d.d3plus.y;
                strippedData.push({
                    d3plus: d,
                    id: d[vars.id.value],
                    value: val
                });
            }
        }
        return groupedData.entries(strippedData);
    };


},{"../fetch/value.coffee":69}],60:[function(require,module,exports){
    var print, validObject,
        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    print = require("../console/print.coffee");

    validObject = require("../../object/validate.coffee");

    module.exports = function(vars, type) {
        var get_keys, k, kk, lengthMatch, ref, ref1, timerString, v, vv;
        timerString = type + " key analysis";
        if (vars.dev.value) {
            print.time(timerString);
        }
        vars[type].keys = {};
        get_keys = function(arr) {
            var a, i, k, len, results, results1, v;
            if (arr instanceof Array) {
                results = [];
                for (i = 0, len = arr.length; i < len; i++) {
                    a = arr[i];
                    results.push(get_keys(a));
                }
                return results;
            } else if (validObject(arr)) {
                results1 = [];
                for (k in arr) {
                    v = arr[k];
                    if (k.indexOf("d3plus") !== 0 && !(indexOf.call(vars[type].keys, k) >= 0) && v !== null) {
                        results1.push(vars[type].keys[k] = typeof v);
                    } else {
                        results1.push(void 0);
                    }
                }
                return results1;
            }
        };
        if (validObject(vars[type].value)) {
            lengthMatch = d3.keys(vars[type].value).length === vars.id.nesting.length;
            ref = vars[type].value;
            for (k in ref) {
                v = ref[k];
                if (lengthMatch && vars.id.nesting.indexOf(k) >= 0 && validObject(v)) {
                    for (kk in v) {
                        vv = v[kk];
                        get_keys(vv);
                    }
                } else {
                    get_keys(v);
                }
            }
        } else {
            ref1 = vars[type].value;
            for (k in ref1) {
                v = ref1[k];
                get_keys(v);
            }
        }
        if (vars.dev.value) {
            return print.time(timerString);
        }
    };


},{"../../object/validate.coffee":174,"../console/print.coffee":54}],61:[function(require,module,exports){
    var print, validObject;

    print = require("../console/print.coffee");

    validObject = require("../../object/validate.coffee");

    module.exports = function(vars, key, next) {
        var consoleMessage, fileType, parser, url;
        consoleMessage = vars.dev.value;
        if (consoleMessage) {
            print.time("loading " + key);
        }
        url = vars[key].url;
        if (!vars[key].filetype.value) {
            fileType = url.slice(url.length - 5).split(".");
            if (fileType.length > 1) {
                fileType = fileType[1];
            } else {
                fileType = false;
            }
            if (fileType) {
                if (fileType === "txt") {
                    fileType = "text";
                }
                if (vars[key].filetype.accepted.indexOf(fileType) < 0) {
                    fileType = "json";
                }
            } else {
                fileType = "json";
            }
        } else {
            fileType = vars[key].filetype.value;
        }
        if (fileType === "dsv") {
            parser = d3.dsv(vars[key].delimiter.value, "text/plain");
        } else {
            parser = d3[fileType];
        }
        return parser(url, function(error, data) {
            var k, ret;
            if (!error && data) {
                if (typeof vars[key].callback === "function") {
                    ret = vars[key].callback(data);
                    if (ret) {
                        if (validObject(ret) && key in ret) {
                            for (k in ret) {
                                if (k in vars) {
                                    vars[k].value = ret[k];
                                }
                            }
                        } else {
                            vars[key].value = ret;
                        }
                    }
                } else {
                    vars[key].value = data;
                }
                if (["json"].indexOf(fileType) < 0) {
                    vars[key].value.forEach(function(d) {
                        var results;
                        results = [];
                        for (k in d) {
                            if (!isNaN(d[k])) {
                                results.push(d[k] = parseFloat(d[k]));
                            } else if (d[k].toLowerCase() === "false") {
                                results.push(d[k] = false);
                            } else if (d[k].toLowerCase() === "true") {
                                results.push(d[k] = true);
                            } else if (d[k].toLowerCase() === "null") {
                                results.push(d[k] = null);
                            } else {
                                if (d[k].toLowerCase() === "undefined") {
                                    results.push(d[k] = void 0);
                                } else {
                                    results.push(void 0);
                                }
                            }
                        }
                        return results;
                    });
                }
                vars[key].changed = true;
                vars[key].loaded = true;
            } else {
                vars.error.internal = "Could not load data from: \"" + url + "\"";
            }
            if (consoleMessage) {
                print.timeEnd("loading " + key);
            }
            return next();
        });
    };


},{"../../object/validate.coffee":174,"../console/print.coffee":54}],62:[function(require,module,exports){
    var fetchValue = require("../fetch/value.coffee"),
        validObject  = require("../../object/validate.coffee"),
        uniqueValues = require("../../util/uniques.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Nests and groups the data.
//------------------------------------------------------------------------------
    var dataNest = function(vars, flatData, nestingLevels, discrete) {

        if (discrete === undefined) discrete = true;

        var nestedData   = d3.nest(),
            groupedData  = [],
            segments     = "temp" in vars ? [ "active" , "temp" , "total" ] : [];

        if (!nestingLevels.length) {
            nestedData.key(function(d){ return true; });
        }
        else {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Loop through each nesting level.
            //----------------------------------------------------------------------------
            nestingLevels.forEach(function(level, i){

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Create a nest key for the current level.
                //--------------------------------------------------------------------------
                nestedData.key(function(d){ return fetchValue(vars, d, level); });

            });

        }

        if (discrete && vars.axes && vars.axes.discrete && (!vars.time || vars[vars.axes.discrete].value !== vars.time.value)) {
            nestedData.key(function(d){
                return fetchValue(vars, d, vars[vars.axes.discrete].value);
            });
        }

        var deepest_is_id = nestingLevels.length && vars.id.nesting.indexOf(nestingLevels[nestingLevels.length - 1]) >= 0;
        var i = nestingLevels.length && deepest_is_id ? nestingLevels.length - 1 : 0;
        var depthKey = deepest_is_id ? vars.id.nesting[i] : vars.depth.value;

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If we're at the deepest level, create the rollup function.
        //----------------------------------------------------------------------------
        nestedData.rollup(function(leaves) {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // If there's only 1 leaf, and it's been processed, return it as-is.
            //--------------------------------------------------------------------------
            if (leaves.length === 1 && ("d3plus" in leaves[0])) {
                groupedData.push(leaves[0]);
                return leaves[0];
            }

            leaves = leaves.reduce(function(arr, ll){
                if (ll.values instanceof Array) {
                    return arr.concat(ll.values);
                }
                arr.push(ll);
                return arr;
            }, []);

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create the "d3plus" object for the return variable, starting with
            // just the current depth.
            //--------------------------------------------------------------------------
            var returnObj = {
                "d3plus": {
                    "data": {},
                    "depth": i
                }
            };

            var merged = d3.sum(leaves, function(ll){ return "d3plus" in ll && ll.d3plus.merged ? 1 : 0; });

            if (merged === leaves.length) {
                for (var ll = 0; ll < leaves.length; ll++) {
                    var l = leaves[ll];
                    if (!returnObj.d3plus.merged) returnObj.d3plus.merged = [];
                    returnObj.d3plus.merged = returnObj.d3plus.merged.concat(l.d3plus.merged);
                    if (l.d3plus.text) returnObj.d3plus.text = l.d3plus.text;
                }
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create a reference sum for the 3 different "segment" variables.
            //--------------------------------------------------------------------------
            for (var s = 0; s < segments.length; s++) {

                var c = segments[s];
                var segmentAgg = vars.aggs && vars.aggs.value[key] ? vars.aggs.value[key] : "sum";

                if ("d3plus" in leaves[0] && c in leaves[0].d3plus) {
                    returnObj.d3plus[c] = d3.sum(leaves, function(d){
                        return d.d3plus[c];
                    });
                }
                else if (typeof segmentAgg === "function") {
                    returnObj.d3plus[c] = segmentAgg(leaves);
                }
                else {

                    returnObj.d3plus[c] = d3[segmentAgg](leaves, function(d) {

                        var a = c === "total" ? 1 : 0;
                        if (vars[c].value) {
                            a = fetchValue(vars, d, vars[c].value);
                            if (typeof a !== "number") a = a ? 1 : 0;
                        }
                        return a;

                    });

                }
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Aggregate all values detected in the data.
            //--------------------------------------------------------------------------
            for (var key in vars.data.keys) {

                if (key in returnObj.d3plus.data) {
                    returnObj[key] = returnObj.d3plus[key];
                }
                else {

                    var agg     = vars.aggs && vars.aggs.value[key] ? vars.aggs.value[key] : "sum",
                        aggType = typeof agg,
                        keyType = vars.data.keys[key],
                        idKey   = vars.id.nesting.indexOf(key) >= 0,
                        timeKey = "time" in vars && key === vars.time.value;

                    if (key in returnObj.d3plus.data) {
                        returnObj[key] = returnObj.d3plus[key];
                    }
                    else if (aggType === "function") {
                        returnObj[key] = vars.aggs.value[key](leaves);
                    }
                    else if (timeKey) {
                        returnObj[key] = parseDates(uniqueValues(leaves, key));
                    }
                    else if (vars.axes && vars.axes.discrete && vars[vars.axes.discrete].value === key) {
                        returnObj[key] = uniqueValues(leaves, key);
                    }
                    else if (keyType === "number" && aggType === "string" && !idKey) {
                        var vals = leaves.map(function(d){ return d[key]; });
                        vals = vals.filter(function(d){ return typeof d === keyType; });
                        if (vals.length) returnObj[key] = d3[agg](vals);
                    }
                    else {

                        var testVals = checkVal(leaves, key);
                        var keyValues = testVals.length === 1 ? testVals[0][key]
                            : uniqueValues(testVals, key);

                        if (testVals.length === 1) {
                            returnObj[key] = keyValues;
                        }
                        else if (keyValues && keyValues.length) {

                            if (!(keyValues instanceof Array)) {
                                keyValues = [keyValues];
                            }

                            if (idKey && vars.id.nesting.indexOf(key) > i) {
                                // if (idKey && vars.id.nesting.indexOf(key) > i && keyValues.length > 1) {
                                // if (nestingLevels.length == 1 && testVals.length > leaves.length) {
                                //   var newNesting = nestingLevels.concat(key);
                                //   testVals = dataNest(vars,testVals,newNesting);
                                // }
                                returnObj[key] = testVals;
                            }
                            else {

                                returnObj[key] = keyValues;

                            }

                        }
                        else if (idKey) {
                            var endPoint = vars.id.nesting.indexOf(key) - 1;
                            if (endPoint >= i && (!("endPoint" in returnObj.d3plus) || returnObj.d3plus.endPoint > i)) {
                                returnObj.d3plus.endPoint = i;
                            }
                        }

                    }

                }

                if (key in returnObj && returnObj[key] instanceof Array && returnObj[key].length === 1) {
                    returnObj[key] = returnObj[key][0];
                }

            }

            for (var lll = 0; lll < nestingLevels.length; lll++) {
                var level = nestingLevels[lll];
                if (!(level in returnObj)) {
                    returnObj[level] = fetchValue(vars, leaves[0], level);
                }
            }

            groupedData.push(returnObj);

            return returnObj;

        });

        var find_keys = function(obj,depth,keys) {
            if (obj.children) {
                if (vars.data.keys[nestingLevels[depth]] == "number") {
                    obj.key = parseFloat(obj.key);
                }
                keys[nestingLevels[depth]] = obj.key;
                delete obj.key;
                for ( var k in keys ) {
                    obj[k] = keys[k];
                }
                depth++;
                obj.children.forEach(function(c){
                    find_keys(c,depth,keys);
                });
            }
        };

        nestedData = nestedData
            .entries(flatData)
            .map(rename_key_value)
            .map(function(obj){
                find_keys(obj,0,{});
                return obj;
            });

        return groupedData;

    };

    var checkVal = function(leaves, key) {

        var returnVals = [];

        function run(obj) {
            if (obj instanceof Array) {
                obj.forEach(run);
            }
            else if (validObject(obj) && key in obj) {
                if (obj[key] instanceof Array) {
                    obj[key].forEach(run);
                }
                else {
                    returnVals.push(obj);
                }
            }
        }

        run(leaves);

        return returnVals;

    };

    var parseDates = function(dateArray) {

        var dates = [];

        function checkDate(arr) {

            for (var i = 0; i < arr.length; i++) {
                var d = arr[i];
                if (d) {
                    if (d.constructor === Array) {
                        checkDate(d);
                    }
                    else {
                        dates.push(d);
                    }
                    // if (d.constructor === Date) dates.push(d);
                    // else if (d.constructor === Array) {
                    //   checkDate(d);
                    // }
                    // else {
                    //   d = new Date(d.toString());
                    //   if (d !== "Invalid Date") {
                    //     d.setTime( d.getTime() + d.getTimezoneOffset() * 60 * 1000 );
                    //     dates.push(d);
                    //   }
                    // }
                }
            }

        }

        checkDate(dateArray);

        return uniqueValues(dates);

    };

    var rename_key_value = function(obj) {
        if (obj.values && obj.values.length) {
            obj.children = obj.values.map(function(obj) {
                return rename_key_value(obj);
            });
            delete obj.values;
            return obj;
        }
        else if(obj.values) {
            return obj.values;
        }
        else {
            return obj;
        }
    };

    module.exports = dataNest;

},{"../../object/validate.coffee":174,"../../util/uniques.coffee":212,"../fetch/value.coffee":69}],63:[function(require,module,exports){
    var arraySort = require("../../array/sort.coffee"),
        dataNest   = require("./nest.js"),
        fetchValue = require("../fetch/value.coffee"),
        fetchColor = require("../fetch/color.coffee"),
        fetchText  = require("../fetch/text.js");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Merges data underneath the size threshold
//-------------------------------------------------------------------
    module.exports = function( vars , rawData , split ) {

        var threshold;
        if ( vars.size.threshold.value === false ) {
            threshold = 0;
        }
        else if (typeof vars.size.threshold.value === "number") {
            threshold = vars.size.threshold.value;
        }
        else if (typeof vars.size.threshold.value === "function") {
            threshold = vars.size.threshold.value(vars);
        }
        else if (typeof vars.types[vars.type.value].threshold === "number") {
            threshold = vars.types[vars.type.value].threshold;
        }
        else if (typeof vars.types[vars.type.value].threshold === "function") {
            threshold = vars.types[vars.type.value].threshold(vars);
        }
        else {
            threshold = 0.02;
        }

        if (typeof threshold == "number" && threshold > 0) {

            var largeEnough = [],
                cutoff = vars.depth.value === 0 ? 0 : {},
                removed = [],
                parents = [],
                labelException = [],
                largest = {};

            var nest = d3.nest();

            if (split) {
                nest
                    .key(function(d){
                        return fetchValue(vars, d, split);
                    });
            }

            nest
                .rollup(function(leaves){
                    var total = leaves.length;
                    if (vars.aggs.value[vars.size.value]) {
                        if (typeof vars.aggs.value[vars.size.value] == "function") {
                            total = vars.aggs.value[vars.size.value](leaves);
                        }
                        else if (typeof vars.aggs.value[vars.size.value] == "string") {
                            total = d3[vars.aggs.value[vars.size.value]](leaves,function(l){
                                return fetchValue(vars,l,vars.size.value);
                            });
                        }
                    }
                    else {
                        total = d3.sum(leaves,function(l){
                            return fetchValue(vars,l,vars.size.value);
                        });
                    }
                    var x = split ? fetchValue(vars,leaves[0],split) : "all";
                    largest[x] = total;
                    return total;
                })
                .entries(rawData);

            rawData.forEach(function(d){
                var id = fetchValue(vars, d, vars.id.value),
                    val = fetchValue(vars, d, vars.size.value),
                    x = split ? fetchValue(vars, d, split) : "all",
                    allowed = val/largest[x] >= threshold;

                if (allowed && largeEnough.indexOf(id) < 0) {
                    largeEnough.push(id);
                    if (vars.depth.value) {
                        var p = fetchValue(vars, d, vars.id.nesting[vars.depth.value-1]);
                        if (parents.indexOf(p) < 0) {
                            parents.push(p);
                        }
                    }
                }

            });

            var filteredData = rawData.filter(function(d){

                var id = fetchValue(vars, d, vars.id.value),
                    allowed = largeEnough.indexOf(id) >= 0;

                var p = vars.depth.value ?
                    fetchValue(vars, d, vars.id.nesting[vars.depth.value-1]) :
                    null;

                if (p !== null && parents.indexOf(p) < 0 && labelException.indexOf(p) < 0) {
                    labelException.push(p);
                }

                if (!allowed) {
                    var val = fetchValue(vars, d, vars.size.value);
                    if (val > 0) {
                        if (vars.depth.value === 0) {
                            if (val > cutoff) cutoff = val;
                        }
                        else {
                            if (!(p in cutoff)) cutoff[p] = 0;
                            if (val > cutoff[p]) cutoff[p] = val;
                        }
                        removed.push(d);
                    }
                }
                return allowed;

            });

            if ( removed.length > 1 ) {

                removed = arraySort( removed , vars.size.value , "desc" , [] , vars );

                var levels = vars.id.nesting.slice(0,vars.depth.value);
                if (vars.types[vars.type.value].requirements.indexOf(vars.axes.discrete) >= 0) {
                    levels.push(vars[vars.axes.discrete].value);
                }
                var merged = dataNest(vars, removed, levels);

                merged.forEach(function(m){

                    var parent = vars.id.nesting[vars.depth.value-1];
                    var p_id = fetchValue(vars, m, parent);
                    children = parent ? removed.filter(function(r){
                        return fetchValue(vars, r, parent) === p_id;
                    }) : removed;

                    if (children.length > 1) {

                        vars.id.nesting.forEach(function(d,i){

                            if (vars.depth.value == i) {
                                var prev = m[d];
                                if ( typeof prev === "string" ) {
                                    m[d] = "d3plus_other_"+prev;
                                }
                                else {
                                    m[d] = "d3plus_other";
                                }
                            }
                            else if (i > vars.depth.value) {
                                delete m[d];
                            }
                        });

                        if (vars.color.value && vars.color.type === "string") {
                            if (vars.depth.value === 0) {
                                m[vars.color.value] = vars.color.missing;
                            }
                            else {
                                m[vars.color.value] = fetchValue(vars,p_id,vars.color.value,parent);
                            }
                        }

                        if (vars.icon.value) {
                            m[vars.icon.value] = fetchValue(vars,p_id,vars.icon.value,parent);
                        }

                        if (p_id) {
                            m.d3plus.depth = vars.depth.value;
                        }

                        var textLabel;
                        if (vars.depth.value === 0) {
                            textLabel = vars.format.value(vars.format.locale.value.ui.values, {"key": "threshold", "vars": vars});
                            textLabel += " < "+vars.format.value(cutoff, {"key": vars.size.value, "vars": vars});
                        }
                        else {
                            textLabel = fetchText(vars,m,vars.depth.value-1);
                            textLabel = textLabel.length ? textLabel[0].split(" < ")[0] : vars.format.value(vars.format.locale.value.ui.values, {"key": "threshold", "vars": vars});
                            if (p_id, labelException.indexOf(p_id) < 0) {
                                textLabel += " < "+vars.format.value(cutoff[p_id], {"key": vars.size.value, "vars": vars});
                            }
                        }
                        if (p_id, labelException.indexOf(p_id) < 0) {
                            textLabel += " ("+vars.format.value(threshold*100, {"key": "share", "vars": vars})+")";
                        }

                        m.d3plus.threshold = cutoff;
                        m.d3plus.merged = children;

                        if (vars.text.value) {
                            m[vars.text.value] = textLabel;
                        }
                        m.d3plus.text = textLabel;

                    }

                });

            }
            else {
                merged = removed;
            }

            return filteredData.concat(merged);

        }

        return rawData;

    };

},{"../../array/sort.coffee":36,"../fetch/color.coffee":65,"../fetch/text.js":68,"../fetch/value.coffee":69,"./nest.js":62}],64:[function(require,module,exports){
    var sizes;

    sizes = require("../../font/sizes.coffee");

    module.exports = function(vars, opts) {
        var f, format, func, getFormat, limit, locale, p, periods, pp, prev, render, small, step, style, time, total, vals, values;
        values = opts.values || vars.data.time.ticks;
        style = opts.style || {};
        limit = opts.limit || vars.width.value;
        time = {};
        periods = vars.data.time.periods;
        step = vars.data.time.stepType;
        total = vars.data.time.totalType;
        func = vars.data.time.functions;
        getFormat = vars.data.time.getFormat;
        locale = vars.format.locale.value.format;
        if (vars.time.format.value) {
            time.format = vars.data.time.format;
            time.values = values;
            time.sizes = sizes(values.map(function(v) {
                return time.format(v);
            }), style);
        } else {
            p = periods.indexOf(step);
            while (p <= periods.indexOf(total)) {
                vals = values.filter(function(t) {
                    var match, pp;
                    if (p === periods.indexOf(step)) {
                        return true;
                    }
                    match = true;
                    pp = p - 1;
                    if (p < 0) {
                        return true;
                    }
                    while (pp >= periods.indexOf(step)) {
                        if (!match) {
                            break;
                        }
                        match = !func[pp](t);
                        pp--;
                    }
                    return match;
                });
                if (periods[p] === total) {
                    format = d3.locale(locale).timeFormat(getFormat(periods[p], total));
                } else {
                    pp = p;
                    format = [];
                    while (pp <= periods.indexOf(total)) {
                        prev = pp - 1 < periods.indexOf(step) ? pp : pp - 1;
                        prev = periods[prev];
                        small = periods[pp] === prev && step !== total;
                        f = getFormat(prev, periods[pp], small);
                        format.push([f, func[pp]]);
                        pp++;
                    }
                    format[format.length - 1][1] = function() {
                        return true;
                    };
                    format = d3.locale(locale).timeFormat.multi(format);
                }
                render = sizes(vals.map(function(v) {
                    return format(v);
                }), style);
                if (d3.sum(render, function(r) {
                        return r.width;
                    }) < limit || p === periods.indexOf(total)) {
                    time.format = format;
                    time.values = vals;
                    time.sizes = render;
                    break;
                }
                p++;
            }
        }
        return time;
    };


},{"../../font/sizes.coffee":103}],65:[function(require,module,exports){
    var fetchValue, getColor, getRandom, randomColor, uniques, validColor, validObject;

    fetchValue = require("./value.coffee");

    randomColor = require("../../color/random.coffee");

    validColor = require("../../color/validate.coffee");

    validObject = require("../../object/validate.coffee");

    uniques = require("../../util/uniques.coffee");

    module.exports = function(vars, id, level) {
        var color, colorLevel, colors, i, obj, value;
        obj = validObject(id);
        if (obj && "d3plus" in id && "color" in id.d3plus) {
            return id.d3plus.color;
        }
        if (level === void 0) {
            level = vars.id.value;
        }
        if (typeof level === "number") {
            level = vars.id.nesting[level];
        }
        if (!vars.color.value) {
            return getRandom(vars, id, level);
        } else {
            colors = [];
            i = vars.id.nesting.indexOf(level);
            while (i >= 0) {
                colorLevel = vars.id.nesting[i];
                value = uniques(id, vars.color.value, fetchValue, vars, colorLevel);
                if (value.length === 1) {
                    value = value[0];
                }
                if (!(value instanceof Array) && value !== void 0 && value !== null) {
                    color = getColor(vars, id, value, level);
                    if (colors.indexOf(color) < 0) {
                        colors.push(color);
                    }
                    break;
                }
                i--;
            }
            if (colors.length === 1) {
                return colors[0];
            } else {
                return vars.color.missing;
            }
        }
    };

    getColor = function(vars, id, color, level) {
        if (!color) {
            if (vars.color.value && typeof vars.color.valueScale === "function") {
                return vars.color.valueScale(0);
            }
            return getRandom(vars, id, level);
        } else if (!vars.color.valueScale) {
            if (validColor(color)) {
                return color;
            } else {
                return getRandom(vars, color, level);
            }
        } else {
            return vars.color.valueScale(color);
        }
    };

    getRandom = function(vars, c, level) {
        if (validObject(c)) {
            c = fetchValue(vars, c, level);
        }
        if (c instanceof Array) {
            c = c[0];
        }
        return randomColor(c, vars.color.scale.value);
    };


},{"../../color/random.coffee":49,"../../color/validate.coffee":53,"../../object/validate.coffee":174,"../../util/uniques.coffee":212,"./value.coffee":69}],66:[function(require,module,exports){
    var dataFilter = require("../data/filter.js"),
        dataNest     = require("../data/nest.js"),
        print        = require("../console/print.coffee"),
        stringFormat = require("../../string/format.js"),
        stringList   = require("../../string/list.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Fetches specific years of data
//-------------------------------------------------------------------
    module.exports = function(vars, years, depth) {

        if (!vars.data.value) return [];

        if (depth === undefined) depth = vars.depth.value;
        var nestLevel = vars.id.nesting[depth];

        if (years && !(years instanceof Array)) years = [years];

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If "years" have not been requested, determine the years using .time()
        // solo and mute
        //----------------------------------------------------------------------------
        if (!years && "time" in vars) {

            years = [];

            var key = vars.time.solo.value.length ? "solo" : "mute",
                filterList = vars.time[key].value;

            if (filterList.length) {

                years = [];
                for (var yi = 0; yi < filterList.length; yi++) {
                    var y = filterList[yi];

                    if (typeof y === "function") {
                        for (var ti = 0; ti < vars.data.time.values.length; ti++) {
                            var ms = vars.data.time.values[ti].getTime();
                            if (y(ms)) years.push(ms);
                        }
                    }
                    else if (y.constructor === Date) {
                        years.push(new Date(y).getTime());
                    }
                    else {
                        y += "";
                        if (y.length === 4 && parseInt(y)+"" === y) y = y + "/01/01";
                        var d = new Date(y);
                        if (d !== "Invalid Date") {
                            // d.setTime(d.getTime() + d.getTimezoneOffset() * 60 * 1000);
                            years.push(d.getTime());
                        }
                    }

                }

                if ( key === "mute" ) {
                    years = vars.data.time.values.filter(function( t ){
                        return years.indexOf(t.getTime()) < 0;
                    });
                }

            }
            else years.push("all");

        }
        else {
            years = ["all"];
        }

        if (years.indexOf("all") >= 0 && vars.data.time.values.length) {
            years = vars.data.time.values.slice(0);
            for (var i = 0; i < years.length; i++) {
                years[i] = years[i].getTime();
            }
        }

        var cacheID = [ vars.type.value , nestLevel , depth ]
                .concat( vars.data.filters )
                .concat( years ),
            filter  = vars.data.solo.length ? "solo" : "mute",
            cacheKeys = d3.keys(vars.data.cache),
            vizFilter = vars.types[vars.type.value].filter || undefined;

        if ( vars.data[filter].length ) {
            for (var di = 0; di < vars.data[filter].length; di++) {
                var f = vars.data[filter][di];
                var vals = vars[f][filter].value.slice(0);
                vals.unshift(f);
                vals.unshift(filter);
                cacheID = cacheID.concat(vals);
            }
        }

        if (vars.axes && vars.axes.discrete) cacheID.push(vars.axes.discrete);

        cacheID = cacheID.join("_");
        vars.data.cacheID = cacheID;

        var match = false;

        for (var c = 0 ; c < cacheKeys.length ; c++) {

            var matchKey = cacheKeys[c].split("_").slice(1).join("_");

            if ( matchKey === cacheID ) {
                cacheID = new Date().getTime() + "_" + cacheID;
                vars.data.cache[cacheID] = vars.data.cache[cacheKeys[c]];
                delete vars.data.cache[cacheKeys[c]];
                break;
            }

        }

        var returnData;

        if ( vars.data.cache[cacheID] ) {

            if ( vars.dev.value ) print.comment("data already cached");

            returnData = vars.data.cache[cacheID].data;
            if ("nodes" in vars) {
                vars.nodes.restricted = vars.data.cache[cacheID].nodes;
                vars.edges.restricted = vars.data.cache[cacheID].edges;
            }

            if ( typeof vizFilter === "function" ) {
                returnData = vizFilter( vars ,  returnData );
            }

            return returnData;

        }
        else {

            var missing = [];
            returnData = [];

            if (vars.data.value && vars.data.value.length) {

                for (var yz = 0; yz < years.length; yz++) {
                    var year = years[yz];
                    if (vars.data.nested[year]) {
                        returnData = returnData.concat(vars.data.nested[year][nestLevel]);
                    }
                    else {
                        missing.push(year);
                    }
                }

            }

            if (returnData.length === 0 && missing.length && !vars.error.internal) {

                if (missing.length > 1) {
                    missing = d3.extent(missing);
                }

                missing = missing.map(function(m){
                    return vars.data.time.format(new Date(m));
                });
                missing = missing.join(" - ");

                var str = vars.format.locale.value.error.dataYear,
                    and = vars.format.locale.value.ui.and;
                missing = stringList(missing,and);
                vars.error.internal = stringFormat(str,missing);
                vars.time.missing = true;

            }
            else {

                if (vars.time) vars.time.missing = false;

                if ( years.length > 1 ) {

                    var separated = false;
                    ["x", "y", "x2", "y2"].forEach(function(a){
                        if (vars[a].value === vars.time.value &&
                            vars[a].scale.value === "discrete" ) {
                            separated = true;
                        }
                    });

                    if (!separated) {
                        var nested = vars.id.nesting.slice(0,depth+1);
                        returnData = dataNest(vars, returnData, nested);
                    }

                }

                if (!returnData) {
                    returnData = [];
                }
                else {
                    returnData = dataFilter(vars, returnData);
                }

                if ( cacheKeys.length === 20 ) {
                    cacheKeys.sort();
                    delete vars.data.cache[cacheKeys[0]];
                }

                cacheID = new Date().getTime() + "_" + cacheID;
                vars.data.cache[cacheID] = {"data": returnData};
                if ("nodes" in vars) {
                    vars.data.cache[cacheID].nodes = vars.nodes.restricted;
                    vars.data.cache[cacheID].edges = vars.edges.restricted;
                }

                if ( typeof vizFilter === "function" ) {
                    returnData = vizFilter( vars , returnData );
                }

                if ( vars.dev.value ) print.comment("storing data in cache");

            }

            return returnData;

        }

    };

},{"../../string/format.js":175,"../../string/list.coffee":176,"../console/print.coffee":54,"../data/filter.js":57,"../data/nest.js":62}],67:[function(require,module,exports){
    var fetchColor, fetchText, fetchValue;

    fetchValue = require("./value.coffee");

    fetchColor = require("./color.coffee");

    fetchText = require("./text.js");

    module.exports = function(vars, d, keys, colors, depth) {
        var agg, i, key, len, obj, value;
        if (!(keys instanceof Array)) {
            keys = [keys];
        }
        if (!(colors instanceof Array)) {
            colors = [colors];
        }
        if (vars) {
            if (depth === void 0) {
                depth = vars.id.value;
            } else if (typeof depth !== "number") {
                depth = vars.id.nesting.indexOf(depth);
            }
        }
        obj = {};
        for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            if (vars) {
                if (colors.indexOf(key) >= 0) {
                    value = fetchColor(vars, d, depth);
                } else if (key === vars.text.value) {
                    value = fetchText(vars, d, depth);
                } else if (d3.keys(d).length === 3 && d["d3plus"] && d["key"] && d["values"]) {
                    value = fetchValue(vars, d.values.map(function(dd) {
                        return dd.d3plus;
                    }), key, depth);
                } else {
                    value = fetchValue(vars, d, key, depth);
                }
            } else {
                value = d[key];
            }
            if ([vars.data.keys[key], vars.attrs.keys[key]].indexOf("number") >= 0) {
                agg = vars.order.agg.value || vars.aggs.value[key] || "sum";
                if (!(value instanceof Array)) {
                    value = [value];
                }
                value = d3[agg](value);
            } else {
                if (value instanceof Array) {
                    value = value[0];
                }
                value = typeof value === "string" ? value.toLowerCase() : value;
            }
            obj[key] = value;
        }
        return obj;
    };


},{"./color.coffee":65,"./text.js":68,"./value.coffee":69}],68:[function(require,module,exports){
    var fetchValue = require("./value.coffee"),
        validObject = require("../../object/validate.coffee"),
        uniques     = require("../../util/uniques.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Get array of available text values
//------------------------------------------------------------------------------
    module.exports = function(vars, obj, depth) {

        if (typeof depth !== "number") depth = vars.depth.value;

        var key = vars.id.nesting[depth], textKeys;

        if ( vars.text.nesting && validObject(vars.text.nesting) ) {
            if ( vars.text.nesting[key] ) {
                textKeys = vars.text.nesting[key];
            }
            else {
                textKeys = vars.text.value;
            }
        }
        else {
            textKeys = [];
            if (vars.text.value && depth === vars.depth.value) textKeys.push(vars.text.value);
            textKeys.push(key);
        }

        if ( !(textKeys instanceof Array) ) {
            textKeys = [ textKeys ];
        }

        var names = [];

        if (validObject(obj) && "d3plus" in obj && obj.d3plus.text) {
            names.push(obj.d3plus.text.toString());
            names.push(vars.format.value(obj.d3plus.text.toString(), {"vars": vars, "data": obj}));
        }
        else {

            var formatObj = validObject(obj) ? obj : undefined;

            if (formatObj && obj[vars.id.value] instanceof Array) {
                obj = obj[vars.id.value];
            }
            else if (!(obj instanceof Array)) {
                obj = [obj];
            }

            textKeys.forEach(function( t ){

                var name = uniques(obj, t, fetchValue, vars, key);

                if ( name.length ) {
                    if (name.length > 1) {
                        name = name.filter(function(n){
                            return (n instanceof Array) || (typeof n === "string" && n.indexOf(" < ") < 0);
                        });
                    }
                    name = name.map(function(n){
                        if (n instanceof Array) {
                            n = n.filter(function(nn){ return nn; });
                            return n.map(function(nn){
                                return vars.format.value(nn.toString(), {"vars": vars, "data": formatObj, "key": t});
                            });
                        }
                        else if (n) {
                            return vars.format.value(n.toString(), {"vars": vars, "data": formatObj, "key": t});
                        }
                    });
                    if (name.length === 1) name = name[0];
                    names.push(name);
                }

            });

        }

        return names;

    };

},{"../../object/validate.coffee":174,"../../util/uniques.coffee":212,"./value.coffee":69}],69:[function(require,module,exports){
    var cacheInit, checkAttrs, checkData, fetch, fetchArray, filterArray, find, uniqueValues, validObject, valueParse;

    validObject = require("../../object/validate.coffee");

    uniqueValues = require("../../util/uniques.coffee");

    find = function(vars, node, variable, depth) {
        var cache, nodeObject, returned, val;
        nodeObject = validObject(node);
        if (typeof variable === "function" && nodeObject) {
            return variable(node, vars);
        }
        if (nodeObject) {
            if (variable in node) {
                return node[variable];
            }
            cache = vars.data.cacheID + "_" + depth;
            cacheInit(node, cache, vars);
            if (variable in node.d3plus.data[cache]) {
                return node.d3plus.data[cache][variable];
            }
            if (depth in node) {
                node = node[depth];
            } else if (vars.id.value in node) {
                node = node[vars.id.value];
                if (depth !== variable) {
                    returned = checkData(vars, node, depth, vars.id.value);
                }
                if (returned === null || returned === void 0) {
                    returned = checkAttrs(vars, node, depth, vars.id.value);
                }
                if (returned === null || returned === void 0) {
                    return null;
                } else if (depth === variable) {
                    return returned;
                }
                node = returned;
            } else {
                return null;
            }
        }
        if (node instanceof Array && !validObject(node[0])) {
            node = uniqueValues(node);
        }
        if (node instanceof Array && validObject(node[0])) {
            val = uniqueValues(node, variable);
            if (val.length) {
                return val;
            }
        }
        val = checkData(vars, node, variable, depth);
        if (val) {
            return val;
        }
        val = checkAttrs(vars, node, variable, depth);
        return val;
    };

    checkData = function(vars, node, variable, depth) {
        var val;
        if (vars.data.viz instanceof Array && variable in vars.data.keys) {
            val = uniqueValues(filterArray(vars.data.viz, node, depth), variable);
        }
        if (val && val.length) {
            return val;
        } else {
            return null;
        }
    };

    checkAttrs = function(vars, node, variable, depth) {
        var attrList, n, val, vals;
        if ("attrs" in vars && vars.attrs.value && variable in vars.attrs.keys) {
            if (validObject(vars.attrs.value) && depth in vars.attrs.value) {
                attrList = vars.attrs.value[depth];
            } else {
                attrList = vars.attrs.value;
            }
            if (attrList instanceof Array) {
                val = uniqueValues(filterArray(attrList, node, depth), variable);
                if (val.length) {
                    return val;
                }
            } else if (node instanceof Array) {
                attrList = [
                    (function() {
                        var j, len, results;
                        if (n in attrList) {
                            results = [];
                            for (j = 0, len = node.length; j < len; j++) {
                                n = node[j];
                                results.push(attrList[n]);
                            }
                            return results;
                        }
                    })()
                ];
                if (attrList.length) {
                    vals = uniqueValues(attrList, variable);
                    if (vals.length) {
                        return vals;
                    }
                }
            } else if (node in attrList) {
                return attrList[node][variable];
            }
        }
        return null;
    };

    filterArray = function(arr, node, depth) {
        if (node instanceof Array) {
            return arr.filter(function(d) {
                return node.indexOf(d[depth]) >= 0;
            });
        } else {
            return arr.filter(function(d) {
                return d[depth] === node;
            });
        }
    };

    cacheInit = function(node, cache, vars) {
        if (!("d3plus" in node)) {
            node.d3plus = {};
        }
        if (!("data" in node.d3plus)) {
            node.d3plus.data = {};
        }
        if (vars.data.changed || (vars.attrs && vars.attrs.changed) || !(cache in node.d3plus.data)) {
            node.d3plus.data[cache] = {};
        }
        return node;
    };

    valueParse = function(vars, node, depth, variable, val) {
        var cache, d, i, j, len, timeVar, v;
        if (val === null) {
            return val;
        }
        timeVar = "time" in vars && vars.time.value === variable;
        if (!(val instanceof Array)) {
            val = [val];
        }
        for (i = j = 0, len = val.length; j < len; i = ++j) {
            v = val[i];
            if (timeVar && v !== null && v.constructor !== Date) {
                v = v + "";
                if (v.length === 4 && parseInt(v) + "" === v) {
                    v += "/01/01";
                }
                d = new Date(v);
                if (d !== "Invalid Date") {
                    val[i] = d;
                }
            }
        }
        if (val.length === 1) {
            val = val[0];
        }
        if (val !== null && validObject(node) && typeof variable === "string" && !(variable in node)) {
            cache = vars.data.cacheID + "_" + depth;
            node.d3plus.data[cache][variable] = val;
        }
        return val;
    };

    fetchArray = function(vars, arr, variable, depth) {
        var item, j, len, v, val;
        val = [];
        for (j = 0, len = arr.length; j < len; j++) {
            item = arr[j];
            if (validObject(item)) {
                v = find(vars, item, variable, depth);
                val.push(valueParse(vars, item, depth, variable, v));
            } else {
                val.push(item);
            }
        }
        if (typeof val[0] !== "number") {
            val = uniqueValues(val);
        }
        if (val.length === 1) {
            return val[0];
        } else {
            return val;
        }
    };

    fetch = function(vars, node, variable, depth) {
        var nodeObject, val;
        if (!variable) {
            return null;
        }
        if (typeof variable === "number") {
            return variable;
        }
        nodeObject = validObject(node);
        if (!depth) {
            depth = vars.id.value;
        }
        if (nodeObject && node.values instanceof Array) {
            val = fetchArray(vars, node.values, variable, depth);
        } else if (nodeObject && node[variable] instanceof Array) {
            val = fetchArray(vars, node[variable], variable, depth);
        } else if (node instanceof Array) {
            val = fetchArray(vars, node, variable, depth);
        } else {
            val = find(vars, node, variable, depth);
            val = valueParse(vars, node, depth, variable, val);
        }
        return val;
    };

    module.exports = fetch;


},{"../../object/validate.coffee":174,"../../util/uniques.coffee":212}],70:[function(require,module,exports){
    module.exports = function(type) {
        var attrs, styles, tester;
        if (["div", "svg"].indexOf(type) < 0) {
            type = "div";
        }
        styles = {
            position: "absolute",
            left: "-9999px",
            top: "-9999px",
            visibility: "hidden",
            display: "block"
        };
        attrs = type === "div" ? {} : {
            position: "absolute"
        };
        tester = d3.select("body").selectAll(type + ".d3plus_tester").data([0]);
        tester.enter().append(type).attr("class", "d3plus_tester").style(styles).attr(attrs);
        return tester;
    };


},{}],71:[function(require,module,exports){
    module.exports = {
        dev: {
            accepted: "{0} is not an accepted value for {1}, please use one of the following: {2}.",
            deprecated: "the {0} method has been removed, please update your code to use {1}.",
            noChange: "{0} was not updated because it did not change.",
            noContainer: "cannot find a container on the page matching {0}.",
            of: "of",
            oldStyle: "style properties for {0} have now been embedded directly into .{1}().",
            sameEdge: "edges cannot link to themselves. automatically removing self-referencing edge {0}.",
            set: "{0} has been set.",
            setLong: "{0} has been set to {1}.",
            setContainer: "please define a container div using .container()"
        },
        error: {
            accepted: "{0} is not an accepted {1} for {2} visualizations, please use one of the following: {3}.",
            connections: "no connections available for {0}.",
            data: "no data available",
            dataYear: "no data available for {0}.",
            lib: "{0} visualizations require loading the {1} library.",
            libs: "{0} visualizations require loading the following libraries: {1}.",
            method: "{0} visualizations require setting the {1} method.",
            methods: "{0} visualizations require setting the following methods: {1}."
        },
        format: {
            decimal: ".",
            thousands: ",",
            grouping: [3],
            currency: ["$", ""],
            dateTime: "%A, %B %-d, %Y %X",
            date: "%-m/%-d/%Y",
            time: "%I:%M:%S %p",
            periods: ["AM", "PM"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        },
        lowercase: ["a", "an", "and", "as", "at", "but", "by", "for", "from", "if", "in", "into", "near", "nor", "of", "on", "onto", "or", "per", "that", "the", "to", "with", "via", "vs", "vs."],
        message: {
            data: "analyzing data",
            draw: "drawing visualization",
            initializing: "initializing {0}",
            loading: "loading data",
            tooltipReset: "resetting tooltips",
            ui: "updating ui"
        },
        method: {
            active: "active segments",
            color: "color",
            depth: "depth",
            dev: "verbose",
            focus: "focus",
            icon: "icon",
            id: "id",
            height: "height",
            labels: "labels",
            legend: "legend",
            margin: "margin",
            messages: "status messages",
            mode: "mode",
            mute: "hide",
            order: "order",
            search: "search",
            shape: "shape",
            size: "size",
            solo: "isolate",
            style: "style",
            temp: "temporary segments",
            text: "text",
            time: "time",
            timeline: "timeline",
            total: "total segments",
            type: "type",
            width: "width",
            x: "x axis",
            y: "y axis",
            zoom: "zoom"
        },
        time: ["date", "day", "month", "time", "year"],
        timeFormat: {
            FullYear: "%Y",
            Month: "%B",
            MonthSmall: "%b",
            Date: "%A %-d",
            DateSmall: "%-d",
            Hours: "%I %p",
            Minutes: "%I:%M",
            Seconds: "%Ss",
            Milliseconds: "%Lms",
            "FullYear-Month": "%b %Y",
            "FullYear-Date": "%-m/%-d/%Y",
            "Month-Date": "%b %-d",
            "Hours-Minutes": "%I:%M %p",
            "Hours-Seconds": "%I:%M:%S %p",
            "Hours-Milliseconds": "%H:%M:%S.%L",
            "Minutes-Seconds": "%I:%M:%S %p",
            "Minutes-Milliseconds": "%H:%M:%S.%L",
            "Seconds-Milliseconds": "%H:%M:%S.%L"
        },
        ui: {
            and: "and",
            back: "back",
            collapse: "click to collapse",
            error: "error",
            expand: "click to expand",
            including: "including",
            loading: "loading...",
            more: "{0} more",
            moreInfo: "click for more info",
            or: "or",
            noResults: "no results matching {0}.",
            primary: "primary connections",
            share: "share",
            total: "total",
            values: "values"
        },
        uppercase: ["CEO", "CEOs", "CFO", "CFOs", "CNC", "COO", "COOs", "CPU", "CPUs", "GDP", "HVAC", "ID", "IT", "R&D", "TV", "UI"],
        visualization: {
            bar: "Bar Chart",
            box: "Box Plot",
            bubbles: "Bubbles",
            chart: "Chart",
            geo_map: "Geo Map",
            line: "Line Plot",
            network: "Network",
            paths: "Paths",
            pie: "Pie Chart",
            rings: "Rings",
            scatter: "Scatter Plot",
            stacked: "Stacked Area",
            table: "Table",
            tree_map: "Tree Map"
        }
    };


},{}],72:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": ".",
            "grouping": [3],
            "currency": ["", " €"],
            "dateTime": "%A, %e de %B de %Y, %X",
            "date": "%d/%m/%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"],
            "days": ["domingo", "lunes", "martes", "miércoles", "jueves", "viernes", "sábado"],
            "shortDays": ["dom", "lun", "mar", "mié", "jue", "vie", "sáb"],
            "months": ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
            "shortMonths": ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"]
        },
        "dev": {
            "accepted": "{0} no es un valor aceptado para {1}, por favor utilice uno de los siguientes: {2}.",
            "deprecated": "el método {0} ha sido eliminado, por favor, actualiza tu código para utilizar {1}.",
            "noChange": "{0} no se actualiza porque no cambió.",
            "noContainer": "no se puede encontrar un contenedor en la página correspondiente a {0}.",
            "of": "de",
            "oldStyle": "propiedades de estilo para {0} ahora se han incorporado directamente en. {1} ().",
            "sameEdge": "los vínculos no se pueden enlazar con si mismos. eliminando automáticamente el vínculo {0} que se autorreferencia.",
            "set": "{0} se ha establecido.",
            "setLong": "{0} ha sido establecido a {1}.",
            "setContainer": "defina un div contenedor utilizando .container ()"
        },
        "error": {
            "accepted": "{0} no es un {1} aceptado para visualizaciones de {2}, por favor utilice uno de los siguientes: {3}.",
            "connections": "no hay conexiones disponibles para {0}.",
            "data": "No hay datos disponibles",
            "dataYear": "no hay datos disponibles para {0}.",
            "lib": "{0} visualizaciones requieren cargar las siguientes librerías: {1}.",
            "libs": "{0} visualizaciones requieren cargar las siguientes librerías: {1}.",
            "method": "{0} visualizaciones requieren establecer el ​​método {1}.",
            "methods": "{0} visualizaciones requieren establecer los siguientes métodos: {1}."
        },
        "lowercase": [
            "una",
            "y",
            "en",
            "pero",
            "en",
            "de",
            "o",
            "el",
            "la",
            "los",
            "las",
            "para",
            "a",
            "con"
        ],
        "method": {
            "active": "segmentos activos",
            "color": "color",
            "depth": "profundidad",
            "dev": "detallado",
            "focus": "foco",
            "icon": "ícono",
            "id": "id",
            "height": "alto",
            "labels": "rótulo",
            "legend": "leyenda",
            "margin": "margen",
            "messages": "mensajes de estado",
            "mute": "ocultar",
            "order": "orden",
            "search": "búsqueda",
            "shape": "forma",
            "size": "tamaño",
            "solo": "aislar",
            "style": "estilo",
            "temp": "segmentos temporales",
            "text": "texto",
            "time": "tiempo",
            "timeline": "línea de tiempo",
            "total": "segmentos totales",
            "type": "tipo",
            "width": "anchura",
            "x": "eje x",
            "y": "eje Y",
            "zoom": "#ERROR!",
            "mode": "modo"
        },
        "time": [
            "fecha",
            "día",
            "mes",
            "hora",
            "año"
        ],
        "visualization": {
            "bubbles": "Burbujas",
            "chart": "Tabla",
            "geo_map": "Mapa Geo",
            "line": "Línea Solar",
            "network": "Red",
            "rings": "Anillos",
            "scatter": "Gráfico De Dispersión",
            "stacked": "Área Apilada",
            "tree_map": "Mapa de Árbol",
            "bar": "Gráfico De Barras",
            "box": "Diagrama de Cajas",
            "paths": "Caminos",
            "pie": "Gráfico de Pastel",
            "table": "Tabla"
        },
        "ui": {
            "and": "y",
            "back": "atrás",
            "collapse": "click para cerrar",
            "error": "error",
            "expand": "haga clic para ampliar",
            "loading": "Cargando ...",
            "more": "{0} más",
            "moreInfo": "clic para más información",
            "noResults": "no se encontraron resultados para {0}.",
            "primary": "relaciones principales",
            "share": "porcentaje",
            "total": "total",
            "values": "valores",
            "including": "Incluyendo",
            "or": "o"
        },
        "message": {
            "data": "analizando los datos",
            "draw": "visualizando",
            "initializing": "inicializando {0}",
            "loading": "cargando datos",
            "tooltipReset": "restableciendo las descripciones emergentes",
            "ui": "actualizando la interfaz de usuario"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "PIB",
            "HVAC",
            "ID",
            "TI",
            "I&D",
            "TV",
            "UI"
        ]
    }

},{}],73:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": ".",
            "grouping": [3],
            "currency": ["", " €"],
            "dateTime": "%A, le %e %B %Y, %X",
            "date": "%d/%m/%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"], // unused
            "days": ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
            "shortDays": ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
            "months": ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
            "shortMonths": ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
        },
        "dev": {
            "accepted": "{0} n'est pas une option valide pour {1}, les valeurs possibles sont: {2}.",
            "deprecated": "{0} a été éliminé de la version courante, mettez à jour votre code source avec {1}.",
            "noChange": "{0} n'a pas été mis à jour car inchangé.",
            "noContainer": "impossible de trouver un contenant correspondant à {0}.",
            "of": "de",
            "oldStyle": "les propriétés de {0} ont été imbriquées dans .{1}().",
            "sameEdge": "un arc ne peut pas boucler sur lui même. L'auto-référence est automatiquement éliminée {0}.",
            "set": "{0} a été mis à jour.",
            "setLong": "{0} a été mis à jour à {1}.",
            "setContainer": "merci de choisir un div qui utilise .container()"
        },
        "error": {
            "accepted": "{0} n'est pas correct {1} pour {2} visualisations, merci d'utilisez une des options suivantes: {3}.",
            "connections": "Pas de connections disponibles pour {0}.",
            "data": "Pas de données disponibles",
            "dataYear": "Pas de données disponibles pour {0}.",
            "lib": "La visualisation de {0} nécessite le chargement de la librairie {1}.",
            "libs": "La visualisation de {0} nécessite le chargement des librairies {1}.",
            "method": "La visualisation du {0} exige la définition de {1}.",
            "methods": "La visualisation du {0} exige les définitions de {1}."
        },
        "lowercase": [
            "un",
            "une",
            "de",
            "des",
            "et",
            "mais",
            "les",
            "ou",
            "pour",
            "avec",
            "comme",
            "par",
            "vers",
            "si",
            "dans",
            "près",
            "ni",
            "dessus",
            "que",
            "le",
            "la",
            "via",
            "sinon",
            "alors"
        ],
        "method": {
            "active": "segments actifs",
            "color": "couleur",
            "depth": "profondeur",
            "dev": "verbeux",
            "focus": "focus",
            "icon": "ícone",
            "id": "id",
            "height": "hauteur",
            "labels": "labels",
            "legend": "légende",
            "margin": "marge",
            "messages": "messages",
            "mute": "cacher",
            "order": "ordre",
            "search": "recherche",
            "shape": "format",
            "size": "taille",
            "solo": "isoler",
            "style": "style",
            "temp": "segments temporaires",
            "text": "texte",
            "time": "temps",
            "timeline": "ligne temporelle",
            "total": "segments totaux",
            "type": "type",
            "width": "largeur",
            "x": "axe x",
            "y": "axe y",
            "zoom": "zoom",
            "mode": "mode"
        },
        "time": [
            "année",
            "date",
            "jour",
            "heure",
            "mois"
        ],
        "visualization": {
            "bubbles": "Bulles",
            "chart": "Graphique",
            "geo_map": "Carte",
            "line": "Courbes",
            "network": "Réseau",
            "rings": "Anneaux",
            "scatter": "Nuage de points",
            "stacked": "Aires empilées",
            "tree_map": "Arbre",
            "bar": "Diagramme en barres",
            "box": "Boîtes à Moustaches",
            "paths": "Chemins",
            "pie": "Camembert",
            "table": "Table"
        },
        "ui": {
            "and": "et",
            "back": "retour",
            "collapse": "clic pour réduire",
            "error": "erreur",
            "expand": "clic pour agrandir",
            "loading": "chargement ...",
            "more": "plus {0}",
            "moreInfo": "clic pour plus d'information",
            "noResults": "pas de résultat correspondant à {0}.",
            "primary": "connections primaires",
            "share": "part",
            "total": "total",
            "values": "valeurs",
            "including": "incluant",
            "or": "ou"
        },
        "message": {
            "data": "analyse des données",
            "draw": "tracé en cours",
            "initializing": "Initialisation {0}",
            "loading": "chargement",
            "tooltipReset": "réinitialisation des bulles",
            "ui": "rafraichissement de l'interface"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "PIB",
            "HVAC",
            "ID",
            "IT",
            "TV",
            "UI"
        ]
    }

},{}],74:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ".",
            "thousands": ",",
            "grouping": [3],
            "currency": ["₩", ""],
            "dateTime": "%Y/%m/%d %a %X",
            "date": "%Y/%m/%d",
            "time": "%H:%M:%S",
            "periods": ["오전", "오후"],
            "days": ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
            "shortDays": ["일", "월", "화", "수", "목", "금", "토"],
            "months": ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
            "shortMonths": ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]
        },
        "dev": {
            "accepted": "{0} {1}, 다음 중 하나를 사용하십시오에 대한 허용 값이 아닙니다 : {2}.",
            "deprecated": "{0} 메소드가 제거 된, 사용하는 코드를 업데이트하십시오 {1}.",
            "noChange": "{0}이 변경되지 않았기 때문에 업데이트되지 않았습니다.",
            "noContainer": "페이지 매칭 {0}에 컨테이너를 찾을 수 없다.",
            "of": "의",
            "oldStyle": "{0} 지금에 직접 내장 된위한 스타일의 호텔 .{1}().",
            "sameEdge": "가장자리는 자신에 링크 할 수 없습니다. 자동으로 자체 참조 가장자리 {0}을 제거하는 단계를 포함한다.",
            "set": "{0} 설정되어 있습니다.",
            "setLong": "{0} {1}로 설정되어 있습니다.",
            "setContainer": ".container() 사용하여 컨테이너 사업부를 정의하십시오"
        },
        "error": {
            "accepted": "{0} 아니다 허용 {1} {2} 시각화는 다음 중 하나를 사용하시기 바랍니다 : {3}.",
            "connections": "{0}에 대한 연결이 없음.",
            "data": "자료 없음",
            "dataYear": "{0}에 대한 자료가 없음.",
            "lib": "{0} 시각화는 {1} 라이브러리를로드 할 필요합니다.",
            "libs": "{0} 시각화는 다음과 같은 라이브러리를로드 할 필요 : {1}.",
            "method": "{0} 시각화를 위해 {1} 메서드를 설정해야 한다.",
            "methods": "{0} 시각화를 위해 다음과 같은 메서드를 설정해야한다: {1}."
        },
        "lowercase": [],
        "method": {
            "active": "활성 세그먼트",
            "color": "색",
            "depth": "깊이",
            "dev": "풀어서",
            "focus": "초점",
            "icon": "상",
            "id": "신분증",
            "height": "높이",
            "labels": "라벨",
            "legend": "범례",
            "margin": "여유",
            "messages": "상태 메시지",
            "order": "주문",
            "search": "수색",
            "shape": "모양",
            "size": "크기",
            "style": "스타일",
            "temp": "임시 세그먼트",
            "text": "본문",
            "time": "시각",
            "timeline": "타임 라인",
            "total": "총 세그먼트",
            "type": "유형",
            "width": "폭",
            "x": "X 축",
            "y": "Y 축",
            "zoom": "줌",
            "mode": "모드",
            "mute": "숨김",
            "solo": "독주"
        },
        "time": [
            "날짜",
            "요일",
            "월",
            "시간",
            "년"
        ],
        "visualization": {
            "bubbles": "버블 차트",
            "chart": "차트",
            "geo_map": "지도형",
            "line": "선형 그래프",
            "network": "네트워크 그래프",
            "rings": "반지",
            "scatter": "산포도",
            "stacked": "스택 영역",
            "tree_map": "트리 맵",
            "bar": "막대 차트",
            "box": "박스 플롯",
            "paths": "경로",
            "pie": "파이 차트",
            "table": "표"
        },
        "ui": {
            "and": "과",
            "back": "뒤로",
            "collapse": "축소하려면 클릭",
            "error": "오류",
            "expand": "확장하려면 클릭",
            "loading": "로드 중 ...",
            "more": "{0} 이상",
            "moreInfo": "추가 정보를 위해 클릭하십시오",
            "noResults": "일치하는 결과값이 없음 {0}.",
            "primary": "기본 연결",
            "share": "비중",
            "total": "합계",
            "values": "값",
            "including": "...을 포함하여",
            "or": "또는"
        },
        "message": {
            "data": "데이터 분석 중",
            "draw": "데이터 시각화 중",
            "initializing": "초기화 {0}",
            "loading": "데이터 로딩 중",
            "tooltipReset": "툴팁을 재설정",
            "ui": "UI 업데이트 중"
        },
        "uppercase": [
            "CEO",
            "최고 경영자",
            "최고 재무 책임자 (CFO)",
            "CFO는",
            "CNC",
            "COO",
            "구구",
            "CPU",
            "CPU를",
            "국내 총생산 (GDP)",
            "HVAC",
            "ID",
            "IT",
            "R & D",
            "TV",
            "UI"
        ]
    }

},{}],75:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": ".",
            "grouping": [3],
            "currency": ["", " ден."],
            "dateTime": "%A, %e %B %Y г. %X",
            "date": "%d.%m.%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"],
            "days": ["недела", "понеделник", "вторник", "среда", "четврток", "петок", "сабота"],
            "shortDays": ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
            "months": ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
            "shortMonths": ["јан", "фев", "мар", "апр", "мај", "јун", "јул", "авг", "сеп", "окт", "ное", "дек"]
        },
        "dev": {
            "accepted": "{0} не е прифатенa вредноста за {1}, ве молиме користете еднa од следниве вредности: {2}.",
            "deprecated": "{0} метод е отстранета, ве молиме обновете го вашиот код за да се користи {1}.",
            "noChange": "{0} не е ажурирана, бидејќи немаше промени.",
            "noContainer": "не можe да се најде контејнер на страницата кој се совпаѓа со {0}.",
            "of": "на",
            "oldStyle": "својствата за стилот за {0} сега се вградени директно во. {1} ().",
            "sameEdge": "рабовите не може да имаат алка самите кон себе. автоматски ги отстранувам рабовите кои се само-референцираат {0}.",
            "set": "{0} е наместен.",
            "setLong": "{0} е поставен на {1}.",
            "setContainer": "Ве молиме дефинирајте контејнер div користејќи .container()"
        },
        "error": {
            "accepted": "{0} не е прифатлива за {1} {2} визуелизација, ве молиме користете една од следниве: {3}.",
            "connections": "не е достапна за врски {0}.",
            "data": "нема податоци",
            "dataYear": "Нема достапни податоци за {0}.",
            "lib": "{0} визуализации бараат вчитување на библиотеката {1} .",
            "libs": "{0} визуализации бараат вчитување следниве библиотеки: {1}.",
            "method": "{0} визуализации бара поставување на {1} методот.",
            "methods": "{0} визуализации бараат поставување на следниве методи: {1}."
        },
        "lowercase": [
            "a",
            "и",
            "во",
            "но",
            "на",
            "или",
            "да",
            "се",
            "со"
        ],
        "method": {
            "active": "активни сегменти",
            "color": "боја",
            "depth": "длабочина",
            "dev": "опширно",
            "focus": "фокус",
            "icon": "икона",
            "id": "id",
            "height": "висина",
            "labels": "етикети",
            "legend": "легенда",
            "margin": "маргина",
            "messages": "пораки за статусот",
            "mute": "скрие",
            "order": "цел",
            "search": "барај",
            "shape": "форма",
            "size": "големина",
            "solo": "изолирање",
            "style": "стил",
            "temp": "привремени сегменти",
            "text": "текст",
            "time": "време",
            "timeline": "времеплов",
            "total": "Вкупно сегменти",
            "type": "тип",
            "width": "ширина",
            "x": "x оската",
            "y": "оската y",
            "zoom": "зум",
            "mode": "режим"
        },
        "time": [
            "датум",
            "ден",
            "месец",
            "време",
            "година"
        ],
        "visualization": {
            "bubbles": "Меурчиња",
            "chart": "Шема",
            "geo_map": "Гео мапа",
            "line": "Линиски график",
            "network": "Мрежа",
            "rings": "Прстени",
            "scatter": "Распрскан график",
            "stacked": "Наредена површина",
            "tree_map": "Мапа во вид на дрво",
            "bar": "Бар табела",
            "box": "Кутија Парцел",
            "paths": "Патеки",
            "pie": "Пита графикон",
            "table": "Табела"
        },
        "ui": {
            "and": "и",
            "back": "назад",
            "collapse": "кликни за да се собере",
            "error": "грешка",
            "expand": "кликни за да се прошири",
            "loading": "Се вчитува ...",
            "more": "{0} повеќе",
            "moreInfo": "кликнете за повеќе информации",
            "noResults": "Не се пронајдени појавување на {0}.",
            "primary": "основно врски",
            "share": "удел",
            "total": "Вкупниот",
            "values": "вредности",
            "including": "Вклучувајќи",
            "or": "или"
        },
        "message": {
            "data": "анализа на податоци",
            "draw": "цртање на визуелизација",
            "initializing": "иницијализација {0}",
            "loading": "податоци за вчитување",
            "tooltipReset": "ресетирање на објаснувањата",
            "ui": "ажурирање на кориничкиот интерфејс"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "GDP",
            "HVAC",
            "ID",
            "IT",
            "R&D",
            "TV",
            "UI"
        ]
    }

},{}],76:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": ".",
            "grouping": [3],
            "currency": ["R$", ""],
            "dateTime": "%A, %e de %B de %Y. %X",
            "date": "%d/%m/%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"],
            "days": ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
            "shortDays": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
            "months": ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            "shortMonths": ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
        },
        "dev": {
            "accepted": "{0} não é um valor válido para {1}, por favor use um dos seguintes procedimentos: {2}.",
            "deprecated": "{0} método foi removido, por favor atualize seu código para utilizar {1}.",
            "noChange": "{0} não foi atualizado porque ele não mudou.",
            "noContainer": "Não foi possível encontrar um local na página correspondente a {0}.",
            "of": "de",
            "oldStyle": "propriedades de estilo para {0} já foi incorporado diretamente no. {1} ().",
            "sameEdge": "bordas não podem vincular a si mesmos. removendo automaticamente borda de auto-referência {0}.",
            "set": "{0} foi definido.",
            "setLong": "{0} foi definida para {1}.",
            "setContainer": "por favor, defina um div utilizando .container()"
        },
        "error": {
            "accepted": "{0} não é um {1} reconhecido para visualizações {2}, favor usar um dos seguintes procedimentos: {3}.",
            "connections": "Não há conexões disponíveis para {0}.",
            "data": "Não há dados disponíveis",
            "dataYear": "Não há dados disponíveis para {0}.",
            "lib": "A visualização {0} necessita que seja carregado a biblioteca {1}.",
            "libs": "A visualização {0} necessita que seja carregado as bibliotecas {1}.",
            "method": "A visualização {0} exige a definição do método {1}.",
            "methods": "A visualização {0} exige a definição dos métodos {1}."
        },
        "lowercase": [
            "um",
            "uma",
            "e",
            "como",
            "em",
            "no",
            "na",
            "mas",
            "por",
            "para",
            "pelo",
            "pela",
            "de",
            "do",
            "da",
            "se",
            "perto",
            "nem",
            "ou",
            "que",
            "o",
            "a",
            "com",
            "v"
        ],
        "method": {
            "active": "segmentos activos",
            "color": "cor",
            "depth": "profundidade",
            "dev": "verboso",
            "focus": "foco",
            "icon": "ícone",
            "id": "identificador",
            "height": "altura",
            "labels": "etiquetas",
            "legend": "legenda",
            "margin": "margem",
            "messages": "mensagens de status",
            "mute": "ocultar",
            "order": "ordenar",
            "search": "pesquisar",
            "shape": "forma",
            "size": "tamanho",
            "solo": "isolar",
            "style": "estilo",
            "temp": "segmentos temporários",
            "text": "texto",
            "time": "tempo",
            "timeline": "linha do tempo",
            "total": "segmentos no total",
            "type": "tipo",
            "width": "largura",
            "x": "eixo x",
            "y": "eixo y",
            "zoom": "zoom",
            "mode": "modo"
        },
        "time": [
            "data",
            "dia",
            "mês",
            "hora",
            "ano"
        ],
        "visualization": {
            "bubbles": "Bolhas",
            "chart": "Gráfico",
            "geo_map": "Mapa",
            "line": "Gráfico de Linha",
            "network": "Rede",
            "rings": "Anéis",
            "scatter": "Dispersão",
            "stacked": "Evolução",
            "tree_map": "Tree Map",
            "bar": "Gráfico de Barras",
            "box": "Box Plot",
            "paths": "Caminhos",
            "pie": "Pie Chart",
            "table": "Tabela"
        },
        "ui": {
            "and": "e",
            "back": "voltar",
            "collapse": "Clique para fechar",
            "error": "erro",
            "expand": "clique para expandir",
            "loading": "carregando ...",
            "more": "mais {0}",
            "moreInfo": "Clique para mais informações",
            "noResults": "nenhum resultado para {0}.",
            "primary": "conexões primárias",
            "share": "participação",
            "total": "total",
            "values": "valores",
            "including": "Incluindo",
            "or": "ou"
        },
        "message": {
            "data": "analisando dados",
            "draw": "desenhando visualização",
            "initializing": "inicializando {0}",
            "loading": "carregando dados",
            "tooltipReset": "redefinindo as dicas",
            "ui": "atualizando interface"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "PIB",
            "HVAC",
            "ID",
            "TI",
            "P&D",
            "TV",
            "IU"
        ]
    }

},{}],77:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": ".",
            "grouping": [3],
            "currency": ["€", ""],
            "dateTime": "%A, %e de %B de %Y. %X",
            "date": "%d/%m/%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"],
            "days": ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
            "shortDays": ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
            "months": ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
            "shortMonths": ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"]
        },
        "dev": {
            "accepted": "{0} não é um valor válido para {1}, por favor escolha uma das seguintes opções: {2}.",
            "deprecated": "o método {0} foi removido, por favor atualize o seu código para usar {1}.",
            "noChange": "{0} não foi atualizado porque não houve modificações.",
            "noContainer": "Não foi possível encontrar um elemento na página correspondente a {0}.",
            "of": "de",
            "oldStyle": "as propriedades de {0} já foram incluídas em .{1}().",
            "sameEdge": "bordas não podem vincular a si mesmos. removendo automaticamente borda de auto-referência {0}.",
            "set": "{0} foi definido.",
            "setLong": "{0} foi alterado para {1}.",
            "setContainer": "por favor indique um elemento div através do método .container()"
        },
        "error": {
            "accepted": "{0} não é uma {1} válida para a visualização {2}, por favor escolha uma das seguintes: {3}.",
            "connections": "não existem ligações disponíveis para {0}.",
            "data": "não existem dados disponíveis",
            "dataYear": "não existem dados disponíveis para {0}.",
            "lib": "a visualização {0} necessita que a biblioteca {1} seja carregada.",
            "libs": "a visualização {0} necessita que as seguintes bibliotecas sejam carregadas: {1}.",
            "method": "A visualização {0} exige a definição do método {1}.",
            "methods": "A visualização {0} exige a definição dos seguintes métodos {1}."
        },
        "lowercase": [
            "um",
            "uma",
            "e",
            "como",
            "em",
            "no",
            "na",
            "mas",
            "por",
            "para",
            "pelo",
            "pela",
            "de",
            "do",
            "da",
            "se",
            "perto",
            "nem",
            "ou",
            "que",
            "o",
            "a",
            "com",
            "v"
        ],
        "method": {
            "active": "segmentos activos",
            "color": "cor",
            "depth": "profundidade",
            "dev": "verboso",
            "focus": "foco",
            "icon": "ícone",
            "id": "identificador",
            "height": "altura",
            "labels": "etiquetas",
            "legend": "legenda",
            "margin": "margem",
            "messages": "estado",
            "order": "ordenar",
            "search": "pesquisar",
            "shape": "forma",
            "size": "tamanho",
            "style": "estilo",
            "temp": "segmentos temporários",
            "text": "texto",
            "time": "tempo",
            "timeline": "linha temporal",
            "total": "segmentos no total",
            "type": "tipo",
            "width": "largura",
            "x": "eixo dos xx",
            "y": "eixo dos yy",
            "zoom": "zoom",
            "mode": "#ERROR!",
            "mute": "ocultar",
            "solo": "isolar"
        },
        "time": [
            "data",
            "dia",
            "mês",
            "hora",
            "ano"
        ],
        "visualization": {
            "bubbles": "Bolhas",
            "chart": "Diagrama",
            "geo_map": "Mapa",
            "line": "Gráfico de Linha",
            "network": "Grafo",
            "rings": "Anéis",
            "scatter": "Gráfico de Dispersão",
            "stacked": "Gráfico de Área",
            "tree_map": "Tree Map",
            "bar": "Gráfico de Barras",
            "box": "Diagrama de Caixa e Bigodes",
            "paths": "Caminhos",
            "pie": "Gráfico de Setores",
            "table": "Tabela"
        },
        "ui": {
            "and": "e",
            "back": "voltar",
            "collapse": "Clique para colapsar",
            "error": "erro",
            "expand": "clique para expandir",
            "loading": "a carregar ...",
            "more": "mais {0}",
            "moreInfo": "Clique para mais informações",
            "noResults": "nenhum resultado para {0}.",
            "primary": "ligações principais",
            "share": "proporção",
            "total": "total",
            "values": "valores",
            "including": "Incluindo",
            "or": "ou"
        },
        "message": {
            "data": "a analisar os dados",
            "draw": "a desenhar a visualização",
            "initializing": "a inicializar {0}",
            "loading": "a carregar os dados",
            "tooltipReset": "a actualizar as caixas de informação",
            "ui": "a actualizar o interface"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "PIB",
            "HVAC",
            "ID",
            "TI",
            "I&D",
            "TV",
            "IU"
        ]
    }

},{}],78:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ",",
            "thousands": "\xa0",
            "grouping": [3],
            "currency": ["", " руб."],
            "dateTime": "%A, %e %B %Y г. %X",
            "date": "%d.%m.%Y",
            "time": "%H:%M:%S",
            "periods": ["AM", "PM"],
            "days": ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
            "shortDays": ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
            "months": ["января", "февраля", "марта", "апреля", "мая", "июня", "июля", "августа", "сентября", "октября", "ноября", "декабря"],
            "shortMonths": ["янв", "фев", "мар", "апр", "май", "июн", "июл", "авг", "сен", "окт", "ноя", "дек"]
        },
        "dev": {
            "accepted": "{0} не принимаются значение {1}, пожалуйста, используйте один из следующих: {2}.",
            "deprecated": "Метод {0} был удален, пожалуйста, обновите ваш код, чтобы использовать {1}.",
            "noChange": "{0} не обновлен, поскольку он не изменится.",
            "noContainer": "не могу найти контейнер на странице соответствия {0}.",
            "of": "из",
            "oldStyle": "свойства стиля для {0} уже в настоящее время были встроен непосредственно в. {1} ().",
            "sameEdge": "Края не может связать себя. автоматически удаляя автореферентных ребро {0}.",
            "set": "{0} был установлен.",
            "setLong": "{0} установлено значение {1}.",
            "setContainer": "пожалуйста, определить контейнер DIV с помощью .container ()"
        },
        "error": {
            "accepted": "{0} не принимаются {1} для {2} визуализации, пожалуйста, используйте один из следующих: {3}.",
            "connections": "нет соединения, доступные для {0}.",
            "data": "данные недоступны",
            "dataYear": "нет данных {0}.",
            "lib": "{0} визуализации требуют загрузки {1} библиотеку.",
            "libs": "{0} визуализации требуют загрузки следующих библиотек: {1}.",
            "method": "{0} визуализации требуют установки {1} метода.",
            "methods": "{0} визуализации требуют установки следующих методов: {1}."
        },
        "lowercase": [
            "и",
            "как",
            "в",
            "но",
            "для",
            "из",
            "если в",
            "в",
            "недалеко",
            "ни",
            "на",
            "на",
            "или",
            "в",
            "что",
            "к",
            "с",
            "с помощью",
            "против",
            "против"
        ],
        "method": {
            "active": "активные сегменты",
            "color": "цвет",
            "depth": "глубина",
            "dev": "многословный",
            "focus": "фокус",
            "icon": "значок",
            "id": "ID",
            "height": "высота",
            "labels": "надписи",
            "legend": "легенда",
            "margin": "поле",
            "messages": "Сообщения о состоянии",
            "mute": "скрывать",
            "order": "порядок",
            "search": "поиск",
            "shape": "форма",
            "size": "размер",
            "solo": "изолировать",
            "style": "стиль",
            "temp": "временные сегменты",
            "text": "текст",
            "time": "время",
            "timeline": "график",
            "total": "всего сегментов",
            "type": "тип",
            "width": "ширина",
            "x": "ось х",
            "y": "Ось Y",
            "zoom": "масштаб",
            "mode": "режим"
        },
        "time": [
            "дата",
            "день",
            "месяц",
            "время",
            "год"
        ],
        "visualization": {
            "bubbles": "Пузыри",
            "chart": "График",
            "geo_map": "Гео Карта",
            "line": "Линия земля",
            "network": "Сеть",
            "rings": "Кольца",
            "scatter": "Разброс земля",
            "stacked": "С накоплением Площадь",
            "tree_map": "Дерево Карта",
            "bar": "Гистограмма",
            "box": "Коробка земля",
            "paths": "Пути",
            "pie": "Круговая диаграмма",
            "table": "Стол"
        },
        "ui": {
            "and": "и",
            "back": "назад",
            "collapse": "Щелкните, чтобы свернуть",
            "error": "ошибка",
            "expand": "щелкните, чтобы развернуть",
            "loading": "загрузка ...",
            "more": "{0} более",
            "moreInfo": "нажмите для получения более подробной информации",
            "noResults": "нет результатов, соответствующих {0}.",
            "primary": "первичные соединения",
            "share": "доля",
            "total": "общее",
            "values": "значения",
            "including": "включая",
            "or": "или"
        },
        "message": {
            "data": "Анализируя данные",
            "draw": "рисунок визуализация",
            "initializing": "инициализации {0}",
            "loading": "загрузка данных",
            "tooltipReset": "сброс подсказки",
            "ui": "обновление пользовательского интерфейса"
        },
        "uppercase": [
            "ID"
        ]
    }

},{}],79:[function(require,module,exports){
    module.exports = {
        "format": {
            "decimal": ".",
            "thousands": ",",
            "grouping": [3],
            "currency": ["¥", ""],
            "dateTime": "%A %B %e %Y %X",
            "date": "%Y/%-m/%-d",
            "time": "%H:%M:%S",
            "periods": ["上午", "下午"],
            "days": ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
            "shortDays": ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
            "months": ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
            "shortMonths": ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
        },
        "dev": {
            "accepted": "{0}不是{1}的可接受值, 请用下列之一的值:{2}",
            "deprecated": "{0}的方法已被移除, 请更新您的代码去使用{1}",
            "noChange": "{0}没有更新, 因为它并没有改变。",
            "noContainer": "无法在该页找到容器去匹配{0}",
            "of": "的",
            "oldStyle": "样式属性{0}现在已经直接嵌入到。{1}（）。",
            "sameEdge": "边缘不能链接到自己。自动去除自我参照边缘{0}。",
            "set": "{0}已经被设置。",
            "setLong": "{0}被设置为{1}。",
            "setContainer": "请使用()容器来定义div容器"
        },
        "error": {
            "accepted": "{0}对于{2}的可视化效果并不是一个可接受的{1}, 请使用如下的一个：{3}.",
            "connections": "没有对{0}可用的连接。",
            "data": "无可用数据",
            "dataYear": "没有数据对{0}可用。",
            "lib": "{0}的可视化要求装载{1}库。",
            "libs": "{0}的可视化需要加载以下库：{1}。",
            "method": "{0}的可视化要求设置{1}方法。",
            "methods": "{0}的可视化要求设置以下方法：{1}。"
        },
        "lowercase": [
            "一个",
            "和",
            "在",
            "但是",
            "在...里",
            "的",
            "或者",
            "这",
            "向",
            "与...一起"
        ],
        "method": {
            "active": "活跃段",
            "color": "颜色",
            "depth": "深度",
            "dev": "详细",
            "focus": "焦点",
            "icon": "图标",
            "id": "身份认证",
            "height": "高度",
            "labels": "标签",
            "legend": "图例注释",
            "margin": "外边距",
            "messages": "状态消息",
            "mute": "隐藏",
            "order": "规则",
            "search": "搜索",
            "shape": "形状",
            "size": "大小",
            "solo": "隔离",
            "style": "样式",
            "temp": "暂时性区段",
            "text": "文本",
            "time": "时间",
            "timeline": "时间轴",
            "total": "总段",
            "type": "类型",
            "width": "宽度",
            "x": "X轴",
            "y": "Y轴",
            "zoom": "缩放",
            "mode": "模式"
        },
        "time": [
            "日",
            "星期",
            "月",
            "时间",
            "年"
        ],
        "visualization": {
            "bubbles": "气泡",
            "chart": "图表",
            "geo_map": "地理地图",
            "line": "线图",
            "network": "网络",
            "rings": "特性",
            "scatter": "散点图",
            "stacked": "堆积面积图",
            "tree_map": "树图",
            "bar": "条图",
            "box": "箱线图",
            "paths": "路径",
            "pie": "饼图",
            "table": "表"
        },
        "ui": {
            "and": "和",
            "back": "后面",
            "collapse": "点击合并",
            "error": "错误",
            "expand": "单击以展开",
            "loading": "载入中...",
            "more": "{0}更多",
            "moreInfo": "点击了解更多信息",
            "noResults": "没有结果匹配{0}。",
            "primary": "主要连接",
            "share": "共享",
            "total": "总",
            "values": "值",
            "including": "包括",
            "or": "或"
        },
        "message": {
            "data": "分析数据",
            "draw": "绘制可视化",
            "initializing": "初始化{0}",
            "loading": "加载数据",
            "tooltipReset": "重置工具提示",
            "ui": "更新UI"
        },
        "uppercase": [
            "CEO",
            "CEOs",
            "CFO",
            "CFOs",
            "CNC",
            "COO",
            "COOs",
            "CPU",
            "CPUs",
            "GDP",
            "HVAC",
            "ID",
            "电视",
            "用户界面",
            "研发"
        ]
    }

},{}],80:[function(require,module,exports){
    module.exports = {
        en_US: require("./languages/en_US.coffee"),
        es_ES: require("./languages/es_ES.js"),
        fr_FR: require("./languages/fr_FR.js"),
        ko_KR: require("./languages/ko_KR.js"),
        mk_MK: require("./languages/mk_MK.js"),
        pt_BR: require("./languages/pt_BR.js"),
        pt_PT: require("./languages/pt_PT.js"),
        ru_RU: require("./languages/ru_RU.js"),
        zh_CN: require("./languages/zh_CN.js")
    };


},{"./languages/en_US.coffee":71,"./languages/es_ES.js":72,"./languages/fr_FR.js":73,"./languages/ko_KR.js":74,"./languages/mk_MK.js":75,"./languages/pt_BR.js":76,"./languages/pt_PT.js":77,"./languages/ru_RU.js":78,"./languages/zh_CN.js":79}],81:[function(require,module,exports){
    var checkObject, copy, createFunction, initialize, print, process, setMethod, stringFormat, validObject;

    copy = require("../../util/copy.coffee");

    print = require("../console/print.coffee");

    process = require("./process/detect.coffee");

    setMethod = require("./set.coffee");

    stringFormat = require("../../string/format.js");

    validObject = require("../../object/validate.coffee");

    module.exports = function(vars, methods) {
        var method, obj, results;
        results = [];
        for (method in methods) {
            obj = methods[method];
            vars[method] = copy(obj);
            vars[method].initialized = initialize(vars, vars[method], method);
            results.push(vars.self[method] = createFunction(vars, method));
        }
        return results;
    };

    initialize = function(vars, obj, method, p) {
        var d, deps, i, len, o;
        obj.previous = false;
        obj.changed = false;
        obj.initialized = false;
        obj.callback = false;
        if ("init" in obj && (!("value" in obj))) {
            obj.value = obj.init(vars);
            delete obj.init;
        }
        if ("process" in obj) {
            obj.value = process(vars, obj, obj.value);
        }
        for (o in obj) {
            if (o === "deprecates") {
                deps = obj[o] instanceof Array ? obj[o] : [obj[o]];
                for (i = 0, len = deps.length; i < len; i++) {
                    d = deps[i];
                    vars.self[d] = (function(dep, n) {
                        return function(x) {
                            var doc, rec, str;
                            str = vars.format.locale.value.dev.deprecated;
                            dep = "." + dep + "()";
                            rec = p ? "\"" + n + "\" in ." + p + "()" : "." + n + "()";
                            doc = p || n;
                            print.error(stringFormat(str, dep, rec), doc);
                            return vars.self;
                        };
                    })(d, method);
                }
            } else if (o === "global") {
                if (!(method in vars)) {
                    vars[method] = [];
                }
            } else if (o !== "value") {
                if (validObject(obj[o])) {
                    initialize(vars, obj[o], o, method);
                }
            }
        }
        return true;
    };

    createFunction = function(vars, key) {
        return function(user, callback) {
            var accepted, checkFont, checkValue, fontAttr, fontAttrValue, s, starting, str;
            accepted = "accepted" in vars[key] ? vars[key].accepted : null;
            if (typeof accepted === "function") {
                accepted = accepted(vars);
            }
            if (!(accepted instanceof Array)) {
                accepted = [accepted];
            }
            if (user === Object) {
                return vars[key];
            } else if (!arguments.length && accepted.indexOf(void 0) < 0) {
                if ("value" in vars[key]) {
                    return vars[key].value;
                } else {
                    return vars[key];
                }
            }
            if (key === "style" && typeof user === "object") {
                str = vars.format.locale.value.dev.oldStyle;
                for (s in user) {
                    print.warning(stringFormat(str, "\"" + s + "\"", s), s);
                    vars.self[s](user[s]);
                }
            }
            if (key === "font") {
                if (typeof user === "string") {
                    user = {
                        family: user
                    };
                }
                starting = true;
                checkValue = function(o, a, m, v) {
                    if (validObject(o[m]) && a in o[m]) {
                        if (validObject(o[m][a])) {
                            if (o[m][a].process) {
                                o[m][a].value = o[m][a].process(v);
                            } else {
                                o[m][a].value = v;
                            }
                        } else {
                            o[m][a] = v;
                        }
                    }
                };
                checkFont = function(o, a, v) {
                    var m;
                    if (validObject(o)) {
                        if (starting) {
                            for (m in o) {
                                checkValue(o, a, m, v);
                            }
                        } else if ("font" in o) {
                            checkValue(o, a, "font", v);
                        }
                        starting = false;
                        for (m in o) {
                            checkFont(o[m], a, v);
                        }
                    }
                };
                for (fontAttr in user) {
                    fontAttrValue = user[fontAttr];
                    if (fontAttr !== "secondary") {
                        if (validObject(fontAttrValue)) {
                            fontAttrValue = fontAttrValue.value;
                        }
                        if (fontAttrValue) {
                            checkFont(vars, fontAttr, fontAttrValue);
                        }
                    }
                }
            }
            checkObject(vars, key, vars, key, user);
            if (typeof callback === "function") {
                vars[key].callback = callback;
            }
            if (vars[key].chainable === false) {
                return vars[key].value;
            } else {
                return vars.self;
            }
        };
    };

    checkObject = function(vars, method, object, key, value) {
        var approvedObject, d, objectOnly, passingObject;
        if (["accepted", "changed", "initialized", "previous", "process"].indexOf(key) < 0) {
            passingObject = validObject(value);
            objectOnly = validObject(object[key]) && "objectAccess" in object[key] && object[key]["objectAccess"] === false;
            approvedObject = passingObject && (objectOnly || ((!("value" in value)) && ((!validObject(object[key])) || (!(d3.keys(value)[0] in object[key])))));
            if (value === null || !passingObject || approvedObject) {
                setMethod(vars, method, object, key, value);
            } else if (passingObject) {
                for (d in value) {
                    checkObject(vars, method, object[key], d, value[d]);
                }
            }
        }
    };


},{"../../object/validate.coffee":174,"../../string/format.js":175,"../../util/copy.coffee":209,"../console/print.coffee":54,"./process/detect.coffee":89,"./set.coffee":95}],82:[function(require,module,exports){
    module.exports = function(g) {
        if (!g) {
            g = false;
        }
        return {
            accepted: [false, Array, Function, Number, Object, String],
            callback: {
                accepted: [false, Function],
                value: false
            },
            global: g,
            process: Array,
            value: []
        };
    };


},{}],83:[function(require,module,exports){
    var rtl;

    rtl = require("../../../client/rtl.coffee");

    module.exports = function(align) {
        var accepted;
        accepted = ["left", "center", "right"];
        if (align === false) {
            accepted.unshift(false);
        }
        if (accepted.indexOf(align) < 0) {
            align = "left";
        }
        return {
            accepted: accepted,
            process: function(value) {
                if (rtl) {
                    if (value === "left") {
                        return "right";
                    } else {
                        if (value === "right") {
                            return "left";
                        } else {
                            return value;
                        }
                    }
                } else {
                    return value;
                }
            },
            value: align
        };
    };


},{"../../../client/rtl.coffee":42}],84:[function(require,module,exports){
    module.exports = function(decoration) {
        var accepted;
        accepted = ["line-through", "none", "overline", "underline"];
        if (decoration === false) {
            accepted.unshift(false);
        }
        if (accepted.indexOf(decoration) < 0) {
            decoration = "none";
        }
        return {
            accepted: accepted,
            value: decoration
        };
    };


},{}],85:[function(require,module,exports){
    var helvetica, validate;

    validate = require("../../../font/validate.coffee");

    helvetica = ["Helvetica Neue", "HelveticaNeue", "Helvetica", "Arial", "sans-serif"];

    module.exports = function(family) {
        if (family === void 0) {
            family = helvetica;
        }
        return {
            process: validate,
            value: family
        };
    };


},{"../../../font/validate.coffee":104}],86:[function(require,module,exports){
    module.exports = function(position) {
        var accepted;
        accepted = ["top", "middle", "bottom"];
        if (position === false) {
            accepted.unshift(false);
        }
        if (accepted.indexOf(position) < 0) {
            position = "bottom";
        }
        return {
            accepted: accepted,
            mapping: {
                top: "0ex",
                middle: "0.5ex",
                bottom: "1ex"
            },
            process: function(value) {
                this.text = value;
                return this.mapping[value];
            },
            value: position
        };
    };


},{}],87:[function(require,module,exports){
    module.exports = function(transform) {
        var accepted;
        accepted = ["capitalize", "lowercase", "none", "uppercase"];
        if (transform === false) {
            accepted.unshift(false);
        }
        if (accepted.indexOf(transform) < 0) {
            transform = "none";
        }
        return {
            accepted: accepted,
            value: transform
        };
    };


},{}],88:[function(require,module,exports){
    module.exports = function(value, vars, method) {
        var elem;
        if (vars.history) {
            vars.history.reset();
        }
        if (value.constructor === String) {
            if (value.indexOf("/") >= 0) {
                method.url = value;
                return [];
            }
            elem = d3.selectAll(value);
            if (elem.size()) {
                return elem;
            }
            if (value.indexOf(".") >= 0) {
                method.url = value;
            }
            return [];
        } else {
            return value;
        }
    };


},{}],89:[function(require,module,exports){
    var copy, update;

    copy = require("../../../util/copy.coffee");

    update = require("../../../array/update.coffee");

    module.exports = function(vars, object, value) {
        if (object.process === Array) {
            return update(copy(object.value), value);
        } else if (typeof object.process === "object" && typeof value === "string") {
            return object.process[value];
        } else if (typeof object.process === "function") {
            return object.process(value, vars, object);
        } else {
            return value;
        }
    };


},{"../../../array/update.coffee":37,"../../../util/copy.coffee":209}],90:[function(require,module,exports){
    var stylesheet;

    stylesheet = require("../../../client/css.coffee");

    module.exports = function(value, vars, method) {
        if (value === false || value.indexOf("fa-") < 0 || (value.indexOf("fa-") === 0 && stylesheet("font-awesome"))) {
            return value;
        } else {
            return method.fallback;
        }
    };


},{"../../../client/css.coffee":38}],91:[function(require,module,exports){
    module.exports = function(value, self) {
        var i, j, k, l, len, len1, len2, len3, m, results, side, sides, v;
        if (typeof value === "string") {
            value = value.split(" ");
            for (i = j = 0, len = value.length; j < len; i = ++j) {
                v = value[i];
                value[i] = parseFloat(v, 10);
            }
            if (value.length === 1) {
                value = value[0];
            } else if (value.length === 2) {
                value = {
                    top: value[0],
                    right: value[1],
                    bottom: value[0],
                    left: value[1]
                };
            } else if (value.length === 3) {
                value = {
                    top: value[0],
                    right: value[1],
                    bottom: value[2],
                    left: value[1]
                };
            } else if (value.length === 4) {
                value = {
                    top: value[0],
                    right: value[1],
                    bottom: value[2],
                    left: value[3]
                };
            } else {
                value = 0;
            }
        }
        sides = ["top", "right", "bottom", "left"];
        if (typeof value === "number") {
            for (k = 0, len1 = sides.length; k < len1; k++) {
                side = sides[k];
                self[side] = value;
            }
        } else {
            for (l = 0, len2 = sides.length; l < len2; l++) {
                side = sides[l];
                self[side] = value[side];
            }
        }
        self.css = "";
        results = [];
        for (i = m = 0, len3 = sides.length; m < len3; i = ++m) {
            side = sides[i];
            if (i) {
                self.css += " ";
            }
            results.push(self.css += self[side] + "px");
        }
        return results;
    };


},{}],92:[function(require,module,exports){
    var contains, format, list, print;

    contains = require("../../array/contains.coffee");

    format = require("../../string/format.js");

    list = require("../../string/list.coffee");

    print = require("../console/print.coffee");

    module.exports = function(vars, accepted, value, method, text) {
        var a, allowed, app, i, len, recs, str, val;
        if (typeof accepted === "function") {
            accepted = accepted(vars);
        }
        if (!(accepted instanceof Array)) {
            accepted = [accepted];
        }
        allowed = contains(accepted, value);
        if (allowed === false && value !== void 0) {
            recs = [];
            val = JSON.stringify(value);
            if (typeof value !== "string") {
                val = "\"" + val + "\"";
            }
            for (i = 0, len = accepted.length; i < len; i++) {
                a = accepted[i];
                if (typeof a === "string") {
                    recs.push("\"" + a + "\"");
                } else if (typeof a === "function") {
                    recs.push(a.toString().split("()")[0].substring(9));
                } else if (a === void 0) {
                    recs.push("undefined");
                } else {
                    recs.push(JSON.stringify(a));
                }
            }
            recs = list(recs, vars.format.locale.value.ui.or);
            if (vars.type && ["mode", "shape"].indexOf(method) >= 0) {
                str = vars.format.locale.value.error.accepted;
                app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value;
                print.warning(format(str, val, method, app, recs), method);
            } else {
                str = vars.format.locale.value.dev.accepted;
                print.warning(format(str, val, text, recs), method);
            }
        }
        return !allowed;
    };


},{"../../array/contains.coffee":35,"../../string/format.js":175,"../../string/list.coffee":176,"../console/print.coffee":54}],93:[function(require,module,exports){
    module.exports = function(rendering) {
        var accepted;
        accepted = ["auto", "optimizeSpeed", "crispEdges", "geometricPrecision"];
        if (!(accepted.indexOf(rendering) >= 0)) {
            rendering = "crispEdges";
        }
        return {
            accepted: accepted,
            value: rendering
        };
    };


},{}],94:[function(require,module,exports){
    var reset, validObject;

    validObject = require("../../object/validate.coffee");

    reset = function(obj, method) {
        var o;
        if (obj.changed) {
            obj.changed = false;
        }
        if (method === "draw") {
            obj.frozen = false;
            obj.update = true;
            obj.first = false;
        }
        for (o in obj) {
            if (o.indexOf("d3plus") < 0 && validObject(obj[o])) {
                reset(obj[o], o);
            }
        }
    };

    module.exports = reset;


},{"../../object/validate.coffee":174}],95:[function(require,module,exports){
    var copy, d3selection, mergeObject, print, process, rejected, stringFormat, updateArray, validObject;

    copy = require("../../util/copy.coffee");

    d3selection = require("../../util/d3selection.coffee");

    validObject = require("../../object/validate.coffee");

    mergeObject = require("../../object/merge.coffee");

    print = require("../console/print.coffee");

    process = require("./process/detect.coffee");

    rejected = require("./rejected.coffee");

    stringFormat = require("../../string/format.js");

    updateArray = require("../../array/update.coffee");

    module.exports = function(vars, method, object, key, value) {
        var accepted, c, callback, d3object, hasValue, id, k, longArray, n, parentKey, str, text, typeFunction, valString;
        if (key === "value" || !key || key === method) {
            text = "." + method + "()";
        } else {
            text = "\"" + key + "\" " + vars.format.locale.value.dev.of + " ." + method + "()";
        }
        if (key === "value" && "accepted" in object) {
            accepted = object.accepted;
        } else if (validObject(object[key]) && "accepted" in object[key]) {
            accepted = object[key].accepted;
        } else {
            accepted = [value];
        }
        if (!rejected(vars, accepted, value, method, text)) {
            if (validObject(object[key]) && "value" in object[key]) {
                parentKey = key;
                object = object[key];
                key = "value";
            }
            if (key === "value" && "process" in object) {
                value = process(vars, object, value);
            }
            if ((!(object[key] instanceof Array)) && object[key] === value && value !== void 0) {
                str = vars.format.locale.value.dev.noChange;
                if (vars.dev.value) {
                    print.comment(stringFormat(str, text));
                }
            } else {
                object.changed = true;
                if (object.loaded) {
                    object.loaded = false;
                }
                if ("history" in vars && method !== "draw") {
                    c = copy(object);
                    c.method = method;
                    vars.history.chain.push(c);
                }
                object.previous = object[key];
                if ("id" in vars && key === "value" && "nesting" in object) {
                    if (method !== "id") {
                        if (typeof object.nesting !== "object") {
                            object.nesting = {};
                        }
                        if (validObject(value)) {
                            for (id in value) {
                                if (typeof value[id] === "string") {
                                    value[id] = [value[id]];
                                }
                            }
                            object.nesting = mergeObject(object.nesting, value);
                            if (!(vars.id.value in object.nesting)) {
                                object.nesting[vars.id.value] = value[d3.keys(value)[0]];
                            }
                        } else if (value instanceof Array) {
                            object.nesting[vars.id.value] = value;
                        } else {
                            object.nesting[vars.id.value] = [value];
                        }
                        object[key] = object.nesting[vars.id.value][0];
                    } else {
                        if (value instanceof Array) {
                            object.nesting = value;
                            if ("depth" in vars && vars.depth.value < value.length) {
                                object[key] = value[vars.depth.value];
                            } else {
                                object[key] = value[0];
                                if ("depth" in vars) {
                                    vars.depth.value = 0;
                                }
                            }
                        } else {
                            object[key] = value;
                            object.nesting = [value];
                            if ("depth" in vars) {
                                vars.depth.value = 0;
                            }
                        }
                    }
                } else if (method === "depth") {
                    if (value >= vars.id.nesting.length) {
                        vars.depth.value = vars.id.nesting.length - 1;
                    } else if (value < 0) {
                        vars.depth.value = 0;
                    } else {
                        vars.depth.value = value;
                    }
                    vars.id.value = vars.id.nesting[vars.depth.value];
                    if (typeof vars.text.nesting === "object") {
                        n = vars.text.nesting[vars.id.value];
                        if (n) {
                            vars.text.nesting[vars.id.value] = typeof n === "string" ? [n] : n;
                            vars.text.value = (n instanceof Array ? n[0] : n);
                        }
                    }
                } else if (validObject(object[key]) && validObject(value)) {
                    object[key] = mergeObject(object[key], value);
                } else {
                    object[key] = value;
                }
                if (key === "value" && object.global) {
                    hasValue = object[key].length > 0;
                    k = parentKey || key;
                    if (k in vars && ((hasValue && vars.data[k].indexOf(method) < 0) || (!hasValue && vars.data[k].indexOf(method) >= 0))) {
                        vars.data[k] = updateArray(vars.data[k], method);
                    }
                }
                if (key === "value" && object.dataFilter && vars.data && vars.data.filters.indexOf(method) < 0) {
                    vars.data.filters.push(method);
                }
                if (vars.dev.value && object.changed && object[key] !== void 0) {
                    longArray = object[key] instanceof Array && object[key].length > 10;
                    d3object = d3selection(object[key]);
                    typeFunction = typeof object[key] === "function";
                    valString = (!longArray && !d3object && !typeFunction ? (typeof object[key] === "string" ? object[key] : JSON.stringify(object[key])) : null);
                    if (valString !== null && valString.length < 260) {
                        str = vars.format.locale.value.dev.setLong;
                        print.log(stringFormat(str, text, "\"" + valString + "\""));
                    } else {
                        str = vars.format.locale.value.dev.set;
                        print.log(stringFormat(str, text));
                    }
                }
            }
            if (key === "value" && object.callback && !object.url) {
                callback = typeof object.callback === "function" ? object.callback : object.callback.value;
                if (callback) {
                    callback(value, vars.self);
                }
            }
        }
    };


},{"../../array/update.coffee":37,"../../object/merge.coffee":173,"../../object/validate.coffee":174,"../../string/format.js":175,"../../util/copy.coffee":209,"../../util/d3selection.coffee":210,"../console/print.coffee":54,"./process/detect.coffee":89,"./rejected.coffee":92}],96:[function(require,module,exports){
    var print = require("../console/print.coffee"),
        stringFormat = require("../../string/format.js")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Cleans edges list and populates nodes list if needed
//-------------------------------------------------------------------
    module.exports = function( vars ) {

        if ( vars.dev.value ) {
            var timerString = "analyzing edges list"
            print.time( timerString )
        }

        var appReqs     = vars.types[vars.type.value].requirements
        if (!(appReqs instanceof Array)) appReqs = [appReqs]
        var createNodes = appReqs.indexOf("nodes") >= 0 && !vars.nodes.value

        if ( createNodes ) {
            vars.nodes.value = []
            var placed = []
            vars.nodes.changed = true
        }

        vars.edges.value.forEach(function(e){

            ["source", "target"].forEach(function(dir){

                var dirType = typeof e[vars.edges[dir]];

                if (dirType !== "object") {
                    if (dirType === "number" && !createNodes && vars.data.keys[vars.id.value] !== "number") {
                        e[vars.edges[dir]] = vars.nodes.value[e[vars.edges[dir]]];
                    }
                    else {
                        if (createNodes && placed.indexOf(e[vars.edges[dir]]) >= 0) {
                            e[vars.edges[dir]] = vars.nodes.value.filter(function(n){
                                return n[vars.id.value] === e[vars.edges[dir]];
                            })[0];
                        }
                        else {
                            var obj = {};
                            obj[vars.id.value] = e[vars.edges[dir]];
                            e[vars.edges[dir]] = obj;
                        }
                    }
                }

                var newNode = e[vars.edges[dir]];
                if (createNodes) {
                    if (placed.indexOf(newNode[vars.id.value]) < 0) {
                        placed.push(newNode[vars.id.value]);
                        vars.nodes.value.push(newNode);
                    }
                }
            });

            if (!("keys" in vars.data)) {
                vars.data.keys = {};
            }

            if (!(vars.id.value in vars.data.keys)) {
                vars.data.keys[vars.id.value] = typeof e[vars.edges.source][vars.id.value];
            }

        });

        vars.edges.value = vars.edges.value.filter(function(e){

            var source = e[vars.edges.source][vars.id.value]
                , target = e[vars.edges.target][vars.id.value]

            if ( source === target ) {
                var str = vars.format.locale.value.dev.sameEdge
                print.warning(stringFormat(str,"\""+source+"\"") , "edges" )
                return false
            }
            else {
                return true
            }

        })

        vars.edges.linked = true

        if ( vars.dev.value ) print.timeEnd( timerString )

    }

},{"../../string/format.js":175,"../console/print.coffee":54}],97:[function(require,module,exports){
    var hideElement = require("./hideElement.js");

// Parses an HTML element for data
    module.exports = function( vars ) {

        var attributes = [ vars.color.value
            , vars.icon.value
            , vars.keywords.value
            , vars.alt.value
            , "style" ]

        if (!vars.text.value) {
            vars.self.text("text")
        }

        attributes = attributes.concat(vars.id.nesting)

        function get_attributes( obj , elem ) {
            [].forEach.call(elem.attributes, function(attr) {
                if (/^data-/.test(attr.name)) {
                    var camelCaseName = attr.name.substr(5).replace(/-(.)/g, function ($0, $1) {
                        return $1.toUpperCase();
                    });
                    obj[camelCaseName] = attr.value;
                }
            })

            attributes.forEach(function(a){

                if ( elem.getAttribute(a) !== null ) {
                    obj[a] = elem.getAttribute(a)
                }

            })

        }

        vars.self.data({"element": vars.data.value})

        var elementTag  = vars.data.element.value.node().tagName.toLowerCase()
            , elementType = vars.data.element.value.attr("type")
            , elementData = []

        if ( elementTag === "select" ) {

            var elementID = vars.data.element.value.node().id
            if ( elementID ) {
                vars.self.container({"id": elementID})
            }

            vars.data.element.value.selectAll("option")
                .each(function( o , i ){

                    var data_obj = {}

                    data_obj.text = d3.select(this).text();

                    get_attributes(data_obj,this)

                    elementData.push(data_obj)

                    if (this.selected) {
                        for (var i = vars.id.nesting.length-1; i >= 0; i--) {
                            var level = vars.id.nesting[i]
                            if (level in data_obj) {
                                vars.self.focus(data_obj[level])
                                break
                            }
                        }
                    }

                })

        }
        else if ( elementTag === "input" && elementType === "radio" ) {

            var elementName = vars.data.element.value.node().getAttribute("name")
            if ( elementName ) {
                vars.self.container({"id": elementName})
            }

            vars.data.element.value
                .each(function( o , i ){

                    var data_obj = {}

                    get_attributes(data_obj,this)

                    var id = data_obj[vars.id.value] || this.id || false

                    if ( id && isNaN(parseFloat(id)) ) {

                        var label = d3.select("label[for="+id+"]")

                        if ( !label.empty() ) {
                            data_obj.text = label.html()
                            label.call(hideElement)
                        }

                    }

                    elementData.push(data_obj)

                    if (this.checked) {
                        vars.self.focus(data_obj[vars.id.value])
                    }

                })

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Get focus from data, if it hasn't been found or set.
        //----------------------------------------------------------------------------
        if ( !vars.focus.value.length && elementData.length ) {

            vars.data.element.value.node().selectedIndex = 0
            vars.self.focus(elementData[0][vars.id.value])

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If a <legend> element exists, use it as the title.
        //----------------------------------------------------------------------------
        var elementLegend = d3.select("legend[for="+vars.container.id+"]")
        if ( !elementLegend.empty() ) {

            vars.self.title(elementLegend.html())
            elementLegend.call(hideElement)

        }

        var containerTag = vars.container.value
            ? vars.container.value.node().tagName.toLowerCase() : false

        if ( vars.container.value === false || containerTag === "body" ) {
            vars.container.value = d3.select(vars.data.element.value.node().parentNode)
        }

        vars.data.element.value.call(hideElement)

        return elementData

    };

},{"./hideElement.js":98}],98:[function(require,module,exports){
    module.exports = function(elem) {

        elem
            .style("position","absolute","important")
            .style("clip","rect(1px 1px 1px 1px)","important")
            .style("clip","rect(1px, 1px, 1px, 1px)","important")
            .style("width","1px","important")
            .style("height","1px","important")
            .style("margin","-1px","important")
            .style("padding","0","important")
            .style("border","0","important")
            .style("overflow","hidden","important");

    }

},{}],99:[function(require,module,exports){
    var print = require("../console/print.coffee");

// Calculates node positions, if needed for network.
    module.exports = function(vars) {

        if (vars.type.value === "network") {

            if (vars.dev.value) {
                var timerString = "analyzing node positions";
                print.time(timerString);
            }

            var set = vars.nodes.value.filter(function(n){
                return typeof n.x === "number" && typeof n.y === "number";
            }).length;

            if (set === vars.nodes.value.length) {
                vars.nodes.positions = true;
            }
            else {

                var force = d3.layout.force()
                    .size([vars.width.viz, vars.height.viz])
                    .nodes(vars.nodes.value)
                    .links(vars.edges.value);

                var strength = vars.edges.strength.value;
                if (strength) {
                    if (typeof strength === "string") {
                        force.linkStrength(function(e){
                            return e[strength];
                        });
                    }
                    else {
                        force.linkStrength(strength);
                    }
                }

                var iterations = 50,
                    threshold = 0.01;

                force.start(); // Defaults to alpha = 0.1
                for (var i = iterations; i > 0; --i) {
                    force.tick();
                    if(force.alpha() < threshold) {
                        break;
                    }
                }
                force.stop();

                vars.nodes.positions = true;

            }

            if (vars.dev.value) print.timeEnd(timerString);

        }

    }

},{"../console/print.coffee":54}],100:[function(require,module,exports){
    var numeric;

    numeric = require('numeric');

    module.exports = function(data, options) {
        var N, X, Xfulltr, Xtr, bestResult, beta_hat, bic, degree, degrees, i, j, k, l, loglike, m, point, prevBIC, q, ref, ref1, residual, sigma2, sse, y, y_hat;
        if (options == null) {
            options = {};
        }
        if (options.maxDegree == null) {
            options.maxDegree = 5;
        }
        N = data.length;
        prevBIC = Number.MAX_VALUE;
        bestResult = null;
        Xfulltr = (function() {
            var l, ref, results;
            results = [];
            for (degree = l = 1, ref = options.maxDegree + 1; 1 <= ref ? l < ref : l > ref; degree = 1 <= ref ? ++l : --l) {
                results.push((function() {
                    var len, m, results1;
                    results1 = [];
                    for (m = 0, len = data.length; m < len; m++) {
                        point = data[m];
                        results1.push(Math.pow(point[0], degree));
                    }
                    return results1;
                })());
            }
            return results;
        })();
        y = (function() {
            var l, len, results;
            results = [];
            for (l = 0, len = data.length; l < len; l++) {
                point = data[l];
                results.push(point[1]);
            }
            return results;
        })();
        for (i = l = 0, ref = 1 << options.maxDegree; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
            Xtr = [
                (function() {
                    var m, ref1, results;
                    results = [];
                    for (q = m = 0, ref1 = N; 0 <= ref1 ? m < ref1 : m > ref1; q = 0 <= ref1 ? ++m : --m) {
                        results.push(1);
                    }
                    return results;
                })()
            ];
            degrees = [0];
            for (j = m = 0, ref1 = options.maxDegree; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
                if ((i & 1 << j) > 0) {
                    Xtr.push(Xfulltr[j]);
                    degrees.push(j + 1);
                }
            }
            X = numeric.transpose(Xtr);
            k = degrees.length;
            beta_hat = numeric.dot(numeric.dot(numeric.inv(numeric.dot(Xtr, X)), Xtr), y);
            y_hat = numeric.dot(X, beta_hat);
            residual = numeric.sub(y, y_hat);
            sse = numeric.dot(residual, residual);
            sigma2 = sse / (N - k);
            loglike = -0.5 * N * Math.log(2 * Math.PI) - 0.5 * N * Math.log(sigma2) - sse / (2 * sigma2);
            bic = -2 * loglike + k * (Math.log(N) - Math.log(2 * Math.PI));
            if (bic < prevBIC) {
                prevBIC = bic;
                bestResult = [degrees, beta_hat, y_hat];
            }
        }
        return bestResult;
    };


},{"numeric":8}],101:[function(require,module,exports){
    var kdtree;

    kdtree = require('static-kdtree');

    module.exports = function(points, K) {
        var avg_lrd, i, j, kdists, ldr, ldrs, neighbors, p, reachDist, result, sqDist, tree;
        if (K == null) {
            K = 10;
        }
        tree = kdtree(points);
        neighbors = (function() {
            var k, len, results;
            results = [];
            for (k = 0, len = points.length; k < len; k++) {
                p = points[k];
                results.push(tree.knn(p, K + 1).slice(1));
            }
            return results;
        })();
        sqDist = function(i, j) {
            var A, B, delta, dist, k, ref;
            A = points[i];
            B = points[j];
            dist = 0;
            for (i = k = 0, ref = A.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                delta = A[i] - B[i];
                dist += delta * delta;
            }
            return dist;
        };
        kdists = (function() {
            var k, ref, results;
            results = [];
            for (i = k = 0, ref = points.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                results.push(sqDist(i, neighbors[i][K - 1]));
            }
            return results;
        })();
        reachDist = function(i, j) {
            return Math.max(sqDist(i, j), kdists[j]);
        };
        ldr = function(i) {
            var j, k, len, rDist, ref;
            rDist = 0;
            ref = neighbors[i];
            for (k = 0, len = ref.length; k < len; k++) {
                j = ref[k];
                rDist += reachDist(i, j);
            }
            return K / rDist;
        };
        ldrs = (function() {
            var k, ref, results;
            results = [];
            for (i = k = 0, ref = points.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                results.push(ldr(i));
            }
            return results;
        })();
        result = (function() {
            var k, l, len, ref, ref1, results;
            results = [];
            for (i = k = 0, ref = points.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
                avg_lrd = 0;
                ref1 = neighbors[i];
                for (l = 0, len = ref1.length; l < len; l++) {
                    j = ref1[l];
                    avg_lrd += ldrs[j];
                }
                avg_lrd /= K;
                results.push([i, avg_lrd / ldrs[i]]);
            }
            return results;
        })();
        return result.sort(function(a, b) {
            return b[1] - a[1];
        });
    };


},{"static-kdtree":10}],102:[function(require,module,exports){
    module.exports = function(points) {
        var mad, median, result;
        median = d3.median(points);
        mad = d3.median(points.map(function(p) {
            return Math.abs(p - median);
        }));
        result = points.map(function(p, i) {
            return [i, Math.abs(p - median) / mad];
        });
        return result.sort(function(a, b) {
            return b[1] - a[1];
        });
    };


},{}],103:[function(require,module,exports){
    var fontTester;

    fontTester = require("../core/font/tester.coffee");

    module.exports = function(words, style, opts) {
        var attr, getHeight, getWidth, sizes, spacing, tester, tspans;
        if (!opts) {
            opts = {};
        }
        style = style || {};
        tester = opts.parent || fontTester("svg").append("text");
        sizes = [];
        if (!(words instanceof Array)) {
            words = [words];
        }
        tspans = tester.selectAll("tspan").data(words);
        attr = {
            left: "0px",
            position: "absolute",
            top: "0px",
            x: 0,
            y: 0
        };
        spacing = 0;
        if ("letter-spacing" in style) {
            spacing = parseFloat(style["letter-spacing"]);
            delete style["letter-spacing"];
        }
        getWidth = function(elem) {
            var add;
            add = 0;
            if (spacing) {
                add = (d3.select(elem).text().length - 1) * spacing;
            }
            return elem.getComputedTextLength() + add;
        };
        getHeight = function(elem) {
            return elem.parentNode.getBBox().height || elem.getBoundingClientRect().height;
        };
        tspans.enter().append("tspan").text(String).style(style).attr(attr).each(function(d) {
            if (typeof opts.mod === "function") {
                return opts.mod(this);
            }
        }).each(function(d) {
            var children, height, width;
            children = d3.select(this).selectAll("tspan");
            if (children.size()) {
                width = [];
                children.each(function() {
                    return width.push(getWidth(this));
                });
                width = d3.max(width);
            } else {
                width = getWidth(this);
            }
            height = getHeight(this);
            return sizes.push({
                height: height,
                text: d,
                width: width
            });
        });
        tspans.remove();
        if (!opts.parent) {
            tester.remove();
        }
        return sizes;
    };


},{"../core/font/tester.coffee":70}],104:[function(require,module,exports){
    var fontTester, validate;

    fontTester = require("../core/font/tester.coffee");

    validate = function(fontList) {
        var completed, family, font, fontString, i, j, len, len1, monospace, proportional, testElement, testWidth, tester, valid;
        if (!(fontList instanceof Array)) {
            fontList = fontList.split(",");
        }
        for (i = 0, len = fontList.length; i < len; i++) {
            font = fontList[i];
            font.trim();
        }
        fontString = fontList.join(", ");
        completed = validate.complete;
        if (fontString in completed) {
            return completed[fontString];
        }
        testElement = function(font) {
            return tester.append("span").style("font-family", font).style("font-size", "32px").style("padding", "0px").style("margin", "0px").text("abcdefghiABCDEFGHI_!@#$%^&*()_+1234567890");
        };
        testWidth = function(font, control) {
            var elem, width1, width2;
            elem = testElement(font);
            width1 = elem.node().offsetWidth;
            width2 = control.node().offsetWidth;
            elem.remove();
            return width1 !== width2;
        };
        tester = fontTester("div");
        monospace = testElement("monospace");
        proportional = testElement("sans-serif");
        for (j = 0, len1 = fontList.length; j < len1; j++) {
            family = fontList[j];
            valid = testWidth(family + ",monospace", monospace);
            if (!valid) {
                valid = testWidth(family + ",sans-serif", proportional);
            }
            if (valid) {
                valid = family;
                break;
            }
        }
        if (!valid) {
            valid = "sans-serif";
        }
        monospace.remove();
        proportional.remove();
        completed[fontString] = valid;
        return valid;
    };

    validate.complete = {};

    module.exports = validate;


},{"../core/font/tester.coffee":70}],105:[function(require,module,exports){
    var arraySort = require("../array/sort.coffee"),
        attach      = require("../core/methods/attach.coffee"),
        dataFormat  = require("../core/data/format.js"),
        dataKeys    = require("../core/data/keys.coffee"),
        dataLoad    = require("../core/data/load.coffee"),
        fetchData   = require("../core/fetch/data.js"),
        ie          = require("../client/ie.js"),
        methodReset = require("../core/methods/reset.coffee"),
        print       = require("../core/console/print.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Form Element shell
//------------------------------------------------------------------------------
    module.exports = function() {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize the global variable object.
        //----------------------------------------------------------------------------
        var vars = {
            "types": {
                "auto": require("./types/auto.js"),
                "button": require("./types/button/button.coffee"),
                "drop": require("./types/drop/drop.coffee"),
                "toggle": require("./types/toggle.js")
            }
        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Create the main drawing function.
        //----------------------------------------------------------------------------
        vars.self = function( selection ) {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Set timing to 0 if it's the first time running this function or if the
            // data length is longer than the "large" limit
            //--------------------------------------------------------------------------
            var large = vars.data.value instanceof Array && vars.data.value.length > vars.data.large;

            vars.draw.timing = vars.draw.first || large || ie ? 0 : vars.timing.ui;

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create/update the UI element
            //--------------------------------------------------------------------------
            if ( vars.data.value instanceof Array ) {

                if ( vars.dev.value ) print.group("drawing \""+vars.type.value+"\"");

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Analyze new data, if changed.
                //------------------------------------------------------------------------
                if ( vars.data.changed ) {
                    vars.data.cache = {};
                    dataKeys( vars , "data" );
                    dataFormat( vars );
                }

                vars.data.viz = fetchData( vars );

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Sort the data, if needed.
                //------------------------------------------------------------------------
                if (vars.data.sort.value && (vars.data.changed || vars.order.changed || vars.order.sort.changed) ) {
                    arraySort( vars.data.viz , vars.order.value || vars.text.value,
                        vars.order.sort.value , vars.color.value , vars );
                }

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Set first element in data as focus if there is no focus set.
                //------------------------------------------------------------------------
                if (vars.focus.value === false && ["auto", "button"].indexOf(vars.type.value) < 0) {

                    var element = vars.data.element.value;

                    if ( element && element.node().tagName.toLowerCase() === "select" ) {
                        var i = element.property("selectedIndex");
                        i = i < 0 ? 0 : i;
                        var option = element.selectAll("option")[0][i],
                            val = option.getAttribute("data-"+vars.id.value) || option.getAttribute(vars.id.value);
                        if (val) vars.focus.value = val;
                    }

                    if ( vars.focus.value === false && vars.data.viz.length ) {
                        vars.focus.value = vars.data.viz[0][vars.id.value];
                    }

                    if (vars.dev.value && vars.focus.value !== false) print.log("\"value\" set to \""+vars.focus.value+"\"");

                }

                var getLevel = function(d,depth) {

                    depth = typeof depth !== "number" ? vars.id.nesting.length === 1 ? 0 : vars.id.nesting.length-1 : depth;
                    var level = vars.id.nesting[depth];

                    if ( depth > 0 && (!(level in d) || d[level] instanceof Array) ) {
                        return getLevel(d,depth-1);
                    }
                    else {
                        return level;
                    }

                };

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Run these things if the data has changed.
                //------------------------------------------------------------------------
                if ( vars.data.changed ) {

                    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    // Determine if search box is needed.
                    //----------------------------------------------------------------------
                    if ( vars.search.value === "auto" ) {

                        if (vars.data.viz.length > 10) {
                            vars.search.enabled = true;
                            if ( vars.dev.value ) print.log("Search enabled.");
                        }
                        else {
                            vars.search.enabled = false;
                            if ( vars.dev.value ) print.log("Search disabled.");
                        }

                    }
                    else {

                        vars.search.enabled = vars.search.value;

                    }

                    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    // Update OPTION elements with the new data.
                    //----------------------------------------------------------------------
                    var elementTag = vars.data.element.value ? vars.data.element.value.node().tagName.toLowerCase() : "";
                    if ( vars.data.element.value && elementTag === "select" ) {

                        var optionData = [];
                        for (var level in vars.data.nested.all) {
                            optionData = optionData.concat(vars.data.nested.all[level]);
                        }

                        options = vars.data.element.value.selectAll("option")
                            .data(optionData,function(d){
                                var level = d ? getLevel(d) : false;
                                return d && level in d ? d[level] : false;
                            });

                        options.exit().remove();

                        options.enter().append("option");

                        options
                            .each(function(d){

                                var level   = getLevel(d),
                                    textKey = level === vars.id.value ? vars.text.value || vars.id.value
                                        : vars.text.nesting !== true && level in vars.text.nesting ? vars.text.nesting[level] : level;

                                for ( var k in d ) {

                                    if ( typeof d[k] !== "object" ) {

                                        if ( k === textKey ) {
                                            d3.select(this).html(d[k]);
                                        }

                                        if ( ["alt","value"].indexOf(k) >= 0 ) {
                                            d3.select(this).attr(k,d[k]);
                                        }
                                        else {
                                            d3.select(this).attr("data-"+k,d[k]);
                                        }

                                    }

                                }

                                if (d[level] === vars.focus.value) {
                                    this.selected = true;
                                }
                                else {
                                    this.selected = false;
                                }

                            });

                    }

                }
                else if (vars.focus.changed && vars.data.element.value) {
                    var tag = vars.data.element.value.node().tagName.toLowerCase();
                    if (tag === "select") {
                        vars.data.element.value.selectAll("option")
                            .each(function(d){
                                if (d[getLevel(d)] === vars.focus.value) {
                                    this.selected = true;
                                }
                                else {
                                    this.selected = false;
                                }
                            });
                    }
                    else {
                        var tag = vars.data.element.value.attr("type").toLowerCase();
                        if (tag === "radio") {
                            vars.data.element.value
                                .each(function(d){
                                    if (this.value === vars.focus.value) {
                                        this.checked = true;
                                    }
                                    else {
                                        this.checked = false;
                                    }
                                })
                        }
                    }
                }

                if ( vars.type.value !== "auto" ) {

                    if ( !vars.container.ui ) {

                        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        // Select container DIV for UI element
                        //----------------------------------------------------------------------
                        vars.container.ui = vars.container.value
                            .selectAll("div#d3plus_"+vars.type.value+"_"+vars.container.id)
                            .data(["container"]);

                        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                        // Create container DIV for UI element
                        //----------------------------------------------------------------------
                        var before = vars.data.element.value ? vars.data.element.value[0][0] : null;

                        if ( before ) {

                            if ( before.id ) {
                                before = "#"+before.id;
                            }
                            else {

                                var id = before.getAttribute(vars.id.value) ? vars.id.value : "data-"+vars.id.value;

                                if ( before.getAttribute(id) ) {
                                    before = "["+id+"="+before.getAttribute(id)+"]";
                                }
                                else {
                                    before = null;
                                }

                            }

                        }

                        vars.container.ui.enter()
                            .insert("div",before)
                            .attr("id","d3plus_"+vars.type.value+"_"+vars.container.id)
                            .style("position","relative")
                            .style("overflow","visible")
                            .style("vertical-align","top");

                    }

                    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    // Update Container
                    //------------------------------------------------------------------------
                    vars.container.ui
                        .style("display", vars.ui.display.value);

                    vars.container.ui.transition().duration(vars.draw.timing)
                        .style("margin", vars.ui.margin.css);

                    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                    // Create title, if available.
                    //------------------------------------------------------------------------
                    var title = vars.container.ui.selectAll("div.d3plus_title")
                        .data(vars.title.value ? [vars.title.value] : []);

                    title.enter().insert("div","#d3plus_"+vars.type.value+"_"+vars.container.id)
                        .attr("class","d3plus_title")
                        .style("display","inline-block");

                    title
                        .style("color",vars.font.color)
                        .style("font-family",vars.font.family.value)
                        .style("font-size",vars.font.size+"px")
                        .style("font-weight",vars.font.weight)
                        .style("padding",vars.ui.padding.css)
                        .style("border-color","transparent")
                        .style("border-style","solid")
                        .style("border-width",vars.ui.border+"px")
                        .text(String)
                        .each(function(d){
                            vars.margin.left = this.offsetWidth;
                        });

                }

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Call specific UI element type, if there is data.
                //------------------------------------------------------------------------
                if ( vars.data.value.length ) {

                    var app = vars.format.locale.value.visualization[vars.type.value];
                    if ( vars.dev.value ) print.time("drawing "+ app);
                    vars.types[vars.type.value]( vars );
                    if ( vars.dev.value ) print.timeEnd("drawing "+ app);

                }
                else if ( vars.data.url && (!vars.data.loaded || vars.data.stream) ) {

                    dataLoad( vars , "data" , vars.self.draw );

                }

                //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                // Initialization complete
                //------------------------------------------------------------------------
                if (vars.dev.value) print.timeEnd("total draw time");
                methodReset( vars );

            }

        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Define methods and expose public variables.
        //----------------------------------------------------------------------------
        attach(vars, {
            "active":    require("./methods/active.coffee"),
            "alt":       require("./methods/alt.coffee"),
            "color":     require("./methods/color.coffee"),
            "config":    require("./methods/config.coffee"),
            "container": require("./methods/container.coffee"),
            "data":      require("./methods/data.js"),
            "depth":     require("./methods/depth.coffee"),
            "dev":       require("./methods/dev.coffee"),
            "draw":      require("./methods/draw.js"),
            "focus":     require("./methods/focus.coffee"),
            "font":      require("./methods/font.coffee"),
            "format":    require("./methods/format.coffee"),
            "height":    require("./methods/height.coffee"),
            "history":   require("./methods/history.coffee"),
            "hover":     require("./methods/hover.coffee"),
            "icon":      require("./methods/icon.coffee"),
            "id":        require("./methods/id.coffee"),
            "keywords":  require("./methods/keywords.coffee"),
            "margin":    require("./methods/margin.coffee"),
            "open":      require("./methods/open.coffee"),
            "order":     require("./methods/order.coffee"),
            "remove":    require("./methods/remove.coffee"),
            "search":    require("./methods/search.coffee"),
            "select":    require("./methods/select.coffee"),
            "selectAll": require("./methods/selectAll.coffee"),
            "text":      require("./methods/text.coffee"),
            "timing":    require("./methods/timing.coffee"),
            "title":     require("./methods/title.coffee"),
            "type":      require("./methods/type.coffee"),
            "ui":        require("./methods/ui.coffee"),
            "width":     require("./methods/width.coffee")
        });

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Finally, return the main UI function to the user
        //----------------------------------------------------------------------------
        return vars.self;

    };

},{"../array/sort.coffee":36,"../client/ie.js":39,"../core/console/print.coffee":54,"../core/data/format.js":58,"../core/data/keys.coffee":60,"../core/data/load.coffee":61,"../core/fetch/data.js":66,"../core/methods/attach.coffee":81,"../core/methods/reset.coffee":94,"./methods/active.coffee":106,"./methods/alt.coffee":107,"./methods/color.coffee":108,"./methods/config.coffee":109,"./methods/container.coffee":110,"./methods/data.js":111,"./methods/depth.coffee":112,"./methods/dev.coffee":113,"./methods/draw.js":114,"./methods/focus.coffee":115,"./methods/font.coffee":116,"./methods/format.coffee":117,"./methods/height.coffee":118,"./methods/history.coffee":119,"./methods/hover.coffee":120,"./methods/icon.coffee":121,"./methods/id.coffee":122,"./methods/keywords.coffee":123,"./methods/margin.coffee":124,"./methods/open.coffee":125,"./methods/order.coffee":126,"./methods/remove.coffee":127,"./methods/search.coffee":128,"./methods/select.coffee":129,"./methods/selectAll.coffee":130,"./methods/text.coffee":131,"./methods/timing.coffee":132,"./methods/title.coffee":133,"./methods/type.coffee":134,"./methods/ui.coffee":135,"./methods/width.coffee":136,"./types/auto.js":137,"./types/button/button.coffee":138,"./types/drop/drop.coffee":143,"./types/toggle.js":160}],106:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Array, Function, Number, String],
        value: false
    };


},{"../../core/methods/filter.coffee":82}],107:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        mute: filter(true),
        solo: filter(true),
        value: "alt"
    };


},{"../../core/methods/filter.coffee":82}],108:[function(require,module,exports){
    module.exports = {
        accepted: [String],
        value: "color"
    };


},{}],109:[function(require,module,exports){
    module.exports = {
        accepted: [Object],
        objectAccess: false,
        process: function(value, vars) {
            var method, setting;
            for (method in value) {
                setting = value[method];
                if (method in vars.self) {
                    vars.self[method](setting);
                }
            }
            return value;
        },
        value: {}
    };


},{}],110:[function(require,module,exports){
    var d3selection;

    d3selection = require("../../util/d3selection.coffee");

    module.exports = {
        accepted: [false, Array, Object, String],
        element: false,
        id: "default",
        process: function(value) {
            if (value === false) {
                return d3.select("body");
            } else if (d3selection(value)) {
                return value;
            } else if (value instanceof Array) {
                return d3.select(value[0][0]);
            } else {
                return d3.select(value);
            }
        },
        value: d3.select("body")
    };


},{"../../util/d3selection.coffee":210}],111:[function(require,module,exports){
    var d3selection = require("../../util/d3selection.coffee"),
        process = require("../../core/methods/process/data.coffee");

    module.exports = {
        "accepted" : [ false , Array , Function , String ],
        "delimiter" : {
            "accepted" : [ String ],
            "value"    : "|"
        },
        "element": {
            "process": function(value, vars) {

                var element = false;

                if ( d3selection(value) ) {
                    element = value;
                }
                else if (typeof value === "string" && !d3.select(value).empty()) {
                    element = d3.select(value);
                }

                if (element) {
                    vars.self.container(d3.select(element.node().parentNode));
                }

                return element;

            },
            "value": false
        },
        "filetype" : {
            "accepted" : [false, "json", "xml", "html", "csv", "dsv", "tsv", "txt"],
            "value"    : false
        },
        "filters"  : [],
        "large": 400,
        "mute"     : [],
        "process"  : function(value, vars) {

            if ( vars.container.id === "default" && value.length ) {
                vars.self.container({"id": "default"+value.length});
            }

            return process(value, vars, this);
        },
        "solo"     : [],
        "sort": {
            "accepted": [Boolean],
            "value":    false
        },
        "value"    : false
    };

},{"../../core/methods/process/data.coffee":88,"../../util/d3selection.coffee":210}],112:[function(require,module,exports){
    module.exports = {
        accepted: [Number],
        value: 0
    };


},{}],113:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean],
        value: false
    };


},{}],114:[function(require,module,exports){
    var d3selection  = require("../../util/d3selection.coffee"),
        hideElement  = require("../../core/parse/hideElement.js"),
        parseElement = require("../../core/parse/element.js"),
        print        = require("../../core/console/print.coffee"),
        stringFormat = require("../../string/format.js")

    module.exports = {
        "accepted" : [ undefined , Function ],
        "first"    : true,
        "frozen"   : false,
        "process"  : function (value, vars) {

            if ( this.initialized === false ) {
                this.initialized = true
                return value
            }

            if (vars.data.value && (!(vars.data.value instanceof Array) || d3selection(vars.data.value))) {
                vars.data.value = parseElement( vars )
            }
            else if (vars.data.element.value) {
                vars.data.element.value.call(hideElement);
            }

            if ( value === undefined && typeof this.value === "function" ) {
                value = this.value
            }

            if ( vars.container.value === false ) {

                var str = vars.format.locale.value.dev.setContainer
                print.warning( str , "container" )

            }
            else if ( vars.container.value.empty() ) {

                var str = vars.format.locale.value.dev.noContainer
                print.warning( stringFormat(str,"\""+vars.container.value+"\"") , "container" )

            }
            else {

                if (vars.dev.value) print.time("total draw time");

                vars.container.value.call(vars.self);

            }

            if ( typeof value === "function" && vars.history.chain.length ) {

                var changesObject = {}
                changes.forEach(function(c){
                    var method = c.method
                    delete c.method
                    changesObject[method] = c
                })

                value(changesObject)

                vars.history.chain = []

            }

            return value

        },
        "update"   : true,
        "value"    : undefined
    }

},{"../../core/console/print.coffee":54,"../../core/parse/element.js":97,"../../core/parse/hideElement.js":98,"../../string/format.js":175,"../../util/d3selection.coffee":210}],115:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number, String],
        deprecates: "highlight",
        process: function(value, vars) {
            var d, element, elementTag, elementType, i, j, k, len, len1, ref;
            element = vars.data.element.value;
            if (element && ["string", "number"].indexOf(typeof value) >= 0) {
                elementTag = element.node().tagName.toLowerCase();
                elementType = element.attr("type");
                if (elementTag === "select") {
                    ref = element.selectAll("option");
                    for (i = j = 0, len = ref.length; j < len; i = ++j) {
                        d = ref[i];
                        if (d && d[vars.id.value] === value) {
                            element.node().selectedIndex = i;
                        }
                    }
                } else if (elementTag === "input" && elementType === "radio") {
                    for (k = 0, len1 = element.length; k < len1; k++) {
                        d = element[k];
                        this.checked = d && d[vars.id.value] === value;
                    }
                }
            }
            return value;
        },
        value: false
    };


},{}],116:[function(require,module,exports){
    var align, decoration, family, transform;

    family = require("../../core/methods/font/family.coffee");

    align = require("../../core/methods/font/align.coffee");

    decoration = require("../../core/methods/font/decoration.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        align: align(),
        color: "#444444",
        decoration: decoration(),
        family: family(),
        secondary: {
            align: align(),
            color: "#444444",
            decoration: decoration(),
            family: family(),
            size: 12,
            spacing: 0,
            transform: transform(),
            weight: 200
        },
        size: 12,
        spacing: 0,
        transform: transform(),
        weight: 200
    };


},{"../../core/methods/font/align.coffee":83,"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],117:[function(require,module,exports){
    var formatNumber, locale, mergeObject, titleCase;

    formatNumber = require("../../number/format.coffee");

    locale = require("../../core/locale/locale.coffee");

    mergeObject = require("../../object/merge.coffee");

    titleCase = require("../../string/title.coffee");

    module.exports = {
        accepted: [Function, String],
        affixes: {
            accepted: [Object],
            objectAccess: false,
            value: {}
        },
        deprecates: ["number_format", "text_format"],
        locale: {
            accepted: function() {
                return d3.keys(locale);
            },
            process: function(value) {
                var defaultLocale, returnObject;
                defaultLocale = "en_US";
                returnObject = locale[defaultLocale];
                if (value !== defaultLocale) {
                    returnObject = mergeObject(returnObject, locale[value]);
                }
                this.language = value;
                return returnObject;
            },
            value: "en_US"
        },
        number: {
            accepted: [false, Function],
            value: false
        },
        process: function(value, vars) {
            if (typeof value === "string") {
                vars.self.format({
                    locale: value
                });
            } else {
                if (typeof value === "function") {
                    return value;
                }
            }
            return this.value;
        },
        text: {
            accepted: [false, Function],
            value: false
        },
        value: function(value, opts) {
            var f, v, vars;
            if (!opts) {
                opts = {};
            }
            vars = opts.vars || {};
            if (vars.time && vars.time.value && opts.key === vars.time.value) {
                v = value.constructor === Date ? value : new Date(value);
                return vars.data.time.format(v);
            } else if (typeof value === "number") {
                f = this.number.value || formatNumber;
                return f(value, opts);
            } else if (typeof value === "string") {
                f = this.text.value || titleCase;
                return f(value, opts);
            } else {
                return JSON.stringify(value);
            }
        }
    };


},{"../../core/locale/locale.coffee":80,"../../number/format.coffee":172,"../../object/merge.coffee":173,"../../string/title.coffee":178}],118:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number],
        max: 600,
        secondary: false,
        value: false
    };


},{}],119:[function(require,module,exports){
    module.exports = {
        back: function() {
            if (this.states.length) {
                return this.states.pop()();
            }
        },
        chain: [],
        reset: function() {
            var results;
            results = [];
            while (this.states.length) {
                results.push(this.states.pop()());
            }
            return results;
        },
        states: []
    };


},{}],120:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean, Number, String],
        value: false
    };


},{}],121:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/icon.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        back: {
            accepted: [false, String],
            fallback: "&#x276e;",
            opacity: 1,
            process: process,
            rotate: 0,
            value: "fa-angle-left"
        },
        button: {
            accepted: [false, String],
            fallback: false,
            opacity: 1,
            process: process,
            rotate: 0,
            value: false
        },
        drop: {
            accepted: [false, String],
            fallback: "&#x276f;",
            opacity: 1,
            process: process,
            rotate: 0,
            value: "fa-angle-down"
        },
        next: {
            accepted: [false, String],
            fallback: "&#x276f;",
            opacity: 1,
            process: process,
            rotate: 0,
            value: "fa-angle-right"
        },
        select: {
            accepted: [false, String],
            fallback: "&#x2713;",
            opacity: 1,
            process: process,
            rotate: 0,
            value: "fa-check"
        },
        style: {
            accepted: [Object, String],
            value: "default"
        },
        value: "icon"
    };


},{"../../core/methods/process/icon.coffee":90}],122:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [Array, String],
        dataFilter: true,
        mute: filter(true),
        nesting: ["value"],
        solo: filter(true),
        value: "value"
    };


},{"../../core/methods/filter.coffee":82}],123:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        mute: filter(true),
        solo: filter(true),
        value: "keywords"
    };


},{"../../core/methods/filter.coffee":82}],124:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/margin.coffee");

    module.exports = {
        accepted: [Number, Object, String],
        process: function(value) {
            var userValue;
            if (value === void 0) {
                value = this.value;
            }
            userValue = value;
            process(value, this);
            return userValue;
        },
        value: 0
    };


},{"../../core/methods/process/margin.coffee":91}],125:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean],
        flipped: {
            accepted: [Boolean],
            value: false
        },
        value: false
    };


},{}],126:[function(require,module,exports){
    module.exports = {
        accepted: [false, Function, String],
        sort: {
            accepted: ["asc", "desc"],
            deprecates: ["sort"],
            value: "asc"
        },
        value: false
    };


},{}],127:[function(require,module,exports){
    module.exports = {
        accepted: void 0,
        process: function(value, vars) {
            if (this.initialized) {
                vars.container.value.remove();
            }
        },
        value: void 0
    };


},{}],128:[function(require,module,exports){
    module.exports = {
        accepted: ["auto", Boolean],
        process: function(value) {
            if (typeof value === "Boolean") {
                this.enabled = value;
            }
            return value;
        },
        term: "",
        value: "auto"
    };


},{}],129:[function(require,module,exports){
    module.exports = {
        accepted: [String],
        chainable: false,
        process: function(value, vars) {
            var container;
            container = vars.container.value;
            if (container && value) {
                return container.select(value);
            } else {
                return value;
            }
        },
        value: void 0
    };


},{}],130:[function(require,module,exports){
    module.exports = {
        accepted: [String],
        chainable: false,
        process: function(value, vars) {
            var container;
            container = vars.container.value;
            if (container && value) {
                return container.selectAll(value);
            } else {
                return value;
            }
        },
        value: void 0
    };


},{}],131:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, String],
        nesting: true,
        mute: filter(true),
        solo: filter(true),
        secondary: {
            accepted: [false, String],
            nesting: true,
            value: false
        },
        value: false
    };


},{"../../core/methods/filter.coffee":82}],132:[function(require,module,exports){
    module.exports = {
        mouseevents: 60,
        ui: 200
    };


},{}],133:[function(require,module,exports){
    var decoration, family, stringStrip, transform;

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    stringStrip = require("../../string/strip.js");

    module.exports = {
        accepted: [false, Function, String],
        font: {
            align: "center",
            color: "#444444",
            decoration: decoration(),
            family: family(),
            size: 16,
            transform: transform(),
            weight: 400
        },
        link: false,
        process: function(value, vars) {
            var id;
            if (vars.container.id.indexOf("default") === 0 && value) {
                id = stringStrip(value).toLowerCase();
                vars.self.container({
                    id: id
                });
            }
            return value;
        },
        value: false
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87,"../../string/strip.js":177}],134:[function(require,module,exports){
    module.exports = {
        accepted: function(vars) {
            return d3.keys(vars.types);
        },
        value: "auto"
    };


},{}],135:[function(require,module,exports){
    var align, decoration, family, margin, transform;

    family = require("../../core/methods/font/family.coffee");

    align = require("../../core/methods/font/align.coffee");

    decoration = require("../../core/methods/font/decoration.coffee");

    margin = require("../../core/methods/process/margin.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        align: align("center"),
        border: 1,
        color: {
            primary: {
                process: function(value, vars) {
                    var primary;
                    primary = this.value;
                    if (!vars.ui.color.secondary.value) {
                        vars.ui.color.secondary.value = d3.rgb(primary).darker(0.75).toString();
                    }
                    return value;
                },
                value: "#ffffff"
            },
            secondary: {
                value: false
            }
        },
        display: {
            acceped: ["block", "inline-block"],
            value: "inline-block"
        },
        font: {
            align: align("center"),
            color: "#444",
            decoration: decoration(),
            family: family(),
            size: 11,
            transform: transform(),
            weight: 200
        },
        margin: {
            process: function(value) {
                var userValue;
                if (value === void 0) {
                    value = this.value;
                }
                userValue = value;
                margin(value, this);
                return userValue;
            },
            value: 5
        },
        padding: {
            process: function(value) {
                var userValue;
                if (value === void 0) {
                    value = this.value;
                }
                userValue = value;
                margin(value, this);
                return userValue;
            },
            value: 5
        }
    };


},{"../../core/methods/font/align.coffee":83,"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87,"../../core/methods/process/margin.coffee":91}],136:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number],
        secondary: false,
        value: false
    };


},{}],137:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Determines form type based on data length.
//------------------------------------------------------------------------------
    module.exports = function( vars ) {

        var dataLength = vars.data.value.length

        if ( dataLength === 1 ) {
            vars.self.type("button").draw()
        }
        else if ( dataLength < 5 ) {
            vars.self.type("toggle").draw()
        }
        else {
            vars.self.type("drop").draw()
        }

    }

},{}],138:[function(require,module,exports){
    module.exports = function(vars) {
        var button, checks, color, icons, mouseevents, print, style, updatedButtons;
        print = require("../../../core/console/print.coffee");
        color = require("./functions/color.coffee");
        icons = require("./functions/icons.js");
        mouseevents = require("./functions/mouseevents.coffee");
        style = require("./functions/style.js");
        button = vars.container.ui.selectAll('div.d3plus_node').data(vars.data.viz, function(d) {
            return d[vars.id.value];
        });
        if (vars.dev.value) {
            print.time("enter");
        }
        button.enter().append("div").attr("class", "d3plus_node").call(color, vars).call(style, vars).call(icons, vars).call(mouseevents, vars);
        if (vars.dev.value) {
            print.timeEnd("enter");
        }
        if (vars.draw.update || vars.draw.timing) {
            if (vars.dev.value) {
                print.time("ordering");
            }
            button.order();
            if (vars.dev.value) {
                print.timeEnd("ordering");
            }
            updatedButtons = button;
        } else {
            checks = [vars.focus.previous, vars.focus.value, vars.hover.previous, vars.hover.value].filter(function(c) {
                return c;
            });
            updatedButtons = button.filter(function(b) {
                return checks.indexOf(b[vars.id.value]) >= 0;
            });
        }
        if (vars.dev.value) {
            print.time("update");
        }
        updatedButtons.classed("d3plus_button_active", function(d) {
            return vars.focus.value === d[vars.id.value];
        });
        if (vars.draw.timing) {
            updatedButtons.transition().duration(vars.draw.timing).call(color, vars).call(style, vars);
        } else {
            updatedButtons.call(color, vars).call(style, vars);
        }
        updatedButtons.call(icons, vars).call(mouseevents, vars);
        if (vars.dev.value) {
            print.timeEnd("update");
        }
        return button.exit().remove();
    };


},{"../../../core/console/print.coffee":54,"./functions/color.coffee":139,"./functions/icons.js":140,"./functions/mouseevents.coffee":141,"./functions/style.js":142}],139:[function(require,module,exports){
    module.exports = function(elem, vars) {
        var legible, lighter, textColor;
        legible = require("../../../../color/legible.coffee");
        lighter = require("../../../../color/lighter.coffee");
        textColor = require("../../../../color/text.coffee");
        return elem.style("background-color", function(d) {
            var color;
            if (vars.focus.value === d[vars.id.value]) {
                color = vars.ui.color.secondary.value;
            } else {
                color = vars.ui.color.primary.value;
            }
            if (vars.hover.value === d[vars.id.value]) {
                color = d3.rgb(color).darker(0.15).toString();
            }
            return color;
        }).style("color", function(d) {
            var bg, color, image, opacity;
            if (vars.focus.value === d[vars.id.value]) {
                opacity = 0.75;
            } else {
                opacity = 1;
            }
            image = d[vars.icon.value] && vars.data.viz.length < vars.data.large;
            if (!image && d[vars.color.value]) {
                color = legible(d[vars.color.value]);
            } else {
                if (vars.focus.value === d[vars.id.value]) {
                    bg = vars.ui.color.secondary.value;
                } else {
                    bg = vars.ui.color.primary.value;
                }
                if (vars.hover.value === d[vars.id.value]) {
                    bg = d3.rgb(bg).darker(0.15).toString();
                }
                color = textColor(bg);
            }
            color = d3.rgb(color);
            return "rgba(" + color.r + "," + color.g + "," + color.b + "," + opacity + ")";
        }).style('border-color', vars.ui.color.secondary.value);
    };


},{"../../../../color/legible.coffee":46,"../../../../color/lighter.coffee":47,"../../../../color/text.coffee":52}],140:[function(require,module,exports){
    var prefix = require("../../../../client/prefix.coffee"),
        rtl = require("../../../../client/rtl.coffee")

    module.exports = function ( elem , vars ) {

        var reversed = (vars.font.align.value === "right" && !rtl)
            || (rtl && vars.font.align.value === "right")

        elem
            .each(function(d,i){

                var children = ["label"]

                if ( d[vars.icon.value] && vars.data.viz.length <= vars.data.large ) {
                    children.push("icon")
                }

                var iconGraphic = vars.icon.button.value
                if ( d[vars.id.value] === vars.focus.value && vars.icon.select.value ) {
                    iconGraphic = vars.icon.select.value
                    children.push("selected")
                }
                else if ( iconGraphic && d.d3plus.icon !== false ) {
                    children.push("selected")
                }

                var buffer = 0

                var items = d3.select(this).selectAll("div.d3plus_button_element")
                    .data(children,function(c){
                        return c
                    })

                items.enter().append("div")
                    .style("display",function(c){
                        return c === "label" ? "block" : "absolute"
                    })

                items.order()
                    .attr("class",function(c){
                        var extra = ""
                        if ( c === "selected" && iconGraphic.indexOf("fa-") === 0 ) {
                            extra = " fa "+iconGraphic
                        }
                        return "d3plus_button_element d3plus_button_" + c + extra
                    })
                    .html(function(c){
                        if ( c === "label" ) {
                            var k = vars.text.value && vars.text.value in d && !(d[vars.text.value] instanceof Array)
                                ? vars.text.value : vars.id.value
                            return vars.format.value(d[k])
                        }
                        return c === "selected" && iconGraphic.indexOf("fa-") < 0
                            ? iconGraphic : ""
                    })
                    .style("background-image",function(c){
                        if (c === "icon") {
                            return "url('"+d[vars.icon.value]+"')"
                        }
                        return "none"
                    })
                    .style("background-color",function(c){
                        if (c === "icon" && d.style === "knockout") {
                            return d[vars.color.value] || vars.ui.color.primary.value
                        }
                        return "transparent"
                    })
                    .style("background-size","100%")
                    .style("text-align",function(c){
                        return c === "label" ? vars.font.align.value : "center"
                    })
                    .style("position",function(c){
                        return c == "label" ? "static" : "absolute"
                    })
                    .style("width",function(c){

                        if ( c === "label" ) {
                            return "auto"
                        }

                        if (vars.height.value) {
                            buffer = (vars.height.value-(vars.ui.padding.top + vars.ui.padding.bottom)-(vars.ui.border*2));
                        }
                        else {
                            buffer = vars.font.size+vars.ui.border;
                        }
                        return buffer+"px"
                    })
                    .style("height",function(c){
                        if ( c === "icon" ) {
                            return buffer+"px"
                        }
                        return "auto"
                    })
                    .style("margin-top",function(c){
                        if ( c === "label" ) {
                            return "0px"
                        }
                        if (this.offsetHeight || this.getBoundingClientRect().height) {
                            var h = this.offsetHeight || this.getBoundingClientRect().height
                        }
                        else if ( c === "selected" ) {
                            var h = vars.font.size
                        }
                        else {
                            var h = buffer
                        }
                        return -h/2+"px"
                    })
                    .style("top",function(c){
                        return c === "label" ? "auto" : "50%"
                    })
                    .style("left",function(c){
                        if ((c === "icon" && !reversed) || (c === "selected" && reversed)) {
                            return vars.ui.padding.left+"px"
                        }
                        return "auto"
                    })
                    .style("right",function(c){
                        if ((c === "icon" && reversed) || (c === "selected" && !reversed)) {
                            return vars.ui.padding.right+"px"
                        }
                        return "auto"
                    })
                    .style(prefix()+"transition",function(c){
                        return c === "selected" ? (vars.draw.timing/1000)+"s" : "none"
                    })
                    .style(prefix()+"transform",function(c){
                        var degree = c === "selected" ? vars.icon.select.rotate : "none"
                        return typeof degree === "string" ? degree : "rotate("+degree+"deg)"
                    })
                    .style("opacity",function(c){
                        return c === "selected" ? vars.icon.select.opacity : 1
                    })

                items.exit().remove()

                var text = d3.select(this).selectAll(".d3plus_button_label")

                if (buffer > 0) {

                    var p = vars.ui.padding;

                    if (children.length === 3) {
                        p = p.top+"px "+(p.right*2+buffer)+"px "+p.bottom+"px "+(p.left*2+buffer)+"px";
                    }
                    else if ((children.indexOf("icon") >= 0 && !rtl) || (children.indexOf("selected") >= 0 && rtl)) {
                        p = p.top+"px "+p.right+"px "+p.bottom+"px "+(p.left*2+buffer)+"px";
                    }
                    else {
                        p = p.top+"px "+(p.right*2+buffer)+"px "+p.bottom+"px "+p.left+"px";
                    }

                    text.style("padding", p)

                }
                else {
                    text.style("padding",vars.ui.padding.css)
                }

                if (typeof vars.width.value === "number") {
                    var width = vars.width.value
                    width -= parseFloat(text.style("padding-left"),10)
                    width -= parseFloat(text.style("padding-right"),10)
                    width -= vars.ui.border*2
                    width += "px"
                }
                else {
                    var width = "auto"
                }

                text.style("width",width)

            })

    }

},{"../../../../client/prefix.coffee":41,"../../../../client/rtl.coffee":42}],141:[function(require,module,exports){
    module.exports = function(elem, vars, color) {
        var events, ie;
        color = require("./color.coffee");
        events = require("../../../../client/pointer.coffee");
        ie = require("../../../../client/ie.js");
        return elem.on(events.over, function(d, i) {
            vars.self.hover(d[vars.id.value]);
            if (ie || !vars.draw.timing) {
                return d3.select(this).style("cursor", "pointer").call(color, vars);
            } else {
                return d3.select(this).style("cursor", "pointer").transition().duration(vars.timing.mouseevents).call(color, vars);
            }
        }).on(events.out, function(d) {
            vars.self.hover(false);
            if (ie || !vars.draw.timing) {
                return d3.select(this).style("cursor", "auto").call(color, vars);
            } else {
                return d3.select(this).style("cursor", "auto").transition().duration(vars.timing.mouseevents).call(color, vars);
            }
        }).on(events.click, function(d) {
            if (vars.focus.value !== false) {
                return vars.self.focus(d[vars.id.value]).draw();
            } else if (vars.focus.callback) {
                return vars.focus.callback(d, vars.self);
            }
        });
    };


},{"../../../../client/ie.js":39,"../../../../client/pointer.coffee":40,"./color.coffee":139}],142:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//
//------------------------------------------------------------------------------
    module.exports = function ( elem , vars ) {

        elem
            .style("position","relative")
            .style("margin",vars.ui.margin.css)
            .style("display",vars.ui.display.value)
            .style("border-style","solid")
            .style("border-width",vars.ui.border+"px")
            .style("font-family",vars.font.family.value)
            .style("font-size",vars.font.size+"px")
            .style("font-weight",vars.font.weight)
            .style("letter-spacing",vars.font.spacing+"px")

    }

},{}],143:[function(require,module,exports){
    module.exports = function(vars) {
        var button, data, element, keyboard, list, search, selector, title, update, width, windowevent;
        element = require("./functions/element.coffee");
        keyboard = require("./functions/keyboard.coffee");
        windowevent = require("./functions/window.js");
        width = require("./functions/width.js");
        button = require("./functions/button.js");
        selector = require("./functions/selector.js");
        title = require("./functions/title.js");
        search = require("./functions/search.js");
        list = require("./functions/list.js");
        data = require("./functions/data.js");
        update = require("./functions/update.js");
        vars.margin.top = 0;
        vars.margin.title = 0;
        element(vars);
        keyboard(vars);
        windowevent(vars);
        width(vars);
        button(vars);
        selector(vars);
        title(vars);
        search(vars);
        list(vars);
        data(vars);
        return update(vars);
    };


},{"./functions/button.js":146,"./functions/data.js":147,"./functions/element.coffee":148,"./functions/keyboard.coffee":151,"./functions/list.js":152,"./functions/search.js":154,"./functions/selector.js":155,"./functions/title.js":156,"./functions/update.js":157,"./functions/width.js":158,"./functions/window.js":159}],144:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Checks to see if a given variable is allowed to be selected.
//------------------------------------------------------------------------------
    module.exports = function ( vars , value , active ) {

        var ret = []
            , active = active || vars.active.value

        if ( active instanceof Array ) {

            for (var i = 0; i < active.length; i++) {
                ret.push(this(vars,value,active[i]))
            }

        }
        else {

            var t = typeof active

            if (t === "number") {
                ret.push(vars.depth.value === active)
            }
            else if (t === "function") {
                ret.push(active(value))
            }
            else {
                ret.push(value === active)
            }

        }

        return ret.indexOf(true) >= 0

    }

},{}],145:[function(require,module,exports){
    var print = require("../../../../core/console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Toggles the state of the dropdown menu.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( vars.dev.value ) print.time("rotating arrow")

        var offset = vars.icon.drop.value === "&#x276f;" ? 90 : 0

        if (vars.open.value != vars.open.flipped.value) {
            var rotate = 180 + offset
        }
        else {
            var rotate = offset
        }

        vars.container.button
            .icon({
                "select": {
                    "opacity": vars.open.value ? 0.5 : 1,
                    "rotate": rotate
                }
            })
            .draw()

        if ( vars.dev.value ) print.timeEnd("rotating arrow")

    }

},{"../../../../core/console/print.coffee":54}],146:[function(require,module,exports){
    var copy = require("../../../../util/copy.coffee"),
        events = require("../../../../client/pointer.coffee"),
        form   = require("../../../form.js"),
        print  = require("../../../../core/console/print.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the main drop button.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( !("button" in vars.container) ) {

            if ( vars.dev.value ) print.time("creating main button")

            vars.container.button = form()
                .container(vars.container.ui)
                .type("button")
                .ui({
                    "margin": 0
                })

            if ( vars.dev.value ) print.timeEnd("creating main button")

        }

        if ( vars.focus.changed || vars.data.changed || vars.depth.changed ) {

            var depth = vars.depth.value

            var buttonData = copy(vars.data.value.filter(function(d){
                var match = false
                for ( var i = 0 ; i < vars.id.nesting.length ; i++ ) {
                    var level = vars.id.nesting[i]
                    match = level in d && d[level] === vars.focus.value
                    if (match) {
                        depth = i
                        break
                    }
                }
                return match
            })[0])

            if ( !buttonData ) {
                buttonData = vars.container.button.data()[0] || vars.data.viz[0]
            }

            vars.container.button
                .data([buttonData])
                .id( vars.id.nesting )
                .depth(depth)

        }

        var hover = vars.hover.value === true ? vars.focus.value : false;

        vars.container.button
            .draw({
                "update": vars.draw.update
            })
            .focus("")
            .font( vars.font )
            .format(vars.format)
            .hover(hover)
            .icon({
                "button": vars.icon.drop.value,
                "select": vars.icon.drop.value,
                "value": vars.icon.value
            })
            .text( vars.text.value )
            .timing({
                "ui": vars.draw.timing
            })
            .ui({
                "border": vars.ui.border,
                "color": vars.ui.color,
                "padding": vars.ui.padding.css
            })
            .width(vars.width.value)
            .draw()

        var button = vars.container.button.container(Object).ui

        vars.margin.top += button.node().offsetHeight || button.node().getBoundingClientRect().height

        button.on(events.click,function(){
            vars.self.open(!vars.open.value).draw()
        })

    }

},{"../../../../client/pointer.coffee":40,"../../../../core/console/print.coffee":54,"../../../../util/copy.coffee":209,"../../../form.js":105}],147:[function(require,module,exports){
    var stringFormat = require("../../../../string/format.js"),
        stringStrip = require("../../../../string/strip.js");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and populates the dropdown list of items.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( vars.data.url && !vars.data.loaded ) {
            var loadingObject = {};
            loadingObject[vars.text.value || vars.id.value] = vars.format.value(vars.format.locale.value.ui.loading);
            vars.data.filtered = [loadingObject];
            vars.data.changed = vars.data.lastFilter !== "loading";
            vars.data.lastFilter = "loading";
        }
        else if (vars.open.value) {

            if (!vars.search.term) {
                vars.data.filtered = vars.data.viz;
                vars.data.changed = vars.data.lastFilter !== "viz";
                vars.data.lastFilter = "viz";
                if (vars.id.nesting.length > 1 && vars.depth.value < vars.id.nesting.length-1) {
                    vars.data.filtered = vars.data.filtered.filter(function(d){
                        if ("endPoint" in d.d3plus && d.d3plus.endPoint === vars.depth.value) {
                            d.d3plus.icon = false;
                        }
                        return true;
                    });
                    vars.data.changed = vars.data.lastFilter !== "depth";
                    vars.data.lastFilter = "depth";
                }
            }
            else {

                var searchWords = stringStrip(vars.search.term).split("_"),
                    searchKeys  = [vars.id.value, vars.text.value, vars.alt.value, vars.keywords.value ];

                searchKeys = searchKeys.filter(function(t){ return t; });
                searchWords = searchWords.filter(function(t){ return t !== ""; });

                var startMatches = [],
                    exactMatches = [],
                    softMatches  = [],
                    searchData   = [];

                vars.id.nesting.forEach(function(n){
                    searchData = searchData.concat(vars.data.nested.all[n]);
                });

                searchData.forEach(function(d){

                    var match = false;

                    searchKeys.forEach(function(key){

                        if ( !match && key in d && typeof d[key] === "string" ) {

                            var text = d[key].toLowerCase();

                            if ( [vars.text.value,vars.id.value].indexOf(key) >= 0 && text.indexOf(vars.search.term) === 0 ) {
                                startMatches.push(d);
                                match = true;
                            }
                            else if ( text.indexOf(vars.search.term) >= 0 ) {
                                exactMatches.push(d);
                                match = true;
                            }
                            else {

                                var texts = stringStrip(text).split("_");

                                for (var t in texts) {

                                    if ( !match ) {

                                        for (var s in searchWords) {
                                            if (texts[t].indexOf(searchWords[s]) === 0) {
                                                softMatches.push(d);
                                                match = true;
                                                break;
                                            }
                                        }

                                    }
                                    else {
                                        break;
                                    }

                                }

                            }
                        }

                    });

                });

                vars.data.filtered = d3.merge([ startMatches , exactMatches , softMatches ]);

                vars.data.filtered.forEach(function(d,i){
                    d.d3plus_order = i;
                });

                vars.data.changed = true;
                vars.data.lastFilter = "search";

                if ( vars.data.filtered.length === 0 ) {

                    var noData = {}, str = vars.format.value(vars.format.locale.value.ui.noResults);
                    noData[vars.text.value || vars.id.value] = stringFormat(str,"\""+vars.search.term+"\"");
                    vars.data.filtered = [ noData ];

                }

            }

        }
        else {
            vars.data.filtered = [];
        }

    };

},{"../../../../string/format.js":175,"../../../../string/strip.js":177}],148:[function(require,module,exports){
    module.exports = function(vars) {
        if (vars.data.element.value) {
            vars.data.element.value.on("focus." + vars.container.id, function() {
                return vars.self.hover(true).draw();
            });
            vars.data.element.value.on("blur." + vars.container.id, function() {
                var search;
                if (vars.search.enabled) {
                    search = d3.event.relatedTarget !== vars.container.value.select('input').node();
                } else {
                    search = true;
                }
                if (search) {
                    return vars.self.open(false).hover(false).draw();
                }
            });
            vars.data.element.value.on("change." + vars.container.id, function() {
                return vars.self.focus(this.value).draw();
            });
            return vars.data.element.value.on("keydown.cancel_" + vars.container.id, function() {
                if (d3.event.keyCode !== 9) {
                    return d3.event.preventDefault();
                }
            });
        }
    };


},{}],149:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculates the height and orientation of the dropdown list, based on
// available screen space.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        var height = vars.height.secondary,
            button = vars.container.button.container().node().getBoundingClientRect(),
            available = window.innerHeight - button.bottom - vars.ui.border * 2 -
                vars.ui.margin.top - vars.ui.margin.bottom -
                vars.ui.padding.top - vars.ui.padding.bottom;

        if (available < button.height * 3) {
            available = button.top-10;
            vars.self.open({"flipped": true});
        }
        // else {
        //   vars.self.open({"flipped": false});
        // }

        if (typeof height !== "number") {
            height = available;
        }

        if (height > vars.height.max) {
            height = vars.height.max;
        }

        vars.self.height({"secondary": height});

    };

},{}],150:[function(require,module,exports){
    var active, copy, form, print;

    active = require("./active.js");

    copy = require("../../../../util/copy.coffee");

    form = require("../../../form.js");

    print = require("../../../../core/console/print.coffee");

    module.exports = function(vars) {
        var deepest, large, order;
        if (vars.open.value) {
            if (vars.dev.value) {
                print.time("updating list items");
            }
            if (!("items" in vars.container)) {
                vars.container.items = form().container(vars.container.list).type("button").ui({
                    border: 0,
                    display: "block",
                    margin: 0
                }).width(false);
            }
            large = vars.draw.timing ? vars.data.large : 1;
            order = copy(vars.order);
            order.value = vars.search.term.length ? "d3plus_order" : vars.order.value;
            deepest = vars.depth.value === vars.id.nesting.length - 1;
            if (vars.focus.changed || vars.container.items.focus() === false) {
                vars.container.items.focus(vars.focus.value, function(value) {
                    var change, data, depth, solo;
                    data = vars.data.filtered.filter(function(f) {
                        return f[vars.id.value] === value;
                    })[0];
                    if (vars.depth.value < vars.id.nesting.length - 1 && vars.id.nesting[vars.depth.value + 1] in data) {
                        depth = vars.depth.value;
                        solo = vars.id.solo.value;
                        vars.history.states.push(function() {
                            return vars.self.depth(depth).id({
                                solo: solo
                            }).draw();
                        });
                        vars.self.depth(vars.depth.value + 1).id({
                            solo: [value]
                        }).draw();
                    } else {
                        if (!vars.depth.changed) {
                            vars.self.open(false);
                        }
                        change = value !== vars.focus.value;
                        if (change && vars.active.value) {
                            change = active(vars, value);
                        }
                        if (change) {
                            vars.self.focus(value).draw();
                        }
                    }
                });
            }
            vars.container.items.active(vars.active.value).data({
                large: large,
                sort: vars.data.sort.value,
                value: vars.data.filtered
            }).draw({
                update: vars.draw.update
            }).font(vars.font.secondary).format(vars.format).hover(vars.hover.value).id(vars.id.value).icon({
                button: (deepest ? false : vars.icon.next),
                select: (deepest ? vars.icon.select : false),
                value: vars.icon.value
            }).order(order).text(vars.text.secondary.value || vars.text.value).timing({
                ui: vars.draw.timing
            }).ui({
                color: {
                    primary: (vars.id.nesting.length === 1 ? vars.ui.color.primary.value : vars.ui.color.secondary.value),
                    secondary: vars.ui.color.secondary.value
                },
                padding: vars.ui.padding.css
            }).draw();
            if (vars.dev.value) {
                print.timeEnd("updating list items");
            }
        }
    };


},{"../../../../core/console/print.coffee":54,"../../../../util/copy.coffee":209,"../../../form.js":105,"./active.js":144}],151:[function(require,module,exports){
    module.exports = function(vars) {
        return d3.select(window).on("keydown." + vars.container.id, function() {
            var d, data, depth, hist, hover, i, index, j, key, len, matchKey, ref, solo;
            key = d3.event.keyCode;
            if (vars.open.value || vars.hover.value === true) {
                matchKey = vars.hover.value === true ? "focus" : "hover";
                index = false;
                ref = vars.data.filtered;
                for (i = j = 0, len = ref.length; j < len; i = ++j) {
                    d = ref[i];
                    if (d[vars.id.value] === vars[matchKey].value) {
                        index = i;
                        break;
                    }
                }
                if (key === 9 && vars.open.value && (!vars.search.enabled || (vars.search.enabled && !d3.event.shiftKey))) {
                    return vars.self.open(false).hover(false).draw();
                } else if ([38, 40].indexOf(key) >= 0) {
                    if (index === false) {
                        index = 0;
                    } else if (key === 38) {
                        if (vars.open.value) {
                            if (index <= 0) {
                                index = vars.data.filtered.length - 1;
                            } else {
                                index -= 1;
                            }
                        }
                    } else if (key === 40) {
                        if (vars.open.value) {
                            if (index >= vars.data.filtered.length - 1) {
                                index = 0;
                            } else {
                                index += 1;
                            }
                        }
                    }
                    if (typeof vars.hover.value !== "boolean") {
                        hover = vars.data.filtered[index][vars.id.value];
                    } else {
                        hover = vars.focus.value;
                    }
                    return vars.self.hover(hover).open(true).draw();
                } else if (key === 13) {
                    if (typeof vars.hover.value !== "boolean") {
                        data = vars.data.filtered.filter(function(f) {
                            return f[vars.id.value] === vars.hover.value;
                        })[0];
                        depth = vars.depth.value;
                        if (depth < vars.id.nesting.length - 1 && vars.id.nesting[depth + 1] in data) {
                            solo = vars.id.solo.value;
                            hist = function() {
                                return vars.self.depth(depth).id({
                                    solo: solo
                                }).draw();
                            };
                            vars.history.states.push(hist);
                            return vars.self.depth(vars.depth.value + 1).id({
                                solo: [vars.hover.value]
                            }).draw();
                        } else {
                            return vars.self.focus(vars.hover.value).hover(true).draw();
                        }
                    } else {
                        return vars.self.hover(vars.focus.value).open(true).draw();
                    }
                } else if (key === 27) {
                    if (vars.open.value) {
                        return vars.self.open(false).hover(true).draw();
                    } else if (vars.hover.value === true) {
                        return vars.self.hover(false).draw();
                    }
                }
            }
        });
    };


},{}],152:[function(require,module,exports){
    var print = require("../../../../core/console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and populates the dropdown list of items.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( vars.dev.value ) print.time("populating list")

        vars.container.list = vars.container.selector.selectAll("div.d3plus_drop_list")
            .data(["list"])

        vars.container.list.enter().append("div")
            .attr("class","d3plus_drop_list")
            .attr("id","d3plus_drop_list_"+vars.container.id)
            .style("overflow-y","auto")
            .style("overflow-x","hidden")

        if ( vars.dev.value ) print.timeEnd("populating list")

    }

},{"../../../../core/console/print.coffee":54}],153:[function(require,module,exports){
    var print = require("../../../../core/console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculates scroll position of list.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if (vars.open.value) {

            if ( vars.dev.value ) print.time("calculating height")

            var hidden = false
            if (vars.container.selector.style("display") == "none") {
                var hidden = true
            }

            if (hidden) vars.container.selector.style("display","block")

            var old_height = vars.container.selector.style("height"),
                old_scroll = vars.container.selector.property("scrollTop"),
                list_height = vars.container.list.style("max-height"),
                list_scroll = vars.container.list.property("scrollTop")

            vars.container.selector.style("height","auto")
            vars.container.list.style("max-height","200000px")

            vars.container.listHeight = parseFloat(vars.container.selector.style("height"),10)

            vars.container.list
                .style("max-height",list_height)
                .property("scrollTop",list_scroll)

            vars.container.selector
                .style("height",old_height)
                .property("scrollTop",old_scroll)

            var scrolling = false
            if (vars.container.listHeight > vars.height.secondary) {
                vars.container.listHeight = vars.height.secondary
                scrolling = true
            }

            if (hidden) vars.container.selector.style("display","none")

            if ( vars.dev.value ) print.timeEnd("calculating height")

            if (scrolling) {

                if ( vars.dev.value ) print.time("calculating scroll position")

                var options = vars.container.list.select("div").selectAll("div.d3plus_node")
                var option = options[0][0]
                var matchID = typeof vars.hover.value !== "boolean" ? vars.hover.value : vars.focus.value;
                options.each(function(d,i){
                    if (d[vars.id.value] === matchID) {
                        option = this
                    }
                })

                var hidden = false
                if (vars.container.selector.style("display") === "none") {
                    hidden = true
                    vars.container.selector.style("display","block")
                }

                var button_top = option.offsetTop,
                    button_height = option.offsetHeight || option.getBoundingClientRect().height,
                    list_top = vars.container.list.property("scrollTop")

                if (hidden) vars.container.selector.style("display","none")

                if ( hidden || vars.data.changed || vars.depth.changed ) {

                    vars.container.listScroll = button_top

                }
                else {

                    vars.container.listScroll = list_top;

                    if (button_top < list_top) {
                        vars.container.listScroll = button_top
                    }
                    else if (button_top+button_height > list_top+vars.height.secondary-vars.search.height) {
                        vars.container.listScroll = button_top - (vars.height.secondary-button_height-vars.search.height)
                    }

                }

                if ( vars.dev.value ) print.timeEnd("calculating scroll position")

            }
            else {
                vars.container.listScroll = 0
            }

        }
        else {
            vars.container.listScroll = vars.container.list.property("scrollTop")
            vars.container.listHeight = 0
        }

    }

},{"../../../../core/console/print.coffee":54}],154:[function(require,module,exports){
    var prefix = require("../../../../client/prefix.coffee"),
        print = require("../../../../core/console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the search box, if enabled.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( vars.dev.value ) print.time("creating search")

        var data = require("./data.js")
            , items = require("./items.coffee")
            , update = require("./update.js")

        vars.container.search = vars.container.selector.selectAll("div.d3plus_drop_search")
            .data(vars.search.enabled ? ["search"] : [])

        function searchStyle(elem) {

            elem
                .style("padding",vars.ui.padding.css)
                .style("display","block")
                .style("background-color",d3.rgb(vars.ui.color.primary.value).darker(0.15).toString())

        }

        function inputStyle(elem) {

            var width = vars.width.secondary - vars.ui.padding.left*2 - vars.ui.padding.right*2 + vars.ui.border*2

            elem
                .style("padding",vars.ui.padding.left/2+vars.ui.padding.right/2+"px")
                .style("width",width+"px")
                .style("border-width","0px")
                .style("font-family",vars.font.secondary.family.value)
                .style("font-size",vars.font.secondary.size+"px")
                .style("font-weight",vars.font.secondary.weight)
                .style("text-align",vars.font.secondary.align)
                .style("outline","none")
                .style(prefix()+"border-radius","0")
                .attr("placeholder",vars.format.value(vars.format.locale.value.method.search))

        }

        if (vars.draw.timing) {

            vars.container.search.transition().duration(vars.draw.timing)
                .call(searchStyle)

            vars.container.search.select("input").transition().duration(vars.draw.timing)
                .call(inputStyle)

        }
        else {

            vars.container.search
                .call(searchStyle)

            vars.container.search.select("input")
                .call(inputStyle)

        }

        vars.container.search.enter()
            .insert("div","#d3plus_drop_list_"+vars.container.id)
            .attr("class","d3plus_drop_search")
            .attr("id","d3plus_drop_search_"+vars.container.id)
            .call(searchStyle)
            .append("input")
            .attr("id","d3plus_drop_input_"+vars.container.id)
            .style("-webkit-appearance","none")
            .call(inputStyle)

        vars.container.search.select("input").on("keyup."+vars.container.id,function(d){
            var term = this.value;
            if (vars.search.term !== term) {
                vars.search.term = term;
                data(vars);
                items(vars);
                update(vars);
            }
        });

        vars.container.search.exit().remove()

        var oldDisplay = vars.container.selector.style("display")
        vars.container.selector.style("display", "block")
        vars.search.height = vars.search.enabled ? vars.container.search.node().offsetHeight ||
            vars.container.search.node().getBoundingClientRect().height : 0;
        vars.container.selector.style("display", oldDisplay)

        if ( vars.search.enabled ) {
            vars.margin.title += vars.search.height
        }

        if ( vars.dev.value ) print.timeEnd("creating search")

    }

},{"../../../../client/prefix.coffee":41,"../../../../core/console/print.coffee":54,"./data.js":147,"./items.coffee":150,"./update.js":157}],155:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the div that holds the search box and item list.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        vars.container.selector = vars.container.ui
            .selectAll("div.d3plus_drop_selector")
            .data(["selector"])

        vars.container.selector.enter().append("div")
            .attr("class","d3plus_drop_selector")
            .style("position","absolute")
            .style("top","0px")
            .style("z-index","-1")
            .style("overflow","hidden")

        vars.container.selector
            .style("padding",vars.ui.border+"px")

    }

},{}],156:[function(require,module,exports){
    var events = require("../../../../client/pointer.coffee"),
        lighter   = require("../../../../color/lighter.coffee"),
        print     = require("../../../../core/console/print.coffee"),
        textColor = require("../../../../color/text.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates and styles the title and back button.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        if ( vars.open.value ) {

            if ( vars.dev.value ) print.time("creating title and back button")

            var self    = this
                , enabled = vars.id.solo.value.length === 1 && vars.depth.value > 0
                , title   = enabled
                , focus   = vars.container.button.data(Object).viz[0]

            title = true
            for (var i = 0; i < vars.id.nesting.length; i++) {
                var level = vars.id.nesting[i]
                if ( level in focus && focus[level] === vars.focus.value ) {
                    title = false
                    break;
                }
            }

            vars.container.title = vars.container.selector.selectAll("div.d3plus_drop_title")
                .data(enabled ? ["title"] : [])

            function boxStyle(elem) {

                elem
                    .style("padding",vars.ui.padding.css)
                    .style("display","block")
                    .style("background-color",vars.ui.color.secondary.value)
                    .style("font-family",vars.font.secondary.family.value)
                    .style("font-size",vars.font.secondary.size+"px")
                    .style("font-weight",vars.font.secondary.weight)
                    .style("text-align",vars.font.secondary.align)
                    .style("color",textColor(vars.ui.color.secondary.value))

            }

            function backStyle(elem) {

                if ( !elem.empty() ) {

                    var className = vars.icon.back.value.indexOf("fa-") === 0 ? " fa "+vars.icon.back.value : ""
                    className = "d3plus_drop_back" + className

                    var text = vars.icon.back.value.indexOf("fa-") === 0 ? "" : vars.icon.back.value

                    elem
                        .style("position","absolute")
                        .attr("class",className)
                        .style("top",vars.ui.padding.top+(vars.font.secondary.size/2)/2.5+"px")
                        .html(text)

                }

            }

            function titleStyle(elem) {

                var text = title ? vars.focus.value : vars.format.locale.value.ui.back

                elem
                    .text(vars.format.value(text))
                    .style("padding","0px "+(vars.ui.padding.left+vars.ui.padding.right)+"px")

            }

            if (vars.draw.timing) {

                vars.container.title.transition().duration(vars.draw.timing)
                    .call(boxStyle)

                vars.container.title.select("div.d3plus_drop_title_text")
                    .transition().duration(vars.draw.timing)
                    .call(titleStyle)

            }
            else {

                vars.container.title
                    .call(boxStyle)

                vars.container.title.select("div.d3plus_drop_title_text")
                    .call(titleStyle)

            }

            vars.container.title.select("span.d3plus_drop_back")
                .call(backStyle)

            var enter = vars.container.title.enter()
                .insert("div","#d3plus_drop_list_"+vars.container.id)
                .attr("class","d3plus_drop_title")
                .attr("id","d3plus_drop_title_"+vars.container.id)
                .call(boxStyle)

            enter.append("span")
                .attr("id","d3plus_drop_back_"+vars.container.id)
                .attr("class","d3plus_drop_back")
                .call(backStyle)

            enter.append("div")
                .attr("id","d3plus_drop_title_text_"+vars.container.id)
                .attr("class","d3plus_drop_title_text")
                .call(titleStyle)

            vars.container.title
                .on(events.over,function(d,i){

                    var color = lighter(vars.ui.color.secondary.value)

                    d3.select(this).style("cursor","pointer")
                        .transition().duration(vars.timing.mouseevents)
                        .style("background-color",color)
                        .style("color",textColor(color))

                })
                .on(events.out,function(d){

                    var color = vars.ui.color.secondary.value

                    d3.select(this).style("cursor","auto")
                        .transition().duration(vars.timing.mouseevents)
                        .style("background-color",color)
                        .style("color",textColor(color))

                })
                .on(events.click,function(d){
                    vars.history.back()
                })

            vars.container.title.exit().remove()

            if ( enabled ) {
                vars.margin.title += vars.container.title.node().offsetHeight || vars.container.title.node().getBoundingClientRect().height
            }

            if ( vars.dev.value ) print.timeEnd("creating title and back button")

        }

    }

},{"../../../../client/pointer.coffee":40,"../../../../color/lighter.coffee":47,"../../../../color/text.coffee":52,"../../../../core/console/print.coffee":54}],157:[function(require,module,exports){
    var items = require("./items.coffee"),
        height     = require("./height.js"),
        print      = require("../../../../core/console/print.coffee"),
        scrolllist = require("./scroll.js"),
        arrow      = require("./arrow.js")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Redraws only the drop down list.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If the menu is open, set the container element's z-index to '9999'.
        //----------------------------------------------------------------------------
        if ( vars.draw.timing ) {

            vars.container.ui.transition().duration(vars.draw.timing)
                .each("start",function(){
                    if (vars.open.value) {
                        d3.select(this).style("z-index",9999)
                    }
                })
                .style("margin",vars.ui.margin.css)
                .each("end",function(){
                    if (!vars.open.value) {
                        d3.select(this).style("z-index","auto")
                    }
                })

        }
        else {

            vars.container.ui
                .style("margin",vars.ui.margin.css)
                .style("z-index",function(){
                    if (vars.open.value) {
                        return 9999
                    }
                    else {
                        return "auto"
                    }
                })

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Update list items based on filtered data.
        //----------------------------------------------------------------------------
        items( vars )

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Calculate the height and orientation of the dropdown list.
        //----------------------------------------------------------------------------
        height( vars )

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Calculate scroll position of dropdown menu.
        //----------------------------------------------------------------------------
        scrolllist( vars )

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Rotate the dropdown button arrow appropriately.
        //----------------------------------------------------------------------------
        arrow( vars )

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Update List
        //----------------------------------------------------------------------------
        if ( vars.dev.value ) print.time("drawing list")

        function position(elem) {
            var flipped = vars.open.flipped.value
            elem
                .style("top",function(){
                    return flipped ? "auto" : vars.margin.top-vars.ui.border+"px";
                })
                .style("bottom",function(){
                    return flipped ? vars.margin.top+vars.ui.border+"px" : "auto";
                });
        }

        function update(elem) {

            elem
                .style("left",function(){
                    if (vars.font.align.value === "left") {
                        return vars.margin.left+"px";
                    }
                    else if (vars.font.align.value === "center") {
                        return vars.margin.left-((vars.width.secondary-vars.width.value)/2)+"px";
                    }
                    else {
                        return "auto";
                    }
                })
                .style("right",function(){
                    return vars.font.align.value === "right" ? "0px" : "auto";
                })
                .style("height",vars.container.listHeight+"px")
                .style("padding",vars.ui.border+"px")
                .style("background-color",vars.ui.color.secondary.value)
                .style("z-index",function(){
                    return vars.open.value ? "9999" : "-1";
                })
                .style("width",(vars.width.secondary-(vars.ui.border*2))+"px")
                .style("opacity",vars.open.value ? 1 : 0)
                .call(position);

        }

        function finish(elem) {

            elem.style("display", vars.open.value ? null : "none")
                .call(position);


            if (vars.search.enabled && vars.open.value) {
                vars.container.selector.select("div.d3plus_drop_search input").node().focus()
            }

        }

        var max_height = vars.open.value ? vars.height.secondary - vars.margin.title: 0;

        if (!vars.draw.timing) {

            vars.container.selector.call(update).call(finish)

            vars.container.list
                .style("width",vars.width.secondary-vars.ui.border*2+"px")
                .style("max-height", max_height + "px")
                .property("scrollTop",vars.container.listScroll);

        }
        else {
            vars.container.selector.transition().duration(vars.draw.timing)
                .each("start",function(){
                    d3.select(this)
                        .style("display",vars.open.value ? "block" : null)
                })
                .call(update)
                .each("end",function(){

                    d3.select(this).transition().duration(vars.draw.timing)
                        .call(finish)

                })

            function scrollTopTween(scrollTop) {
                return function() {
                    var i = d3.interpolateNumber(this.scrollTop, scrollTop);
                    return function(t) { this.scrollTop = i(t); };
                };
            }

            vars.container.list.transition().duration(vars.draw.timing)
                .style("width",vars.width.secondary-vars.ui.border*2+"px")
                .style("max-height",max_height+"px")
                .tween("scroll",scrollTopTween(vars.container.listScroll))
        }

        if ( vars.dev.value ) print.timeEnd("drawing list")

    }

},{"../../../../core/console/print.coffee":54,"./arrow.js":145,"./height.js":149,"./items.coffee":150,"./scroll.js":153}],158:[function(require,module,exports){
    var copy = require("../../../../util/copy.coffee"),
        fontTester  = require("../../../../core/font/tester.coffee"),
        form        = require("../../../form.js"),
        print       = require("../../../../core/console/print.coffee"),
        validObject = require("../../../../object/validate.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// If no widths are defined, then this calculates the width needed to fit the
// longest entry in the list.
//------------------------------------------------------------------------------
    module.exports = function ( vars ) {

        var data = [], buffer = 0
        for ( var level in vars.data.nested.all ) {
            var newData = vars.data.nested.all[level]
                , key     = validObject(vars.text.nesting) && level in vars.text.nesting
                ? vars.text.nesting[level][0] : level

            if ( [vars.id.value,vars.text.value].indexOf(key) < 0 ) {
                newData = copy(newData)
                newData.forEach(function(d){
                    d[vars.text.value || vars.id.value] = d[key]
                })
            }
            data = data.concat( newData )
        }

        function getWidth( type ) {

            var key  = type === "primary" ? "value" : type
                , icon = key === "value" ? vars.icon.drop.value
                : vars.icon.select.value || vars.icon.drop.value
                , text = key === "value" ? vars.text.value
                : vars.text.secondary.value || vars.text.value
                , font = key === "value" ? vars.font : vars.font.secondary

            if ( vars.dev.value ) print.time("calculating "+type+" width")

            var button = form()
                .container( fontTester() )
                .data({
                    "large": 9999,
                    "value": data
                })
                .draw({ "update": false })
                .font( font )
                .format(vars.format)
                .icon({ "button": icon, "value": vars.icon.value })
                .id(vars.id.value)
                .timing({
                    "ui": 0
                })
                .text( text || vars.id.value )
                .type( "button" )
                .ui({
                    "border": type === "primary" ? vars.ui.border : 0,
                    "display": "inline-block",
                    "margin": 0,
                    "padding": vars.ui.padding.css
                })
                .width(false)
                .draw()

            var w = []
            button.selectAll("div.d3plus_node").each(function(o){
                w.push(this.offsetWidth + 1)
            }).remove()

            var dropWidth = {}
            dropWidth[key] = d3.max(w)

            vars.self.width( dropWidth )

            if ( vars.dev.value ) print.timeEnd("calculating "+type+" width")

        }

        if ( typeof vars.width.value !== "number" ) {

            getWidth( "primary" )

        }

        if ( typeof vars.width.secondary !== "number" ) {

            if ( !vars.text.secondary.value || vars.text.value === vars.text.secondary.value ) {
                vars.self.width({"secondary": vars.width.value})
            }
            else {
                getWidth( "secondary" )
            }

        }

    }

},{"../../../../core/console/print.coffee":54,"../../../../core/font/tester.coffee":70,"../../../../object/validate.coffee":174,"../../../../util/copy.coffee":209,"../../../form.js":105}],159:[function(require,module,exports){
    var child = require("../../../../util/child.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Recursive function that applies a click event to all parent windows that
// will close the dropdown if it is open.
//------------------------------------------------------------------------------
    var windowEvents = function ( vars , elem ) {

        if ( elem === undefined ) {
            var elem = window
        }

        d3.select(elem).on("click."+vars.container.id,function(){

            var element = d3.event.target || d3.event.toElement
                , parent  = element.parentNode

            if ( parent && ["d3plus_node","d3plus_drop_title"].indexOf(parent.className) >= 0 ) {
                element = parent.parentNode
            }

            if (element && parent && !child(vars.container.ui, element) && (vars.open.value || vars.hover.value)) {
                vars.self.open(false).hover(false).draw()
            }

        })

        try {
            var same_origin = window.parent.location.host === window.location.host;
        }
        catch (e) {
            var same_origin = false
        }

        if (same_origin) {
            if (elem.self !== window.top) {
                windowEvents( vars , elem.parent )
            }
        }

    }

    module.exports = windowEvents

},{"../../../../util/child.coffee":207}],160:[function(require,module,exports){
    var form = require("../form.js")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a set of Toggle Buttons
//------------------------------------------------------------------------------
    module.exports = function( vars ) {

        if ( !("buttons" in vars.container) ) {

            vars.container.buttons = form()
                .container(vars.container.ui)
                .type("button")

        }

        var dataLength  = vars.data.viz.length
            , buttonWidth = vars.width.value
            ? vars.width.value/dataLength
            : false

        var toggles = vars.container.ui.selectAll("div.d3plus_toggle")
            .data(vars.data.viz,function(d){
                return d[vars.id.value];
            })

        toggles.exit().remove();

        toggles.enter().append("div")
            .attr("class","d3plus_toggle")
            .style("display","inline-block")
            .style("vertical-align","top")

        toggles.order()
            .each(function(d){

                if (!("form" in d.d3plus)) {
                    d.d3plus.form = form().container(d3.select(this))
                }

                var id = vars.id.nesting.length > vars.depth.value ? vars.id.nesting[vars.depth.value+1] : vars.id.value

                if (d[id] instanceof Array) {
                    d.d3plus.form
                        .container({"id": vars.container.id+"_"+d[vars.id.value]})
                        .data(d[id])
                        .id(vars.id.nesting.slice(1))
                        .type("drop")
                }
                else {
                    d.d3plus.form
                        .data([d])
                        .id(vars.id.value)
                        .type("button")
                }

                d.d3plus.form
                    .color(vars.color)
                    .focus(vars.focus.value,function(value){

                        if (value !== vars.focus.value) {
                            vars.self.focus(value).draw()
                        }

                    })
                    .hover(vars.hover.value)
                    .icon({
                        "select": false,
                        "value": vars.icon.value
                    })
                    .font(vars.font)
                    .format(vars.format)
                    .order(vars.order)
                    .text(vars.text.value)
                    .ui({
                        "border": vars.ui.border,
                        "color": vars.ui.color,
                        "display": "inline-block",
                        "margin": 0,
                        "padding": vars.ui.padding.css
                    })
                    .width(buttonWidth)
                    .draw()

            })

        if (vars.data.element.value) {
            vars.data.element.value
                .on("focus."+vars.container.id, function(){
                    vars.self.focus(this.value).hover(this.value).draw();
                })
                .on("blur."+vars.container.id, function(){
                    vars.self.hover(false).draw();
                })
        }

    }

},{"../form.js":105}],161:[function(require,module,exports){
    var intersectPoints, lineIntersection, pointInPoly, pointInSegmentBox, polyInsidePoly, rayIntersectsSegment, rotatePoint, rotatePoly, segmentsIntersect, simplify, squaredDist;

    simplify = require("simplify-js");

    module.exports = function(poly, options) {
        var aRatio, aRatios, angle, angleRad, angleStep, angles, area, aspectRatioStep, aspectRatios, bBox, boxHeight, boxWidth, centroid, events, height, i, insidePoly, j, k, l, left, len, len1, len2, len3, m, maxArea, maxAspectRatio, maxHeight, maxRect, maxWidth, maxx, maxy, minAspectRatio, minSqDistH, minSqDistW, minx, miny, modifOrigins, origOrigin, origin, origins, p, p1H, p1W, p2H, p2W, rectPoly, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, right, rndPoint, rndX, rndY, tempPoly, tolerance, width, widthStep, x0, y0;
        if (poly.length < 3) {
            return null;
        }
        events = [];
        aspectRatioStep = 0.5;
        angleStep = 5;
        if (options == null) {
            options = {};
        }
        if (options.maxAspectRatio == null) {
            options.maxAspectRatio = 15;
        }
        if (options.minWidth == null) {
            options.minWidth = 0;
        }
        if (options.minHeight == null) {
            options.minHeight = 0;
        }
        if (options.tolerance == null) {
            options.tolerance = 0.02;
        }
        if (options.nTries == null) {
            options.nTries = 20;
        }
        if (options.angle != null) {
            if (options.angle instanceof Array) {
                angles = options.angle;
            } else if (typeof options.angle === 'number') {
                angles = [options.angle];
            } else if (typeof options.angle === 'string' && !isNaN(options.angle)) {
                angles = [Number(options.angle)];
            }
        }
        if (angles == null) {
            angles = d3.range(-90, 90 + angleStep, angleStep);
        }
        if (options.aspectRatio != null) {
            if (options.aspectRatio instanceof Array) {
                aspectRatios = options.aspectRatio;
            } else if (typeof options.aspectRatio === 'number') {
                aspectRatios = [options.aspectRatio];
            } else if (typeof options.aspectRatio === 'string' && !isNaN(options.aspectRatio)) {
                aspectRatios = [Number(options.aspectRatio)];
            }
        }
        if (options.origin != null) {
            if (options.origin instanceof Array) {
                if (options.origin[0] instanceof Array) {
                    origins = options.origin;
                } else {
                    origins = [options.origin];
                }
            }
        }
        area = Math.abs(d3.geom.polygon(poly).area());
        if (area === 0) {
            return null;
        }
        ref = d3.extent(poly, function(d) {
            return d[0];
        }), minx = ref[0], maxx = ref[1];
        ref1 = d3.extent(poly, function(d) {
            return d[1];
        }), miny = ref1[0], maxy = ref1[1];
        tolerance = Math.min(maxx - minx, maxy - miny) * options.tolerance;
        tempPoly = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = poly.length; j < len; j++) {
                p = poly[j];
                results.push({
                    x: p[0],
                    y: p[1]
                });
            }
            return results;
        })();
        if (tolerance > 0) {
            tempPoly = simplify(tempPoly, tolerance);
            poly = (function() {
                var j, len, results;
                results = [];
                for (j = 0, len = tempPoly.length; j < len; j++) {
                    p = tempPoly[j];
                    results.push([p.x, p.y]);
                }
                return results;
            })();
        }
        if (options.vdebug) {
            events.push({
                type: 'simplify',
                poly: poly
            });
        }
        ref2 = d3.extent(poly, function(d) {
            return d[0];
        }), minx = ref2[0], maxx = ref2[1];
        ref3 = d3.extent(poly, function(d) {
            return d[1];
        }), miny = ref3[0], maxy = ref3[1];
        bBox = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
        ref4 = [maxx - minx, maxy - miny], boxWidth = ref4[0], boxHeight = ref4[1];
        widthStep = Math.min(boxWidth, boxHeight) / 50;
        if (origins == null) {
            origins = [];
            centroid = d3.geom.polygon(poly).centroid();
            if (pointInPoly(centroid, poly)) {
                origins.push(centroid);
            }
            while (origins.length < options.nTries) {
                rndX = Math.random() * boxWidth + minx;
                rndY = Math.random() * boxHeight + miny;
                rndPoint = [rndX, rndY];
                if (pointInPoly(rndPoint, poly)) {
                    origins.push(rndPoint);
                }
            }
        }
        if (options.vdebug) {
            events.push({
                type: 'origins',
                points: origins
            });
        }
        maxArea = 0;
        maxRect = null;
        for (j = 0, len = angles.length; j < len; j++) {
            angle = angles[j];
            angleRad = -angle * Math.PI / 180;
            if (options.vdebug) {
                events.push({
                    type: 'angle',
                    angle: angle
                });
            }
            for (i = k = 0, len1 = origins.length; k < len1; i = ++k) {
                origOrigin = origins[i];
                ref5 = intersectPoints(poly, origOrigin, angleRad), p1W = ref5[0], p2W = ref5[1];
                ref6 = intersectPoints(poly, origOrigin, angleRad + Math.PI / 2), p1H = ref6[0], p2H = ref6[1];
                modifOrigins = [];
                if ((p1W != null) && (p2W != null)) {
                    modifOrigins.push([(p1W[0] + p2W[0]) / 2, (p1W[1] + p2W[1]) / 2]);
                }
                if ((p1H != null) && (p2H != null)) {
                    modifOrigins.push([(p1H[0] + p2H[0]) / 2, (p1H[1] + p2H[1]) / 2]);
                }
                if (options.vdebug) {
                    events.push({
                        type: 'modifOrigin',
                        idx: i,
                        p1W: p1W,
                        p2W: p2W,
                        p1H: p1H,
                        p2H: p2H,
                        modifOrigins: modifOrigins
                    });
                }
                for (l = 0, len2 = modifOrigins.length; l < len2; l++) {
                    origin = modifOrigins[l];
                    if (options.vdebug) {
                        events.push({
                            type: 'origin',
                            cx: origin[0],
                            cy: origin[1]
                        });
                    }
                    ref7 = intersectPoints(poly, origin, angleRad), p1W = ref7[0], p2W = ref7[1];
                    if (p1W === null || p2W === null) {
                        continue;
                    }
                    minSqDistW = Math.min(squaredDist(origin, p1W), squaredDist(origin, p2W));
                    maxWidth = 2 * Math.sqrt(minSqDistW);
                    ref8 = intersectPoints(poly, origin, angleRad + Math.PI / 2), p1H = ref8[0], p2H = ref8[1];
                    if (p1H === null || p2H === null) {
                        continue;
                    }
                    minSqDistH = Math.min(squaredDist(origin, p1H), squaredDist(origin, p2H));
                    maxHeight = 2 * Math.sqrt(minSqDistH);
                    if (maxWidth * maxHeight < maxArea) {
                        continue;
                    }
                    if (aspectRatios != null) {
                        aRatios = aspectRatios;
                    } else {
                        minAspectRatio = Math.max(1, options.minWidth / maxHeight, maxArea / (maxHeight * maxHeight));
                        maxAspectRatio = Math.min(options.maxAspectRatio, maxWidth / options.minHeight, (maxWidth * maxWidth) / maxArea);
                        aRatios = d3.range(minAspectRatio, maxAspectRatio + aspectRatioStep, aspectRatioStep);
                    }
                    for (m = 0, len3 = aRatios.length; m < len3; m++) {
                        aRatio = aRatios[m];
                        left = Math.max(options.minWidth, Math.sqrt(maxArea * aRatio));
                        right = Math.min(maxWidth, maxHeight * aRatio);
                        if (right * maxHeight < maxArea) {
                            continue;
                        }
                        if ((right - left) >= widthStep) {
                            if (options.vdebug) {
                                events.push({
                                    type: 'aRatio',
                                    aRatio: aRatio
                                });
                            }
                        }
                        while ((right - left) >= widthStep) {
                            width = (left + right) / 2;
                            height = width / aRatio;
                            x0 = origin[0], y0 = origin[1];
                            rectPoly = [[x0 - width / 2, y0 - height / 2], [x0 + width / 2, y0 - height / 2], [x0 + width / 2, y0 + height / 2], [x0 - width / 2, y0 + height / 2]];
                            rectPoly = rotatePoly(rectPoly, angleRad, origin);
                            if (polyInsidePoly(rectPoly, poly)) {
                                insidePoly = true;
                                maxArea = width * height;
                                maxRect = {
                                    cx: x0,
                                    cy: y0,
                                    width: width,
                                    height: height,
                                    angle: angle
                                };
                                left = width;
                            } else {
                                insidePoly = false;
                                right = width;
                            }
                            if (options.vdebug) {
                                events.push({
                                    type: 'rectangle',
                                    cx: x0,
                                    cy: y0,
                                    width: width,
                                    height: height,
                                    areaFraction: (width * height) / area,
                                    angle: angle,
                                    insidePoly: insidePoly
                                });
                            }
                        }
                    }
                }
            }
        }
        return [maxRect, maxArea, events];
    };

    squaredDist = function(a, b) {
        var deltax, deltay;
        deltax = b[0] - a[0];
        deltay = b[1] - a[1];
        return deltax * deltax + deltay * deltay;
    };

    rayIntersectsSegment = function(p, p1, p2) {
        var a, b, mAB, mAP, ref;
        ref = p1[1] < p2[1] ? [p1, p2] : [p2, p1], a = ref[0], b = ref[1];
        if (p[1] === b[1] || p[1] === a[1]) {
            p[1] += Number.MIN_VALUE;
        }
        if (p[1] > b[1] || p[1] < a[1]) {
            return false;
        } else if (p[0] > a[0] && p[0] > b[0]) {
            return false;
        } else if (p[0] < a[0] && p[0] < b[0]) {
            return true;
        } else {
            mAB = (b[1] - a[1]) / (b[0] - a[0]);
            mAP = (p[1] - a[1]) / (p[0] - a[0]);
            return mAP > mAB;
        }
    };

    pointInPoly = function(p, poly) {
        var a, b, c, i, n;
        i = -1;
        n = poly.length;
        b = poly[n - 1];
        c = 0;
        while (++i < n) {
            a = b;
            b = poly[i];
            if (rayIntersectsSegment(p, a, b)) {
                c++;
            }
        }
        return c % 2 !== 0;
    };

    pointInSegmentBox = function(p, p1, q1) {
        var eps, px, py;
        eps = 1e-9;
        px = p[0], py = p[1];
        if (px < Math.min(p1[0], q1[0]) - eps || px > Math.max(p1[0], q1[0]) + eps || py < Math.min(p1[1], q1[1]) - eps || py > Math.max(p1[1], q1[1]) + eps) {
            return false;
        }
        return true;
    };

    lineIntersection = function(p1, q1, p2, q2) {
        var cross1, cross2, denom, dx1, dx2, dy1, dy2, eps, px, py;
        eps = 1e-9;
        dx1 = p1[0] - q1[0];
        dy1 = p1[1] - q1[1];
        dx2 = p2[0] - q2[0];
        dy2 = p2[1] - q2[1];
        denom = dx1 * dy2 - dy1 * dx2;
        if (Math.abs(denom) < eps) {
            return null;
        }
        cross1 = p1[0] * q1[1] - p1[1] * q1[0];
        cross2 = p2[0] * q2[1] - p2[1] * q2[0];
        px = (cross1 * dx2 - cross2 * dx1) / denom;
        py = (cross1 * dy2 - cross2 * dy1) / denom;
        return [px, py];
    };

    segmentsIntersect = function(p1, q1, p2, q2) {
        var p;
        p = lineIntersection(p1, q1, p2, q2);
        if (p == null) {
            return false;
        }
        return pointInSegmentBox(p, p1, q1) && pointInSegmentBox(p, p2, q2);
    };

    polyInsidePoly = function(polyA, polyB) {
        var aA, aB, bA, bB, iA, iB, nA, nB;
        iA = -1;
        nA = polyA.length;
        nB = polyB.length;
        bA = polyA[nA - 1];
        while (++iA < nA) {
            aA = bA;
            bA = polyA[iA];
            iB = -1;
            bB = polyB[nB - 1];
            while (++iB < nB) {
                aB = bB;
                bB = polyB[iB];
                if (segmentsIntersect(aA, bA, aB, bB)) {
                    return false;
                }
            }
        }
        return pointInPoly(polyA[0], polyB);
    };

    rotatePoint = function(p, alpha, origin) {
        var cosAlpha, sinAlpha, xshifted, yshifted;
        if (origin == null) {
            origin = [0, 0];
        }
        xshifted = p[0] - origin[0];
        yshifted = p[1] - origin[1];
        cosAlpha = Math.cos(alpha);
        sinAlpha = Math.sin(alpha);
        return [cosAlpha * xshifted - sinAlpha * yshifted + origin[0], sinAlpha * xshifted + cosAlpha * yshifted + origin[1]];
    };

    rotatePoly = function(poly, alpha, origin) {
        var j, len, point, results;
        results = [];
        for (j = 0, len = poly.length; j < len; j++) {
            point = poly[j];
            results.push(rotatePoint(point, alpha, origin));
        }
        return results;
    };

    intersectPoints = function(poly, origin, alpha) {
        var a, b, closestPointLeft, closestPointRight, eps, i, idx, minSqDistLeft, minSqDistRight, n, p, shiftedOrigin, sqDist, x0, y0;
        eps = 1e-9;
        origin = [origin[0] + eps * Math.cos(alpha), origin[1] + eps * Math.sin(alpha)];
        x0 = origin[0], y0 = origin[1];
        shiftedOrigin = [x0 + Math.cos(alpha), y0 + Math.sin(alpha)];
        idx = 0;
        if (Math.abs(shiftedOrigin[0] - x0) < eps) {
            idx = 1;
        }
        i = -1;
        n = poly.length;
        b = poly[n - 1];
        minSqDistLeft = Number.MAX_VALUE;
        minSqDistRight = Number.MAX_VALUE;
        closestPointLeft = null;
        closestPointRight = null;
        while (++i < n) {
            a = b;
            b = poly[i];
            p = lineIntersection(origin, shiftedOrigin, a, b);
            if ((p != null) && pointInSegmentBox(p, a, b)) {
                sqDist = squaredDist(origin, p);
                if (p[idx] < origin[idx]) {
                    if (sqDist < minSqDistLeft) {
                        minSqDistLeft = sqDist;
                        closestPointLeft = p;
                    }
                } else if (p[idx] > origin[idx]) {
                    if (sqDist < minSqDistRight) {
                        minSqDistRight = sqDist;
                        closestPointRight = p;
                    }
                }
            }
        }
        return [closestPointLeft, closestPointRight];
    };


},{"simplify-js":9}],162:[function(require,module,exports){
    module.exports = function(radians, distance, shape) {
        var adjacentLegLength, coords, diagonal, oppositeLegLength;
        coords = {
            x: 0,
            y: 0
        };
        if (radians < 0) {
            radians = Math.PI * 2 + radians;
        }
        if (shape === "square") {
            diagonal = 45 * (Math.PI / 180);
            if (radians <= Math.PI) {
                if (radians < (Math.PI / 2)) {
                    if (radians < diagonal) {
                        coords.x += distance;
                        oppositeLegLength = Math.tan(radians) * distance;
                        coords.y += oppositeLegLength;
                    } else {
                        coords.y += distance;
                        adjacentLegLength = distance / Math.tan(radians);
                        coords.x += adjacentLegLength;
                    }
                } else {
                    if (radians < (Math.PI - diagonal)) {
                        coords.y += distance;
                        adjacentLegLength = distance / Math.tan(Math.PI - radians);
                        coords.x -= adjacentLegLength;
                    } else {
                        coords.x -= distance;
                        oppositeLegLength = Math.tan(Math.PI - radians) * distance;
                        coords.y += oppositeLegLength;
                    }
                }
            } else {
                if (radians < (3 * Math.PI / 2)) {
                    if (radians < (diagonal + Math.PI)) {
                        coords.x -= distance;
                        oppositeLegLength = Math.tan(radians - Math.PI) * distance;
                        coords.y -= oppositeLegLength;
                    } else {
                        coords.y -= distance;
                        adjacentLegLength = distance / Math.tan(radians - Math.PI);
                        coords.x -= adjacentLegLength;
                    }
                } else {
                    if (radians < (2 * Math.PI - diagonal)) {
                        coords.y -= distance;
                        adjacentLegLength = distance / Math.tan(2 * Math.PI - radians);
                        coords.x += adjacentLegLength;
                    } else {
                        coords.x += distance;
                        oppositeLegLength = Math.tan(2 * Math.PI - radians) * distance;
                        coords.y -= oppositeLegLength;
                    }
                }
            }
        } else {
            coords.x += distance * Math.cos(radians);
            coords.y += distance * Math.sin(radians);
        }
        return coords;
    };


},{}],163:[function(require,module,exports){
    var offset;

    offset = require("../geom/offset.coffee");

    module.exports = function(path) {
        var angle, i, j, last, len, length, o, obtuse, p, poly, prev, radius, segments, start, step, width;
        if (!path) {
            return [];
        }
        path = path.slice(1).slice(0, -1).split(/L|A/);
        poly = [];
        for (j = 0, len = path.length; j < len; j++) {
            p = path[j];
            p = p.split(" ");
            if (p.length === 1) {
                poly.push(p[0].split(",").map(function(d) {
                    return parseFloat(d);
                }));
            } else {
                prev = poly[poly.length - 1];
                last = p.pop().split(",").map(function(d) {
                    return parseFloat(d);
                });
                radius = parseFloat(p.shift().split(",")[0]);
                width = Math.sqrt(Math.pow(last[0] - prev[0], 2) + Math.pow(last[1] - prev[1], 2));
                angle = Math.acos((radius * radius + radius * radius - width * width) / (2 * radius * radius));
                obtuse = p[1].split(",")[0] === "1";
                if (obtuse) {
                    angle = Math.PI * 2 - angle;
                }
                length = angle / (Math.PI * 2) * (radius * Math.PI * 2);
                segments = length / 5;
                start = Math.atan2(-prev[1], -prev[0]) - Math.PI;
                step = angle / segments;
                i = step;
                while (i < angle) {
                    o = offset(start + i, radius);
                    poly.push([o.x, o.y]);
                    i += step;
                }
                poly.push(last);
            }
        }
        return poly;
    };


},{"../geom/offset.coffee":162}],164:[function(require,module,exports){

    /**
     * @class d3plus
     */
    var d3plus, message, stylesheet;

    d3plus = {};


    /**
     * The current version of **D3plus** you are using. Returns a string in
     * [semantic versioning](http://semver.org/) format.
     * @property d3plus.version
     * @for d3plus
     * @type String
     * @static
     */

    d3plus.version = "1.9.3 - Cornflower";


    /**
     * The URL for the repo, used internally for certain error messages.
     * @property d3plus.repo
     * @for d3plus
     * @type String
     * @static
     */

    d3plus.repo = "https://github.com/alexandersimoes/d3plus/";


    /**
     * Utilities related to modifying arrays.
     * @class d3plus.array
     * @for d3plus
     * @static
     */

    d3plus.array = {
        comparator: require("./array/comparator.coffee"),
        contains: require("./array/contains.coffee"),
        sort: require("./array/sort.coffee"),
        update: require("./array/update.coffee")
    };


    /**
     * Utilities related to the client's browser.
     * @class d3plus.client
     * @for d3plus
     * @static
     */

    d3plus.client = {
        css: require("./client/css.coffee"),
        ie: require("./client/ie.js"),
        pointer: require("./client/pointer.coffee"),
        prefix: require("./client/prefix.coffee"),
        rtl: require("./client/rtl.coffee"),
        scroll: require("./client/scroll.js"),
        scrollbar: require("./client/scrollbar.coffee"),
        touch: require("./client/touch.coffee")
    };


    /**
     * Utilities related to color manipulation.
     * @class d3plus.color
     * @for d3plus
     * @static
     */

    d3plus.color = {
        legible: require("./color/legible.coffee"),
        lighter: require("./color/lighter.coffee"),
        mix: require("./color/mix.coffee"),
        random: require("./color/random.coffee"),
        scale: require("./color/scale.coffee"),
        sort: require("./color/sort.coffee"),
        text: require("./color/text.coffee"),
        validate: require("./color/validate.coffee")
    };


    /**
     * Utilities related to manipulating data.
     * @class d3plus.data
     * @for d3plus
     * @static
     */

    d3plus.data = {
        bestRegress: require("./data/bestRegress.coffee"),
        lof: require("./data/lof.coffee"),
        mad: require("./data/mad.coffee")
    };


    /**
     * Utilities related to fonts.
     * @class d3plus.font
     * @for d3plus
     * @static
     */

    d3plus.font = {
        sizes: require("./font/sizes.coffee"),
        validate: require("./font/validate.coffee")
    };


    /**
     * D3plus Forms
     * @class d3plus.form
     * @for d3plus
     */

    d3plus.form = require("./form/form.js");


    /**
     * Utilities related to geometric algorithms.
     * @class d3plus.geom
     * @for d3plus
     * @static
     */

    d3plus.geom = {
        largestRect: require("./geom/largestRect.coffee"),
        offset: require("./geom/offset.coffee"),
        path2poly: require("./geom/path2poly.coffee")
    };


    /**
     * Utilities related to network graphs.
     * @class d3plus.network
     * @for d3plus
     * @static
     */

    d3plus.network = {
        cluster: require("./network/cluster.coffee"),
        distance: require("./network/distance.coffee"),
        normalize: require("./network/normalize.coffee"),
        shortestPath: require("./network/shortestPath.coffee"),
        smallestGap: require("./network/smallestGap.coffee"),
        subgraph: require("./network/subgraph.coffee")
    };


    /**
     * Utilities that process numbers.
     * @class d3plus.number
     * @for d3plus
     * @static
     */

    d3plus.number = {
        format: require("./number/format.coffee")
    };


    /**
     * D3plus features a set of methods that relate to various object properties. These methods may be used outside of the normal constraints of the visualizations.
     * @class d3plus.object
     * @for d3plus
     * @static
     */

    d3plus.object = {
        merge: require("./object/merge.coffee"),
        validate: require("./object/validate.coffee")
    };


    /**
     * Utilities that process strings.
     * @class d3plus.string
     * @for d3plus
     * @static
     */

    d3plus.string = {
        format: require("./string/format.js"),
        list: require("./string/list.coffee"),
        strip: require("./string/strip.js"),
        title: require("./string/title.coffee")
    };


    /**
     * D3plus SVG Textwrapping
     * @class d3plus.textwrap
     * @for d3plus
     */

    d3plus.textwrap = require("./textwrap/textwrap.coffee");


    /**
     * D3plus Tooltips
     * @class d3plus.tooltip
     * @for d3plus
     */

    d3plus.tooltip = {
        create: require("./tooltip/create.js"),
        move: require("./tooltip/move.coffee"),
        remove: require("./tooltip/remove.coffee")
    };


    /**
     * D3plus features Utilities that can be used to help with some common javascript processes.
     * @class d3plus.util
     * @for d3plus
     * @static
     */

    d3plus.util = {
        buckets: require("./util/buckets.coffee"),
        child: require("./util/child.coffee"),
        closest: require("./util/closest.coffee"),
        copy: require("./util/copy.coffee"),
        d3selection: require("./util/d3selection.coffee"),
        dataurl: require("./util/dataURL.coffee"),
        uniques: require("./util/uniques.coffee")
    };


    /**
     * D3plus Visualizations
     * @class d3plus.viz
     * @for d3plus
     */

    d3plus.viz = require("./viz/viz.coffee");

    stylesheet = require("./client/css.coffee");

    message = require("./core/console/print.coffee");

    if (stylesheet("d3plus.css")) {
        message.warning("d3plus.css has been deprecated, you do not need to load this file.", d3plus.repo + "releases/tag/v1.4.0");
    }

    if (typeof window !== "undefined") {
        window.d3plus = d3plus;
    }

    module.exports = d3plus;


},{"./array/comparator.coffee":34,"./array/contains.coffee":35,"./array/sort.coffee":36,"./array/update.coffee":37,"./client/css.coffee":38,"./client/ie.js":39,"./client/pointer.coffee":40,"./client/prefix.coffee":41,"./client/rtl.coffee":42,"./client/scroll.js":43,"./client/scrollbar.coffee":44,"./client/touch.coffee":45,"./color/legible.coffee":46,"./color/lighter.coffee":47,"./color/mix.coffee":48,"./color/random.coffee":49,"./color/scale.coffee":50,"./color/sort.coffee":51,"./color/text.coffee":52,"./color/validate.coffee":53,"./core/console/print.coffee":54,"./data/bestRegress.coffee":100,"./data/lof.coffee":101,"./data/mad.coffee":102,"./font/sizes.coffee":103,"./font/validate.coffee":104,"./form/form.js":105,"./geom/largestRect.coffee":161,"./geom/offset.coffee":162,"./geom/path2poly.coffee":163,"./network/cluster.coffee":166,"./network/distance.coffee":167,"./network/normalize.coffee":168,"./network/shortestPath.coffee":169,"./network/smallestGap.coffee":170,"./network/subgraph.coffee":171,"./number/format.coffee":172,"./object/merge.coffee":173,"./object/validate.coffee":174,"./string/format.js":175,"./string/list.coffee":176,"./string/strip.js":177,"./string/title.coffee":178,"./textwrap/textwrap.coffee":202,"./tooltip/create.js":203,"./tooltip/move.coffee":204,"./tooltip/remove.coffee":205,"./util/buckets.coffee":206,"./util/child.coffee":207,"./util/closest.coffee":208,"./util/copy.coffee":209,"./util/d3selection.coffee":210,"./util/dataURL.coffee":211,"./util/uniques.coffee":212,"./viz/viz.coffee":335}],165:[function(require,module,exports){
    window.d3 = require("d3");

    window.topojson = require("topojson");


},{"d3":5,"topojson":33}],166:[function(require,module,exports){
    var normalize;

    normalize = require("./normalize.coffee");

    module.exports = function(edges, options) {
        var Q, a, b, cid, commSize, commSizes, communities, community, deltaQ, distance, edge, endpoint, events, i, id, iter, j, k, len, len1, linksMap, m, maxa, maxb, node, nodeid, nodes, nodesMap, ref, ref1, result, startpoint;
        events = [];
        if (options == null) {
            options = {};
        }
        if ((options.nodes == null) || typeof options.nodes !== 'object') {
            ref = normalize(edges, options), edges = ref[0], options = ref[1];
            if (options === null) {
                return null;
            }
        }
        distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, nodes = options.nodes;
        nodesMap = {};
        for (id in nodes) {
            nodesMap[id] = {
                node: nodes[id].node,
                degree: 0
            };
        }
        m = 0;
        linksMap = {};
        for (i = 0, len = edges.length; i < len; i++) {
            edge = edges[i];
            a = nodeid(startpoint(edge));
            b = nodeid(endpoint(edge));
            if (!(a in linksMap)) {
                linksMap[a] = {};
            }
            if (!(b in linksMap)) {
                linksMap[b] = {};
            }
            if (!(b in linksMap[a])) {
                linksMap[a][b] = 0;
                linksMap[b][a] = 0;
                m++;
                nodesMap[a].degree += 1;
                nodesMap[b].degree += 1;
            }
        }
        communities = {};
        Q = 0;
        for (id in nodesMap) {
            node = nodesMap[id];
            communities[id] = {
                score: node.degree / (2.0 * m),
                nodes: [id]
            };
        }
        for (a in linksMap) {
            for (b in linksMap[a]) {
                linksMap[a][b] = 1.0 / (2 * m) - (nodesMap[a].degree * nodesMap[b].degree) / (4.0 * m * m);
            }
        }
        iter = 0;
        while (iter < 1000) {
            deltaQ = -1;
            maxa = void 0;
            maxb = void 0;
            for (a in linksMap) {
                for (b in linksMap[a]) {
                    if (linksMap[a][b] > deltaQ) {
                        deltaQ = linksMap[a][b];
                        maxa = a;
                        maxb = b;
                    }
                }
            }
            if (deltaQ < 0) {
                break;
            }
            for (k in linksMap[maxa]) {
                if (k !== maxb) {
                    if (k in linksMap[maxb]) {
                        linksMap[maxb][k] += linksMap[maxa][k];
                    } else {
                        linksMap[maxb][k] = linksMap[maxa][k] - 2 * communities[maxb].score * communities[k].score;
                    }
                    linksMap[k][maxb] = linksMap[maxb][k];
                }
                delete linksMap[k][maxa];
            }
            for (k in linksMap[maxb]) {
                if (!(k in linksMap[maxa]) && k !== maxb) {
                    linksMap[maxb][k] -= 2 * communities[maxa].score * communities[k].score;
                    linksMap[k][maxb] = linksMap[maxb][k];
                }
            }
            ref1 = communities[maxa].nodes;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                node = ref1[j];
                communities[maxb].nodes.push(node);
            }
            communities[maxb].score += communities[maxa].score;
            if (options.vdebug) {
                events.push({
                    type: 'merge',
                    father: maxb,
                    child: maxa,
                    nodes: communities[maxb].nodes
                });
            }
            delete communities[maxa];
            delete linksMap[maxa];
            Q += deltaQ;
            iter++;
        }
        commSizes = (function() {
            var results;
            results = [];
            for (cid in communities) {
                community = communities[cid];
                results.push([cid, community.nodes.length]);
            }
            return results;
        })();
        commSizes.sort(function(a, b) {
            return b[1] - a[1];
        });
        result = (function() {
            var l, len2, results;
            results = [];
            for (l = 0, len2 = commSizes.length; l < len2; l++) {
                commSize = commSizes[l];
                results.push(communities[commSize[0]].nodes);
            }
            return results;
        })();
        return [result, events];
    };


},{"./normalize.coffee":168}],167:[function(require,module,exports){
    module.exports = function(n1, n2) {
        var xx, yy;
        if (!(n1 instanceof Array)) {
            n1 = [n1.x, n1.y];
        }
        if (!(n2 instanceof Array)) {
            n2 = [n2.x, n2.y];
        }
        xx = Math.abs(n1[0] - n2[0]);
        yy = Math.abs(n1[1] - n2[1]);
        return Math.sqrt((xx * xx) + (yy * yy));
    };


},{}],168:[function(require,module,exports){
    var print;

    print = require("../core/console/print.coffee");

    module.exports = function(edges, options) {
        var K, a, b, directed, distance, edge, edge2distance, endpoint, errormsg, i, id, id1, idA, idB, j, k, l, len, len1, len2, node, nodeA, nodeB, nodeid, nodes, ref, ref1, source, startpoint, target, vdebug;
        source = options.source, target = options.target, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, vdebug = options.vdebug;
        if (!directed) {
            directed = false;
        }
        if (K == null) {
            K = 1;
        }
        if (nodeid == null) {
            nodeid = function(node) {
                return node;
            };
        } else if (typeof nodeid === 'string') {
            nodeid = (function(nodeid) {
                return function(node) {
                    return node[nodeid];
                };
            })(nodeid);
        }
        if ((source != null) && typeof source === 'object') {
            source = nodeid(source);
        }
        if ((target != null) && typeof target === 'object') {
            target = nodeid(target);
        }
        if (startpoint == null) {
            startpoint = function(edge) {
                return edge.source;
            };
        } else if (typeof startpoint === 'string') {
            startpoint = (function(startpoint) {
                return function(edge) {
                    return edge[startpoint];
                };
            })(startpoint);
        }
        if (endpoint == null) {
            endpoint = function(edge) {
                return edge.target;
            };
        } else if (typeof endpoint === 'string') {
            endpoint = (function(endpoint) {
                return function(edge) {
                    return edge[endpoint];
                };
            })(endpoint);
        }
        if (distance == null) {
            distance = function(edge) {
                return 1;
            };
        } else if (typeof distance === 'number') {
            distance = (function(distance) {
                return function(edge) {
                    return distance;
                };
            })(distance);
        } else if (typeof distance === 'string') {
            distance = (function(distance) {
                return function(edge) {
                    return edge[distance];
                };
            })(distance);
        } else if (distance instanceof Array) {
            edge2distance = {};
            for (i = j = 0, len = edges.length; j < len; i = ++j) {
                edge = edges[i];
                a = nodeid(startpoint(edge));
                b = nodeid(endpoint(edge));
                edge2distance[a + '_' + b] = distance[i];
            }
            distance = function(edge) {
                a = nodeid(startpoint(edge));
                b = nodeid(endpoint(edge));
                return edge2distance[a + '_' + b];
            };
        }
        nodes = {};
        for (k = 0, len1 = edges.length; k < len1; k++) {
            edge = edges[k];
            nodeA = startpoint(edge);
            nodeB = endpoint(edge);
            idA = nodeid(nodeA);
            idB = nodeid(nodeB);
            ref = [nodeA, nodeB];
            for (l = 0, len2 = ref.length; l < len2; l++) {
                node = ref[l];
                id = nodeid(node);
                if (!(id in nodes)) {
                    nodes[id] = {
                        node: node,
                        outedges: []
                    };
                }
            }
            nodes[idA].outedges.push(edge);
            if (!directed) {
                nodes[idB].outedges.push(edge);
            }
        }
        errormsg = null;
        if (edges.length === 0) {
            errormsg = 'The length of edges is 0';
        } else if (K < 0) {
            errormsg = 'K can not have negative value';
        } else if (distance(edges[0]) == null) {
            errormsg = 'Check the distance function/attribute';
        } else if (startpoint(edges[0]) == null) {
            errormsg = 'Check the startpoint function/attribute';
        } else if (endpoint(edges[0]) == null) {
            errormsg = 'Check the endpoint function/attribute';
        } else {
            id1 = nodeid(startpoint(edges[0]));
            if ((id1 == null) || ((ref1 = typeof id1) !== 'string' && ref1 !== 'number')) {
                errormsg = 'Check the nodeid function/attribute';
            } else if ((source != null) && !(source in nodes)) {
                errormsg = 'The source is not in the graph';
            } else if ((target != null) && !(target in nodes)) {
                errormsg = 'The target is not in the graph';
            }
        }
        if (errormsg != null) {
            print.error(errormsg);
            return null;
        }
        return [
            edges, {
                source: source,
                target: target,
                directed: directed,
                distance: distance,
                nodeid: nodeid,
                startpoint: startpoint,
                endpoint: endpoint,
                K: K,
                nodes: nodes,
                vdebug: vdebug
            }
        ];
    };


},{"../core/console/print.coffee":54}],169:[function(require,module,exports){
    var Heap, normalize;

    Heap = require('heap');

    normalize = require("./normalize.coffee");

    module.exports = function(edges, source, options) {
        var K, a, alt, b, directed, distance, edge, endpoint, getPath, heap, i, id, j, len, len1, maxsize, node, nodeid, nodes, path, ref, ref1, ref2, res, result, startpoint, target, u, visited;
        if (options == null) {
            options = {};
        }
        options.source = source;
        if ((options.nodes == null) || typeof options.nodes !== 'object') {
            ref = normalize(edges, options), edges = ref[0], options = ref[1];
            if (options === null) {
                return null;
            }
        }
        source = options.source, target = options.target, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, nodes = options.nodes;
        for (id in nodes) {
            node = nodes[id];
            node.count = 0;
        }
        heap = new Heap(function(a, b) {
            return a.distance - b.distance;
        });
        visited = {};
        if (target == null) {
            visited[source] = true;
        }
        heap.push({
            edge: null,
            target: source,
            distance: 0
        });
        maxsize = 0;
        result = [];
        while (!heap.empty()) {
            maxsize = Math.max(maxsize, heap.size());
            path = heap.pop();
            u = path.target;
            nodes[u].count++;
            if (target == null) {
                result.push(path);
            } else if (u === target) {
                result.push(path);
            }
            if (result.length === K) {
                break;
            }
            if (nodes[u].count <= K) {
                ref1 = nodes[u].outedges;
                for (i = 0, len = ref1.length; i < len; i++) {
                    edge = ref1[i];
                    a = nodeid(startpoint(edge));
                    b = nodeid(endpoint(edge));
                    if (!directed && b === u) {
                        ref2 = [b, a], a = ref2[0], b = ref2[1];
                    }
                    if (target == null) {
                        if (visited[b]) {
                            continue;
                        }
                        visited[b] = true;
                    }
                    alt = path.distance + distance(edge);
                    heap.push({
                        edge: edge,
                        previous: path,
                        target: b,
                        distance: alt
                    });
                }
            }
        }
        getPath = function(path) {
            edges = [];
            while (path.edge != null) {
                edges.push(path.edge);
                path = path.previous;
            }
            return edges.reverse();
        };
        for (j = 0, len1 = result.length; j < len1; j++) {
            res = result[j];
            if (target != null) {
                delete res.target;
                res.edges = getPath(res);
            }
            delete res.edge;
            delete res.previous;
        }
        return result;
    };


},{"./normalize.coffee":168,"heap":6}],170:[function(require,module,exports){
    var distance;

    distance = require("./distance.coffee");

    module.exports = function(arr, opts) {
        var distances, quad;
        if (!opts) {
            opts = {};
        }
        distances = [];
        quad = d3.geom.quadtree().x(function(d) {
            if (opts.accessor) {
                return opts.accessor(d)[0];
            } else {
                return d[0];
            }
        }).y(function(d) {
            if (opts.accessor) {
                return opts.accessor(d)[1];
            } else {
                return d[1];
            }
        });
        quad(arr).visit(function(node) {
            var i, j, len, len1, n1, n2, ref, ref1;
            if (!node.leaf) {
                ref = node.nodes;
                for (i = 0, len = ref.length; i < len; i++) {
                    n1 = ref[i];
                    if (n1 && n1.point) {
                        if (opts.origin) {
                            distances.push(distance(n1, opts));
                        } else {
                            ref1 = node.nodes;
                            for (j = 0, len1 = ref1.length; j < len1; j++) {
                                n2 = ref1[j];
                                if (n2 && n2.point && n2.point !== n1.point) {
                                    distances.push(distance(n1, n2));
                                }
                            }
                        }
                    }
                }
            }
            return false;
        });
        if (opts.all) {
            return distances.sort(function(aa, bb) {
                return aa - bb;
            });
        } else {
            return d3.min(distances);
        }
    };


},{"./distance.coffee":167}],171:[function(require,module,exports){
    var normalize;

    normalize = require("./normalize.coffee");

    module.exports = function(edges, source, options) {
        var K, dfs, directed, distance, edge, endpoint, id, nodeid, nodes, ref, startpoint, visited;
        if (options == null) {
            options = {};
        }
        options.source = source;
        if ((options.nodes == null) || typeof options.nodes !== 'object') {
            ref = normalize(edges, options), edges = ref[0], options = ref[1];
            if (options === null) {
                return null;
            }
        }
        source = options.source, directed = options.directed, distance = options.distance, nodeid = options.nodeid, startpoint = options.startpoint, endpoint = options.endpoint, K = options.K, nodes = options.nodes;
        visited = {};
        visited[source] = true;
        dfs = function(origin, curr_distance) {
            var a, b, edge, i, len, new_distance, ref1, ref2, results;
            ref1 = nodes[origin].outedges;
            results = [];
            for (i = 0, len = ref1.length; i < len; i++) {
                edge = ref1[i];
                a = nodeid(startpoint(edge));
                b = nodeid(endpoint(edge));
                if (!directed && b === origin) {
                    ref2 = [b, a], a = ref2[0], b = ref2[1];
                }
                if (!(b in visited)) {
                    new_distance = curr_distance + distance(edge);
                    if (new_distance <= K) {
                        visited[b] = true;
                        results.push(dfs(b, new_distance));
                    } else {
                        results.push(void 0);
                    }
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        dfs(source, 0);
        return {
            nodes: (function() {
                var results;
                results = [];
                for (id in visited) {
                    results.push(nodes[id].node);
                }
                return results;
            })(),
            edges: (function() {
                var i, len, results;
                results = [];
                for (i = 0, len = edges.length; i < len; i++) {
                    edge = edges[i];
                    if (nodeid(startpoint(edge)) in visited && nodeid(endpoint(edge)) in visited) {
                        results.push(edge);
                    }
                }
                return results;
            })()
        };
    };


},{"./normalize.coffee":168}],172:[function(require,module,exports){
    var defaultLocale;

    defaultLocale = require("../core/locale/languages/en_US.coffee");

    module.exports = function(number, opts) {
        var affixes, format, key, labels, length, locale, ret, sigs, symbol, time, vars, zeros;
        if (number === void 0 || number === null || number === false) {
            return "";
        }
        if (!opts) {
            opts = {};
        }
        if ("locale" in opts) {
            locale = opts.locale;
        } else {
            locale = defaultLocale;
        }
        time = locale.time.slice();
        format = d3.locale(locale.format);
        if (!opts) {
            opts = {};
        }
        vars = opts.vars || {};
        key = opts.key;
        labels = "labels" in opts ? opts.labels : true;
        length = number.toString().split(".")[0].length;
        if (vars.time && vars.time.value) {
            time.push(vars.time.value);
        }
        if (typeof key === "string" && time.indexOf(key.toLowerCase()) >= 0) {
            ret = number;
        } else if (key === "share") {
            if (number === 0) {
                ret = 0;
            } else if (number >= 100) {
                ret = format.numberFormat(",f")(number);
            } else if (number > 99) {
                ret = format.numberFormat(".3g")(number);
            } else {
                ret = format.numberFormat(".2g")(number);
            }
            ret += "%";
        } else if (number < 10 && number > -10) {
            length = number.toString().split(".");
            sigs = 1;
            if (length.length > 1) {
                sigs = d3.min([parseFloat(length[1]).toString().length, 2]);
                if (!((-1 < number && number < 1))) {
                    zeros = length[1].length - parseFloat(length[1]).toString().length;
                    sigs += 1 + zeros;
                }
            }
            ret = format.numberFormat("." + sigs + "g")(number);
        } else if (length > 3) {
            symbol = d3.formatPrefix(number).symbol;
            symbol = symbol.replace("G", "B");
            number = d3.formatPrefix(number).scale(number);
            number = format.numberFormat(".3g")(number);
            number = number.replace(locale.format.decimal, ".");
            number = parseFloat(number) + "";
            number = number.replace(".", locale.format.decimal);
            ret = number + symbol;
        } else if (length === 3) {
            ret = format.numberFormat(",f")(number);
        } else if (number === 0) {
            ret = 0;
        } else {
            if (number === parseInt(number, 10)) {
                ret = format.numberFormat(".2")(number);
            } else {
                ret = format.numberFormat(".3g")(number);
            }
        }
        if (ret.length > 2 && "" + ret.indexOf(".0") === ret.length - 2) {
            ret = ret.slice(0, ret.length - 2);
        }
        if (labels && key && "format" in vars && key in vars.format.affixes.value) {
            affixes = vars.format.affixes.value[key];
            return affixes[0] + ret + affixes[1];
        } else {
            return ret;
        }
    };


},{"../core/locale/languages/en_US.coffee":71}],173:[function(require,module,exports){
    var d3selection, validate;

    d3selection = require("../util/d3selection.coffee");

    validate = require("./validate.coffee");


    /**
     * Given any two objects, this method will merge the two objects together, returning a new third object. The values of the second object always overwrite the first.
     * @method d3plus.object.merge
     * @for d3plus.object
     * @param obj1 {Object} The primary object.
     * @param obj2 {Object} The secondary object to merge into the first.
     * @return {Object}
     */

    module.exports = function(obj1, obj2) {
        var copyObject, obj3;
        copyObject = function(obj, ret, shallow) {
            var k, results, v;
            results = [];
            for (k in obj) {
                v = obj[k];
                if (typeof v !== "undefined") {
                    if (!shallow && validate(v)) {
                        if (typeof ret[k] !== "object") {
                            ret[k] = {};
                        }
                        results.push(copyObject(v, ret[k], k.indexOf("d3plus") === 0));
                    } else if (!d3selection(v) && v instanceof Array) {
                        results.push(ret[k] = v.slice(0));
                    } else {
                        results.push(ret[k] = v);
                    }
                } else {
                    results.push(void 0);
                }
            }
            return results;
        };
        obj3 = {};
        if (obj1) {
            copyObject(obj1, obj3);
        }
        if (obj2) {
            copyObject(obj2, obj3);
        }
        return obj3;
    };


},{"../util/d3selection.coffee":210,"./validate.coffee":174}],174:[function(require,module,exports){

    /**
     * This function returns true if the variable passed is a literal javascript keyed Object. It's a small, simple function, but it catches some edge-cases that can throw off your code (such as Arrays and `null`).
     * @method d3plus.object.validate
     * @for d3plus.object
     * @param obj {Object} The object to validate.
     * @return {Boolean}
     */
    module.exports = function(obj) {
        return obj && obj.constructor === Object;
    };


},{}],175:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Formats a string similar to Python's "format"
//------------------------------------------------------------------------------
    module.exports = function() {

        var args = Array.prototype.slice.call(arguments)
            , str = args.shift()

        str.unkeyed_index = 0;
        return str.replace(/\{(\w*)\}/g, function(match, key) {
            if (key === '') {
                key = str.unkeyed_index;
                str.unkeyed_index++
            }
            if (key == +key) {
                return args[key] !== 'undefined'
                    ? args[key]
                    : match;
            } else {
                for (var i = 0; i < args.length; i++) {
                    if (typeof args[i] === 'object' && typeof args[i][key] !== 'undefined') {
                        return args[i][key];
                    }
                }
                return match;
            }
        }.bind(str));

    }

},{}],176:[function(require,module,exports){
    var format, locale;

    format = require("./format.js");

    locale = require("../core/locale/languages/en_US.coffee").ui;

    module.exports = function(list, andText, max, moreText) {
        var amount;
        if (!(list instanceof Array)) {
            return list;
        } else {
            list = list.slice(0);
        }
        if (!andText) {
            andText = locale.and;
        }
        if (!moreText) {
            moreText = locale.moreText;
        }
        if (list.length === 2) {
            return list.join(" " + andText + " ");
        } else {
            if (max && list.length > max) {
                amount = list.length - max + 1;
                list = list.slice(0, max - 1);
                list[max - 1] = format(moreText, amount);
            }
            if (list.length > 1) {
                list[list.length - 1] = andText + " " + list[list.length - 1];
            }
            return list.join(", ");
        }
    };


},{"../core/locale/languages/en_US.coffee":71,"./format.js":175}],177:[function(require,module,exports){
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Removes all non ASCII characters
//------------------------------------------------------------------------------
    module.exports = function(str) {

        var removed = [ "!","@","#","$","%","^","&","*","(",")",
            "[","]","{","}",".",",","/","\\","|",
            "'","\"",";",":","<",">","?","=","+"];

        var diacritics = [
            [/[\300-\306]/g, "A"],
            [/[\340-\346]/g, "a"],
            [/[\310-\313]/g, "E"],
            [/[\350-\353]/g, "e"],
            [/[\314-\317]/g, "I"],
            [/[\354-\357]/g, "i"],
            [/[\322-\330]/g, "O"],
            [/[\362-\370]/g, "o"],
            [/[\331-\334]/g, "U"],
            [/[\371-\374]/g, "u"],
            [/[\321]/g, "N"],
            [/[\361]/g, "n"],
            [/[\307]/g, "C"],
            [/[\347]/g, "c"]
        ];

        str += "";

        return ""+str.replace(/[^A-Za-z0-9\-_]/g, function(chr) {

            if (" " === chr) {
                return "_";
            }
            else if (removed.indexOf(chr) >= 0) {
                return "";
            }

            var ret = chr;
            for (var d = 0; d < diacritics.length; d++) {
                if (new RegExp(diacritics[d][0]).test(chr)) {
                    ret = diacritics[d][1];
                    break;
                }
            }

            return ret;

        });

    };

},{}],178:[function(require,module,exports){
    var defaultLocale;

    defaultLocale = require("../core/locale/languages/en_US.coffee");

    module.exports = function(text, opts) {
        var biglow, bigs, key, locale, smalls;
        if (!text) {
            return "";
        }
        if (!opts) {
            opts = {};
        }
        key = opts.key;
        if (text.charAt(text.length - 1) === ".") {
            return text.charAt(0).toUpperCase() + text.substr(1);
        }
        locale = "locale" in this ? this.locale.value : defaultLocale;
        smalls = locale.lowercase.map(function(b) {
            return b.toLowerCase();
        });
        bigs = locale.uppercase;
        bigs = bigs.concat(bigs.map(function(b) {
            return b + "s";
        }));
        biglow = bigs.map(function(b) {
            return b.toLowerCase();
        });
        return text.replace(/[^\s!-#%&(-\x2A,-:;\x3F@\x5B-\x5D_\x7B}\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]*/g, function(txt, i) {
            var bigindex, new_txt;
            if (txt) {
                bigindex = biglow.indexOf(txt.toLowerCase());
                if (bigindex >= 0) {
                    return new_txt = bigs[bigindex];
                } else if (smalls.indexOf(txt.toLowerCase()) >= 0 && i !== 0 && i !== text.length - 1) {
                    return new_txt = txt.toLowerCase();
                } else {
                    return new_txt = txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                }
            } else {
                return "";
            }
        });
    };


},{"../core/locale/languages/en_US.coffee":71}],179:[function(require,module,exports){
    var foreign, tspan;

    foreign = require("./foreign.coffee");

    tspan = require("./tspan.coffee");

    module.exports = function(vars) {
        if (vars.text.html.value) {
            foreign(vars);
        } else {
            tspan(vars);
        }
    };


},{"./foreign.coffee":180,"./tspan.coffee":183}],180:[function(require,module,exports){
    module.exports = function(vars) {
        var anchor, color, family, opacity, text;
        text = vars.container.value;
        family = text.attr("font-family") || text.style("font-family");
        anchor = vars.align.value || text.attr("text-anchor") || text.style("text-anchor");
        color = text.attr("fill") || text.style("fill");
        opacity = text.attr("opacity") || text.style("opacity");
        anchor = anchor === "end" ? "right" : (anchor === "middle" ? "center" : "left");
        d3.select(text.node().parentNode).append("foreignObject").attr("width", vars.width.value + "px").attr("height", vars.height.value + "px").attr("x", "0px").attr("y", "0px").append("xhtml:div").style("font-family", family).style("font-size", vars.size.value[1] + "px").style("color", color).style("text-align", anchor).style("opacity", opacity).text(vars.text.current);
    };


},{}],181:[function(require,module,exports){
    module.exports = function(vars) {
        var diff, elem, height, prev, radius, shape, size, width, x, y;
        elem = vars.container.value;
        prev = elem.node().previousElementSibling;
        shape = prev ? prev.tagName.toLowerCase() : "";
        if (prev) {
            prev = d3.select(prev);
        }
        vars.container.x = vars.x.value || parseFloat(elem.attr("x"), 10);
        vars.container.y = vars.y.value || parseFloat(elem.attr("y"), 10);
        if (prev) {
            if (vars.shape.accepted.indexOf(shape) >= 0) {
                vars.self.shape(shape);
            }
            if (shape === "rect") {
                x = parseFloat(prev.attr("x"), 10) || 0;
                y = parseFloat(prev.attr("y"), 10) || 0;
                if (vars.padding.value === false) {
                    diff = Math.abs(x - vars.container.x);
                    if (diff) {
                        vars.self.padding(diff);
                    }
                }
                if (!vars.container.x) {
                    vars.container.x = x + vars.padding.value;
                }
                if (!vars.container.y) {
                    vars.container.y = y + vars.padding.value;
                }
                if (!vars.width.value) {
                    width = parseFloat(prev.attr("width" || prev.style("width", 10)));
                    vars.self.width(width);
                }
                if (!vars.height.value) {
                    height = parseFloat(prev.attr("height" || prev.style("height", 10)));
                    vars.self.height(height);
                }
            } else if (shape === "circle") {
                radius = parseFloat(prev.attr("r"), 10);
                x = parseFloat(prev.attr("cx"), 10) || 0;
                x -= radius;
                y = parseFloat(prev.attr("cy"), 10) || 0;
                y -= radius;
                if (vars.padding.value === false) {
                    diff = Math.abs(x - vars.container.x);
                    if (diff) {
                        vars.self.padding(diff);
                    }
                }
                if (!vars.container.x) {
                    vars.container.x = x + vars.padding.value;
                }
                if (!vars.container.y) {
                    vars.container.y = y + vars.padding.value;
                }
                if (!vars.width.value) {
                    vars.self.width(radius * 2, 10);
                }
                if (!vars.height.value) {
                    vars.self.height(radius * 2, 10);
                }
            } else {
                if (!vars.width.value) {
                    vars.self.width(500);
                }
                if (!vars.height.value) {
                    vars.self.height(500);
                }
            }
        }
        if (!vars.container.x) {
            vars.container.x = 0;
        }
        if (!vars.container.y) {
            vars.container.y = 0;
        }
        vars.width.inner = vars.width.value - vars.padding.value * 2;
        vars.height.inner = vars.height.value - vars.padding.value * 2;
        size = elem.attr("font-size") || elem.style("font-size");
        size = parseFloat(size, 10);
        vars.container.fontSize = size;
        vars.container.dy = parseFloat(elem.attr("dy"), 10);
        if (!vars.size.value) {
            if (vars.resize.value) {
                return vars.self.size([4, 80]);
            } else {
                return vars.self.size([size / 2, size]);
            }
        }
    };


},{}],182:[function(require,module,exports){
    module.exports = function(vars) {
        var text;
        if (!vars.text.value) {
            text = vars.container.value.text();
            if (text) {
                if (text.indexOf("tspan") >= 0) {
                    text.replace(/\<\/tspan\>\<tspan\>/g, " ");
                    text.replace(/\<\/tspan\>/g, "");
                    text.replace(/\<tspan\>/g, "");
                }
                text = text.replace(/(\r\n|\n|\r)/gm, "");
                text = text.replace(/^\s+|\s+$/g, "");
                vars.self.text(text);
            }
        }
        if (vars.text.value instanceof Array) {
            vars.text.phrases = vars.text.value.filter(function(t) {
                return ["string", "number"].indexOf(typeof t) >= 0;
            });
        } else {
            vars.text.phrases = [vars.text.value + ""];
        }
        if (!vars.align.value) {
            return vars.container.align = vars.container.value.style("text-anchor") || vars.container.value.attr("text-anchor");
        }
    };


},{}],183:[function(require,module,exports){
    var rtl;

    rtl = require("../../client/rtl.coffee");

    module.exports = function(vars) {
        var anchor, dy, ellipsis, fontSize, h, height, line, lineWidth, lines, mirror, newLine, placeWord, progress, reverse, rmod, rotate, rx, ry, space, start, textBox, translate, truncate, valign, width, words, wrap, x, xOffset, y, yOffset;
        newLine = function(first) {
            var tspan;
            if (!reverse || first) {
                tspan = vars.container.value.append("tspan");
            } else {
                tspan = vars.container.value.insert("tspan", "tspan");
            }
            return tspan.attr("x", x + "px").attr("dy", dy + "px").style("baseline-shift", "0%").attr("dominant-baseline", "alphabetic");
        };
        mirror = vars.rotate.value === -90 || vars.rotate.value === 90;
        width = mirror ? vars.height.inner : vars.width.inner;
        height = mirror ? vars.width.inner : vars.height.inner;
        if (vars.shape.value === "circle") {
            anchor = "middle";
        } else {
            anchor = vars.align.value || vars.container.align || "start";
        }
        if (anchor === "end" || (anchor === "start" && rtl)) {
            xOffset = width;
        } else if (anchor === "middle") {
            xOffset = width / 2;
        } else {
            xOffset = 0;
        }
        valign = vars.valign.value || "top";
        x = vars.container.x + xOffset;
        fontSize = vars.resize.value ? vars.size.value[1] : vars.container.fontSize || vars.size.value[0];
        dy = vars.container.dy || fontSize * 1.1;
        textBox = null;
        progress = null;
        words = null;
        reverse = false;
        yOffset = 0;
        if (vars.shape.value === "circle") {
            if (valign === "middle") {
                yOffset = ((height / dy % 1) * dy) / 2;
            } else if (valign === "end") {
                yOffset = (height / dy % 1) * dy;
            }
        }
        vars.container.value.attr("text-anchor", anchor).attr("font-size", fontSize + "px").style("font-size", fontSize + "px").attr("x", vars.container.x).attr("y", vars.container.y);
        truncate = function() {
            textBox.remove();
            if (reverse) {
                line++;
                textBox = vars.container.value.select("tspan");
            } else {
                line--;
                textBox = d3.select(vars.container.value.node().lastChild);
            }
            if (!textBox.empty()) {
                words = textBox.text().match(/[^\s-]+-?/g);
                return ellipsis();
            }
        };
        lineWidth = function() {
            var b;
            if (vars.shape.value === "circle") {
                b = ((line - 1) * dy) + yOffset;
                if (b > height / 2) {
                    b += dy;
                }
                return 2 * Math.sqrt(b * ((2 * (width / 2)) - b));
            } else {
                return width;
            }
        };
        ellipsis = function() {
            var lastChar, lastWord;
            if (words && words.length) {
                lastWord = words.pop();
                lastChar = lastWord.charAt(lastWord.length - 1);
                if (lastWord.length === 1 && vars.text.split.value.indexOf(lastWord) >= 0) {
                    return ellipsis();
                } else {
                    if (vars.text.split.value.indexOf(lastChar) >= 0) {
                        lastWord = lastWord.substr(0, lastWord.length - 1);
                    }
                    textBox.text(words.join(" ") + " " + lastWord + "...");
                    if (textBox.node().getComputedTextLength() > lineWidth()) {
                        return ellipsis();
                    }
                }
            } else {
                return truncate();
            }
        };
        placeWord = function(word) {
            var current, i, joiner, next_char;
            current = textBox.text();
            next_char = "";
            if (reverse) {
                next_char = vars.text.current.charAt(vars.text.current.length - progress.length - 1);
                if (next_char === " ") {
                    joiner = "";
                    i = 2;
                    while (next_char === " ") {
                        joiner += " ";
                        next_char = vars.text.current.charAt(vars.text.current.length - progress.length - i);
                        i++;
                    }
                } else {
                    joiner = "";
                }
                progress = word + joiner + progress;
                textBox.text(word + joiner + current);
            } else {
                next_char = vars.text.current.charAt(progress.length);
                if (next_char === " ") {
                    joiner = "";
                    i = 1;
                    while (next_char === " ") {
                        joiner += " ";
                        next_char = vars.text.current.charAt(progress.length + i);
                        i++;
                    }
                } else {
                    joiner = "";
                }
                progress += joiner + word;
                textBox.text(current + joiner + word);
            }
            if (Math.floor(textBox.node().getComputedTextLength()) > lineWidth() || next_char === "\n") {
                textBox.text(current);
                if (current.length) {
                    textBox = newLine();
                }
                textBox.text(word);
                if (reverse) {
                    return line--;
                } else {
                    return line++;
                }
            }
        };
        start = 1;
        line = null;
        lines = null;
        wrap = function() {
            var i, j, len, next_char, unsafe, word;
            vars.container.value.text("").html("");
            words = vars.text.words.slice();
            if (reverse) {
                words.reverse();
            }
            progress = "";
            textBox = newLine(true);
            line = start;
            for (j = 0, len = words.length; j < len; j++) {
                word = words[j];
                if (line * dy > height) {
                    truncate();
                    break;
                }
                placeWord(word);
                unsafe = true;
                while (unsafe) {
                    next_char = vars.text.current.charAt(progress.length);
                    i = 1;
                    while (next_char === " ") {
                        next_char = vars.text.current.charAt(progress.length + i);
                        i++;
                    }
                    unsafe = vars.text.split.value.indexOf(next_char) >= 0;
                    if (unsafe) {
                        placeWord(next_char);
                    }
                }
            }
            if (line * dy > height) {
                truncate();
            }
            return lines = Math.abs(line - start) + 1;
        };
        wrap();
        lines = 0;
        vars.container.value.selectAll("tspan").each(function() {
            if (d3.select(this).text().length) {
                return lines++;
            }
        });
        if (vars.shape.value === "circle") {
            space = height - lines * dy;
            if (space > dy) {
                if (valign === "middle") {
                    start = (space / dy / 2 >> 0) + 1;
                    wrap();
                } else if (valign === "bottom") {
                    reverse = true;
                    start = height / dy >> 0;
                    wrap();
                }
            }
        }
        lines = 0;
        vars.container.value.selectAll("tspan").each(function() {
            if (d3.select(this).text().length) {
                return lines++;
            }
        });
        if (valign === "top") {
            y = 0;
        } else {
            h = lines * dy;
            y = valign === "middle" ? height / 2 - h / 2 : height - h;
        }
        y -= dy * 0.2;
        translate = "translate(0," + y + ")";
        if (vars.rotate.value === 180 || vars.rotate.value === -180) {
            rx = vars.container.x + width / 2;
            ry = vars.container.y + height / 2;
        } else {
            rmod = vars.rotate.value < 0 ? width : height;
            rx = vars.container.x + rmod / 2;
            ry = vars.container.y + rmod / 2;
        }
        rotate = "rotate(" + vars.rotate.value + ", " + rx + ", " + ry + ")";
        return vars.container.value.attr("transform", rotate + translate);
    };


},{"../../client/rtl.coffee":42}],184:[function(require,module,exports){
    var flow, fontSizes, resize, wrap;

    flow = require("./flow.coffee");

    fontSizes = require("../../font/sizes.coffee");

    wrap = function(vars) {
        var firstChar;
        if (vars.text.phrases.length) {
            vars.text.current = vars.text.phrases.shift() + "";
            vars.text.words = vars.text.current.match(vars.text["break"]);
            firstChar = vars.text.current.charAt(0);
            if (firstChar !== vars.text.words[0].charAt(0)) {
                vars.text.words[0] = firstChar + vars.text.words[0];
            }
            vars.container.value.html("");
            if (vars.resize.value) {
                resize(vars);
            } else {
                flow(vars);
            }
        }
    };

    module.exports = wrap;

    resize = function(vars) {
        var addon, areaMod, areaRatio, boxArea, height, heightMax, i, lineWidth, maxWidth, mirror, sizeMax, sizeRatio, sizes, textArea, width, widthRatio, words;
        words = [];
        i = 0;
        while (i < vars.text.words.length) {
            addon = (i === vars.text.words.length - 1 ? "" : " ");
            words.push(vars.text.words[i] + addon);
            i++;
        }
        mirror = vars.rotate.value === -90 || vars.rotate.value === 90;
        width = mirror ? vars.height.inner : vars.width.inner;
        height = mirror ? vars.width.inner : vars.height.inner;
        sizeMax = Math.floor(vars.size.value[1]);
        lineWidth = vars.shape.value === "circle" ? width * 0.75 : width;
        sizes = fontSizes(words, {
            "font-size": sizeMax + "px"
        }, {
            parent: vars.container.value
        });
        maxWidth = d3.max(sizes, function(d) {
            return d.width;
        });
        areaMod = 1.165 + (width / height * 0.11);
        textArea = d3.sum(sizes, function(d) {
            var h;
            h = vars.container.dy || sizeMax * 1.2;
            return d.width * h;
        }) * areaMod;
        if (vars.shape.value === "circle") {
            boxArea = Math.PI * Math.pow(width / 2, 2);
        } else {
            boxArea = lineWidth * height;
        }
        if (maxWidth > lineWidth || textArea > boxArea) {
            areaRatio = Math.sqrt(boxArea / textArea);
            widthRatio = lineWidth / maxWidth;
            sizeRatio = d3.min([areaRatio, widthRatio]);
            sizeMax = d3.max([vars.size.value[0], Math.floor(sizeMax * sizeRatio)]);
        }
        heightMax = Math.floor(height * 0.8);
        if (sizeMax > heightMax) {
            sizeMax = heightMax;
        }
        if (maxWidth * (sizeMax / vars.size.value[1]) <= lineWidth) {
            if (sizeMax !== vars.size.value[1]) {
                vars.self.size([vars.size.value[0], sizeMax]);
            }
            flow(vars);
        } else {
            wrap(vars);
        }
    };


},{"../../font/sizes.coffee":103,"./flow.coffee":179}],185:[function(require,module,exports){
    module.exports = {
        accepted: [false, "start", "middle", "end", "left", "center", "right"],
        process: function(value) {
            var css;
            css = ["left", "center", "right"].indexOf(value);
            if (css >= 0) {
                value = this.accepted[css + 1];
            }
            return value;
        },
        value: false
    };


},{}],186:[function(require,module,exports){
    arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],187:[function(require,module,exports){
    var d3selection;

    d3selection = require("../../util/d3selection.coffee");

    module.exports = {
        accepted: [false, Array, Object, String],
        element: false,
        id: "default",
        process: function(value) {
            if (value === false) {
                return false;
            } else if (d3selection(value)) {
                return value;
            } else if (value instanceof Array) {
                return d3.select(value[0][0]);
            } else {
                return d3.select(value);
            }
        },
        value: false
    };


},{"../../util/d3selection.coffee":210}],188:[function(require,module,exports){
    arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],189:[function(require,module,exports){
    var print, stringFormat;

    print = require("../../core/console/print.coffee");

    stringFormat = require("../../string/format.js");

    module.exports = {
        accepted: [void 0],
        process: function(value, vars) {
            var str;
            if (this.initialized === false) {
                return value;
            }
            if (vars.container.value === false) {
                str = vars.format.locale.value.dev.setContainer;
                print.warning(str, "container");
            } else if (vars.container.value.empty()) {
                str = vars.format.locale.value.dev.noContainer;
                print.warning(stringFormat(str, "\"" + vars.container.value + "\""), "container");
            } else {
                if (vars.dev.value) {
                    print.time("total draw time");
                }
                vars.container.value.call(vars.self);
            }
            return value;
        },
        value: void 0
    };


},{"../../core/console/print.coffee":54,"../../string/format.js":175}],190:[function(require,module,exports){
    var locale, mergeObject;

    locale = require("../../core/locale/locale.coffee");

    mergeObject = require("../../object/merge.coffee");

    module.exports = {
        accepted: [Function, String],
        locale: {
            accepted: function() {
                return d3.keys(locale);
            },
            process: function(value) {
                var defaultLocale, returnObject;
                defaultLocale = "en_US";
                returnObject = locale[defaultLocale];
                if (value !== defaultLocale) {
                    returnObject = mergeObject(returnObject, locale[value]);
                }
                this.language = value;
                return returnObject;
            },
            value: "en_US"
        },
        process: function(value, vars) {
            if (this.initialized && typeof value === "string") {
                vars.self.format({
                    locale: value
                });
            } else {
                if (typeof value === "function") {
                    return value;
                }
            }
            return this.value;
        },
        value: "en_US"
    };


},{"../../core/locale/locale.coffee":80,"../../object/merge.coffee":173}],191:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number],
        value: false
    };


},{}],192:[function(require,module,exports){
    arguments[4][191][0].apply(exports,arguments)
},{"dup":191}],193:[function(require,module,exports){
    arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],194:[function(require,module,exports){
    module.exports = {
        accepted: [-180, -90, 0, 90, 180],
        value: 0
    };


},{}],195:[function(require,module,exports){
    module.exports = {
        accepted: ["circle", "square"],
        value: false
    };


},{}],196:[function(require,module,exports){
    module.exports = {
        accepted: [Array, false],
        value: false
    };


},{}],197:[function(require,module,exports){
    module.exports = {
        accepted: [false, Array, Number, String],
        html: {
            accepted: [Boolean],
            value: false
        },
        init: function(vars) {
            var s;
            s = this.split.value;
            this["break"] = new RegExp("[^\\s\\" + s.join("\\") + "]+\\" + s.join("?\\") + "?", "g");
            return false;
        },
        split: {
            accepted: [Array],
            process: function(s) {
                this["break"] = new RegExp("[^\\s\\" + s.join("\\") + "]+\\" + s.join("?\\") + "?", "g");
                return s;
            },
            value: ["-", "/", ";", ":", "&"]
        }
    };


},{}],198:[function(require,module,exports){
    module.exports = {
        accepted: [false, "top", "middle", "bottom"],
        value: false
    };


},{}],199:[function(require,module,exports){
    arguments[4][191][0].apply(exports,arguments)
},{"dup":191}],200:[function(require,module,exports){
    arguments[4][191][0].apply(exports,arguments)
},{"dup":191}],201:[function(require,module,exports){
    arguments[4][191][0].apply(exports,arguments)
},{"dup":191}],202:[function(require,module,exports){
    var attach, print, sizes, text, wrap;

    attach = require("../core/methods/attach.coffee");

    sizes = require("./helpers/parseSize.coffee");

    print = require("../core/console/print.coffee");

    text = require("./helpers/parseText.coffee");

    wrap = require("./helpers/wrap.coffee");

    module.exports = function() {
        var vars;
        vars = {
            self: function(selection) {
                selection.each(function() {
                    sizes(vars);
                    if (vars.size.value[0] <= vars.height.inner) {
                        text(vars);
                        wrap(vars);
                    } else {
                        vars.container.value.html("");
                    }
                    if (vars.dev.value) {
                        print.timeEnd("total draw time");
                    }
                });
                return vars.self;
            }
        };
        attach(vars, {
            align: require("./methods/align.coffee"),
            config: require("./methods/config.coffee"),
            container: require("./methods/container.coffee"),
            dev: require("./methods/dev.coffee"),
            draw: require("./methods/draw.coffee"),
            format: require("./methods/format.coffee"),
            height: require("./methods/height.coffee"),
            padding: require("./methods/padding.coffee"),
            resize: require("./methods/resize.coffee"),
            rotate: require("./methods/rotate.coffee"),
            text: require("./methods/text.coffee"),
            shape: require("./methods/shape.coffee"),
            size: require("./methods/size.coffee"),
            valign: require("./methods/valign.coffee"),
            width: require("./methods/width.coffee"),
            x: require("./methods/x.coffee"),
            y: require("./methods/y.coffee")
        });
        return vars.self;
    };


},{"../core/console/print.coffee":54,"../core/methods/attach.coffee":81,"./helpers/parseSize.coffee":181,"./helpers/parseText.coffee":182,"./helpers/wrap.coffee":184,"./methods/align.coffee":185,"./methods/config.coffee":186,"./methods/container.coffee":187,"./methods/dev.coffee":188,"./methods/draw.coffee":189,"./methods/format.coffee":190,"./methods/height.coffee":191,"./methods/padding.coffee":192,"./methods/resize.coffee":193,"./methods/rotate.coffee":194,"./methods/shape.coffee":195,"./methods/size.coffee":196,"./methods/text.coffee":197,"./methods/valign.coffee":198,"./methods/width.coffee":199,"./methods/x.coffee":200,"./methods/y.coffee":201}],203:[function(require,module,exports){
    var defaultLocale = require("../core/locale/languages/en_US.coffee"),
        events        = require("../client/pointer.coffee"),
        legible       = require("../color/legible.coffee"),
        move          = require("./move.coffee"),
        prefix        = require("../client/prefix.coffee"),
        rtl           = require("../client/rtl.coffee"),
        removeTooltip = require("./remove.coffee"),
        scroll        = require("../client/scroll.js"),
        stringList    = require("../string/list.coffee"),
        textColor     = require("../color/text.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Create a Tooltip
//-------------------------------------------------------------------
    module.exports = function(params) {

        var default_width = params.fullscreen ? 250 : 200
            , vendor = prefix()
        params.width = params.width || default_width
        params.max_width = params.max_width || 386
        params.id = params.id || "default"
        params.size = params.fullscreen || params.html ? "large" : "small"
        params.offset = params.offset || 0
        params.arrow_offset = params.arrow ? 8 : 0
        params.x = params.x || 0
        params.y = params.y || 0
        params.parent = params.parent || d3.select("body")
        params.curtain = params.curtain || "#fff"
        params.curtainopacity = params.curtainopacity || 0.8
        params.background = params.background || "#fff"
        params.fontcolor = params.fontcolor || "#444"
        params.fontfamily = params.fontfamily || "sans-serif"
        params.fontweight = params.fontweight || "normal"
        params.fontsize = params.fontsize || "12px"
        params.style = params.style || "default"
        params.zindex = params.size == "small" ? 2000 : 500
        params.locale = params.locale || defaultLocale
        params.stacked = params.stacked || false;


        var parentHeight = params.parent ? params.parent.node().offsetHeight
            || params.parent.node().getBoundingClientRect().height : 0

        if (!params.iconsize) {
            params.iconsize = params.size == "small" ? 22 : 50
        }

        if (params.parent.node() === document.body) {
            params.limit = [window.innerWidth + scroll.x(), window.innerHeight + scroll.y()];
        }
        else {
            params.limit = [
                parseFloat(params.parent.style("width"),10),
                parseFloat(params.parent.style("height"),10)
            ];
        }

        if ( params.title instanceof Array ) {

            var and = params.locale.ui.and
                , more = params.locale.ui.more

            params.title = stringList( params.title , and , 3 , more )

        }

        removeTooltip(params.id)

        params.anchor = {}
        if (params.fullscreen) {
            params.anchor.x = "center"
            params.anchor.y = "center"
            params.x = params.parent ? params.parent.node().offsetWidth/2 : window.innerWidth/2
            params.y = params.parent ? parentHeight/2 : window.innerHeight/2
        }
        else if (params.align) {
            var a = params.align.split(" ")
            params.anchor.y = a[0]
            if (a[1]) params.anchor.x = a[1]
            else params.anchor.x = "center"
        }
        else {
            params.anchor.x = "center"
            params.anchor.y = "top"
        }

        var title_width = params.width - 30

        if (params.fullscreen) {
            var curtain = params.parent.append("div")
                .attr("id","d3plus_tooltip_curtain_"+params.id)
                .attr("class","d3plus_tooltip_curtain")
                .style("background-color",params.curtain)
                .style("opacity",params.curtainopacity)
                .style("position","absolute")
                .style("z-index",499)
                .style("top","0px")
                .style("right","0px")
                .style("bottom","0px")
                .style("left","0px")
                .on(events.click,function(){
                    removeTooltip(params.id)
                })
        }

        var tooltip = params.parent.append("div")
            .datum(params)
            .attr("id","d3plus_tooltip_id_"+params.id)
            .attr("class","d3plus_tooltip d3plus_tooltip_"+params.size)
            .style("color",params.fontcolor)
            .style("font-family",params.fontfamily)
            .style("font-weight",params.fontweight)
            .style("font-size",params.fontsize+"px")
            .style(vendor+"box-shadow","0px 1px 3px rgba(0, 0, 0, 0.25)")
            .style("position","absolute")
            // .style("z-index",params.zindex)
            .on(events.out, close_descriptions)

        if (params.max_height) {
            tooltip.style("max-height",params.max_height+"px")
        }

        if (params.fixed) {
            tooltip.style("z-index",500)
            params.mouseevents = true
        }
        else {
            tooltip.style("z-index",2000)
        }

        var container = tooltip.append("div")
            .datum(params)
            .attr("class","d3plus_tooltip_container")
            .style("background-color",params.background)
            .style("padding","6px")

        if (params.fullscreen && params.html && !params.stacked) {

            w = params.parent ? params.parent.node().offsetWidth*0.75 : window.innerWidth*0.75
            h = params.parent ? parentHeight*0.75 : window.innerHeight*0.75

            container
                .style("width",w+"px")
                .style("height",h+"px")

            var body = container.append("div")
                .attr("class","d3plus_tooltip_body")
                .style("padding-right","6px")
                .style("display","inline-block")
                .style("z-index",1)
                .style("width",params.width+"px")

        }
        else {

            if (params.width == "auto") {
                var w = "auto"
                container.style("max-width",params.max_width+"px")
            }
            else var w = params.width-14+"px"

            var body = container
                .style("width",w)

        }

        if (params.title || params.icon) {
            var header = body.append("div")
                .attr("class","d3plus_tooltip_header")
                .style("position","relative")
                .style("z-index",1)
        }

        if (params.fullscreen) {
            var close = tooltip.append("div")
                .attr("class","d3plus_tooltip_close")
                .style("background-color",params.color)
                .style("color",textColor(params.color))
                .style("position","absolute")
                .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.25)")
                .style("font-size","20px")
                .style("height","18px")
                .style("line-height","14px")
                .style("text-align","center")
                .style("right","16px")
                .style("top","-10px")
                .style("width","18px")
                .style("z-index",10)
                .html("\&times;")
                .on(events.over,function(){
                    d3.select(this)
                        .style("cursor","pointer")
                        .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.5)")
                })
                .on(events.out,function(){
                    d3.select(this)
                        .style("cursor","auto")
                        .style(vendor+"box-shadow","0 1px 3px rgba(0, 0, 0, 0.25)")
                })
                .on(events.click,function(){
                    removeTooltip(params.id)
                })

            d3.select("body").on("keydown.esc_" + params.id, function(){
                if (d3.event.keyCode === 27) {
                    removeTooltip(params.id);
                    d3.select("body").on("keydown.esc_" + params.id, null);
                }
            })

        }

        if (!params.mouseevents) {
            tooltip.style("pointer-events","none")
        }
        else if (params.mouseevents !== true) {

            var oldout = d3.select(params.mouseevents).on(events.out)

            var newout = function() {

                var target = d3.event.toElement || d3.event.relatedTarget
                if (target) {
                    var c = typeof target.className == "string" ? target.className : target.className.baseVal
                    var istooltip = c.indexOf("d3plus_tooltip") == 0
                }
                else {
                    var istooltip = false
                }
                if (!target || (!ischild(tooltip.node(),target) && !ischild(params.mouseevents,target) && !istooltip)) {
                    oldout(d3.select(params.mouseevents).datum())
                    close_descriptions()
                    d3.select(params.mouseevents).on(events.out,oldout)
                }
            }

            var ischild = function(parent, child) {
                var node = child.parentNode;
                while (node !== null) {
                    if (node == parent) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            }

            d3.select(params.mouseevents).on(events.out,newout)
            tooltip.on(events.out,newout)

            var move_event = d3.select(params.mouseevents).on(events.move)
            if (move_event) {
                tooltip.on(events.move,move_event)
            }

        }

        if (params.arrow) {
            var arrow = tooltip.append("div")
                .attr("class","d3plus_tooltip_arrow")
                .style("background-color",params.background)
                .style(vendor+"box-shadow","0px 1px 3px rgba(0, 0, 0, 0.25)")
                .style("position","absolute")
                .style("bottom","-5px")
                .style("height","10px")
                .style("left","50%")
                .style("margin-left","-5px")
                .style("width","10px")
                .style(vendor+"transform","rotate(45deg)")
                .style("z-index",-1)
        }

        if (params.icon) {

            var title_icon = header.append("div")
                .attr("class","d3plus_tooltip_icon")
                .style("width",params.iconsize+"px")
                .style("height",params.iconsize+"px")
                .style("z-index",1)
                .style("background-position","50%")
                .style("background-size","100%")
                .style("background-image","url("+params.icon+")")
                .style("display","inline-block")
                .style("margin","0px 3px 3px 0px")

            if (params.style == "knockout") {
                title_icon.style("background-color",params.color)
            }

            title_width -= title_icon.node().offsetWidth
        }

        if (params.title) {
            var mw = params.max_width-6
            if ( params.icon ) mw -= (params.iconsize+6)
            mw += "px"

            var title = header.append("div")
                .attr("class","d3plus_tooltip_title")
                .style("max-width",mw)
                .style("color",!params.icon ? legible(params.color) : params.fontcolor)
                .style("vertical-align","top")
                .style("width",title_width+"px")
                .style("display","inline-block")
                .style("overflow","hidden")
                .style("text-overflow","ellipsis")
                .style("word-wrap","break-word")
                .style("z-index",1)
                .style("font-size",params.size === "large" ? "18px" : "16px")
                .style("line-height",params.size === "large" ? "20px" : "17px")
                .style("padding",params.size === "large" ? "3px 6px" : "3px")
                .text(params.title)
        }

        if (params.description) {
            var description = body.append("div")
                .attr("class","d3plus_tooltip_description")
                .style("font-size","12px")
                .style("padding","6px")
                .text(params.description)
        }

        if (params.data || params.html && !params.fullscreen) {

            var data_container = body.append("div")
                .attr("class","d3plus_tooltip_data_container")
                .style("overflow-y","auto")
                .style("z-index",-1)
        }

        if (params.data) {

            var val_width = 0, val_heights = {}

            var last_group = null
            params.data.forEach(function(d,i){

                if (d.group) {
                    if (last_group != d.group) {
                        last_group = d.group
                        data_container.append("div")
                            .attr("class","d3plus_tooltip_data_title")
                            .style("font-size","12px")
                            .style("font-weight","bold")
                            .style("padding","6px 3px 0px 3px")
                            .text(d.group)
                    }
                }

                var block = data_container.append("div")
                    .attr("class","d3plus_tooltip_data_block")
                    .style("font-size","12px")
                    .style("padding","3px 6px")
                    .style("position","relative")
                    .datum(d)

                if ( d.highlight === true ) {
                    block.style("color",legible(params.color))
                }
                else if ( d.allColors || d.highlight !== params.color ) {
                    block.style("color",legible(d.highlight))
                }

                var name = block.append("div")
                    .attr("class","d3plus_tooltip_data_name")
                    .style("display","inline-block")
                    .html(d.name)
                    .on(events.out,function(){
                        d3.event.stopPropagation()
                    })

                if (d.link) {
                    name
                        .style("cursor","pointer")
                        .on(events.click,d.link)
                }

                if ( d.value instanceof Array ) {

                    var and = params.locale.ui.and
                        , more = params.locale.ui.more

                    d.value = list( d.value , and , 3 , more )

                }

                var val = block.append("div")
                    .attr("class","d3plus_tooltip_data_value")
                    .style("display","block")
                    .style("position","absolute")
                    .style("text-align","right")
                    .style("top","3px")
                    .html(d.value)
                    .on(events.out,function(){
                        d3.event.stopPropagation()
                    })

                if (rtl) {
                    val.style("left","6px")
                }
                else {
                    val.style("right","6px")
                }

                if (params.mouseevents && d.desc) {
                    var desc = block.append("div")
                        .attr("class","d3plus_tooltip_data_desc")
                        .style("color","#888")
                        .style("overflow","hidden")
                        .style(vendor+"transition","height 0.5s")
                        .style("width","85%")
                        .text(d.desc)
                        .on(events.out,function(){
                            d3.event.stopPropagation()
                        })

                    var dh = desc.node().offsetHeight || desc.node().getBoundingClientRect().height

                    desc.style("height","0px")

                    var help = name.append("div")
                        .attr("class","d3plus_tooltip_data_help")
                        .style("background-color","#ccc")
                        .style(vendor+"border-radius","5px")
                        .style("color","#fff")
                        .style("cursor","pointer")
                        .style("display","inline-block")
                        .style("font-size","8px")
                        .style("font-weight","bold")
                        .style("height","10px")
                        .style("margin","3px 0px 0px 3px")
                        .style("padding-right","1px")
                        .style("text-align","center")
                        .style("width","10px")
                        .style("vertical-align","top")
                        .style(prefix+"transition","background-color 0.5s")
                        .text("?")
                        .on(events.over,function(){
                            var c = d3.select(this.parentNode.parentNode).style("color")
                            d3.select(this).style("background-color",c)
                            desc.style("height",dh+"px")
                        })
                        .on(events.out,function(){
                            d3.event.stopPropagation()
                        })

                    name
                        .style("cursor","pointer")
                        .on(events.over,function(){
                            close_descriptions()
                            var c = d3.select(this.parentNode).style("color")
                            help.style("background-color",c)
                            desc.style("height",dh+"px")
                        })

                    block.on(events.out,function(){
                        d3.event.stopPropagation()
                        close_descriptions()
                    })
                }

                var w = parseFloat(val.style("width"),10)
                if (w > params.width/2) w = params.width/2
                if (w > val_width) val_width = w

                if (i != params.data.length-1) {
                    if ((d.group && d.group == params.data[i+1].group) || !d.group && !params.data[i+1].group)
                        data_container.append("div")
                            .attr("class","d3plus_tooltip_data_seperator")
                            .style("background-color","#ddd")
                            .style("display","block")
                            .style("height","1px")
                            .style("margin","0px 3px")
                }

            })

            data_container.selectAll(".d3plus_tooltip_data_name")
                .style("width",function(){
                    var w = parseFloat(d3.select(this.parentNode).style("width"),10)
                    return (w-val_width-30)+"px"
                })

            data_container.selectAll(".d3plus_tooltip_data_value")
                .style("width",val_width+"px")
                .each(function(d){
                    var h = parseFloat(d3.select(this).style("height"),10)
                    val_heights[d.name] = h
                })

            data_container.selectAll(".d3plus_tooltip_data_name")
                .style("min-height",function(d){
                    return val_heights[d.name]+"px"
                })

        }

        if (params.html && (!params.fullscreen || params.stacked)) {
            data_container.append("div")
                .html(params.html)
            if (params.js) {
                params.js(container)
            }
        }

        var footer = body.append("div")
            .attr("class","d3plus_tooltip_footer")
            .style("font-size","10px")
            .style("position","relative")
            .style("text-align","center")

        if (params.footer) {
            footer.html(params.footer)
        }

        params.height = tooltip.node().offsetHeight || tooltip.node().getBoundingClientRect().height

        if (params.html && params.fullscreen && !params.stacked) {
            var h = params.height-12
            var w = tooltip.node().offsetWidth-params.width-44
            container.append("div")
                .attr("class","d3plus_tooltip_html")
                .style("width",w+"px")
                .style("height",h+"px")
                .style("display","inline-block")
                .style("vertical-align","top")
                .style("overflow-y","auto")
                .style("padding","0px 12px")
                .style("position","absolute")
                .html(params.html)
            if (params.js) {
                params.js(container)
            }
        }

        params.width = tooltip.node().offsetWidth

        if (params.anchor.y != "center") params.height += params.arrow_offset
        else params.width += params.arrow_offset

        if (params.data || ((!params.fullscreen || params.stacked) && params.html)) {

            if (!params.fullscreen || params.stacked) {
                var limit = params.fixed ? parentHeight-params.y-10 : parentHeight-10
                var h = params.height < limit ? params.height : limit
            }
            else {
                var h = params.height
            }
            h -= parseFloat(container.style("padding-top"),10)
            h -= parseFloat(container.style("padding-bottom"),10)
            if (header) {
                h -= header.node().offsetHeight || header.node().getBoundingClientRect().height
                h -= parseFloat(header.style("padding-top"),10)
                h -= parseFloat(header.style("padding-bottom"),10)
            }
            if (footer) {
                h -= footer.node().offsetHeight || footer.node().getBoundingClientRect().height
                h -= parseFloat(footer.style("padding-top"),10)
                h -= parseFloat(footer.style("padding-bottom"),10)
            }

            data_container
                .style("max-height",h+"px")
        }

        params.height = tooltip.node().offsetHeight || tooltip.node().getBoundingClientRect().height

        move(params.x, params.y, params.id);

    }



//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Function that closes ALL Descriptions
//-------------------------------------------------------------------
    function close_descriptions() {
        d3.selectAll("div.d3plus_tooltip_data_desc").style("height","0px");
        d3.selectAll("div.d3plus_tooltip_data_help").style("background-color","#ccc");
    }

},{"../client/pointer.coffee":40,"../client/prefix.coffee":41,"../client/rtl.coffee":42,"../client/scroll.js":43,"../color/legible.coffee":46,"../color/text.coffee":52,"../core/locale/languages/en_US.coffee":71,"../string/list.coffee":176,"./move.coffee":204,"./remove.coffee":205}],204:[function(require,module,exports){
    var arrowStyle, scroll;

    scroll = require("../client/scroll.js");

    module.exports = function(x, y, id) {
        var d, mins, tooltip;
        if (!id) {
            id = "default";
        }
        tooltip = d3.select("div#d3plus_tooltip_id_" + id);
        if (tooltip.node()) {
            d = tooltip.datum();
            d.cx = x;
            d.cy = y;
            if (!d.fixed) {
                if (d.parent.node().tagName.toLowerCase() === "body") {
                    mins = [scroll.x(), scroll.y()];
                } else {
                    mins = [0, 0];
                }
                if (d.anchor.y !== "center") {
                    if (d.anchor.x === "right") {
                        d.x = d.cx - d.arrow_offset - 4;
                    } else if (d.anchor.x === "center") {
                        d.x = d.cx - d.width / 2;
                    } else {
                        if (d.anchor.x === "left") {
                            d.x = d.cx - d.width + d.arrow_offset + 2;
                        }
                    }
                    if (d.anchor.y === "bottom") {
                        d.flip = d.cy + d.height + d.offset <= d.limit[1];
                    } else {
                        if (d.anchor.y === "top") {
                            d.flip = d.cy - d.height - d.offset < mins[1];
                        }
                    }
                    if (d.flip) {
                        d.y = d.cy + d.offset + d.arrow_offset;
                    } else {
                        d.y = d.cy - d.height - d.offset - d.arrow_offset;
                    }
                } else {
                    d.y = d.cy - d.height / 2;
                    if (d.anchor.x === "right") {
                        d.flip = d.cx + d.width + d.offset <= d.limit[0];
                    } else {
                        if (d.anchor.x === "left") {
                            d.flip = d.cx - d.width - d.offset < mins[0];
                        }
                    }
                    if (d.anchor.x === "center") {
                        d.flip = false;
                        d.x = d.cx - d.width / 2;
                    } else if (d.flip) {
                        d.x = d.cx + d.offset + d.arrow_offset;
                    } else {
                        d.x = d.cx - d.width - d.offset;
                    }
                }
                if (d.x < mins[0]) {
                    d.x = mins[0];
                } else {
                    if (d.x + d.width > d.limit[0]) {
                        d.x = d.limit[0] - d.width;
                    }
                }
                if (d.y < mins[1]) {
                    d.y = mins[1];
                } else {
                    if (d.y + d.height > d.limit[1]) {
                        d.y = d.limit[1] - d.height;
                    }
                }
            }
            tooltip.style("top", d.y + "px").style("left", d.x + "px");
            if (d.arrow) {
                tooltip.selectAll(".d3plus_tooltip_arrow").call(arrowStyle);
            }
        }
        return tooltip;
    };

    arrowStyle = function(arrow) {
        return arrow.style("bottom", function(d) {
            if (d.anchor.y !== "center" && !d.flip) {
                return "-5px";
            } else {
                return "auto";
            }
        }).style("right", function(d) {
            if (d.anchor.y === "center" && !d.flip) {
                return "-5px";
            } else {
                return "auto";
            }
        }).style("top", function(d) {
            if (d.anchor.y !== "center" && d.flip) {
                return "-5px";
            } else if (d.anchor.y === "center") {
                return "50%";
            } else {
                return "auto";
            }
        }).style("left", function(d) {
            if (d.anchor.y === "center" && d.flip) {
                return "-5px";
            } else if (d.anchor.y !== "center") {
                return "50%";
            } else {
                return "auto";
            }
        }).style("margin-left", function(d) {
            var arrow_x;
            if (d.anchor.y === "center") {
                return "auto";
            } else {
                if (d.anchor.x === "right") {
                    arrow_x = -d.width / 2 + d.arrow_offset / 2;
                } else if (d.anchor.x === "left") {
                    arrow_x = d.width / 2 - d.arrow_offset * 2 - 5;
                } else {
                    arrow_x = -5;
                }
                if (d.cx - d.width / 2 - 5 < arrow_x) {
                    arrow_x = d.cx - d.width / 2 - 5;
                    if (arrow_x < 2 - d.width / 2) {
                        arrow_x = 2 - d.width / 2;
                    }
                } else if (-(d.limit[0] - d.cx - d.width / 2 + 5) > arrow_x) {
                    arrow_x = -(d.limit[0] - d.cx - d.width / 2 + 5);
                    if (arrow_x > d.width / 2 - 11) {
                        arrow_x = d.width / 2 - 11;
                    }
                }
                return arrow_x + "px";
            }
        }).style("margin-top", function(d) {
            var arrow_y;
            if (d.anchor.y !== "center") {
                return "auto";
            } else {
                if (d.anchor.y === "bottom") {
                    arrow_y = -d.height / 2 + d.arrow_offset / 2 - 1;
                } else if (d.anchor.y === "top") {
                    arrow_y = d.height / 2 - d.arrow_offset * 2 - 2;
                } else {
                    arrow_y = -9;
                }
                if (d.cy - d.height / 2 - d.arrow_offset < arrow_y) {
                    arrow_y = d.cy - d.height / 2 - d.arrow_offset;
                    if (arrow_y < 4 - d.height / 2) {
                        arrow_y = 4 - d.height / 2;
                    }
                } else if (-(d.limit[1] - d.cy - d.height / 2 + d.arrow_offset) > arrow_y) {
                    arrow_y = -(d.limit[1] - d.cy - d.height / 2 + d.arrow_offset);
                    if (arrow_y > d.height / 2 - 22) {
                        arrow_y = d.height / 2 - 22;
                    }
                }
                return arrow_y + "px";
            }
        });
    };


},{"../client/scroll.js":43}],205:[function(require,module,exports){
    module.exports = function(id) {
        if (id) {
            d3.selectAll("div#d3plus_tooltip_curtain_" + id).remove();
            return d3.selectAll("div#d3plus_tooltip_id_" + id).remove();
        } else {
            d3.selectAll("div.d3plus_tooltip_curtain").remove();
            return d3.selectAll("div.d3plus_tooltip").remove();
        }
    };


},{}],206:[function(require,module,exports){
    module.exports = function(arr, n) {
        var buckets, step;
        buckets = [];
        step = 1 / (n - 1) * (arr[1] - arr[0]);
        return d3.range(arr[0], arr[1] + step, step);
    };


},{}],207:[function(require,module,exports){
    var d3selection;

    d3selection = require("./d3selection.coffee");

    module.exports = function(parent, child) {
        var node;
        if (!parent || !child) {
            return false;
        }
        if (d3selection(parent)) {
            parent = parent.node();
        }
        if (d3selection(parent)) {
            child = child.node();
        }
        node = child.parentNode;
        while (node !== null) {
            if (node === parent) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };


},{"./d3selection.coffee":210}],208:[function(require,module,exports){
    module.exports = function(arr, value) {
        var closest, i;
        if (value.constructor === String) {
            i = arr.indexOf(value);
            if (i > -1) {
                return arr[i];
            } else {
                return arr[0];
            }
        }
        closest = arr[0];
        arr.forEach(function(p) {
            if (Math.abs(value - p) < Math.abs(value - closest)) {
                return closest = p;
            }
        });
        return closest;
    };


},{}],209:[function(require,module,exports){
    var copy, objectMerge, objectValidate;

    objectMerge = require("../object/merge.coffee");

    objectValidate = require("../object/validate.coffee");

    copy = function(variable) {
        var ret;
        if (objectValidate(variable)) {
            return objectMerge(variable);
        } else if (variable instanceof Array) {
            ret = [];
            variable.forEach(function(o) {
                return ret.push(copy(o));
            });
            return ret;
        } else {
            return variable;
        }
    };

    module.exports = copy;


},{"../object/merge.coffee":173,"../object/validate.coffee":174}],210:[function(require,module,exports){
    var ie;

    ie = require("../client/ie.js");

    module.exports = function(elem) {
        if (ie) {
            return typeof elem === "object" && elem instanceof Array && "size" in elem && "select" in elem;
        } else {
            return elem instanceof d3.selection;
        }
    };


},{"../client/ie.js":39}],211:[function(require,module,exports){
    module.exports = function(url, callback) {
        var img;
        img = new Image();
        img.src = url;
        img.crossOrigin = "Anonymous";
        img.onload = function() {
            var canvas, context;
            canvas = document.createElement("canvas");
            canvas.width = this.width;
            canvas.height = this.height;
            context = canvas.getContext("2d");
            context.drawImage(this, 0, 0);
            callback.call(this, canvas.toDataURL("image/png"));
            canvas = null;
        };
    };


},{}],212:[function(require,module,exports){
    var objectValidate, uniques;

    objectValidate = require("../object/validate.coffee");

    uniques = function(data, value, fetch, vars, depth, sorted) {
        var check, d, i, j, k, len, len1, len2, len3, lookups, m, v, val, vals;
        if (data === void 0) {
            return [];
        }
        if (vars && depth === void 0) {
            depth = vars.id.value;
        }
        sorted = (true === sorted && sorted === void 0);
        if (!(data instanceof Array)) {
            data = [data];
        }
        lookups = [];
        if (value === void 0) {
            return data.reduce(function(p, c) {
                var lookup;
                lookup = JSON.stringify(c);
                if (lookups.indexOf(lookup) < 0) {
                    if (p.indexOf(c) < 0) {
                        p.push(c);
                    }
                    lookups.push(lookup);
                }
                return p;
            }, []);
        }
        vals = [];
        check = function(v) {
            var l;
            if (v !== void 0 && v !== null) {
                l = JSON.stringify(v);
                if (lookups.indexOf(l) < 0) {
                    vals.push(v);
                    return lookups.push(l);
                }
            }
        };
        if (typeof fetch === "function" && vars) {
            for (i = 0, len = data.length; i < len; i++) {
                d = data[i];
                val = uniques(fetch(vars, d, value, depth));
                for (j = 0, len1 = val.length; j < len1; j++) {
                    v = val[j];
                    check(v);
                }
            }
        } else if (typeof value === "function") {
            for (k = 0, len2 = data.length; k < len2; k++) {
                d = data[k];
                val = value(d);
                check(val);
            }
        } else {
            for (m = 0, len3 = data.length; m < len3; m++) {
                d = data[m];
                if (objectValidate(d)) {
                    val = d[value];
                    check(val);
                }
            }
        }
        if (sorted) {
            return vals.sort(function(a, b) {
                return a - b;
            });
        } else {
            return vals;
        }
    };

    module.exports = uniques;


},{"../object/validate.coffee":174}],213:[function(require,module,exports){
    module.exports = function(vars) {
        var checkParent, i, len, ref, s;
        vars.container.value.style("position", function() {
            var current, remain;
            current = d3.select(this).style("position");
            remain = ["absolute", "fixed"].indexOf(current) >= 0;
            if (remain) {
                return current;
            } else {
                return "relative";
            }
        });
        if (vars.container.changed) {
            vars.container.value.html("");
        }
        ref = ["width", "height"];
        for (i = 0, len = ref.length; i < len; i++) {
            s = ref[i];
            if (!vars[s].value) {
                checkParent = function(element) {
                    var elem, val;
                    if (element.tagName === void 0 || ["BODY", "HTML"].indexOf(element.tagName) >= 0) {
                        val = window["inner" + s.charAt(0).toUpperCase() + s.slice(1)];
                        elem = document !== element ? d3.select(element) : false;
                        if (elem) {
                            if (s === "width") {
                                val -= parseFloat(elem.style("margin-left"), 10);
                                val -= parseFloat(elem.style("margin-right"), 10);
                                val -= parseFloat(elem.style("padding-left"), 10);
                                val -= parseFloat(elem.style("padding-right"), 10);
                            } else {
                                val -= parseFloat(elem.style("margin-top"), 10);
                                val -= parseFloat(elem.style("margin-bottom"), 10);
                                val -= parseFloat(elem.style("padding-top"), 10);
                                val -= parseFloat(elem.style("padding-bottom"), 10);
                            }
                        }
                        return vars[s].value = val <= 20 ? vars[s].small : val;
                    } else {
                        val = parseFloat(d3.select(element).style(s), 10);
                        if (typeof val === "number" && val > 0) {
                            return vars[s].value = val;
                        } else if (element.tagName !== "BODY") {
                            return checkParent(element.parentNode);
                        }
                    }
                };
                checkParent(vars.container.value.node());
                if (d3.selectAll("body > *:not(script)").size() === 1) {
                    d3.select("body").style("overflow", "hidden");
                }
            }
        }
        vars.container.value.style("width", vars.width.value + "px").style("height", vars.height.value + "px");
    };


},{}],214:[function(require,module,exports){
    var dataFormat    = require("../../core/data/format.js"),
        dataColor     = require("../../core/data/color.js"),
        dataKeys      = require("../../core/data/keys.coffee"),
        dataLoad      = require("../../core/data/load.coffee"),
        drawDrawer    = require("./ui/drawer.js"),
        drawLegend    = require("./ui/legend.js"),
        drawTimeline  = require("./ui/timeline.coffee"),
        errorCheck    = require("./errorCheck.js"),
        fetchData     = require("../../core/fetch/data.js"),
        finish        = require("./finish.js"),
        focusTooltip  = require("./focus/tooltip.coffee"),
        history       = require("./ui/history.coffee"),
        parseEdges    = require("../../core/parse/edges.js"),
        parseNodes    = require("../../core/parse/nodes.js"),
        print         = require("../../core/console/print.coffee"),
        removeTooltip = require("../../tooltip/remove.coffee"),
        runType       = require("./types/run.coffee"),
        shapes        = require("./shapes/draw.js"),
        stringFormat  = require("../../string/format.js"),
        svgSetup      = require("./svg/enter.js"),
        svgUpdate     = require("./svg/update.js"),
        titles        = require("./ui/titles.js"),
        validObject   = require("../../object/validate.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Calculate steps needed to redraw the visualization
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        var steps       = []
            , appType     = vars.type.value
            , locale      = vars.format.locale.value
            , uiMessage   = locale.message.ui
            , drawMessage = locale.message.draw

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if any data needs to be loaded with JSON
        //----------------------------------------------------------------------------
        var urlLoads = [ "data" , "attrs" , "coords" , "nodes" , "edges" ]
        urlLoads.forEach(function(u){

            if (!vars.error.value && !vars[u].loaded && vars[u].url) {

                steps.push({
                    "function": function( vars , next ){
                        dataLoad( vars , u , next )
                    },
                    "message": locale.message.loading,
                    "wait": true
                })

            }

        })

        if (vars.draw.update) {

            var appName     = locale.visualization[appType] || appType
                , appSetup    = vars.types[appType].setup || false
                , appReqs     = vars.types[appType].requirements || []
                , appMessage  = stringFormat(locale.message.initializing,appName)
                , dataMessage = locale.message.data

            if (!(appReqs instanceof Array)) appReqs = [appReqs]
            appName = appName.toLowerCase()

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // If it has one, run the current app's setup function.
            //--------------------------------------------------------------------------
            if (!vars.error.value && typeof appSetup === "function") {

                steps.push({
                    "function": function( vars ) {

                        if ( vars.dev.value ) {
                            var timerString = "running " + appName + " setup"
                            print.time( timerString )
                        }

                        appSetup( vars )

                        if ( vars.dev.value ) print.timeEnd( timerString )

                    },
                    "message": appMessage
                })

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create SVG group elements if the container is new or has changed
            //--------------------------------------------------------------------------
            if (vars.container.changed) {

                steps.push({ "function" : svgSetup , "message" : appMessage })

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create group for current app, if it doesn't exist.
            //--------------------------------------------------------------------------
            if (!(appType in vars.g.apps)) {

                steps.push({
                    "function": function( vars ) {

                        if ( vars.dev.value ) {
                            var timerString = "creating " + appName + " group"
                            print.time( timerString )
                        }

                        vars.g.apps[appType] = vars.g.app.append("g")
                            .attr("id", appType)
                            .attr("opacity", 0);

                        if ( vars.dev.value ) print.timeEnd( timerString )

                    },
                    "message": appMessage
                })

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // If new data is detected, analyze and reset it.
            //--------------------------------------------------------------------------
            if (vars.data.changed) {

                steps.push({
                    "function": function(vars) {
                        vars.data.cache = {}
                        delete vars.nodes.restricted
                        delete vars.edges.restricted
                        dataKeys(vars, "data")
                    },
                    "message": dataMessage
                })

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // If new attributes are detected, analyze them.
            //--------------------------------------------------------------------------
            if (vars.attrs.changed) {

                steps.push({
                    "function": function( vars ) {
                        dataKeys(vars, "attrs")
                    },
                    "message": dataMessage
                })

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Determine color type
            //--------------------------------------------------------------------------
            steps.push({
                "function": function(vars) {

                    if (!vars.color.type || vars.color.changed || vars.data.changed ||
                        vars.attrs.changed || vars.id.changed || vars.depth.changed ||
                        (vars.time.fixed.value &&
                            (vars.time.solo.changed || vars.time.mute.changed))) {

                        vars.color.valueScale = false;

                        if ( vars.dev.value ) {
                            var timerString = "checking color type";
                            print.time(timerString);
                        }

                        vars.color.type = false;

                        if (vars.color.value) {

                            var colorKey = vars.color.value;

                            if ( validObject(colorKey) ) {
                                if (colorKey[vars.id.value]) {
                                    colorKey = colorKey[vars.id.value];
                                }
                                else {
                                    colorKey = colorKey[d3.keys(colorKey)[0]];
                                }
                            }

                            if (vars.data.keys && colorKey in vars.data.keys) {
                                vars.color.type = vars.data.keys[colorKey];
                            }
                            else if (vars.attrs.keys && colorKey in vars.attrs.keys) {
                                vars.color.type = vars.attrs.keys[colorKey];
                            }

                        }
                        else if (vars.data.keys) {
                            vars.color.type = vars.data.keys[vars.id.value];
                        }

                        if (vars.dev.value) print.timeEnd(timerString);

                    }

                },
                "message": dataMessage
            })

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Format nodes/edges if needed
            //--------------------------------------------------------------------------
            if ( appReqs.indexOf("edges") >= 0 && vars.edges.value
                && ( !vars.edges.linked || vars.edges.changed ) ) {
                steps.push({ "function" : parseEdges, "message" : dataMessage })
            }

            if ( appReqs.indexOf("nodes") >= 0 && vars.edges.value
                && ( !vars.nodes.positions || vars.nodes.changed || vars.type.changed ) ) {
                steps.push({ "function" : parseNodes , "message" : dataMessage })
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Groups data by time and nesting.
            //--------------------------------------------------------------------------
            if (vars.data.changed || vars.time.changed || vars.time.format.changed || vars.id.changed || (vars.x.scale.changed && [vars.x.scale.value, vars.x.scale.previous].indexOf("discrete") >= 0) || (vars.y.scale.changed && [vars.y.scale.value, vars.y.scale.previous].indexOf("discrete") >= 0)) {
                steps.push({ "function" : dataFormat , "message" : dataMessage })
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Fetches data for app and "pool"
            //--------------------------------------------------------------------------
            if (!vars.error.value) {
                steps.push({
                    "function": function(vars) {

                        var year = !vars.time.fixed.value ? ["all"] : null
                        if (vars.dev.value) {
                            var timerString = year ? "fetching pool data" : "fetching data"
                            print.time( timerString )
                        }
                        vars.data.pool = fetchData( vars , year )
                        if (vars.dev.value) print.timeEnd( timerString )
                        if ( !year ) {
                            vars.data.viz = vars.data.pool
                        }
                        else {
                            if ( vars.dev.value ) print.time("fetching data for current year")
                            vars.data.viz = fetchData( vars )
                            if ( vars.dev.value ) print.timeEnd("fetching data for current year")
                        }

                        vars.draw.timing = vars.data.viz.length < vars.data.large ?
                            vars.timing.transitions : 0;

                    },
                    "message": dataMessage
                })
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Calculate color scale if type is number
            //--------------------------------------------------------------------------
            if (!vars.error.value) {
                steps.push({
                    "check": function(vars) {

                        return vars.color.value && vars.color.type === "number" &&
                            vars.color.valueScale === false

                    },
                    "function": dataColor,
                    "message": dataMessage
                })

            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Remove any lingering tooltips.
        //----------------------------------------------------------------------------
        steps.push({
            "function": function(vars) {
                if ( vars.dev.value ) {
                    var str = vars.format.locale.value.message.tooltipReset
                    print.time(str)
                }
                if ( vars.type.previous && appType !== vars.type.previous ) {
                    removeTooltip(vars.type.previous)
                }
                removeTooltip(appType)
                if ( vars.dev.value ) print.timeEnd(str)
            },
            "message": uiMessage
        })

        if (!vars.error.value) {
            steps.push({"function": errorCheck, "message": uiMessage})
        }

        steps.push({
            "function": function(vars) {

                vars.margin.process()
                titles(vars)

                if (!vars.error.value) {
                    if (vars.draw.update) {

                        drawDrawer(vars)
                        drawTimeline(vars)
                        drawLegend(vars)

                    }
                    else {

                        if ( vars.dev.value ) print.time("calculating margins")

                        var drawer = vars.container.value.select("div#d3plus_drawer").node().offsetHeight
                            || vars.container.value.select("div#d3plus_drawer").node().getBoundingClientRect().height

                        var timeline = vars.g.timeline.node().getBBox()
                        timeline = vars.timeline.value ? timeline.height+vars.ui.padding : 0

                        var legend = vars.g.legend.node().getBBox()
                        legend = vars.legend.value ? legend.height+vars.ui.padding : 0

                        vars.margin.bottom += drawer+timeline+legend

                        if ( vars.dev.value ) print.timeEnd("calculating margins")

                    }
                }

                history(vars)
                vars.height.viz -= (vars.margin.top+vars.margin.bottom)
                vars.width.viz -= (vars.margin.left+vars.margin.right)

            },
            "message": uiMessage
        })

        if (!vars.error.value) {
            steps.push({
                "function": focusTooltip,
                "message": uiMessage
            })
        }

        steps.push({
            "function": svgUpdate,
            "message": drawMessage
        })

        if (!vars.error.value && vars.draw.update) {
            steps.push({
                "function" : [ runType, shapes ],
                "message"  : drawMessage
            })
        }

        steps.push({
            "function" : finish,
            "message" : drawMessage
        })

        return steps

    }

},{"../../core/console/print.coffee":54,"../../core/data/color.js":56,"../../core/data/format.js":58,"../../core/data/keys.coffee":60,"../../core/data/load.coffee":61,"../../core/fetch/data.js":66,"../../core/parse/edges.js":96,"../../core/parse/nodes.js":99,"../../object/validate.coffee":174,"../../string/format.js":175,"../../tooltip/remove.coffee":205,"./errorCheck.js":215,"./finish.js":216,"./focus/tooltip.coffee":217,"./shapes/draw.js":227,"./svg/enter.js":240,"./svg/update.js":241,"./types/run.coffee":244,"./ui/drawer.js":245,"./ui/history.coffee":246,"./ui/legend.js":247,"./ui/timeline.coffee":249,"./ui/titles.js":250}],215:[function(require,module,exports){
    var fetchText    = require("../../core/fetch/text.js"),
        print        = require("../../core/console/print.coffee"),
        rejected     = require("../../core/methods/rejected.coffee"),
        stringFormat = require("../../string/format.js"),
        stringList   = require("../../string/list.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Miscellaneous Error Checks
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        if ( vars.dev.value ) print.time("checking for errors")

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if we have all required variables set
        //----------------------------------------------------------------------------
        var reqs = ["id"]
            , app_reqs = vars.types[vars.type.value].requirements
        if (app_reqs) {
            if (!(app_reqs instanceof Array)) reqs.push(app_reqs)
            else reqs = reqs.concat(vars.types[vars.type.value].requirements)
        }

        var missing = []
        reqs.forEach(function(r){
            if (typeof r === "string") {
                if (!vars[r].value) missing.push("\""+r+"\"")
            }
            else if (typeof r === "function") {
                var reqReturn = r(vars)
                if (!reqReturn.status && reqReturn.text) {
                    missing.push("\""+reqReturn.text+"\"")
                }
            }
        })

        if ( missing.length > 1 ) {
            var str = vars.format.locale.value.error.methods
                , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
                , and = vars.format.locale.value.ui.and
            missing = stringList(missing,and)
            vars.error.internal = stringFormat(str,app,missing)
        }
        else if ( missing.length === 1 ) {
            var str = vars.format.locale.value.error.method
                , app = vars.format.locale.value.visualization[vars.type.value] || vars.type.value
            vars.error.internal = stringFormat(str,app,missing[0])
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if we have focus connections, if needed
        //----------------------------------------------------------------------------
        if (!vars.error.internal && reqs.indexOf("edges") >= 0 && reqs.indexOf("focus") >= 0) {
            var connections = vars.edges.connections(vars.focus.value[0],vars.id.value)
            if (connections.length == 0) {
                var name = fetchText(vars,vars.focus.value[0],vars.depth.value)
                    , str = vars.format.locale.value.error.connections
                vars.error.internal = stringFormat(str,"\""+name+"\"")
            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if we have all required libraries
        //----------------------------------------------------------------------------
        var reqs = ["d3"]
        if (vars.types[vars.type.value].libs) {
            reqs = reqs.concat(vars.types[vars.type.value].libs)
        }
        var missing = []
        reqs.forEach(function(r){
            if (!window[r]) missing.push("\""+r+"\"")
        })

        if ( missing.length > 1 ) {
            var str = vars.format.locale.value.error.libs
                , app = vars.format.locale.value.visualization[vars.type.value]
                , and = vars.format.locale.value.ui.and
            missing = stringList(missing,and)
            vars.error.internal = stringFormat(str,app,missing)
        }
        else if ( missing.length === 1 ) {
            var str = vars.format.locale.value.error.lib
                , app = vars.format.locale.value.visualization[vars.type.value]
            vars.error.internal = stringFormat(str,app,missing[0])
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if the requested app supports the set shape
        //----------------------------------------------------------------------------
        var shapes = vars.shape.accepted(vars);
        if (!(shapes instanceof Array)) shapes = [shapes]
        var shape = vars.shape.value;

        if (!shape || rejected(vars, shapes, shape, "shape")) {
            vars.self.shape(shapes[0]);
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check to see if the requested app supports the set "mode"
        //----------------------------------------------------------------------------
        if ("modes" in vars.types[vars.type.value]) {

            var modes = vars.types[vars.type.value].modes
            if (!(modes instanceof Array)) modes = [modes]
            var mode = vars.type.mode.value

            if (!mode || rejected(vars, modes, mode, "mode")) {
                vars.self.type({"mode": modes[0]})
            }

        }

        if ( vars.dev.value ) print.timeEnd("checking for errors")

    }

},{"../../core/console/print.coffee":54,"../../core/fetch/text.js":68,"../../core/methods/rejected.coffee":92,"../../string/format.js":175,"../../string/list.coffee":176}],216:[function(require,module,exports){
    var edges = require("./shapes/edges.js"),
        paths       = require("./shapes/paths.js"),
        flash       = require("./ui/message.js"),
        focusViz    = require("./focus/viz.js"),
        methodReset = require("../../core/methods/reset.coffee"),
        print       = require("../../core/console/print.coffee"),
        shapeLabels = require("./shapes/labels.js"),
        titleCase   = require("../../string/title.coffee")

    var bounds = require("./zoom/bounds.coffee")
    var labels = require("./zoom/labels.coffee")
    var mouse  = require("./zoom/mouse.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Finalize Visualization
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        // Highlight focus nodes/edges
        if (vars.draw.first) {
            setTimeout(function(){
                focusViz(vars);
            }, vars.draw.timing);
        }
        else {
            focusViz(vars);
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Zoom to fit bounds, if applicable
        //----------------------------------------------------------------------------
        if (!vars.error.value) {

            var zoom = vars.zoom.viewport || vars.zoom.bounds
            if (vars.types[vars.type.value].zoom && vars.zoom.value && zoom) {

                if ( vars.dev.value ) print.time("calculating zoom")

                if (vars.draw.first || vars.zoom.reset) {
                    bounds(vars, zoom, 0);
                }
                else if (vars.type.changed || vars.focus.changed || vars.height.changed || vars.width.changed || vars.nodes.changed || vars.legend.changed || vars.timeline.changed || vars.ui.changed) {
                    bounds(vars, zoom);
                }

                if ( vars.dev.value ) print.timeEnd("calculating zoom")

            }
            else {
                vars.zoom.bounds = [[0,0],[vars.width.viz,vars.height.viz]]
                vars.zoom.scale = 1
                bounds(vars)
            }

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Resize/Reposition Overlay Rect for Mouse events
        //----------------------------------------------------------------------------
        var w = vars.zoom.size ? vars.zoom.size.width : vars.width.viz,
            h = vars.zoom.size ? vars.zoom.size.height : vars.height.viz,
            x = vars.zoom.bounds ? vars.zoom.bounds[0][0] : 0,
            y = vars.zoom.bounds ? vars.zoom.bounds[0][1] : 0

        vars.g.overlay
            .attr("width",w)
            .attr("height",h)
            .attr("x",x)
            .attr("y",y)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Create labels
        //----------------------------------------------------------------------------
        if (!vars.error.value) {
            if (vars.draw.update) {
                if (vars.edges.path) {
                    paths(vars);
                }
                else {
                    edges(vars);
                }
                // if (vars.draw.timing || (!vars.types[vars.type.value].zoom && !vars.draw.timing)) {
                shapeLabels(vars, "data");
                if (vars.edges.label && !vars.edges.path) {
                    setTimeout(function(){
                        shapeLabels(vars, "edges");
                    }, vars.draw.timing + 200);
                }
                // }
            }
            else if ((vars.labels.value || vars.labels.changed) && vars.types[vars.type.value].zoom && vars.zoom.value && vars.draw.timing) {
                setTimeout(function(){
                    labels(vars)
                },vars.draw.timing)
            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check for Errors
        //----------------------------------------------------------------------------
        if (!vars.error.value) {
            var reqs = vars.types[vars.type.value].requirements || []
            if (!(reqs instanceof Array)) reqs = [reqs]
            var data_req = reqs.indexOf("data") >= 0
            if (!vars.error.internal) {
                if ((!vars.data.viz || !vars.returned.nodes.length) && data_req) {
                    vars.error.internal = vars.format.locale.value.error.data
                }
            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Hide the previous app, if applicable
        //----------------------------------------------------------------------------
        var prev = vars.type.previous
        if (prev && vars.type.value != prev && vars.g.apps[prev]) {
            if ( vars.dev.value ) print.time("hiding \"" + prev + "\"")
            if (vars.draw.timing) {
                vars.g.apps[prev].transition().duration(vars.draw.timing)
                    .attr("opacity",0)
            }
            else {
                vars.g.apps[prev].attr("opacity",0)
            }
            if ( vars.dev.value ) print.timeEnd()
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Show the current app, data, and edges groups
        //----------------------------------------------------------------------------
        if (!vars.error.value) {
            var new_opacity = (data_req && vars.data.viz.length === 0) ||
            vars.error.internal || vars.error.value ? 0 : vars.focus.value.length &&
            vars.types[vars.type.value].zoom && vars.zoom.value ?
                1 - vars.tooltip.curtain.opacity : 1;

            var timing = vars.draw.timing;

            vars.group.transition().duration(timing)
                .attr("opacity",new_opacity);

            vars.g.data.transition().duration(timing)
                .attr("opacity",new_opacity);

            vars.g.edges.transition().duration(timing)
                .attr("opacity",new_opacity);

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Display and reset internal_error, if applicable
        //----------------------------------------------------------------------------
        if (vars.error.value) {
            flash(vars, vars.error.value);
        }
        else if (vars.error.internal) {
            vars.error.internal = titleCase(vars.error.internal);
            print.warning(vars.error.internal);
            flash(vars, vars.error.internal);
            vars.error.internal = null;
        }
        else {
            flash(vars);
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Unfreeze controls and apply zoom behavior, if applicable
        //----------------------------------------------------------------------------
        setTimeout(function(){

            methodReset( vars )

            if (vars.types[vars.type.value].zoom && vars.zoom.value) {
                vars.g.zoom
                    .datum(vars)
                    .call(vars.zoom.behavior.on("zoom",mouse))
                if (!vars.zoom.scroll.value) {
                    vars.g.zoom
                        .on("mousewheel.zoom",null)
                        .on("MozMousePixelScroll.zoom",null)
                        .on("wheel.zoom",null)
                }
                if (!vars.zoom.click.value) {
                    vars.g.zoom.on("dblclick.zoom",null)
                }
                if (!vars.zoom.pan.value) {
                    vars.g.zoom
                        .on("mousedown.zoom",null)
                        .on("mousemove.zoom",null)
                }
            }
            else {
                vars.g.zoom
                    .call(vars.zoom.behavior.on("zoom",null))
                    .on("dblclick.zoom",null)
                    .on("mousedown.zoom",null)
                    .on("mousemove.zoom",null)
                    .on("mousewheel.zoom",null)
                    .on("MozMousePixelScroll.zoom",null)
                    .on("touchstart.zoom",null)
                    .on("wheel.zoom",null)
            }

        },vars.draw.timing)

    }

},{"../../core/console/print.coffee":54,"../../core/methods/reset.coffee":94,"../../string/title.coffee":178,"./focus/viz.js":218,"./shapes/edges.js":228,"./shapes/labels.js":230,"./shapes/paths.js":232,"./ui/message.js":248,"./zoom/bounds.coffee":251,"./zoom/labels.coffee":253,"./zoom/mouse.coffee":254}],217:[function(require,module,exports){
    var createTooltip, fetchValue, print, removeTooltip;

    createTooltip = require("../tooltip/create.js");

    fetchValue = require("../../../core/fetch/value.coffee");

    print = require("../../../core/console/print.coffee");

    removeTooltip = require("../../../tooltip/remove.coffee");

    module.exports = function(vars) {
        var data, focus, offset;
        focus = vars.focus;
        if (!vars.error.internal && focus.value.length === 1 && focus.value.length && !vars.small && focus.tooltip.value) {
            if (vars.dev.value) {
                print.time("drawing focus tooltip");
            }
            data = vars.data.pool.filter(function(d) {
                return fetchValue(vars, d, vars.id.value) === focus.value[0];
            });
            if (data.length >= 1) {
                data = data[0];
            } else {
                data = {};
                data[vars.id.value] = focus.value[0];
            }
            offset = vars.labels.padding;
            createTooltip({
                anchor: "top left",
                arrow: false,
                data: data,
                fullscreen: false,
                id: "visualization_focus",
                length: "long",
                maxheight: vars.height.viz - offset * 2,
                mouseevents: true,
                offset: 0,
                vars: vars,
                width: vars.tooltip.large,
                x: vars.width.value - vars.margin.right - offset,
                y: vars.margin.top + offset
            });
            vars.width.viz -= vars.tooltip.large + offset * 2;
            if (vars.dev.value) {
                print.timeEnd("drawing focus tooltip");
            }
        } else {
            removeTooltip("visualization_focus");
        }
    };


},{"../../../core/console/print.coffee":54,"../../../core/fetch/value.coffee":69,"../../../tooltip/remove.coffee":205,"../tooltip/create.js":242}],218:[function(require,module,exports){
    var events = require("../../../client/pointer.coffee"),
        ie           = require("../../../client/ie.js"),
        fetchValue   = require("../../../core/fetch/value.coffee"),
        print        = require("../../../core/console/print.coffee"),
        uniqueValues = require("../../../util/uniques.coffee")

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates focus elements, if available
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        vars.g.edge_focus
            .selectAll("g")
            .remove()

        vars.g.data_focus
            .selectAll("g")
            .remove()

        if (vars.focus.value.length && vars.types[vars.type.value].zoom && vars.zoom.value) {

            if ( vars.dev.value ) print.time("drawing focus elements")

            var edges = vars.g.edges.selectAll("g")

            if (edges.size() > 0) {

                edges.each(function(l){

                    var source = l[vars.edges.source][vars.id.value],
                        target = l[vars.edges.target][vars.id.value]

                    if (source == vars.focus.value[0] || target == vars.focus.value[0]) {
                        var elem = vars.g.edge_focus.node().appendChild(this.cloneNode(true))
                        d3.select(elem).datum(l).attr("opacity",1)
                            .selectAll("line, path").datum(l)
                    }

                })


                var marker = vars.edges.arrows.value

                vars.g.edge_focus.selectAll("line, path")
                    .attr("vector-effect","non-scaling-stroke")
                    .style("stroke",vars.color.focus)
                    .style("stroke-width",function(){
                        if (ie && vars.types[vars.type.value].zoom) return 0;
                        return vars.edges.size.value ? d3.select(this).style("stroke-width")
                            : vars.data.stroke.width*2
                    })
                    .attr("marker-start",function(e){

                        var direction = vars.edges.arrows.direction.value

                        if ("bucket" in e.d3plus) {
                            var d = "_"+e.d3plus.bucket
                        }
                        else {
                            var d = ""
                        }

                        return direction == "source" && marker
                            ? "url(#d3plus_edge_marker_focus"+d+")" : "none"

                    })
                    .attr("marker-end",function(e){

                        var direction = vars.edges.arrows.direction.value

                        if ("bucket" in e.d3plus) {
                            var d = "_"+e.d3plus.bucket
                        }
                        else {
                            var d = ""
                        }

                        return direction == "target" && marker
                            ? "url(#d3plus_edge_marker_focus"+d+")" : "none"

                    })

                vars.g.edge_focus.selectAll("text")
                    .style("fill",vars.color.focus)

            }

            var focii = uniqueValues(vars.edges.connections(vars.focus.value[0],vars.id.value,true),vars.id.value, fetchValue, vars)
            focii.push(vars.focus.value[0])

            var x_bounds = [], y_bounds = [], x_buffer = [0], y_buffer = [0]

            var groups = vars.g.data.selectAll("g")
                .each(function(d){
                    if (focii.indexOf(d[vars.id.value]) >= 0) {
                        var elem = vars.g.data_focus.node().appendChild(this.cloneNode(true))
                        var elem = d3.select(elem).datum(d).attr("opacity",1)

                        if (vars.shape.value == "coordinates") {

                            vars.zoom.viewport = vars.path.bounds(vars.zoom.coords[d.d3plus.id])

                        }
                        else if ("d3plus" in d) {
                            if ("x" in d.d3plus) {
                                x_bounds.push(d.d3plus.x)
                            }
                            if ("y" in d.d3plus) {
                                y_bounds.push(d.d3plus.y)
                            }
                            if ("r" in d.d3plus) {
                                x_buffer.push(d.d3plus.r)
                                y_buffer.push(d.d3plus.r)
                            }
                            else {
                                if ("width" in d.d3plus) {
                                    x_buffer.push(d.d3plus.width/2)
                                }
                                if ("height" in d.d3plus) {
                                    y_buffer.push(d.d3plus.height/2)
                                }
                            }
                        }

                        for (e in events) {
                            var evt = d3.select(this).on(events[e])
                            if (evt) {
                                elem.on(events[e],evt)
                            }
                        }

                    }
                })

            if (x_bounds.length && y_bounds.length) {

                var xcoords = d3.extent(x_bounds),
                    ycoords = d3.extent(y_bounds),
                    xmax = d3.max(x_buffer),
                    ymax = d3.max(y_buffer)

                vars.zoom.viewport = [
                    [xcoords[0]-xmax,ycoords[0]-ymax],
                    [xcoords[1]+xmax,ycoords[1]+ymax]
                ]

            }

            vars.g.data_focus.selectAll("path")
                .style("stroke-width", ie && vars.types[vars.type.value].zoom ?
                    0 : vars.data.stroke.width * 2);

            if ( vars.dev.value ) print.timeEnd("drawing focus elements")

        }
        else {
            vars.zoom.viewport = false
        }

    }

},{"../../../client/ie.js":39,"../../../client/pointer.coffee":40,"../../../core/console/print.coffee":54,"../../../core/fetch/value.coffee":69,"../../../util/uniques.coffee":212}],219:[function(require,module,exports){
    var angles, largestRect, path2poly, shapeStyle;

    shapeStyle = require("./style.coffee");

    largestRect = require("../../../geom/largestRect.coffee");

    path2poly = require("../../../geom/path2poly.coffee");

    angles = {
        start: {},
        end: {}
    };

    module.exports = function(vars, selection, enter, exit) {
        var arc, arcTween, data, newarc;
        arc = d3.svg.arc().innerRadius(0).outerRadius(function(d) {
            return d.d3plus.r;
        }).startAngle(function(d) {
            return d.d3plus.startAngle;
        }).endAngle(function(d) {
            return d.d3plus.endAngle;
        });
        data = function(d) {
            var poly, rect;
            if (vars.labels.value) {
                if (d.d3plus.label) {
                    d.d3plus_label = d.d3plus.label;
                } else {
                    poly = path2poly(arc(d));
                    rect = largestRect(poly, {
                        angle: 0
                    });
                    if (rect[0]) {
                        d.d3plus_label = {
                            w: rect[0].width,
                            h: rect[0].height,
                            x: rect[0].cx,
                            y: rect[0].cy
                        };
                    } else {
                        delete d.d3plus_label;
                    }
                }
            }
            return [d];
        };
        if (vars.draw.timing) {
            newarc = d3.svg.arc().innerRadius(0).outerRadius(function(d) {
                return d.d3plus.r;
            }).startAngle(function(d) {
                if (angles.start[d.d3plus.id] === void 0) {
                    angles.start[d.d3plus.id] = 0;
                }
                if (isNaN(angles.start[d.d3plus.id])) {
                    angles.start[d.d3plus.id] = d.d3plus.startAngle;
                }
                return angles.start[d.d3plus.id];
            }).endAngle(function(d) {
                if (angles.end[d.d3plus.id] === void 0) {
                    angles.end[d.d3plus.id] = 0;
                }
                if (isNaN(angles.end[d.d3plus.id])) {
                    angles.end[d.d3plus.id] = d.d3plus.endAngle;
                }
                return angles.end[d.d3plus.id];
            });
            arcTween = function(arcs, newAngle) {
                return arcs.attrTween("d", function(d) {
                    var e, interpolateE, interpolateS, s;
                    if (newAngle === void 0) {
                        s = d.d3plus.startAngle;
                        e = d.d3plus.endAngle;
                    } else if (newAngle === 0) {
                        s = 0;
                        e = 0;
                    }
                    interpolateS = d3.interpolate(angles.start[d.d3plus.id], s);
                    interpolateE = d3.interpolate(angles.end[d.d3plus.id], e);
                    return function(t) {
                        angles.start[d.d3plus.id] = interpolateS(t);
                        angles.end[d.d3plus.id] = interpolateE(t);
                        return newarc(d);
                    };
                });
            };
            enter.append("path").attr("class", "d3plus_data").call(shapeStyle, vars).attr("d", newarc);
            selection.selectAll("path.d3plus_data").data(data).transition().duration(vars.draw.timing).call(shapeStyle, vars).call(arcTween);
            exit.selectAll("path.d3plus_data").transition().duration(vars.draw.timing).call(arcTween, 0);
        } else {
            enter.append("path").attr("class", "d3plus_data");
            selection.selectAll("path.d3plus_data").data(data).call(shapeStyle, vars).attr("d", arc);
        }
    };


},{"../../../geom/largestRect.coffee":161,"../../../geom/path2poly.coffee":163,"./style.coffee":236}],220:[function(require,module,exports){
    var fetchText = require("../../../core/fetch/text.js"),
        fontSizes   = require("../../../font/sizes.coffee"),
        largestRect = require("../../../geom/largestRect.coffee"),
        shapeStyle  = require("./style.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars, selection, enter, exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // D3 area definition
        //----------------------------------------------------------------------------
        var area = d3.svg.area()
            .x(function(d) { return d.d3plus.x; })
            .y0(function(d) { return d.d3plus.y0; })
            .y1(function(d) { return d.d3plus.y; })
            .interpolate(vars.shape.interpolate.value);

        var startArea = d3.svg.area()
            .x(function(d) { return d.d3plus.x; })
            .y0(function(d) { return d.d3plus.y0; })
            .y1(function(d) { return d.d3plus.y0; })
            .interpolate(vars.shape.interpolate.value);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .attr("d",function(d){ return startArea(d.values); })
            .call(shapeStyle,vars);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------

        var style = {
            "font-weight": vars.labels.font.weight,
            "font-family": vars.labels.font.family.value
        };

        selection.selectAll("path.d3plus_data")
            .data(function(d) {

                if (vars.labels.value && d.values.length > 1) {

                    var max = d3.max(d.values, function(v){
                        return v.d3plus.y0 - v.d3plus.y;
                    }), lr = false;

                    if (max > vars.labels.font.size) {

                        var tops = [], bottoms = [], names = fetchText(vars, d);

                        d.values.forEach(function(v){
                            tops.push([v.d3plus.x,v.d3plus.y]);
                            bottoms.push([v.d3plus.x,v.d3plus.y0]);
                        });
                        tops = tops.concat(bottoms.reverse());

                        var ratio = null;
                        if (names.length) {
                            var size = fontSizes(names[0],style);
                            ratio = size[0].width/size[0].height;
                        }

                        lr = largestRect(tops,{
                            "angle": d3.range(-70, 71, 1),
                            "aspectRatio": ratio,
                            "tolerance": 0
                        });

                    }

                    if (lr && lr[0]) {

                        var label = {
                            "w": ~~(lr[0].width),
                            "h": ~~(lr[0].height),
                            "x": ~~(lr[0].cx),
                            "y": ~~(lr[0].cy),
                            "angle": lr[0].angle*-1,
                            "padding": 2,
                            "names": names
                        }

                        if (lr[0].angle !== 0) {
                            label.translate = {
                                "x":label.x,
                                "y":label.y
                            }
                        }
                        else {
                            label.translate = false
                        }

                        if (label.w >= 10 && label.h >= 10) {
                            d.d3plus_label = label
                        }

                    }

                }

                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .attr("d",function(d){ return area(d.values) })
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .attr("d",function(d){ return area(d.values) })
                .call(shapeStyle,vars)
        }

    }

},{"../../../core/fetch/text.js":68,"../../../font/sizes.coffee":103,"../../../geom/largestRect.coffee":161,"./style.coffee":236}],221:[function(require,module,exports){
    var fetchText = require("../../../core/fetch/text.js"),
        largestRect = require("../../../geom/largestRect.coffee"),
        shapeStyle  = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize check scale on enter and exit.
        //----------------------------------------------------------------------------
        function init(paths){
            paths.attr("transform", "scale(1)")
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Change scale of check on update.
        //---------------------------------------------------------------------------
        function update(paths){
            paths.attr("transform", function(d){
                var smaller_dim = Math.min(d.d3plus.width, d.d3plus.height);
                var scale = Math.floor(smaller_dim / 16);
                return "scale("+scale+")";
            })
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .attr("d", "M5-6.844L3.594-5.407L-2,0.188l-1.594-1.594L-5-2.844L-7.844,0l1.438,1.406l3,3L-2,5.843l1.406-1.438l7-7L7.844-4L5-6.844z")
            .call(init)
            .call(shapeStyle,vars)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------
        selection.selectAll("path.d3plus_data")
            .data(function(d) {
                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .call(update)
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .call(update)
                .call(shapeStyle,vars)
        }

    }

},{"../../../core/fetch/text.js":68,"../../../geom/largestRect.coffee":161,"./style.coffee":236}],222:[function(require,module,exports){
    var fetchColor, fetchValue, lighter, segments;

    fetchValue = require("../../../core/fetch/value.coffee");

    fetchColor = require("../../../core/fetch/color.coffee");

    lighter = require("../../../color/lighter.coffee");

    segments = require("./segments.coffee");

    module.exports = function(d, vars, stroke) {
        var active, shape, temp, total;
        shape = d.d3plus.shape || vars.shape.value;
        if (vars.shape.value === "line" && shape !== "circle") {
            return "none";
        } else if (vars.shape.value === "area" || shape === "active" || vars.shape.value === "line") {
            return fetchColor(vars, d);
        } else if (shape === "temp") {
            if (stroke) {
                return fetchColor(vars, d);
            } else {
                return "url(#d3plus_hatch_" + d.d3plus.id + ")";
            }
        } else if (d.d3plus["static"]) {
            return lighter(fetchColor(vars, d), .75);
        }
        active = segments(vars, d, "active");
        temp = segments(vars, d, "temp");
        total = segments(vars, d, "total");
        if ((!vars.active.value && !vars.temp.value) || active === true || (active && total && active >= total && !temp) || (active && !total)) {
            return fetchColor(vars, d);
        } else if (vars.active.spotlight.value) {
            return vars.color.missing;
        } else {
            return lighter(fetchColor(vars, d), .75);
        }
    };


},{"../../../color/lighter.coffee":47,"../../../core/fetch/color.coffee":65,"../../../core/fetch/value.coffee":69,"./segments.coffee":235}],223:[function(require,module,exports){
    var copy, distance, fetchText, fontSizes, labels, largestRect, path2poly, shapeStyle;

    copy = require("../../../util/copy.coffee");

    distance = require("../../../network/distance.coffee");

    fetchText = require("../../../core/fetch/text.js");

    fontSizes = require("../../../font/sizes.coffee");

    largestRect = require("../../../geom/largestRect.coffee");

    path2poly = require("../../../geom/path2poly.coffee");

    shapeStyle = require("./style.coffee");

    labels = {};

    module.exports = function(vars, selection, enter, exit) {
        var projection, size_change;
        projection = d3.geo[vars.coords.projection.value]();
        if (projection.center) {
            projection.center(vars.coords.center);
        }
        if (!vars.zoom.scale) {
            vars.zoom.scale = 1;
        }
        vars.zoom.area = 1 / vars.zoom.scale / vars.zoom.scale;
        vars.path = d3.geo.path().projection(projection);
        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data").attr("d", vars.path).transition().duration(vars.draw.timing).call(shapeStyle, vars);
        } else {
            selection.selectAll("path.d3plus_data").attr("d", vars.path).call(shapeStyle, vars);
        }
        enter.append("path").attr("id", function(d) {
            return d.id;
        }).attr("class", "d3plus_data").attr("d", vars.path).call(shapeStyle, vars);
        size_change = vars.old_height !== vars.height.viz || vars.height.changed || vars.old_width !== vars.width.viz || vars.width.changed;
        vars.old_height = vars.height.viz;
        vars.old_width = vars.width.viz;
        if (vars.coords.changed || size_change || vars.coords.mute.changed || vars.coords.solo.changed || vars.type.changed || vars.text.changed || vars.coords.projection.changed || vars.labels.changed) {
            vars.zoom.bounds = null;
            vars.zoom.reset = true;
            vars.zoom.coords = {};
            return selection.each(function(d) {
                var areaM, areas, b, c, center, coords, dist_cutoff, dist_values, distances, i, j, largest, len, names, path, ratio, rect, reduced, ref, size, style;
                if (vars.coords.simplify.value && d.geometry.coordinates.length > 1) {
                    distances = [];
                    areas = [];
                    areaM = 0;
                    largest = copy(d);
                    reduced = copy(d);
                    d.geometry.coordinates = d.geometry.coordinates.filter(function(c, i) {
                        var a;
                        reduced.geometry.coordinates = [c];
                        a = vars.path.area(reduced);
                        if (a > 0) {
                            areas.push(a);
                            if (a > areaM) {
                                largest.geometry.coordinates = [c];
                                areaM = a;
                            }
                            return true;
                        } else {
                            return false;
                        }
                    });
                    center = vars.path.centroid(largest);
                    ref = d.geometry.coordinates;
                    for (i = j = 0, len = ref.length; j < len; i = ++j) {
                        c = ref[i];
                        reduced.geometry.coordinates = [c];
                        distances.push(distance(vars.path.centroid(reduced), center));
                    }
                    dist_values = distances.reduce(function(arr, dist, i) {
                        if (dist) {
                            arr.push(areas[i] / dist);
                        }
                        return arr;
                    }, []);
                    dist_cutoff = d3.quantile(dist_values, vars.coords.threshold.value);
                    reduced.geometry.coordinates = d.geometry.coordinates.filter(function(c, i) {
                        var a, dist;
                        dist = distances[i];
                        a = areas[i];
                        return dist === 0 || a / dist >= dist_cutoff;
                    });
                    coords = largest.geometry.coordinates[0];
                    if (coords && largest.geometry.type === "MultiPolygon") {
                        coords = coords[0];
                        largest.geometry.coordinates[0] = coords;
                        largest.geometry.type = "Polygon";
                    }
                } else {
                    reduced = d;
                    largest = d;
                    coords = d.geometry.coordinates[0];
                }
                vars.zoom.coords[d.d3plus.id] = reduced;
                delete d.d3plus_label;
                if (vars.labels.value) {
                    names = fetchText(vars, d);
                    if (coords && names.length) {
                        path = path2poly(vars.path(largest));
                        style = {
                            "font-weight": vars.labels.font.weight,
                            "font-family": vars.labels.font.family.value
                        };
                        ratio = null;
                        if (names[0].split(" ").length === 1) {
                            size = fontSizes(names[0], style)[0];
                            ratio = size.width / size.height;
                        }
                        rect = largestRect(path, {
                            angle: 0,
                            aspectRatio: ratio
                        });
                        if (rect) {
                            rect = rect[0];
                            d.d3plus_label = {
                                anchor: "middle",
                                valign: "center",
                                h: rect.height,
                                w: rect.width,
                                x: rect.cx,
                                y: rect.cy,
                                names: names
                            };
                        }
                    }
                }
                labels[d.id] = d.d3plus_label;
                b = vars.path.bounds(reduced);
                if (!vars.zoom.bounds) {
                    return vars.zoom.bounds = b;
                } else {
                    if (vars.zoom.bounds[0][0] > b[0][0]) {
                        vars.zoom.bounds[0][0] = b[0][0];
                    }
                    if (vars.zoom.bounds[0][1] > b[0][1]) {
                        vars.zoom.bounds[0][1] = b[0][1];
                    }
                    if (vars.zoom.bounds[1][0] < b[1][0]) {
                        vars.zoom.bounds[1][0] = b[1][0];
                    }
                    if (vars.zoom.bounds[1][1] < b[1][1]) {
                        return vars.zoom.bounds[1][1] = b[1][1];
                    }
                }
            });
        } else if (!vars.focus.value.length) {
            vars.zoom.viewport = false;
            return selection.each(function(d) {
                return d.d3plus_label = labels[d.id];
            });
        }
    };


},{"../../../core/fetch/text.js":68,"../../../font/sizes.coffee":103,"../../../geom/largestRect.coffee":161,"../../../geom/path2poly.coffee":163,"../../../network/distance.coffee":167,"../../../util/copy.coffee":209,"./style.coffee":236}],224:[function(require,module,exports){
    var shapeStyle  = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize check scale on enter and exit.
        //----------------------------------------------------------------------------
        function init(paths){
            paths.attr("d", d3.svg.symbol().type("cross").size(10))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Change scale of check on update.
        //---------------------------------------------------------------------------
        function update(paths){
            paths.attr("d", d3.svg.symbol().type("cross").size(function(d){
                var smaller_dim = Math.min(d.d3plus.width, d.d3plus.height);
                return d3.scale.pow().exponent(2)(smaller_dim/2);
            }))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .call(init)
            .call(shapeStyle,vars)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------
        selection.selectAll("path.d3plus_data")
            .data(function(d) {
                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .call(update)
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .call(update)
                .call(shapeStyle,vars)
        }

    }

},{"./style.coffee":236}],225:[function(require,module,exports){
    var shapeStyle  = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize check scale on enter and exit.
        //----------------------------------------------------------------------------
        function init(paths){
            paths.attr("d", d3.svg.symbol().type("diamond").size(10))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Change scale of check on update.
        //---------------------------------------------------------------------------
        function update(paths){
            paths.attr("d", d3.svg.symbol().type("diamond").size(function(d){
                var smaller_dim = Math.min(d.d3plus.width, d.d3plus.height);
                return d3.scale.pow().exponent(2)(smaller_dim/2);
            }))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .call(init)
            .call(shapeStyle,vars)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------
        selection.selectAll("path.d3plus_data")
            .data(function(d) {
                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .call(update)
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .call(update)
                .call(shapeStyle,vars)
        }

    }

},{"./style.coffee":236}],226:[function(require,module,exports){
    var shapeStyle = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "donut" shapes using svg:path with arcs
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // In order to correctly animate each donut's size and arcs, we need to store
        // it's previous values in a lookup object that does not get destroyed when
        // redrawing the visualization.
        //----------------------------------------------------------------------------
        if (!vars.arcs) {
            vars.arcs = {
                "donut": {},
                "active": {},
                "temp": {}
            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // This is the main arc function that determines what values to use for each
        // arc angle and radius.
        //----------------------------------------------------------------------------
        var arc = d3.svg.arc()
            .startAngle(0)
            .endAngle(function(d){
                var a = vars.arcs[d.d3plus.shape][d.d3plus.id].a;
                return a > Math.PI*2 ? Math.PI*2 : a;
            })
            .innerRadius(function(d){
                if (d.d3plus.static) return 0;
                var r = vars.arcs[d.d3plus.shape][d.d3plus.id].r;
                return r * vars.data.donut.size;
            })
            .outerRadius(function(d){
                return vars.arcs[d.d3plus.shape][d.d3plus.id].r;
            })

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // This is the main "arcTween" function where all of the animation happens
        // for each arc.
        //----------------------------------------------------------------------------
        function size(path,mod,rad,ang) {
            if (!mod) var mod = 0
            if (typeof rad != "number") var rad = undefined
            if (typeof ang != "number") var ang = undefined
            path.attrTween("d", function(d){
                if (rad == undefined) var r = d.d3plus.r ? d.d3plus.r : d3.max([d.d3plus.width,d.d3plus.height])
                else var r = rad
                if (ang == undefined) var a = d.d3plus.segments[d.d3plus.shape]
                else var a = ang
                if (!vars.arcs[d.d3plus.shape][d.d3plus.id]) {
                    vars.arcs[d.d3plus.shape][d.d3plus.id] = {"r": 0}
                    vars.arcs[d.d3plus.shape][d.d3plus.id].a = Math.PI * 2
                }
                var radius = d3.interpolate(vars.arcs[d.d3plus.shape][d.d3plus.id].r,r+mod),
                    angle = d3.interpolate(vars.arcs[d.d3plus.shape][d.d3plus.id].a,a)
                return function(t) {
                    vars.arcs[d.d3plus.shape][d.d3plus.id].r = radius(t)
                    vars.arcs[d.d3plus.shape][d.d3plus.id].a = angle(t)
                    return arc(d)
                }
            })
        }

        function data(d) {

            if (d.d3plus.label) {
                d.d3plus_label = d.d3plus.label;
            }
            else {
                delete d.d3plus_label;
            }

            return [d];
        }

        if (vars.draw.timing) {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Exit
            //----------------------------------------------------------------------------
            exit.selectAll("path.d3plus_data").transition().duration(vars.draw.timing)
                .call(size,0,0)
                .each("end",function(d){
                    delete vars.arcs[d.d3plus.shape][d.d3plus.id];
                });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Update
            //----------------------------------------------------------------------------
            selection.selectAll("path.d3plus_data")
                .data(data)
                .transition().duration(vars.draw.timing)
                .call(size)
                .call(shapeStyle,vars);

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Enter
            //----------------------------------------------------------------------------
            enter.append("path")
                .attr("class","d3plus_data")
                .transition().duration(0)
                .call(size,0,0)
                .call(shapeStyle,vars)
                .transition().duration(vars.draw.timing)
                .call(size)
                .call(shapeStyle,vars);

        }
        else {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Exit
            //----------------------------------------------------------------------------
            exit.selectAll("path.d3plus_data")
                .each(function(d){
                    delete vars.arcs[d.d3plus.shape][d.d3plus.id];
                });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Enter
            //----------------------------------------------------------------------------
            enter.append("path")
                .attr("class","d3plus_data");

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" Update
            //----------------------------------------------------------------------------
            selection.selectAll("path.d3plus_data")
                .data(data)
                .call(size)
                .call(shapeStyle,vars);
        }

    };

},{"./style.coffee":236}],227:[function(require,module,exports){
    var child         = require("../../../util/child.coffee"),
        closest       = require("../../../util/closest.coffee"),
        createTooltip = require("../tooltip/create.js"),
        events        = require("../../../client/pointer.coffee"),
        fetchValue    = require("../../../core/fetch/value.coffee"),
        fetchColor    = require("../../../core/fetch/color.coffee"),
        fetchText     = require("../../../core/fetch/text.js"),
        legible       = require("../../../color/legible.coffee"),
        print         = require("../../../core/console/print.coffee"),
        removeTooltip = require("../../../tooltip/remove.coffee"),
        segments      = require("./segments.coffee"),
        shapeFill     = require("./fill.js"),
        stringStrip   = require("../../../string/strip.js"),
        touch         = require("../../../client/touch.coffee"),
        touchEvent    = require("../zoom/propagation.coffee"),
        uniqueValues  = require("../../../util/uniques.coffee"),
        validObject   = require("../../../object/validate.coffee"),
        zoomDirection = require("../zoom/direction.coffee");

    var drawShape = {
        "arc":           require("./arc.coffee"),
        "area":          require("./area.js"),
        "check":         require("./check.js"),
        "coordinates":   require("./coordinates.coffee"),
        "cross":         require("./cross.js"),
        "diamond":       require("./diamond.js"),
        "donut":         require("./donut.js"),
        "line":          require("./line.js"),
        "radial":        require("./radial.coffee"),
        "rect":          require("./rect.coffee"),
        "triangle_down": require("./triangle_down.js"),
        "triangle_up":   require("./triangle_up.js"),
        "whisker":       require("./whisker.coffee")
    };

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws the appropriate shape based on the data
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        var data = vars.returned.nodes || [],
            edges = vars.returned.edges || [];

        vars.draw.timing = data.length < vars.data.large &&
        edges.length < vars.edges.large ?
            vars.timing.transitions : 0;

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Match vars.shape types to their respective d3plus.shape functions. For
        // example, both "square", and "circle" shapes use "rect" as their drawing
        // class.
        //----------------------------------------------------------------------------
        var shapeLookup = {
            "arc":           "arc",
            "area":          "area",
            "check":         "check",
            "circle":        "rect",
            "coordinates":   "coordinates",
            "cross":         "cross",
            "donut":         "donut",
            "diamond":       "diamond",
            "line":          "line",
            "plus":          "cross",
            "radial":        "radial",
            "rect":          "rect",
            "square":        "rect",
            "triangle_down": "triangle_down",
            "triangle":      "triangle_up",
            "triangle_up":   "triangle_up",
            "whisker":       "whisker"
        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Split the data by each shape type in the data.
        //----------------------------------------------------------------------------
        var shapes = {};
        data.forEach(function(d){
            var s = d.d3plus && d.d3plus.shape ? d.d3plus.shape : vars.shape.value;
            if (s in shapeLookup) {
                if (d.d3plus) d.d3plus.shape = s
                s = shapeLookup[s]
                if (!shapes[s]) shapes[s] = []
                shapes[s].push(d)
            }
        })

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Resets the "id" of each data point to use with matching.
        //----------------------------------------------------------------------------
        function id(d) {

            if (!d.d3plus.id) {
                d.d3plus.id = "";
                for (var i = 0; i <= vars.depth.value; i++) {
                    d.d3plus.id += fetchValue(vars,d,vars.id.nesting[i])+"_"
                }

                d.d3plus.id += shape;

                ["x", "y", "x2", "y2"].forEach(function(axis){
                    if (vars[axis].scale.value == "discrete") {
                        var val = fetchValue(vars, d, vars[axis].value)
                        if (val.constructor === Date) val = val.getTime()
                        d.d3plus.id += "_"+val
                    }
                })

                if (d.d3plus.suffix) {
                    d.d3plus.id += "_" + d.d3plus.suffix;
                }

                d.d3plus.id = stringStrip(d.d3plus.id)
            }

            return d
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Transforms the positions and scale of each group.
        //----------------------------------------------------------------------------
        function transform(g,grow) {

            var scales = vars.types[vars.type.value].scale,
                scale = 1;
            if (scales) {
                if (validObject[scales] && vars.shape.value in scales) {
                    scale = scales[vars.shape.value];
                }
                else if (typeof scales == "function") {
                    scale = scales(vars, vars.shape.value);
                }
                else if (typeof scales == "number") {
                    scale = scales;
                }
            }

            scale = grow ? scale : 1;
            g.attr("transform", function(d){

                if (["line", "area", "coordinates"].indexOf(shape) < 0) {
                    var x = d.d3plus.x || 0, y = d.d3plus.y || 0;
                    return "translate("+x+","+y+")scale("+scale+")";
                }
                else {
                    return "scale("+scale+")";
                }

            });

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Sets the class name for a group
        //----------------------------------------------------------------------------
        function className(g) {
            g.attr("class", function(d){
                var c = vars.class.value ? " " + fetchValue(vars, d, vars.class.value) : "";
                return "d3plus_" + shape + c;
            });
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Remove old groups
        //----------------------------------------------------------------------------
        for (var s in shapeLookup) {
            if (!(shapeLookup[s] in shapes) || d3.keys(shapes).length === 0) {
                var oldShapes = vars.g.data.selectAll("g.d3plus_"+shapeLookup[s]);
                if (vars.draw.timing) {
                    oldShapes
                        .transition().duration(vars.draw.timing)
                        .attr("opacity",0)
                        .remove();
                }
                else {
                    oldShapes
                        .remove();
                }
            }
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize arrays for labels and sizes
        //----------------------------------------------------------------------------
        var labels = [], shares = [];

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Create groups by shape, apply data, and call specific shape drawing class.
        //----------------------------------------------------------------------------
        for (var shape in shapes) {

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Bind Data to Groups
            //--------------------------------------------------------------------------
            var selection = vars.g.data.selectAll("g.d3plus_"+shape)
                .data(shapes[shape],function(d){

                    if (!d.d3plus) d.d3plus = {}

                    if ( shape === "coordinates" ) {
                        d.d3plus.id = d.id
                        return d.id
                    }

                    if ( !d.d3plus.id ) {

                        if (d.values) {

                            d.values.forEach(function(v){
                                v = id(v)
                                v.d3plus.shape = "circle"
                            })
                            d.d3plus.id = d.key

                        }
                        else {

                            d = id(d)

                            if (!d.d3plus.segments) {

                                d.d3plus.segments = {"donut": Math.PI*2}
                                var active = segments(vars, d, "active"),
                                    temp   = segments(vars, d, "temp"),
                                    total  = segments(vars, d, "total");

                                if (total) {
                                    if (active) {
                                        d.d3plus.segments.active = (active/total) * (Math.PI * 2)
                                    }
                                    else {
                                        d.d3plus.segments.active = 0
                                    }
                                    if (temp) {
                                        d.d3plus.segments.temp = ((temp/total) * (Math.PI * 2)) + d.d3plus.segments.active
                                    }
                                    else {
                                        d.d3plus.segments.temp = 0
                                    }
                                }

                            }

                        }

                    }

                    return d.d3plus ? d.d3plus.id : false;

                })

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Groups Exit
            //--------------------------------------------------------------------------
            if (vars.draw.timing) {
                var exit = selection.exit()
                    .transition().duration(vars.draw.timing)
                    .attr("opacity",0)
                    .remove()
            }
            else {
                var exit = selection.exit()
                    .remove()
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Existing Groups Update
            //--------------------------------------------------------------------------
            if (vars.draw.timing) {
                selection
                    .transition().duration(vars.draw.timing)
                    .call(transform)
                    .call(className);
            }
            else {
                selection.call(transform).call(className);
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Groups Enter
            //--------------------------------------------------------------------------
            var opacity = vars.draw.timing ? 0 : 1
            var enter = selection.enter().append("g")
                .attr("opacity",opacity)
                .call(transform)
                .call(className);

            if (vars.draw.timing) {
                enter.transition().duration(vars.draw.timing)
                    .attr("opacity",1)
            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // All Groups Sort Order
            //--------------------------------------------------------------------------
            selection.order()

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Draw appropriate graphics inside of each group
            //--------------------------------------------------------------------------
            if ( vars.dev.value ) print.time("drawing \"" + shape + "\" shapes")
            drawShape[shape]( vars , selection , enter , exit , transform )
            if ( vars.dev.value ) print.timeEnd("drawing \"" + shape + "\" shapes")

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Check for active and temp fills for rects and donuts
            //--------------------------------------------------------------------------
            if (["rect","donut"].indexOf(shape) >= 0 && vars.types[vars.type.value].fill) {
                if ( vars.dev.value ) print.time("filling \"" + shape + "\" shapes")
                shapeFill( vars , selection , enter , exit , transform )
                if ( vars.dev.value ) print.timeEnd("filling \"" + shape + "\" shapes")
            }

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Function to Update Edges
        //----------------------------------------------------------------------------
        function edge_update(d) {

            if (d && vars.g.edges.selectAll("g").size() > 0) {

                vars.g.edge_hover
                    .selectAll("*")
                    .remove()

                vars.g.edges.selectAll("g")
                    .each(function(l){

                        var id = d[vars.id.value],
                            source = l[vars.edges.source][vars.id.value],
                            target = l[vars.edges.target][vars.id.value];

                        if (source == id || source == "left_" + id || source == "right_" + id ||
                            target == id || target == "left_" + id || target == "right_" + id) {
                            var elem = vars.g.edge_hover.node().appendChild(this.cloneNode(true))
                            d3.select(elem).datum(l).attr("opacity",1)
                                .selectAll("line, path").datum(l)
                        }

                    })


                var marker = vars.edges.arrows.value

                vars.g.edge_hover
                    .attr("opacity",0)
                    .selectAll("line, path")
                    .style("stroke",vars.color.primary)
                    .style("stroke-width",function(d){
                        if (vars.edges.path && d.dy) {
                            return Math.max(1, d.dy);
                        }
                        return vars.edges.size.value ? d3.select(this).style("stroke-width")
                            : vars.data.stroke.width*2
                    })
                    .attr("marker-start",function(e){

                        var direction = vars.edges.arrows.direction.value

                        if ("bucket" in e.d3plus) {
                            var d = "_"+e.d3plus.bucket
                        }
                        else {
                            var d = ""
                        }

                        return direction == "source" && marker
                            ? "url(#d3plus_edge_marker_highlight"+d+")" : "none"

                    })
                    .attr("marker-end",function(e){

                        var direction = vars.edges.arrows.direction.value

                        if ("bucket" in e.d3plus) {
                            var d = "_"+e.d3plus.bucket
                        }
                        else {
                            var d = ""
                        }

                        return direction == "target" && marker
                            ? "url(#d3plus_edge_marker_highlight"+d+")" : "none"

                    })


                vars.g.edge_hover.selectAll("text")
                    .style("fill",vars.color.primary)

                if (vars.draw.timing) {

                    vars.g.edge_hover
                        .transition().duration(vars.timing.mouseevents)
                        .attr("opacity",1)

                    vars.g.edges
                        .transition().duration(vars.timing.mouseevents)
                        .attr("opacity",0.5)

                }
                else {

                    vars.g.edge_hover
                        .attr("opacity",1)

                }

            }
            else {

                if (vars.draw.timing) {

                    vars.g.edge_hover
                        .transition().duration(vars.timing.mouseevents)
                        .attr("opacity",0)
                        .transition()
                        .selectAll("*")
                        .remove()

                    vars.g.edges
                        .transition().duration(vars.timing.mouseevents)
                        .attr("opacity",1)

                }
                else {

                    vars.g.edge_hover
                        .selectAll("*")
                        .remove()

                }

            }

        }

        edge_update()

        if (vars.tooltip.value) {

            vars.g.data.selectAll("g")
                .on(events.over,function(d){

                    if (touch) touchEvent(vars, d3.event);

                    if (!d3.event.buttons && vars.mouse.value && vars.mouse.over.value && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

                        if (typeof vars.mouse.over.value === "function") {
                            vars.mouse.over.value(d, vars.self);
                        }
                        else {

                            var zoomDir = zoomDirection(d.d3plus_data || d, vars)
                            var pointer = typeof vars.mouse.viz === "function" ||
                                typeof vars.mouse.viz[events.click] === "function" ||
                                (vars.zoom.value && (vars.types[vars.type.value].zoom ||
                                    (d.d3plus.threshold && d.d3plus.merged) ||
                                    zoomDir === 1 ||
                                    (zoomDir === -1 && vars.history.states.length && !vars.tooltip.value.long)));

                            d3.select(this)
                                .style("cursor", pointer ? "pointer" : "auto")
                                .transition().duration(vars.timing.mouseevents)
                                .call(transform,true)

                            d3.select(this).selectAll(".d3plus_data")
                                .transition().duration(vars.timing.mouseevents)
                                .attr("opacity",1)

                            vars.covered = false

                            if (d.values && vars.axes.discrete) {

                                var index = vars.axes.discrete === "x" ? 0 : 1
                                    , mouse = d3.mouse(vars.container.value.node())[index]
                                    , positions = uniqueValues(d.values,function(x){return x.d3plus[vars.axes.discrete]})
                                    , match = closest(positions,mouse)

                                d.d3plus_data = d.values[positions.indexOf(match)]
                                d.d3plus = d.values[positions.indexOf(match)].d3plus

                            }

                            var tooltip_data = d.d3plus_data ? d.d3plus_data : d

                            createTooltip({
                                "vars": vars,
                                "data": tooltip_data
                            })

                            if (typeof vars.mouse.viz == "function") {
                                vars.mouse.viz(d.d3plus_data || d, vars)
                            }
                            else if (vars.mouse.viz[events.over]) {
                                vars.mouse.viz[events.over](d.d3plus_data || d, vars)
                            }

                            edge_update(d)

                        }

                    }
                    else {
                        removeTooltip(vars.type.value);
                    }

                })
                .on(events.move,function(d){

                    if (touch) touchEvent(vars, d3.event);

                    if (!d3.event.buttons && vars.mouse.value && vars.mouse.move.value && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

                        if (typeof vars.mouse.move.value === "function") {
                            vars.mouse.move.value(d, vars.self);
                        }
                        else {

                            var zoomDir = zoomDirection(d.d3plus_data || d, vars)
                            var pointer = typeof vars.mouse.viz === "function" ||
                                typeof vars.mouse.viz[events.click] === "function" ||
                                (vars.zoom.value && (vars.types[vars.type.value].zoom ||
                                    (d.d3plus.threshold && d.d3plus.merged) ||
                                    zoomDir === 1 ||
                                    (zoomDir === -1 && vars.history.states.length && !vars.tooltip.value.long)));


                            d3.select(this).style("cursor", pointer ? "pointer" : "auto");

                            // vars.covered = false
                            var tooltipType = vars.types[vars.type.value].tooltip || "follow"

                            if (d.values && vars.axes.discrete) {

                                var index = vars.axes.discrete === "x" ? 0 : 1
                                    , mouse = d3.mouse(vars.container.value.node())[index]
                                    , positions = uniqueValues(d.values,function(x){return x.d3plus[vars.axes.discrete]})
                                    , match = closest(positions,mouse)

                                d.d3plus_data = d.values[positions.indexOf(match)]
                                d.d3plus = d.values[positions.indexOf(match)].d3plus

                            }

                            var tooltip_data = d.d3plus_data ? d.d3plus_data : d
                            createTooltip({
                                "vars": vars,
                                "data": tooltip_data
                            })

                            if (typeof vars.mouse.viz == "function") {
                                vars.mouse.viz(d.d3plus_data || d, vars)
                            }
                            else if (vars.mouse.viz[events.move]) {
                                vars.mouse.viz[events.move](d.d3plus_data || d, vars)
                            }

                        }

                    }
                    else {
                        removeTooltip(vars.type.value);
                    }

                })
                .on(events.out,function(d){

                    if (touch) touchEvent(vars, d3.event);

                    if (!d3.event.buttons && vars.mouse.value && vars.mouse.out.value) {

                        if (typeof vars.mouse.out.value === "function") {
                            vars.mouse.out.value(d, vars.self);
                        }
                        else {

                            var childElement = child(this,d3.event.toElement)

                            if (!childElement && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

                                d3.select(this)
                                    .transition().duration(vars.timing.mouseevents)
                                    .call(transform)

                                d3.select(this).selectAll(".d3plus_data")
                                    .transition().duration(vars.timing.mouseevents)
                                    .attr("opacity",vars.data.opacity)

                                if (!vars.covered) {
                                    removeTooltip(vars.type.value)
                                }

                                if (typeof vars.mouse.viz == "function") {
                                    vars.mouse.viz(d.d3plus_data || d, vars)
                                }
                                else if (vars.mouse.viz[events.out]) {
                                    vars.mouse.viz[events.out](d.d3plus_data || d, vars)
                                }

                                edge_update()

                            }

                        }

                    }
                    else {
                        removeTooltip(vars.type.value);
                    }

                })

        }
        else {

            var mouseEvent = function() {
                touchEvent(vars, d3.event)
            }

            vars.g.data.selectAll("g")
                .on(events.over, mouseEvent)
                .on(events.move, mouseEvent)
                .on(events.out , mouseEvent)

        }

        d3.select(window).on("scroll.d3plus", function(){
            removeTooltip(vars.type.value);
        });

        vars.g.data.selectAll("g")
            .on(events.click,function(d){

                if (!(vars.mouse.viz && vars.mouse.viz.click === false) && vars.mouse.value && vars.mouse.click.value && !d3.event.defaultPrevented && !vars.draw.frozen && (!d.d3plus || !d.d3plus.static)) {

                    if (typeof vars.mouse.click.value === "function") {
                        vars.mouse.click.value(d, vars.self);
                    }
                    else {

                        if (d.values && vars.axes.discrete) {

                            var index = vars.axes.discrete === "x" ? 0 : 1
                                , mouse = d3.mouse(vars.container.value.node())[index]
                                , positions = uniqueValues(d.values,function(x){return x.d3plus[vars.axes.discrete]})
                                , match = closest(positions,mouse)

                            d.d3plus_data = d.values[positions.indexOf(match)]
                            d.d3plus = d.values[positions.indexOf(match)].d3plus

                        }

                        if (typeof vars.mouse.viz == "function") {
                            vars.mouse.viz(d.d3plus_data || d, vars)
                        }
                        else if (vars.mouse.viz[events.out]) {
                            vars.mouse.viz[events.out](d.d3plus_data || d, vars)
                        }
                        else if (vars.mouse.viz[events.click]) {
                            vars.mouse.viz[events.click](d.d3plus_data || d, vars)
                        }

                        var depth_delta = zoomDirection(d.d3plus_data || d, vars)
                            , previous = vars.id.solo.value
                            , title = fetchText(vars,d)[0]
                            , color = legible(fetchColor(vars,d))
                            , prev_sub = vars.title.sub.value || false
                            , prev_color = vars.title.sub.font.color
                            , prev_total = vars.title.total.font.color

                        if (d.d3plus.threshold && d.d3plus.merged && vars.zoom.value) {

                            vars.history.states.push(function(){

                                vars.self
                                    .id({"solo": previous})
                                    .title({
                                        "sub": {
                                            "font": {
                                                "color": prev_color
                                            },
                                            "value": prev_sub
                                        },
                                        "total": {
                                            "font": {
                                                "color": prev_total
                                            }
                                        }
                                    })
                                    .draw()

                            })

                            vars.self
                                .id({"solo": previous.concat(uniqueValues(d.d3plus.merged, vars.id.value, fetchValue, vars))})
                                .title({
                                    "sub": {
                                        "font": {
                                            "color": color
                                        },
                                        "value": title
                                    },
                                    "total": {
                                        "font": {
                                            "color": color
                                        }
                                    }
                                })
                                .draw()

                        }
                        else if (depth_delta === 1 && vars.zoom.value) {

                            var id = fetchValue(vars, d.d3plus_data || d, vars.id.value)

                            vars.history.states.push(function(){

                                vars.self
                                    .depth(vars.depth.value-1)
                                    .id({"solo": previous})
                                    .title({
                                        "sub": {
                                            "font": {
                                                "color": prev_color
                                            },
                                            "value": prev_sub
                                        },
                                        "total": {
                                            "font": {
                                                "color": prev_total
                                            }
                                        }
                                    })
                                    .draw()

                            })

                            vars.self
                                .depth(vars.depth.value+1)
                                .id({"solo": previous.concat(id)})
                                .title({
                                    "sub": {
                                        "font": {
                                            "color": color
                                        },
                                        "value": title
                                    },
                                    "total": {
                                        "font": {
                                            "color": color
                                        }
                                    }
                                })
                                .draw()

                        }
                        else if (depth_delta === -1 && vars.zoom.value &&
                            vars.history.states.length && !vars.tooltip.value.long) {

                            vars.history.back()

                        }
                        else if (vars.types[vars.type.value].zoom && vars.zoom.value) {

                            edge_update()

                            d3.select(this)
                                .transition().duration(vars.timing.mouseevents)
                                .call(transform)

                            d3.select(this).selectAll(".d3plus_data")
                                .transition().duration(vars.timing.mouseevents)
                                .attr("opacity",vars.data.opacity)

                            removeTooltip(vars.type.value)
                            vars.draw.update = false

                            if (!d || d[vars.id.value] == vars.focus.value[0]) {
                                vars.self.focus(false).draw()
                            }
                            else {
                                vars.self.focus(d[vars.id.value]).draw()
                            }

                        }
                        else if (vars.types[vars.type.value].requirements.indexOf("focus") < 0) {

                            edge_update()

                            var tooltip_data = d.d3plus_data ? d.d3plus_data : d

                            createTooltip({
                                "vars": vars,
                                "data": tooltip_data
                            })

                        }

                    }

                }

            })

    }

},{"../../../client/pointer.coffee":40,"../../../client/touch.coffee":45,"../../../color/legible.coffee":46,"../../../core/console/print.coffee":54,"../../../core/fetch/color.coffee":65,"../../../core/fetch/text.js":68,"../../../core/fetch/value.coffee":69,"../../../object/validate.coffee":174,"../../../string/strip.js":177,"../../../tooltip/remove.coffee":205,"../../../util/child.coffee":207,"../../../util/closest.coffee":208,"../../../util/uniques.coffee":212,"../tooltip/create.js":242,"../zoom/direction.coffee":252,"../zoom/propagation.coffee":255,"./arc.coffee":219,"./area.js":220,"./check.js":221,"./coordinates.coffee":223,"./cross.js":224,"./diamond.js":225,"./donut.js":226,"./fill.js":229,"./line.js":231,"./radial.coffee":233,"./rect.coffee":234,"./segments.coffee":235,"./triangle_down.js":237,"./triangle_up.js":238,"./whisker.coffee":239}],228:[function(require,module,exports){
    var buckets = require("../../../util/buckets.coffee"),
        offset  = require("../../../geom/offset.coffee");

    module.exports = function(vars) {

        var edges = vars.returned.edges || [],
            scale = vars.zoom.behavior.scaleExtent()[0];

        if (typeof vars.edges.size.value === "string") {

            var strokeDomain = d3.extent(edges, function(e){
                    return e[vars.edges.size.value];
                }),
                maxSize = d3.min(vars.returned.nodes || [], function(n){
                    return n.d3plus.r;
                }) * (vars.edges.size.scale * 2);

            vars.edges.scale = d3.scale.sqrt()
                .domain(strokeDomain)
                .range([vars.edges.size.min,maxSize*scale]);

        }
        else {

            var defaultWidth = typeof vars.edges.size.value == "number" ?
                vars.edges.size.value : vars.edges.size.min;

            vars.edges.scale = function(){
                return defaultWidth;
            };

        }

        var o = vars.edges.opacity.value;
        var o_type = typeof o;

        if (vars.edges.opacity.changed && o_type === "string") {
            vars.edges.opacity.scale.value
                .domain(d3.extent(edges, function(d){
                    return d[o];
                }))
                .range([vars.edges.opacity.min.value,1]);
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialization of Lines
        //----------------------------------------------------------------------------
        function init(l) {

            l
                .attr("opacity", 0)
                .style("stroke-width",0)
                .style("stroke",vars.background.value)
                .style("fill","none");
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Styling of Lines
        //----------------------------------------------------------------------------
        function style(edges) {

            var marker = vars.edges.arrows.value;

            edges
                .attr("opacity", function(d){
                    return o_type === "number" ? o :
                        o_type === "function" ? o(d, vars) :
                            vars.edges.opacity.scale.value(d[o]);
                })
                .style("stroke-width",function(e){
                    return vars.edges.scale(e[vars.edges.size.value]);
                })
                .style("stroke",vars.edges.color)
                .attr("marker-start",function(e){

                    var direction = vars.edges.arrows.direction.value;

                    if ("bucket" in e.d3plus) {
                        var d = "_"+e.d3plus.bucket;
                    }
                    else {
                        var d = "";
                    }

                    return direction == "source" && marker
                        ? "url(#d3plus_edge_marker_default"+d+")" : "none"

                })
                .attr("marker-end",function(e){

                    var direction = vars.edges.arrows.direction.value

                    if ("bucket" in e.d3plus) {
                        var d = "_"+e.d3plus.bucket
                    }
                    else {
                        var d = ""
                    }

                    return direction == "target" && marker
                        ? "url(#d3plus_edge_marker_default"+d+")" : "none"

                })
                .attr("vector-effect","non-scaling-stroke")
                .attr("pointer-events","none")
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Positioning of Lines
        //----------------------------------------------------------------------------
        function line(l) {
            l
                .attr("x1",function(d){
                    return d[vars.edges.source].d3plus.edges[d[vars.edges.target][vars.id.value]].x;
                })
                .attr("y1",function(d){
                    return d[vars.edges.source].d3plus.edges[d[vars.edges.target][vars.id.value]].y;
                })
                .attr("x2",function(d){
                    return d[vars.edges.target].d3plus.edges[d[vars.edges.source][vars.id.value]].x;
                })
                .attr("y2",function(d){
                    return d[vars.edges.target].d3plus.edges[d[vars.edges.source][vars.id.value]].y;
                });
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Positioning of Splines
        //----------------------------------------------------------------------------
        var curve = d3.svg.line().interpolate(vars.edges.interpolate.value);

        function spline(l) {
            l
                .attr("d", function(d) {

                    return curve(d.d3plus.spline);

                });
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Calculates and Draws Label for edge
        //----------------------------------------------------------------------------
        function label(d) {

            delete d.d3plus_label

            if (vars.g.edges.selectAll("line, path").size() < vars.edges.large && vars.edges.label && d[vars.edges.label]) {

                if ("spline" in d.d3plus) {

                    var length = this.getTotalLength(),
                        center = this.getPointAtLength(length/2),
                        prev = this.getPointAtLength((length/2)-(length*.1)),
                        next = this.getPointAtLength((length/2)+(length*.1)),
                        radians = Math.atan2(next.y-prev.y,next.x-prev.x),
                        angle = radians*(180/Math.PI),
                        bounding = this.parentNode.getBBox(),
                        width = length*.8,
                        x = center.x,
                        y = center.y

                }
                else {

                    var bounds = this.getBBox(),
                        source = d[vars.edges.source],
                        target = d[vars.edges.target],
                        start = {"x": source.d3plus.edges[target[vars.id.value]].x, "y": source.d3plus.edges[target[vars.id.value]].y},
                        end = {"x": target.d3plus.edges[source[vars.id.value]].x, "y": target.d3plus.edges[source[vars.id.value]].y},
                        xdiff = end.x-start.x,
                        ydiff = end.y-start.y,
                        center = {"x": end.x-(xdiff)/2, "y": end.y-(ydiff)/2},
                        radians = Math.atan2(ydiff,xdiff),
                        angle = radians*(180/Math.PI),
                        length = Math.sqrt((xdiff*xdiff)+(ydiff*ydiff)),
                        width = length,
                        x = center.x,
                        y = center.y

                }

                width += vars.labels.padding*2

                var m = 0
                if (vars.edges.arrows.value) {
                    m = typeof vars.edges.arrows.value === "number"
                        ? vars.edges.arrows.value : 8
                    m = m/vars.zoom.behavior.scaleExtent()[1]
                    width -= m*2
                }

                if (angle < -90 || angle > 90) {
                    angle -= 180
                }

                if (width*vars.zoom.behavior.scaleExtent()[0] > 20) {

                    d.d3plus_label = {
                        "x": x,
                        "y": y,
                        "translate": {"x": x, "y": y},
                        "w": width,
                        "h": 15+vars.labels.padding*2,
                        "angle": angle,
                        "anchor": "middle",
                        "valign": "center",
                        "color": vars.edges.color,
                        "resize": false,
                        "names": [vars.format.value(d[vars.edges.label])],
                        "background": 1
                    }

                }

            }

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Enter/update/exit the Arrow Marker
        //----------------------------------------------------------------------------
        var markerData = vars.edges.arrows.value ? typeof vars.edges.size.value == "string"
            ? [ "default_0", "default_1", "default_2",
                "highlight_0", "highlight_1", "highlight_2",
                "focus_0", "focus_1", "focus_2" ]
            : [ "default", "highlight", "focus" ] : []

        if (typeof vars.edges.size.value == "string") {
            var b = buckets(vars.edges.scale.range(),4)
                , markerSize = []
            for (var i = 0; i < 3; i++) {
                markerSize.push(b[i+1]+(b[1]-b[0])*(i+2)*2)
            }
        }
        else {
            var m = typeof vars.edges.arrows.value === "number"
                ? vars.edges.arrows.value : 8

            var markerSize = typeof vars.edges.size.value === "number"
                ? vars.edges.size.value/m : m
        }

        var marker = vars.defs.selectAll(".d3plus_edge_marker")
            .data(markerData, String)

        var marker_style = function(path) {
            path
                .attr("d",function(id){

                    var depth = id.split("_")

                    if (depth.length == 2 && vars.edges.scale) {
                        depth = parseInt(depth[1])
                        var m = markerSize[depth]
                    }
                    else {
                        var m = markerSize
                    }

                    if (vars.edges.arrows.direction.value == "target") {
                        return "M 0,-"+m/2+" L "+m*.85+",0 L 0,"+m/2+" L 0,-"+m/2
                    }
                    else {
                        return "M 0,-"+m/2+" L -"+m*.85+",0 L 0,"+m/2+" L 0,-"+m/2
                    }
                })
                .attr("fill",function(d){

                    var type = d.split("_")[0]

                    if (type == "default") {
                        return vars.edges.color
                    }
                    else if (type == "focus") {
                        return vars.color.focus
                    }
                    else {
                        return vars.color.primary
                    }
                })
                .attr("transform","scale("+1/scale+")")
        }

        if (vars.draw.timing) {
            marker.exit().transition().duration(vars.draw.timing)
                .attr("opacity",0)
                .remove()

            marker.select("path").transition().duration(vars.draw.timing)
                .attr("opacity",1)
                .call(marker_style)
        }
        else {
            marker.exit().remove()

            marker.select("path")
                .attr("opacity",1)
                .call(marker_style)
        }

        var opacity = vars.draw.timing ? 0 : 1
        var enter = marker.enter().append("marker")
            .attr("id",function(d){
                return "d3plus_edge_marker_"+d
            })
            .attr("class","d3plus_edge_marker")
            .attr("orient","auto")
            .attr("markerUnits","userSpaceOnUse")
            .style("overflow","visible")
            .append("path")
            .attr("opacity",opacity)
            .attr("vector-effect","non-scaling-stroke")
            .call(marker_style)

        if (vars.draw.timing) {
            enter.transition().duration(vars.draw.timing)
                .attr("opacity",1)
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Bind "edges" data to lines in the "edges" group
        //----------------------------------------------------------------------------
        var strokeBuckets = typeof vars.edges.size.value == "string"
            ? buckets(vars.edges.scale.domain(),4)
            : null
            , direction = vars.edges.arrows.direction.value

        var line_data = edges.filter(function(l){

            if (!l.d3plus) l.d3plus = {}

            l.d3plus.id = "edge_"+l[vars.edges.source][vars.id.value]+"_"+l[vars.edges.target][vars.id.value]

            if ( l.d3plus.spline !== true ) {

                if (strokeBuckets) {
                    var size = l[vars.edges.size.value]
                    l.d3plus.bucket = size < strokeBuckets[1] ? 0
                        : size < strokeBuckets[2] ? 1 : 2
                    var marker = markerSize[l.d3plus.bucket]*.85/scale
                }
                else {
                    delete l.d3plus.bucket
                    var marker = markerSize*.85/scale
                }

                var source = l[vars.edges.source]
                    , target = l[vars.edges.target]

                if (!source.d3plus || !target.d3plus) return false

                var sourceAngle = Math.atan2( source.d3plus.y - target.d3plus.y
                    , source.d3plus.x - target.d3plus.x )
                    , targetAngle = Math.atan2( target.d3plus.y - source.d3plus.y
                    , target.d3plus.x - source.d3plus.x )
                    , sourceRadius = direction == "source" && vars.edges.arrows.value
                    ? source.d3plus.r + marker
                    : source.d3plus.r
                    , targetRadius = direction == "target" && vars.edges.arrows.value
                    ? target.d3plus.r + marker
                    : target.d3plus.r
                    , sourceOffset = offset( sourceAngle
                    , sourceRadius
                    , vars.shape.value )
                    , targetOffset = offset( targetAngle
                    , targetRadius
                    , vars.shape.value )

                if (!("edges" in source.d3plus)) source.d3plus.edges = {}
                source.d3plus.edges[target[vars.id.value]] = {
                    "x": source.d3plus.x - sourceOffset.x,
                    "y": source.d3plus.y - sourceOffset.y
                }

                if (!("edges" in target.d3plus)) target.d3plus.edges = {}
                target.d3plus.edges[source[vars.id.value]] = {
                    "x": target.d3plus.x - targetOffset.x,
                    "y": target.d3plus.y - targetOffset.y
                }

                return true
            }

            return false

        })

        var lines = vars.g.edges.selectAll("g.d3plus_edge_line")
            .data(line_data,function(d){

                return d.d3plus.id

            })

        var spline_data = edges.filter(function(l){

            if (l.d3plus.spline) {

                if (strokeBuckets) {
                    var size = l[vars.edges.size.value]
                    l.d3plus.bucket = size < strokeBuckets[1] ? 0
                        : size < strokeBuckets[2] ? 1 : 2
                    var marker = markerSize[l.d3plus.bucket]*.85/scale
                }
                else {
                    delete l.d3plus.bucket
                    var marker = markerSize*.85/scale
                }

                var source = l[vars.edges.source]
                    , target = l[vars.edges.target]
                    , sourceEdge = source.d3plus.edges ? source.d3plus.edges[target[vars.id.value]] || {} : {}
                    , targetEdge = target.d3plus.edges ? target.d3plus.edges[source[vars.id.value]] || {} : {}
                    , sourceMod = vars.edges.arrows.value && direction == "source" ? marker : 0
                    , targetMod = vars.edges.arrows.value && direction == "target" ? marker : 0
                    , angleTweak = 0.1
                    , sourceTweak = source.d3plus.x > target.d3plus.x ? 1-angleTweak : 1+angleTweak
                    , targetTweak = source.d3plus.x > target.d3plus.x ? 1+angleTweak : 1-angleTweak
                    , sourceAngle = typeof sourceEdge.angle === "number" ? sourceEdge.angle
                    : Math.atan2( source.d3plus.y - target.d3plus.y
                    , source.d3plus.x - target.d3plus.x ) * sourceTweak
                    , sourceOffset = offset(sourceAngle, source.d3plus.r + sourceMod, vars.shape.value )
                    , targetAngle = typeof targetEdge.angle === "number" ? targetEdge.angle
                    : Math.atan2( target.d3plus.y - source.d3plus.y
                    , target.d3plus.x - source.d3plus.x ) * targetTweak
                    , targetOffset = offset(targetAngle, target.d3plus.r + targetMod, vars.shape.value )
                    , start = [source.d3plus.x-sourceOffset.x, source.d3plus.y-sourceOffset.y]
                    , startOffset = sourceEdge.offset ? offset(sourceAngle,sourceEdge.offset) : false
                    , startPoint = startOffset ? [start[0]-startOffset.x,start[1]-startOffset.y] : start
                    , end = [target.d3plus.x-targetOffset.x, target.d3plus.y-targetOffset.y]
                    , endOffset = targetEdge.offset ? offset(targetAngle,targetEdge.offset) : false
                    , endPoint = endOffset ? [end[0]-endOffset.x,end[1]-endOffset.y] : end
                    , xd = endPoint[0] - startPoint[0]
                    , yd = endPoint[1] - startPoint[1]
                    , sourceDistance = typeof sourceEdge.radius === "number" ? sourceEdge.radius : Math.sqrt(xd*xd+yd*yd)/4
                    , targetDistance = typeof targetEdge.radius === "number" ? targetEdge.radius : Math.sqrt(xd*xd+yd*yd)/4
                    , startAnchor = offset(sourceAngle,sourceDistance-source.d3plus.r-sourceMod*2)
                    , endAnchor = offset(targetAngle,targetDistance-target.d3plus.r-targetMod*2)

                l.d3plus.spline = [ start, end ]
                var testAngle = Math.abs(Math.atan2( source.d3plus.y - target.d3plus.y
                    , source.d3plus.x - target.d3plus.x )).toFixed(5)
                    , testStart = Math.abs(sourceAngle).toFixed(5)
                    , testEnd   = Math.abs(targetAngle - Math.PI).toFixed(5)

                if (testStart !== testEnd || [testStart,testEnd].indexOf(testAngle) < 0) {

                    l.d3plus.spline.splice(1,0,[startPoint[0]-startAnchor.x,startPoint[1]-startAnchor.y],
                        [endPoint[0]-endAnchor.x,endPoint[1]-endAnchor.y])

                    if (startOffset) l.d3plus.spline.splice(1,0,startPoint)
                    if (endOffset) l.d3plus.spline.splice(l.d3plus.spline.length-1,0,endPoint)

                }

                return true

            }

            return false

        })

        var splines = vars.g.edges.selectAll("g.d3plus_edge_path")
            .data(spline_data,function(d){

                return d.d3plus.id

            })

        if (vars.draw.timing) {

            lines.exit().transition().duration(vars.draw.timing)
                .attr("opacity",0)
                .remove()

            splines.exit().transition().duration(vars.draw.timing)
                .attr("opacity",0)
                .remove()

            lines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .transition().duration(vars.draw.timing/2)
                .attr("opacity",0)
                .remove()

            splines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .transition().duration(vars.draw.timing/2)
                .attr("opacity",0)
                .remove()

            lines.selectAll("line")
                .data(function(d){ return [d] })
                .transition().duration(vars.draw.timing)
                .call(line)
                .call(style)
                .each("end",label)

            splines.selectAll("path")
                .data(function(d){ return [d] })
                .transition().duration(vars.draw.timing)
                .call(spline)
                .call(style)
                .each("end",label)

            lines.enter().append("g")
                .attr("class","d3plus_edge_line")
                .append("line")
                .call(line)
                .call(init)
                .transition().duration(vars.draw.timing)
                .call(style)
                .each("end",label)

            splines.enter().append("g")
                .attr("class","d3plus_edge_path")
                .append("path")
                .call(spline)
                .call(init)
                .transition().duration(vars.draw.timing)
                .call(style)
                .each("end",label)

        }
        else {

            lines.exit().remove()

            splines.exit().remove()

            lines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .remove()

            splines.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .remove()

            lines.selectAll("line")
                .data(function(d){ return [d] })
                .call(line)
                .call(style)
                .call(label)

            splines.selectAll("path")
                .data(function(d){ return [d] })
                .call(spline)
                .call(style)
                .call(label)

            lines.enter().append("g")
                .attr("class","d3plus_edge_line")
                .append("line")
                .call(line)
                .call(init)
                .call(style)
                .call(label)

            splines.enter().append("g")
                .attr("class","d3plus_edge_path")
                .append("path")
                .call(spline)
                .call(init)
                .call(style)
                .call(label)

        }

    }

},{"../../../geom/offset.coffee":162,"../../../util/buckets.coffee":206}],229:[function(require,module,exports){
    var copy       = require("../../../util/copy.coffee"),
        fetchColor = require("../../../core/fetch/color.coffee"),
        fetchValue = require("../../../core/fetch/value.coffee"),
        segments   = require("./segments.coffee"),
        shapeStyle = require("./style.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // The position and size of each rectangle on enter and exit.
        //----------------------------------------------------------------------------
        function init(nodes) {

            nodes
                .attr("x",0)
                .attr("y",0)
                .attr("width",0)
                .attr("height",0);

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // The position and size of each rectangle on update.
        //----------------------------------------------------------------------------
        function update(nodes,mod) {
            if (!mod) mod = 0;
            nodes
                .attr("x",function(d){
                    var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                    return (-w/2)-(mod/2);
                })
                .attr("y",function(d){
                    var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                    return (-h/2)-(mod/2);
                })
                .attr("width",function(d){
                    var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                    return w+mod;
                })
                .attr("height",function(d){
                    var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                    return h+mod;
                })
                .attr("rx",function(d){
                    var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                    var rounded = ["circle","donut"].indexOf(vars.shape.value) >= 0;
                    return rounded ? (w+mod)/2 : 0;
                })
                .attr("ry",function(d){
                    var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                    var rounded = ["circle","donut"].indexOf(vars.shape.value) >= 0;
                    return rounded ? (h+mod)/2 : 0;
                })
                .attr("shape-rendering",function(d){
                    if (["square"].indexOf(vars.shape.value) >= 0) {
                        return vars.shape.rendering.value;
                    }
                    else {
                        return "auto";
                    }
                });
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // In order to correctly animate each donut's size and arcs, we need to store
        // it's previous values in a lookup object that does not get destroyed when
        // redrawing the visualization.
        //----------------------------------------------------------------------------
        if (!vars.arcs) {
            vars.arcs = {
                "donut": {},
                "active": {},
                "temp": {}
            };
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // This is the main arc function that determines what values to use for each
        // arc angle and radius.
        //----------------------------------------------------------------------------
        var arc = d3.svg.arc()
            .startAngle(0)
            .endAngle(function(d){
                var a = vars.arcs[d.d3plus.shape][d.d3plus.id].a;
                return a > Math.PI*2 ? Math.PI*2 : a;
            })
            .innerRadius(function(d){
                if (!d.d3plus.static && vars.shape.value === "donut") {
                    var r = vars.arcs[d.d3plus.shape][d.d3plus.id].r;
                    return r * vars.data.donut.size;
                }
                else {
                    return 0;
                }
            })
            .outerRadius(function(d){
                var r = vars.arcs[d.d3plus.shape][d.d3plus.id].r;
                return vars.shape.value === "donut" ? r : r*2;
            });

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // This is the main "arcTween" function where all of the animation happens
        // for each arc.
        //----------------------------------------------------------------------------
        function size(path,mod,rad,ang) {
            if (!mod) mod = 0;
            if (typeof rad != "number") rad = undefined;
            if (typeof ang != "number") ang = undefined;
            path.attrTween("d", function(d){
                if (rad === undefined) var r = d.d3plus.r ? d.d3plus.r : d3.max([d.d3plus.width,d.d3plus.height]);
                else var r = rad;
                if (ang === undefined) var a = d.d3plus.segments[d.d3plus.shape];
                else var a = ang;
                if (!vars.arcs[d.d3plus.shape][d.d3plus.id]) {
                    vars.arcs[d.d3plus.shape][d.d3plus.id] = {"r": 0};
                    vars.arcs[d.d3plus.shape][d.d3plus.id].a = d.d3plus.shape === "donut" ? Math.PI * 2 : 0;
                }
                var radius = d3.interpolate(vars.arcs[d.d3plus.shape][d.d3plus.id].r,r+mod),
                    angle = d3.interpolate(vars.arcs[d.d3plus.shape][d.d3plus.id].a,a);

                return function(t) {
                    vars.arcs[d.d3plus.shape][d.d3plus.id].r = radius(t);
                    vars.arcs[d.d3plus.shape][d.d3plus.id].a = angle(t);
                    return arc(d);
                };
            });
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check each data point for active and temp data
        //----------------------------------------------------------------------------
        selection.each(function(d){

            var active = segments(vars, d, "active"),
                temp  = segments(vars, d, "temp"),
                total = segments(vars, d, "total"),
                group = d3.select(this),
                color = fetchColor(vars,d);

            var fill_data = [], hatch_data = [];

            if (total && vars.types[vars.type.value].fill) {

                if (temp) {
                    var c = copy(d);
                    c.d3plus.shape = "temp";
                    fill_data.push(c);
                    hatch_data = ["temp"];
                }

                if (active && (active < total || temp)) {
                    var c = copy(d);
                    c.d3plus.shape = "active";
                    fill_data.push(c);
                }

            }

            function hatch_lines(l) {
                l
                    .attr("stroke",color)
                    .attr("stroke-width",1)
                    .attr("shape-rendering",vars.shape.rendering.value);
            }

            var pattern = vars.defs.selectAll("pattern#d3plus_hatch_"+d.d3plus.id)
                .data(hatch_data);

            if (vars.draw.timing) {

                pattern.selectAll("rect")
                    .transition().duration(vars.draw.timing)
                    .style("fill",color);

                pattern.selectAll("line")
                    .transition().duration(vars.draw.timing)
                    .style("stroke",color);

            }
            else {

                pattern.selectAll("rect").style("fill",color);

                pattern.selectAll("line").style("stroke",color);

            }

            var pattern_enter = pattern.enter().append("pattern")
                .attr("id","d3plus_hatch_"+d.d3plus.id)
                .attr("patternUnits","userSpaceOnUse")
                .attr("x","0")
                .attr("y","0")
                .attr("width","10")
                .attr("height","10")
                .append("g");

            pattern_enter.append("rect")
                .attr("x","0")
                .attr("y","0")
                .attr("width","10")
                .attr("height","10")
                .attr("fill",color)
                .attr("fill-opacity",0.25);

            pattern_enter.append("line")
                .attr("x1","0")
                .attr("x2","10")
                .attr("y1","0")
                .attr("y2","10")
                .call(hatch_lines);

            pattern_enter.append("line")
                .attr("x1","-1")
                .attr("x2","1")
                .attr("y1","9")
                .attr("y2","11")
                .call(hatch_lines);

            pattern_enter.append("line")
                .attr("x1","9")
                .attr("x2","11")
                .attr("y1","-1")
                .attr("y2","1")
                .call(hatch_lines);

            var clip_data = fill_data.length ? [d] : [];

            var clip = group.selectAll("#d3plus_clip_"+d.d3plus.id)
                .data(clip_data);

            clip.enter().insert("clipPath",".d3plus_mouse")
                .attr("id","d3plus_clip_"+d.d3plus.id)
                .append("rect")
                .attr("class","d3plus_clipping")
                .call(init);

            if (vars.draw.timing) {

                clip.selectAll("rect").transition().duration(vars.draw.timing)
                    .call(update);

                clip.exit().transition().delay(vars.draw.timing)
                    .remove();

            }
            else {

                clip.selectAll("rect").call(update);

                clip.exit().remove();

            }

            var fills = group.selectAll("path.d3plus_fill")
                .data(fill_data);

            fills.transition().duration(vars.draw.timing)
                .call(shapeStyle,vars)
                .call(size);

            fills.enter().insert("path","rect.d3plus_mouse")
                .attr("class","d3plus_fill")
                .attr("clip-path","url(#d3plus_clip_"+d.d3plus.id+")")
                .transition().duration(0)
                .call(shapeStyle,vars)
                .call(size,0,undefined,0)
                .transition().duration(vars.draw.timing)
                .call(size)
                .call(shapeStyle,vars);

            fills.exit().transition().duration(vars.draw.timing)
                .call(size,0,undefined,0)
                .remove();

        });

    };

},{"../../../core/fetch/color.coffee":65,"../../../core/fetch/value.coffee":69,"../../../util/copy.coffee":209,"./segments.coffee":235,"./style.coffee":236}],230:[function(require,module,exports){
    var copy       = require("../../../util/copy.coffee"),
        fetchText  = require("../../../core/fetch/text.js"),
        fetchValue = require("../../../core/fetch/value.coffee"),
        mix        = require("../../../color/mix.coffee"),
        print      = require("../../../core/console/print.coffee"),
        rtl        = require("../../../client/rtl.coffee"),
        segments   = require("./segments.coffee"),
        shapeColor = require("./color.coffee"),
        stringList = require("../../../string/list.coffee"),
        textColor  = require("../../../color/text.coffee"),
        textWrap   = require("../../../textwrap/textwrap.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "labels" using svg:text and d3plus.textwrap
//------------------------------------------------------------------------------
    module.exports = function( vars , group ) {

        var scale = vars.types[vars.type.value].zoom ? vars.zoom.behavior.scaleExtent() : [1,1],
            selection = vars.g[ group ].selectAll("g");

        var opacity = function(elem) {

            elem
                .attr("opacity",function(d){
                    // if (vars.draw.timing) return 1;
                    var size = parseFloat(d3.select(this).attr("font-size"),10);
                    d.visible = size * (vars.zoom.scale/scale[1]) >= 2;
                    return d.visible ? 1 : 0;
                });

        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Label Exiting
        //----------------------------------------------------------------------------
        var remove = function(text) {

            if (vars.draw.timing) {
                text
                    .transition().duration(vars.draw.timing)
                    .attr("opacity",0)
                    .remove();
            }
            else {
                text.remove();
            }

        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Label Styling
        //----------------------------------------------------------------------------
        var style = function(text) {

            var salign = vars.labels.valign.value === "bottom" ? "top" : "bottom";

            text
                .attr("font-weight",vars.labels.font.weight)
                .attr("font-family",vars.labels.font.family.value)
                .attr("stroke", "none")
                .attr("pointer-events",function(t){
                    return t.mouse ? "auto": "none";
                })
                .attr("fill", function(t){

                    if ( t.color ) return t.color;

                    var color = shapeColor(t.parent,vars),
                        legible = textColor(color),
                        opacity = t.text ? 0.15 : 1;

                    return mix( color , legible , 0.2 , opacity );

                })
                .each(function(t){

                    if (t.resize instanceof Array) {
                        var min = t.resize[0], max = t.resize[1];
                    }

                    var size = t.resize, resize = true;

                    if (t.text) {

                        if ( !(size instanceof Array) ) {
                            size = [9, 50];
                            resize = t.resize;
                        }

                        var y = t.y - t.h*scale[1]/2 + t.padding/2;
                        if (salign === "bottom") y += (t.h * scale[1])/2;

                        textWrap()
                            .align("center")
                            .container(d3.select(this))
                            .height((t.h * scale[1])/2)
                            .padding(t.padding/2)
                            .resize(resize)
                            .size(size)
                            .text(vars.format.value(t.text*100,{"key": "share", "vars": vars}))
                            .width(t.w * scale[1])
                            .valign(salign)
                            .x(t.x - t.w*scale[1]/2 + t.padding/2)
                            .y(y)
                            .draw();

                    }
                    else {

                        if ( !(t.resize instanceof Array) ) {
                            size = [7, 40*(scale[1]/scale[0])];
                            resize = t.resize;
                        }

                        var yOffset = vars.labels.valign.value === "bottom" ? t.share : 0;

                        textWrap()
                            .align(t.anchor || vars.labels.align.value)
                            .container( d3.select(this) )
                            .height(t.h * scale[1] - t.share)
                            .padding(t.padding/2)
                            .resize( resize )
                            .size( size )
                            .shape(t.shape || "square")
                            .text( t.names )
                            .valign(vars.labels.valign.value)
                            .width(t.w * scale[1])
                            .x(t.x - t.w*scale[1]/2 + t.padding/2)
                            .y(t.y - t.h*scale[1]/2 + t.padding/2 + yOffset)
                            .draw();

                    }

                })
                .attr("transform",function(t){
                    var translate = d3.select(this).attr("transform") || "";
                    var a = t.angle || 0,
                        x = t.translate && t.translate.x ? t.translate.x : 0,
                        y = t.translate && t.translate.y ? t.translate.y : 0;

                    if (translate.length) {
                        translate = translate.split(")").slice(-3).join(")");
                    }
                    return "rotate("+a+","+x+","+y+")scale("+1/scale[1]+")translate("+(t.x*scale[1]-t.x)+","+(t.y*scale[1]-t.y)+")" + translate;

                });

        };

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Loop through each selection and analyze the labels
        //----------------------------------------------------------------------------
        if (group === "edges" || vars.labels.value) {

            if ( vars.dev.value ) {
                var timerString = "drawing " + group + " labels";
                print.time( timerString );
            }

            selection.each(function(d){

                var disabled = d.d3plus && "label" in d.d3plus && !d.d3plus.label,
                    label = d.d3plus_label || null,
                    share = d.d3plus_share,
                    names = d.d3plus.text ? d.d3plus.text :
                        label && label.names ? label.names :
                            vars.labels.text.value ?
                                fetchValue(vars, d, vars.labels.text.value) :
                                fetchText(vars,d),
                    group = label && "group" in label ? label.group : d3.select(this),
                    share_size = 0,
                    fill = vars.types[vars.type.value].fill;

                if (!(names instanceof Array)) names = [names];

                if (label) {

                    if (["line","area"].indexOf(vars.shape.value) >= 0) {
                        var background = true;
                    }
                    else if (d && "d3plus" in d) {
                        var active = segments(vars, d, "active"),
                            temp   = segments(vars, d, "temp"),
                            total  = segments(vars, d, "total"),
                            background = (!temp && !active) || (active >= total) || (!active && temp >= total);
                    }

                }

                if (!disabled && ((label && label.force) || background || !fill)) {

                    if (share && d.d3plus.share && share.w-vars.labels.padding*2 >= 10 && share.h-vars.labels.padding*2 >= 10 && vars.labels.valign.value != "middle") {

                        share.resize = vars.labels.resize.value === false ? false :
                            share && "resize" in share ? share.resize : true;

                        share.padding = vars.labels.padding;

                        share.text = d.d3plus.share;
                        share.parent = d;

                        var text = group.selectAll("text#d3plus_share_"+d.d3plus.id)
                            .data([share],function(t){
                                return t.w+""+t.h+""+t.text;
                            });

                        if (vars.draw.timing && vars.zoom.scale === 1) {

                            text
                                .transition().duration(vars.draw.timing/2)
                                .call(style);

                            text.enter().append("text")
                                .attr("id","d3plus_share_"+d.d3plus.id)
                                .attr("class","d3plus_share")
                                .attr("opacity",0)
                                .call(style)
                                .transition().duration(vars.draw.timing/2)
                                .delay(vars.draw.timing/2)
                                .attr("opacity",1);

                        }
                        else {

                            text
                                .attr("opacity",1)
                                .call(style);

                            text.enter().append("text")
                                .attr("id","d3plus_share_"+d.d3plus.id)
                                .attr("class","d3plus_share")
                                .attr("opacity",1)
                                .call(style);

                        }

                        share_size = text.node().getBBox().height + vars.labels.padding;

                        text.exit().call(remove);

                    }
                    else {
                        group.selectAll("text.d3plus_share")
                            .call(remove);
                    }

                    if (label) {

                        label.resize = vars.labels.resize.value === false ? false :
                            label && "resize" in label ? label.resize : true;

                        label.padding = typeof label.padding === "number" ? label.padding : vars.labels.padding;

                    }

                    if (label && label.w*scale[1]-label.padding >= 20 && label.h*scale[1]-label.padding >= 10 && names.length) {

                        var and = vars.format.locale.value.ui.and,
                            more = vars.format.locale.value.ui.more;

                        for (var i = 0; i < names.length; i++) {
                            if (names[i] instanceof Array) {
                                names[i] = stringList(names[i],and,3,more);
                            }
                        }

                        label.names = names;

                        label.share = share_size;
                        label.parent = d;

                        var text = group.selectAll("text#d3plus_label_"+d.d3plus.id)
                            .data([label],function(t){
                                if (!t) return false;
                                return t.w+"_"+t.h+"_"+t.x+"_"+t.y+"_"+t.names.join("_");
                            }), fontSize = label.resize ? undefined :
                            (vars.labels.font.size * scale[0]) + "px";

                        if (vars.draw.timing && vars.zoom.scale === 1) {

                            text
                                .transition().duration(vars.draw.timing/2)
                                .call(style)
                                .call(opacity);

                            text.enter().append("text")
                                .attr("font-size",fontSize)
                                .attr("id","d3plus_label_"+d.d3plus.id)
                                .attr("class","d3plus_label")
                                .attr("opacity",0)
                                .call(style)
                                .transition().duration(vars.draw.timing/2)
                                .delay(vars.draw.timing/2)
                                .call(opacity);

                        }
                        else {

                            text
                                .attr("opacity",1)
                                .call(style)
                                .call(opacity);

                            text.enter().append("text")
                                .attr("font-size",fontSize)
                                .attr("id","d3plus_label_"+d.d3plus.id)
                                .attr("class","d3plus_label")
                                .call(style)
                                .call(opacity);

                        }

                        text.exit().call(remove);

                        if (text.size() === 0 || text.selectAll("tspan").size() === 0) {
                            delete d.d3plus_label;
                            d3.select(this).selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                                .call(remove);
                            vars.g.labels.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                                .call(remove);
                        }
                        else {

                            if (label.background) {

                                var background_data = ["background"];

                                var box = text.node().getBBox();
                                var bounds = {
                                    "height": box.height,
                                    "width": box.width,
                                    "x": box.x,
                                    "y": box.y
                                };
                                bounds.width += vars.labels.padding*scale[0];
                                bounds.height += vars.labels.padding*scale[0];
                                bounds.x -= (vars.labels.padding*scale[0])/2;
                                bounds.y -= (vars.labels.padding*scale[0])/2;
                                var y = text.attr("transform").match(/translate\(([^a-z]+)\)/gi)[0];
                                y = y.replace(/([^a-z])\s([^a-z])/gi, "$1,$2");
                                y = y.split(",");
                                if (y.length > 1) {
                                    y = y[y.length - 1];
                                    y = y.substring(0, y.length - 1);
                                    bounds.y += y;
                                }

                            }
                            else {
                                var background_data = [],
                                    bounds = {};
                            }

                            var bg = group.selectAll("rect#d3plus_label_bg_"+d.d3plus.id)
                                    .data(background_data),
                                bg_opacity = typeof label.background === "number" ?
                                    label.background :
                                    typeof label.background === "string" ? 1 : 0.6;

                            function bg_style(elem) {

                                var color = typeof label.background === "string" ? label.background : vars.background.value === "none"
                                    ? "#ffffff" : vars.background.value
                                    , fill = typeof label.background === "string"
                                    ? label.background : color
                                    , transform = text.attr("transform").split(")");
                                transform.pop();
                                transform.pop();
                                transform.push("");
                                transform = transform.join(")");

                                elem
                                    .attr("fill",fill)
                                    .attr(bounds)
                                    .attr("transform",transform);

                            }

                            if (vars.draw.timing) {

                                bg.exit().transition().duration(vars.draw.timing)
                                    .attr("opacity",0)
                                    .remove();

                                bg.transition().duration(vars.draw.timing)
                                    .attr("opacity",bg_opacity)
                                    .call(bg_style);

                                bg.enter().insert("rect",".d3plus_label")
                                    .attr("id","d3plus_label_bg_"+d.d3plus.id)
                                    .attr("class","d3plus_label_bg")
                                    .attr("opacity",0)
                                    .call(bg_style)
                                    .transition().duration(vars.draw.timing)
                                    .attr("opacity",bg_opacity);

                            }
                            else {

                                bg.exit().remove();

                                bg.enter().insert("rect",".d3plus_label")
                                    .attr("id","d3plus_label_bg_"+d.d3plus.id)
                                    .attr("class","d3plus_label_bg");

                                bg.attr("opacity",bg_opacity)
                                    .call(bg_style);

                            }

                        }

                    }
                    else {
                        delete d.d3plus_label;
                        d3.select(this).selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                            .call(remove);
                        vars.g.labels.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                            .call(remove);
                    }

                }
                else {
                    delete d.d3plus_label;
                    d3.select(this).selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                        .call(remove);
                    vars.g.labels.selectAll("text#d3plus_label_"+d.d3plus.id+", rect#d3plus_label_bg_"+d.d3plus.id)
                        .call(remove);
                }
            });

            if ( vars.dev.value ) print.timeEnd( timerString );

        }
        else {

            if ( vars.dev.value ) {
                var timerString = "removing " + group + " labels";
                print.time( timerString );
            }

            selection.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .call(remove);

            vars.g.labels.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .call(remove);

            if ( vars.dev.value ) print.timeEnd( timerString );

        }
    }

},{"../../../client/rtl.coffee":42,"../../../color/mix.coffee":48,"../../../color/text.coffee":52,"../../../core/console/print.coffee":54,"../../../core/fetch/text.js":68,"../../../core/fetch/value.coffee":69,"../../../string/list.coffee":176,"../../../textwrap/textwrap.coffee":202,"../../../util/copy.coffee":209,"./color.coffee":222,"./segments.coffee":235}],231:[function(require,module,exports){
    var copy       = require("../../../util/copy.coffee"),
        closest    = require("../../../util/closest.coffee"),
        events     = require("../../../client/pointer.coffee"),
        shapeStyle = require("./style.coffee"),
        fetchValue = require("../../../core/fetch/value.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "line" shapes using svg:line
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // The D3 line function that determines what variables to use for x and y
        // positioning, as well as line interpolation defined by the user.
        //----------------------------------------------------------------------------
        var line = d3.svg.line()
            .x(function(d){ return d.d3plus.x; })
            .y(function(d){ return d.d3plus.y; })
            .interpolate(vars.shape.interpolate.value);

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Divide each line into it's segments. We do this so that there can be gaps
        // in the line and mouseover.
        //
        // Then, create new data group from values to become small nodes at each
        // point on the line.
        //----------------------------------------------------------------------------

        var stroke = vars.size.value || vars.data.stroke.width * 2,
            discrete = vars[vars.axes.discrete],
            hitarea = function(l){
                var s = stroke;
                if (s.constructor !== Number) {
                    var v = fetchValue(vars, l, stroke);
                    if (v && v.length) s = d3.max(v);
                    else s = vars.data.stroke.width;
                }
                return s < 15 ? 15 : s;
            };

        var ticks = discrete.ticks.values.map(function(d){
            if (d.constructor === Date) return d.getTime();
            else return d;
        });

        selection.each(function(d){

            var lastIndex = false,
                segments = [],
                nodes = [],
                temp = copy(d),
                group = d3.select(this);

            temp.values = [];
            temp.segment_key = temp.key;
            d.values.forEach(function(v,i,arr){

                var k = fetchValue(vars, v, discrete.value);

                if (k.constructor === Date) k = k.getTime();

                var index = ticks.indexOf(closest(ticks,k));

                if (lastIndex === false || lastIndex === index - 1) {
                    temp.values.push(v);
                    temp.segment_key += "_" + index;
                }
                else {
                    if (temp.values.length > 1) {
                        segments.push(temp);
                    }
                    else {
                        nodes.push(temp.values[0]);
                    }
                    temp = copy(d);
                    temp.values = [v];
                }

                if ( i === arr.length - 1 ) {
                    if (temp.values.length > 1) {
                        segments.push(temp);
                    }
                    else {
                        nodes.push(temp.values[0]);
                    }
                }

                lastIndex = index;

            });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Bind segment data to "paths"
            //--------------------------------------------------------------------------
            var paths = group.selectAll("path.d3plus_line")
                .data(segments, function(d){
                    if (!d.d3plus) d.d3plus = {};
                    d.d3plus.shape = "line";
                    return d.segment_key;
                });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Bind node data to "rects"
            //--------------------------------------------------------------------------
            var rects = group.selectAll("rect.d3plus_anchor")
                .data(nodes, function(d){
                    if (!d.d3plus) d.d3plus = {};
                    d.d3plus.r = vars.data.stroke.width * 2;
                    return d.d3plus.id;
                });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // "paths" and "rects" Enter/Update
            //--------------------------------------------------------------------------
            if (vars.draw.timing) {

                paths.exit().transition().duration(vars.draw.timing)
                    .attr("opacity", 0)
                    .remove();

                paths.transition().duration(vars.draw.timing)
                    .attr("d",function(d){ return line(d.values); })
                    .call(shapeStyle,vars);

                paths.enter().append("path")
                    .attr("class","d3plus_line")
                    .style("stroke-linecap","round")
                    .attr("d", function(d){ return line(d.values); })
                    .call(shapeStyle,vars)
                    .attr("opacity", 0)
                    .transition().duration(vars.draw.timing)
                    .attr("opacity", 1);

                rects.enter().append("rect")
                    .attr("class","d3plus_anchor")
                    .attr("id",function(d){ return d.d3plus.id; })
                    .call(init)
                    .call(shapeStyle,vars);

                rects.transition().duration(vars.draw.timing)
                    .call(update)
                    .call(shapeStyle,vars);

                rects.exit().transition().duration(vars.draw.timing)
                    .call(init)
                    .remove();

            }
            else {

                paths.exit().remove();

                paths.enter().append("path")
                    .attr("class","d3plus_line")
                    .style("stroke-linecap","round");

                paths
                    .attr("d",function(d){ return line(d.values); })
                    .call(shapeStyle,vars);

                rects.enter().append("rect")
                    .attr("class","d3plus_anchor")
                    .attr("id",function(d){
                        return d.d3plus.id;
                    });

                rects.exit().remove();

                rects.call(update)
                    .call(shapeStyle,vars);

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Create mouse event lines
            //--------------------------------------------------------------------------
            var mouse = group.selectAll("path.d3plus_mouse")
                .data(segments, function(d){
                    return d.segment_key;
                });

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Mouse "paths" Enter
            //--------------------------------------------------------------------------
            mouse.enter().append("path")
                .attr("class","d3plus_mouse")
                .attr("d", function(l){ return line(l.values); })
                .style("stroke","black")
                .style("stroke-width",hitarea)
                .style("fill","none")
                .style("stroke-linecap","round")
                .attr("opacity",0);

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Mouse "paths" Update
            //--------------------------------------------------------------------------
            mouse
                .on(events.over,function(m){
                    if (!vars.draw.frozen) mouseStyle(vars, this, stroke, 2);
                })
                .on(events.out,function(d){
                    if (!vars.draw.frozen) mouseStyle(vars, this, stroke, 0);
                });

            if (vars.draw.timing) {

                mouse.transition().duration(vars.draw.timing)
                    .attr("d",function(l){ return line(l.values); })
                    .style("stroke-width",hitarea);

            }
            else {

                mouse.attr("d",function(l){ return line(l.values); })
                    .style("stroke-width",hitarea);

            }

            //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            // Mouse "paths" Exit
            //--------------------------------------------------------------------------
            mouse.exit().remove();

        });

    };

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// The position and size of each anchor point on enter and exit.
//----------------------------------------------------------------------------
    function init(n) {

        n
            .attr("x",function(d){
                return d.d3plus.x;
            })
            .attr("y",function(d){
                return d.d3plus.y;
            })
            .attr("width",0)
            .attr("height",0);

    }

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// The position and size of each anchor point on update.
//----------------------------------------------------------------------------
    function update(n,mod) {

        if (mod === undefined) mod = 0;

        n
            .attr("x",function(d){
                var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                return d.d3plus.x - ((w/2)+(mod/2));
            })
            .attr("y",function(d){
                var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                return d.d3plus.y - ((h/2)+(mod/2));
            })
            .attr("width",function(d){
                var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                return w+mod;
            })
            .attr("height",function(d){
                var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                return h+mod;
            })
            .attr("rx",function(d){
                var w = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.width;
                return (w+mod)/2;
            })
            .attr("ry",function(d){
                var h = d.d3plus.r ? d.d3plus.r*2 : d.d3plus.height;
                return (h+mod)/2;
            });

    }

    function mouseStyle(vars, elem, stroke, mod) {

        var timing = vars.draw.timing ? vars.timing.mouseevents : 0;
        if (mod === undefined) mod = 0;

        if (timing) {

            d3.select(elem.parentNode).selectAll("path.d3plus_line")
                .transition().duration(timing)
                .style("stroke-width",function(l){
                    var s = stroke;
                    if (s.constructor !== Number) {
                        var v = fetchValue(vars, l, stroke);
                        if (v && v.length) s = d3.max(v);
                        else s = vars.data.stroke.width;
                    }
                    return s + mod;
                });

            d3.select(elem.parentNode).selectAll("rect")
                .transition().duration(timing)
                .style("stroke-width",function(l){
                    var s = stroke;
                    if (s.constructor !== Number) {
                        var v = fetchValue(vars, l, stroke);
                        if (v && v.length) s = d3.max(v);
                        else s = vars.data.stroke.width;
                    }
                    return s;
                })
                .call(update, mod);

        }
        else {

            d3.select(elem.parentNode).selectAll("path.d3plus_line")
                .style("stroke-width",function(l){
                    var s = stroke;
                    if (s.constructor !== Number) {
                        var v = fetchValue(vars, l, stroke);
                        if (v && v.length) s = d3.max(v);
                        else s = vars.data.stroke.width;
                    }
                    return s + mod;
                });

            d3.select(elem.parentNode).selectAll("rect")
                .style("stroke-width",function(l){
                    var s = stroke;
                    if (s.constructor !== Number) {
                        var v = fetchValue(vars, l, stroke);
                        if (v && v.length) s = d3.max(v);
                        else s = vars.data.stroke.width;
                    }
                    return s;
                })
                .call(update, mod);
        }

    }

},{"../../../client/pointer.coffee":40,"../../../core/fetch/value.coffee":69,"../../../util/closest.coffee":208,"../../../util/copy.coffee":209,"./style.coffee":236}],232:[function(require,module,exports){
    module.exports = function(vars) {

        var edges = vars.returned.edges || [];

        var paths = vars.g.edges.selectAll("g.d3plus_edge_path")
            .data(edges, function(d){
                d.d3plus.id = "path_" + d[vars.edges.source][vars.id.value] + "_" + d[vars.edges.target][vars.id.value];
                return d.d3plus.id;
            });

        function pathStyles(p) {
            p
                .attr("d", vars.edges.path)
                .style("stroke-width", function(d) {
                    return Math.max(1, d.dy);
                })
                .style("stroke", "#ddd")
                .style("fill", "none")
                .attr("transform", function(d){
                    return "translate(" + d.d3plus.x + "," + d.d3plus.y + ")";
                });
        }

        if (vars.draw.timing) {

            paths.exit().transition().duration(vars.draw.timing)
                .attr("opacity",0)
                .remove();

            paths.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .transition().duration(vars.draw.timing/2)
                .attr("opacity",0)
                .remove();

            paths.selectAll("path")
                .data(function(d){ return [d] })
                .transition().duration(vars.draw.timing)
                .call(pathStyles);

            paths.enter().append("g")
                .attr("class","d3plus_edge_path")
                .append("path")
                .style("stroke-width", 0)
                .transition().duration(vars.draw.timing)
                .call(pathStyles);

        }
        else {

            paths.exit().remove();

            paths.selectAll("text.d3plus_label, rect.d3plus_label_bg")
                .remove();

            paths.selectAll("path")
                .data(function(d){ return [d] })
                .call(pathStyles);

            paths.enter().append("g")
                .attr("class","d3plus_edge_path")
                .append("path")
                .call(pathStyles);

        }

    }

},{}],233:[function(require,module,exports){
    var angles, interpolates, radii, shapeStyle;

    shapeStyle = require("./style.coffee");

    radii = {};

    angles = {};

    interpolates = {
        r: {},
        a: {}
    };

    module.exports = function(vars, selection, enter, exit) {
        var data, newRadial, nextLevel, radial, radialTween;
        nextLevel = vars.id.nesting[vars.depth.value + 1];
        radial = d3.svg.line.radial().interpolate("linear-closed").radius(function(d) {
            return d.d3plus.r;
        }).angle(function(d) {
            return d.d3plus.a;
        });
        data = function(d) {
            if (vars.labels.value) {
                if (d.d3plus.label) {
                    d.d3plus_label = d.d3plus.label;
                } else {
                    delete d.d3plus_label;
                }
            }
            return [d];
        };
        if (vars.draw.timing) {
            selection.each(function(d) {
                var c, j, len, ref, results;
                ref = d[nextLevel];
                results = [];
                for (j = 0, len = ref.length; j < len; j++) {
                    c = ref[j];
                    results.push(c.d3plus.id = c[vars.id.value] + "_" + c[nextLevel]);
                }
                return results;
            });
            newRadial = d3.svg.line.radial().interpolate("linear-closed").radius(function(d, i) {
                if (radii[d.d3plus.id] === void 0) {
                    radii[d.d3plus.id] = 0;
                }
                if (isNaN(radii[d.d3plus.id])) {
                    radii[d.d3plus.id] = d.d3plus.r;
                }
                return radii[d.d3plus.id];
            }).angle(function(d, i) {
                if (angles[d.d3plus.id] === void 0) {
                    angles[d.d3plus.id] = d.d3plus.a;
                }
                if (isNaN(angles[d.d3plus.id])) {
                    angles[d.d3plus.id] = d.d3plus.a;
                }
                return angles[d.d3plus.id];
            });
            radialTween = function(arcs, newRadius) {
                return arcs.attrTween("d", function(d) {
                    var a, c, i, j, len, r, ref;
                    ref = d[nextLevel];
                    for (i = j = 0, len = ref.length; j < len; i = ++j) {
                        c = ref[i];
                        a = c.d3plus.a;
                        if (newRadius === void 0) {
                            r = c.d3plus.r;
                        } else if (newRadius === 0) {
                            r = 0;
                        }
                        interpolates.a[c.d3plus.id] = d3.interpolate(angles[c.d3plus.id], a);
                        interpolates.r[c.d3plus.id] = d3.interpolate(radii[c.d3plus.id], r);
                    }
                    return function(t) {
                        var k, len1, ref1;
                        ref1 = d[nextLevel];
                        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
                            c = ref1[i];
                            angles[c.d3plus.id] = interpolates.a[c.d3plus.id](t);
                            radii[c.d3plus.id] = interpolates.r[c.d3plus.id](t);
                        }
                        return newRadial(d[nextLevel]);
                    };
                });
            };
            enter.append("path").attr("class", "d3plus_data").call(shapeStyle, vars).attr("d", function(d) {
                return newRadial(d[nextLevel]);
            });
            selection.selectAll("path.d3plus_data").data(data).transition().duration(vars.draw.timing).call(shapeStyle, vars).call(radialTween);
            exit.selectAll("path.d3plus_data").transition().duration(vars.draw.timing).call(radialTween, 0);
        } else {
            enter.append("path").attr("class", "d3plus_data");
            selection.selectAll("path.d3plus_data").data(data).call(shapeStyle, vars).attr("d", function(d) {
                return radial(d[nextLevel]);
            });
        }
    };


},{"./style.coffee":236}],234:[function(require,module,exports){
    var shapeStyle;

    shapeStyle = require("./style.coffee");

    module.exports = function(vars, selection, enter, exit) {
        var data, init, update;
        data = function(d) {
            var h, w;
            if (vars.labels.value && !d.d3plus.label) {
                w = (d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.width);
                h = (d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.height);
                d.d3plus_label = {
                    w: w,
                    h: h,
                    x: 0,
                    y: 0
                };
                d.d3plus_share = {
                    w: w,
                    h: h,
                    x: 0,
                    y: 0
                };
                d.d3plus_label.shape = (d.d3plus.shape === "circle" ? "circle" : "square");
            } else if (d.d3plus.label) {
                d.d3plus_label = d.d3plus.label;
            } else {
                delete d.d3plus_label;
            }
            return [d];
        };
        init = function(nodes) {
            return nodes.attr("x", function(d) {
                if (d.d3plus.init && "x" in d.d3plus.init) {
                    return d.d3plus.init.x;
                } else {
                    if (d.d3plus.init && "width" in d.d3plus.init) {
                        return -d.d3plus.width / 2;
                    } else {
                        return 0;
                    }
                }
            }).attr("y", function(d) {
                if (d.d3plus.init && "y" in d.d3plus.init) {
                    return d.d3plus.init.y;
                } else {
                    if (d.d3plus.init && "height" in d.d3plus.init) {
                        return -d.d3plus.height / 2;
                    } else {
                        return 0;
                    }
                }
            }).attr("width", function(d) {
                if (d.d3plus.init && "width" in d.d3plus.init) {
                    return d.d3plus.init.width;
                } else {
                    return 0;
                }
            }).attr("height", function(d) {
                if (d.d3plus.init && "height" in d.d3plus.init) {
                    return d.d3plus.init.height;
                } else {
                    return 0;
                }
            });
        };
        update = function(nodes) {
            return nodes.attr("x", function(d) {
                var w;
                w = d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.width;
                return -w / 2;
            }).attr("y", function(d) {
                var h;
                h = d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.height;
                return -h / 2;
            }).attr("width", function(d) {
                if (d.d3plus.r) {
                    return d.d3plus.r * 2;
                } else {
                    return d.d3plus.width;
                }
            }).attr("height", function(d) {
                if (d.d3plus.r) {
                    return d.d3plus.r * 2;
                } else {
                    return d.d3plus.height;
                }
            }).attr("rx", function(d) {
                var rounded, w;
                rounded = d.d3plus.shape === "circle";
                w = d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.width;
                if (rounded) {
                    return (w + 2) / 2;
                } else {
                    return 0;
                }
            }).attr("ry", function(d) {
                var h, rounded;
                rounded = d.d3plus.shape === "circle";
                h = d.d3plus.r ? d.d3plus.r * 2 : d.d3plus.height;
                if (rounded) {
                    return (h + 2) / 2;
                } else {
                    return 0;
                }
            }).attr("transform", function(d) {
                if ("rotate" in d.d3plus) {
                    return "rotate(" + d.d3plus.rotate + ")";
                } else {
                    return "";
                }
            }).attr("shape-rendering", function(d) {
                if (d.d3plus.shape === "square" && (!("rotate" in d.d3plus))) {
                    return vars.shape.rendering.value;
                } else {
                    return "auto";
                }
            });
        };
        if (vars.draw.timing) {
            enter.append("rect").attr("class", "d3plus_data").call(init).call(shapeStyle, vars);
            selection.selectAll("rect.d3plus_data").data(data).transition().duration(vars.draw.timing).call(update).call(shapeStyle, vars);
            return exit.selectAll("rect.d3plus_data").transition().duration(vars.draw.timing).call(init);
        } else {
            enter.append("rect").attr("class", "d3plus_data");
            return selection.selectAll("rect.d3plus_data").data(data).call(update).call(shapeStyle, vars);
        }
    };


},{"./style.coffee":236}],235:[function(require,module,exports){
    var fetchValue;

    fetchValue = require("../../../core/fetch/value.coffee");

    module.exports = function(vars, d, segment) {
        var ret;
        ret = vars[segment].value;
        if (ret) {
            if (segment in d.d3plus) {
                return d.d3plus[segment];
            } else {
                return fetchValue(vars, d, ret);
            }
        } else {
            return d.d3plus[segment];
        }
    };


},{"../../../core/fetch/value.coffee":69}],236:[function(require,module,exports){
    var color, ie, value;

    color = require("./color.coffee");

    ie = require("../../../client/ie.js");

    value = require("../../../core/fetch/value.coffee");

    module.exports = function(nodes, vars) {
        return nodes.attr("fill", function(d) {
            if (d.d3plus && d.d3plus.spline) {
                return "none";
            } else {
                return color(d, vars);
            }
        }).style("stroke", function(d) {
            var c;
            if (d.d3plus && d.d3plus.stroke) {
                return d.d3plus.stroke;
            } else {
                c = d.values ? color(d.values[0], vars) : color(d, vars, true);
                return d3.rgb(c).darker(0.6);
            }
        }).style("stroke-width", function(d) {
            var v;
            if (ie && vars.types[vars.type.value].zoom) {
                return 0;
            }
            if (d.d3plus.shape === "line" && vars.size.value) {
                if (vars.size.value.constructor === Number) {
                    return vars.size.value;
                }
                v = value(vars, d, vars.size.value);
                if (v && v.length) {
                    return d3.max(v);
                }
            }
            return vars.data.stroke.width;
        }).attr("opacity", vars.data.opacity).attr("vector-effect", "non-scaling-stroke");
    };


},{"../../../client/ie.js":39,"../../../core/fetch/value.coffee":69,"./color.coffee":222}],237:[function(require,module,exports){
    var shapeStyle  = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize check scale on enter and exit.
        //----------------------------------------------------------------------------
        function init(paths){
            paths.attr("d", d3.svg.symbol().type("triangle-down").size(10))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Change scale of check on update.
        //---------------------------------------------------------------------------
        function update(paths){
            paths.attr("d", d3.svg.symbol().type("triangle-down").size(function(d){
                var smaller_dim = Math.min(d.d3plus.width, d.d3plus.height);
                return d3.scale.pow().exponent(2)(smaller_dim/2);
            }))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .call(init)
            .call(shapeStyle,vars)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------
        selection.selectAll("path.d3plus_data")
            .data(function(d) {
                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .call(update)
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .call(update)
                .call(shapeStyle,vars)
        }

    }

},{"./style.coffee":236}],238:[function(require,module,exports){
    var shapeStyle  = require("./style.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws "square" and "circle" shapes using svg:rect
//------------------------------------------------------------------------------
    module.exports = function(vars,selection,enter,exit) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize check scale on enter and exit.
        //----------------------------------------------------------------------------
        function init(paths){
            paths.attr("d", d3.svg.symbol().type("triangle-up").size(10))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Change scale of check on update.
        //---------------------------------------------------------------------------
        function update(paths){
            paths.attr("d", d3.svg.symbol().type("triangle-up").size(function(d){
                var smaller_dim = Math.min(d.d3plus.width, d.d3plus.height);
                return d3.scale.pow().exponent(2)(smaller_dim/2);
            }))
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Enter
        //----------------------------------------------------------------------------
        enter.append("path").attr("class","d3plus_data")
            .call(init)
            .call(shapeStyle,vars)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // "paths" Update
        //----------------------------------------------------------------------------
        selection.selectAll("path.d3plus_data")
            .data(function(d) {
                return [d];
            })

        if (vars.draw.timing) {
            selection.selectAll("path.d3plus_data")
                .transition().duration(vars.draw.timing)
                .call(update)
                .call(shapeStyle,vars)
        }
        else {
            selection.selectAll("path.d3plus_data")
                .call(update)
                .call(shapeStyle,vars)
        }

    }

},{"./style.coffee":236}],239:[function(require,module,exports){
    module.exports = function(vars, selection, enter, exit) {
        var d, data, init, marker, orient, pos, position, size, style;
        data = function(d) {
            if (d.d3plus.text) {
                d.d3plus_label = {
                    w: size,
                    h: size,
                    x: 0,
                    y: 0,
                    background: "#fff",
                    resize: false,
                    angle: ["left", "right"].indexOf(d.d3plus.position) >= 0 ? 90 : 0
                };
            } else if (d.d3plus.label) {
                d.d3plus_label = d.d3plus.label;
            } else {
                delete d.d3plus_label;
            }
            return [d];
        };
        style = function(line) {
            return line.style("stroke-width", vars.data.stroke.width).style("stroke", "#444").attr("fill", "none").attr("shape-rendering", vars.shape.rendering.value);
        };
        init = function(line) {
            return line.attr("x1", 0).attr("x2", 0).attr("y1", 0).attr("y2", 0);
        };
        position = function(line) {
            return line.attr("x1", function(d) {
                var offset, w, x;
                if (["top", "bottom"].indexOf(d.d3plus.position) >= 0) {
                    return 0;
                } else {
                    offset = d.d3plus.offset || 0;
                    w = d.d3plus.width || 0;
                    x = offset < 0 ? -w : w;
                    return x + offset;
                }
            }).attr("x2", function(d) {
                if (["top", "bottom"].indexOf(d.d3plus.position) >= 0) {
                    return 0;
                } else {
                    return d.d3plus.offset || 0;
                }
            }).attr("y1", function(d) {
                var h, offset, y;
                if (["left", "right"].indexOf(d.d3plus.position) >= 0) {
                    return 0;
                } else {
                    offset = d.d3plus.offset || 0;
                    h = d.d3plus.height || 0;
                    y = offset < 0 ? -h : h;
                    return y + offset;
                }
            }).attr("y2", function(d) {
                if (["left", "right"].indexOf(d.d3plus.position) >= 0) {
                    return 0;
                } else {
                    return d.d3plus.offset || 0;
                }
            }).attr("marker-start", "url(#d3plus_whisker_marker)");
        };
        marker = vars.defs.selectAll("#d3plus_whisker_marker").data([0]);
        marker.enter().append("marker").attr("id", "d3plus_whisker_marker").attr("markerUnits", "userSpaceOnUse").style("overflow", "visible").append("line");
        d = selection.datum();
        if (d) {
            pos = d.d3plus.position;
            orient = ["top", "bottom"].indexOf(pos) >= 0 ? "horizontal" : "vertical";
            size = orient === "horizontal" ? d.d3plus.width : d.d3plus.height;
        } else {
            orient = "horizontal";
            size = 0;
        }
        marker.select("line").attr("x1", orient === "horizontal" ? -size / 2 : 0).attr("x2", orient === "horizontal" ? size / 2 : 0).attr("y1", orient === "vertical" ? -size / 2 : 0).attr("y2", orient === "vertical" ? size / 2 : 0).call(style).style("stroke-width", vars.data.stroke.width * 2);
        if (vars.draw.timing) {
            enter.append("line").attr("class", "d3plus_data").call(style).call(init);
            selection.selectAll("line.d3plus_data").data(data).transition().duration(vars.draw.timing).call(style).call(position);
            exit.selectAll("line.d3plus_data").transition().duration(vars.draw.timing).call(init);
        } else {
            enter.append("line").attr("class", "d3plus_data");
            selection.selectAll("line.d3plus_data").data(data).call(style).call(position);
        }
    };


},{}],240:[function(require,module,exports){
    var events = require("../../../client/pointer.coffee"),
        prefix     = require("../../../client/prefix.coffee"),
        print      = require("../../../core/console/print.coffee"),
        touch      = require("../../../client/touch.coffee"),
        touchEvent = require("../zoom/propagation.coffee");

// Enter SVG Elements
    module.exports = function(vars) {

        if ( vars.dev.value ) print.time("creating SVG elements");

        // Enter SVG
        vars.svg = vars.container.value.selectAll("svg#d3plus").data([0]);
        vars.svg.enter().insert("svg","#d3plus_message")
            .attr("id","d3plus")
            .attr("width",vars.width.value)
            .attr("height",vars.height.value)
            .attr("xmlns","http://www.w3.org/2000/svg")
            .attr("xmlns:xlink","http://www.w3.org/1999/xlink");

        // Enter BG Rectangle
        vars.g.bg = vars.svg.selectAll("rect#bg").data(["bg"]);
        vars.g.bg.enter().append("rect")
            .attr("id","bg")
            .attr("fill",vars.background.value)
            .attr("stroke", "none")
            .attr("width",vars.width.value)
            .attr("height",vars.height.value);

        // Enter Timeline Group
        vars.g.timeline = vars.svg.selectAll("g#timeline").data(["timeline"]);
        vars.g.timeline.enter().append("g")
            .attr("id","timeline")
            .attr("transform","translate(0,"+vars.height.value+")");

        // Enter Key Group
        vars.g.legend = vars.svg.selectAll("g#key").data(["key"]);
        vars.g.legend.enter().append("g")
            .attr("id","key")
            .attr("transform","translate(0,"+vars.height.value+")");

        // Enter Footer Group
        vars.g.footer = vars.svg.selectAll("g#footer").data(["footer"]);
        vars.g.footer.enter().append("g")
            .attr("id","footer")
            .attr("transform","translate(0,"+vars.height.value+")");

        // Enter App Clipping Mask
        var clipID = "clipping_" + vars.container.id;
        vars.g.clipping = vars.svg.selectAll("#clipping").data(["clipping"]);
        vars.g.clipping.enter().append("clipPath")
            .attr("id", clipID)
            .append("rect")
            .attr("width",vars.width.viz)
            .attr("height",vars.height.viz);

        // Enter Container Group
        vars.g.container = vars.svg.selectAll("g#container").data(["container"]);
        vars.g.container.enter().append("g")
            .attr("id","container")
            .attr("clip-path","url(#" + clipID + ")")
            .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")");

        // Enter Zoom Group
        vars.g.zoom = vars.g.container.selectAll("g#zoom").data(["zoom"]);
        vars.g.zoom.enter().append("g")
            .attr("id","zoom");

        // Enter App Background Group
        vars.g.viz = vars.g.zoom.selectAll("g#d3plus_viz").data(["d3plus_viz"]);
        vars.g.viz.enter().append("g")
            .attr("id","d3plus_viz");

        // Enter App Overlay Rect
        vars.g.overlay = vars.g.viz.selectAll("rect#d3plus_overlay").data([{"id":"d3plus_overlay"}]);
        vars.g.overlay.enter().append("rect")
            .attr("id","d3plus_overlay")
            .attr("width",vars.width.value)
            .attr("height",vars.height.value)
            .attr("opacity",0);

        vars.g.overlay
            .on(events.move,function(d){

                if (touch) touchEvent(vars, d3.event);

                if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
                    vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
                    d3.select(this).style("cursor",prefix()+"grab");
                }
                else {
                    d3.select(this).style("cursor","auto");
                }

            })
            .on(events.up,function(d){

                if (touch) touchEvent(vars, d3.event);

                if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
                    vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
                    d3.select(this).style("cursor",prefix()+"grab");
                }
                else {
                    d3.select(this).style("cursor","auto");
                }

            })
            .on(events.down,function(d){

                if (touch) touchEvent(vars, d3.event);

                if (vars.types[vars.type.value].zoom && vars.zoom.pan.value &&
                    vars.zoom.behavior.scaleExtent()[0] < vars.zoom.scale) {
                    d3.select(this).style("cursor",prefix()+"grabbing");
                }
                else {
                    d3.select(this).style("cursor","auto");
                }

            });

        // Enter App Background Group
        vars.g.app = vars.g.viz.selectAll("g#app").data(["app"]);
        vars.g.app.enter().append("g")
            .attr("id","app");

        // Enter Edges Group
        vars.g.edges = vars.g.viz.selectAll("g#edges").data(["edges"]);
        vars.g.edges.enter().append("g")
            .attr("id","edges")
            .attr("opacity",0);

        // Enter Edge Focus Group
        vars.g.edge_focus = vars.g.viz.selectAll("g#focus").data(["focus"]);
        vars.g.edge_focus.enter().append("g")
            .attr("id","focus");

        // Enter Edge Hover Group
        vars.g.edge_hover = vars.g.viz.selectAll("g#edge_hover").data(["edge_hover"]);
        vars.g.edge_hover.enter().append("g")
            .attr("id","edge_hover")
            .attr("opacity",0);

        // Enter App Data Group
        vars.g.data = vars.g.viz.selectAll("g#data").data(["data"]);
        vars.g.data.enter().append("g")
            .attr("id","data")
            .attr("opacity",0);

        // Enter Data Focus Group
        vars.g.data_focus = vars.g.viz.selectAll("g#data_focus").data(["data_focus"]);
        vars.g.data_focus.enter().append("g")
            .attr("id","data_focus");

        // Enter Top Label Group
        vars.g.labels = vars.g.viz.selectAll("g#d3plus_labels").data(["d3plus_labels"]);
        vars.g.labels.enter().append("g")
            .attr("id","d3plus_labels");

        vars.defs = vars.svg.selectAll("defs").data(["defs"]);
        vars.defs.enter().append("defs");

        if ( vars.dev.value ) print.timeEnd("creating SVG elements");

    };

},{"../../../client/pointer.coffee":40,"../../../client/prefix.coffee":41,"../../../client/touch.coffee":45,"../../../core/console/print.coffee":54,"../zoom/propagation.coffee":255}],241:[function(require,module,exports){
    var print = require("../../../core/console/print.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Updating Elements
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        if ( vars.dev.value ) print.time("updating SVG elements")

        if ( vars.draw.timing ) {

            // Update Parent Element
            vars.container.value.transition().duration(vars.draw.timing)
                .style("width",vars.width.value+"px")
                .style("height",vars.height.value+"px")

            // Update SVG
            vars.svg.transition().duration(vars.draw.timing)
                .attr("width",vars.width.value)
                .attr("height",vars.height.value)

            // Update Background Rectangle
            vars.g.bg.transition().duration(vars.draw.timing)
                .attr("width",vars.width.value)
                .attr("height",vars.height.value)
                .attr("fill",vars.background.value);

            // Update App Clipping Rectangle
            vars.g.clipping.select("rect").transition().duration(vars.draw.timing)
                .attr("width",vars.width.viz)
                .attr("height",vars.height.viz)

            // Update Container Groups
            vars.g.container.transition().duration(vars.draw.timing)
                .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")")

        }
        else {

            // Update Parent Element
            vars.container.value
                .style("width",vars.width.value+"px")
                .style("height",vars.height.value+"px")

            // Update SVG
            vars.svg
                .attr("width",vars.width.value)
                .attr("height",vars.height.value)

            // Update Background Rectangle
            vars.g.bg
                .attr("width",vars.width.value)
                .attr("height",vars.height.value)
                .attr("fill",vars.background.value);

            // Update App Clipping Rectangle
            vars.g.clipping.select("rect")
                .attr("width",vars.width.viz)
                .attr("height",vars.height.viz)

            // Update Container Groups
            vars.g.container
                .attr("transform","translate("+vars.margin.left+","+vars.margin.top+")")

        }

        if ( vars.dev.value ) print.timeEnd("updating SVG elements")

    }

},{"../../../core/console/print.coffee":54}],242:[function(require,module,exports){
    var arraySort     = require("../../../array/sort.coffee"),
        createTooltip = require("../../../tooltip/create.js"),
        dataNest      = require("../../../core/data/nest.js"),
        fetchData     = require("./data.js"),
        fetchColor    = require("../../../core/fetch/color.coffee"),
        fetchText     = require("../../../core/fetch/text.js"),
        fetchValue    = require("../../../core/fetch/value.coffee"),
        mergeObject   = require("../../../object/merge.coffee"),
        removeTooltip = require("../../../tooltip/remove.coffee"),
        segments      = require("../shapes/segments.coffee"),
        scroll        = require("../../../client/scroll.js"),
        uniques       = require("../../../util/uniques.coffee"),
        validObject   = require("../../../object/validate.coffee"),
        zoomDirection = require("../zoom/direction.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates correctly formatted tooltip for Apps
//-------------------------------------------------------------------
    module.exports = function(params) {

        if ( !( "d3plus" in params.data ) ) {
            params.data.d3plus = {}
        }

        var vars = params.vars,
            d = params.data,
            dataDepth = "d3plus" in d && "depth" in d.d3plus ? d.d3plus.depth : vars.depth.value,
            ex = params.ex,
            mouse = params.mouseevents ? params.mouseevents : false,
            arrow = "arrow" in params ? params.arrow : true,
            id = fetchValue(vars,d,vars.id.value),
            tooltip_id = params.id || vars.type.value

        if ((d3.event && d3.event.type == "click") && (vars.tooltip.html.value || vars.tooltip.value.long) && !("fullscreen" in params)) {
            var fullscreen = true,
                arrow = false,
                mouse = true,
                length = "long",
                footer = vars.footer.value

            vars.covered = true
        }
        else {
            var fullscreen = false,
                align = params.anchor || vars.tooltip.anchor,
                length = params.length || "short",
                zoom = zoomDirection(d, vars)

            if (zoom === -1) {
                var key = vars.id.nesting[dataDepth-1],
                    parent = fetchValue(vars,id,key)
            }

            var text = "";
            if (!(!vars.mouse.click.value || (vars.mouse.viz && vars.mouse.viz.click === false))) {
                if (zoom === 1 && vars.zoom.value) {
                    var text = vars.format.value(vars.format.locale.value.ui.expand)
                }
                else if (zoom === -1 && vars.zoom.value && vars.history.states.length && !vars.tooltip.value.long) {
                    var text = vars.format.value(vars.format.locale.value.ui.collapse)
                }
                else if (!vars.small && length == "short" && (vars.tooltip.html.value || vars.tooltip.value.long) && (vars.focus.value.length !== 1 || vars.focus.value[0] != id)) {
                    var text = vars.format.locale.value.ui.moreInfo
                }
                else if (length == "long") {
                    var text = vars.footer.value || ""
                }
            }

            var footer = text.length ? vars.format.value(text,{"key": "footer", "vars": vars}) : false

        }

        if ("x" in params) {
            var x = params.x;
        }
        else if (vars.types[vars.type.value].tooltip === "static") {
            var x = d.d3plus.x;
            if (vars.zoom.translate && vars.zoom.scale) {
                x = vars.zoom.translate[0]+x*vars.zoom.scale;
            }
            x += vars.margin.left;
            if (params.length !== "long") {
                y += scroll.x();
                x += vars.container.value.node().getBoundingClientRect().left;
                x += parseFloat(vars.container.value.style("padding-left"), 10);
            }
        }
        else {
            var x = d3.mouse(d3.select("html").node())[0];
        }

        if ("y" in params) {
            var y = params.y;
        }
        else if (vars.types[vars.type.value].tooltip == "static") {
            var y = d.d3plus.y;
            if (vars.zoom.translate && vars.zoom.scale) {
                y = vars.zoom.translate[1]+y*vars.zoom.scale;
            }
            y += vars.margin.top;
            if (params.length !== "long") {
                y += scroll.y();
                y += vars.container.value.node().getBoundingClientRect().top;
                y += parseFloat(vars.container.value.style("padding-top"), 10);
            }
        }
        else {
            var y = d3.mouse(d3.select("html").node())[1];
        }

        if ("offset" in params) {
            var offset = params.offset;
        }
        else if (vars.types[vars.type.value].tooltip == "static") {
            var offset = d.d3plus.r ? d.d3plus.r : d.d3plus.height/2;
            if (vars.zoom.scale) {
                offset = offset * vars.zoom.scale;
            }
        }
        else {
            var offset = 3;
        }

        function make_tooltip(html) {

            var titleDepth = "depth" in params ? params.depth : dataDepth;

            var ex = {},
                children,
                depth     = vars.id.nesting[titleDepth+1] in d ? titleDepth + 1 : titleDepth,
                nestKey   = vars.id.nesting[depth],
                nameList  = "merged" in d.d3plus ? d.d3plus.merged : d[nestKey];

            if (!(nameList instanceof Array)) nameList = [nameList];

            var dataValue = fetchValue( vars , d , vars.size.value );

            if (vars.tooltip.children.value) {

                nameList = nameList.slice(0);
                if (nameList.length > 1 && validObject(nameList[0])) nameList = dataNest(vars, nameList, [nestKey]);

                if (vars.size.value && validObject(nameList[0])) {

                    var namesNoValues = [];
                    var namesWithValues = nameList.filter(function(n){
                        var val = fetchValue(vars, n, vars.size.value);
                        if (val !== null && (!("d3plus" in n) || !n.d3plus.merged)) {
                            return true;
                        }
                        else {
                            namesNoValues.push(n);
                        }
                    });

                    arraySort(namesWithValues, vars.size.value, "desc", [], vars);

                    nameList = namesWithValues.concat(namesNoValues);

                }

                var limit = length === "short" ? 3 : vars.data.large,
                    listLength = nameList.length,
                    max   = d3.min([listLength , limit]),
                    objs  = [];

                children = {"values": []};
                for (var i = 0; i < max; i++) {

                    if (!nameList.length) break;

                    var obj  = nameList.shift(),
                        name = fetchText(vars, obj, depth)[0],
                        id   = validObject(obj) ? fetchValue(vars, obj, nestKey, depth) : obj;

                    if (id !== d[vars.id.nesting[titleDepth]] && name && !children[name]) {

                        var value = validObject(obj) ? fetchValue(vars, obj, vars.size.value, nestKey) : null,
                            color = fetchColor(vars, obj, nestKey);

                        children[name] = value && !(value instanceof Array) ? vars.format.value(value, {"key": vars.size.value, "vars": vars, "data": obj}) : "";
                        var child = {};
                        child[name] = children[name];
                        children.values.push(child);

                        if (color) {
                            if ( !children.d3plus_colors ) children.d3plus_colors = {};
                            children.d3plus_colors[name] = color;
                        }

                    }
                    else {
                        i--;
                    }

                }

                if ( listLength > max ) {
                    children.d3plusMore = listLength - max;
                }

            }

            if (d.d3plus.tooltip) {
                ex = mergeObject(ex, d.d3plus.tooltip);
            }

            function getLabel(method) {
                return typeof vars[method].value === "string" ? vars[method].value :
                    vars.format.locale.value.method[method];
            }

            if ( vars.tooltip.size.value ) {
                if (dataValue && typeof vars.size.value !== "number") {
                    ex[getLabel("size")] = dataValue;
                }
                if (vars.axes.opposite && vars[vars.axes.opposite].value !== vars.size.value) {
                    ex[getLabel(vars.axes.opposite)] = fetchValue(vars, d, vars[vars.axes.opposite].value);
                }
                if (vars.axes.opposite && vars[vars.axes.opposite + "2"].value !== vars.size.value) {
                    ex[getLabel(vars.axes.opposite + "2")] = fetchValue(vars, d, vars[vars.axes.opposite + "2"].value);
                }
                if (vars.color.valueScale) {
                    ex[getLabel("color")] = fetchValue(vars, d, vars.color.value);
                }
            }

            var active = segments(vars, d, "active"),
                temp   = segments(vars, d, "temp"),
                total  = segments(vars, d, "total");

            if (typeof active == "number" && active > 0 && total) {
                ex[getLabel("active")] = active+"/"+total+" ("+vars.format.value((active/total)*100, {"key": "share", "vars": vars, "data": d})+")";
            }

            if (typeof temp == "number" && temp > 0 && total) {
                ex[getLabel("temp")] = temp+"/"+total+" ("+vars.format.value((temp/total)*100, {"key": "share", "vars": vars, "data": d})+")";
            }

            if ( vars.tooltip.share.value && d.d3plus.share ) {
                ex.share = vars.format.value(d.d3plus.share*100, {"key": "share", "vars": vars, "data": d});
            }

            var depth = "depth" in params ? params.depth : dataDepth,
                title = params.title || fetchText(vars,d,depth)[0],
                icon = uniques(d, vars.icon.value, fetchValue, vars, vars.id.nesting[depth]),
                tooltip_data = fetchData(vars,d,length,ex,children,depth)

            if (icon.length === 1 && typeof icon[0] === "string") {
                icon = icon[0];
            }
            else {
                icon = false;
            }

            if ((tooltip_data.length > 0 || footer) || ((!d.d3plus_label && length == "short" && title) || (d.d3plus_label && (!("visible" in d.d3plus_label) || ("visible" in d.d3plus_label && d.d3plus_label.visible === false))))) {

                if (!title) {
                    title = vars.format.value(id, {"key": vars.id.value, "vars": vars});
                }

                var depth = "d3plus" in d && "merged" in d.d3plus ? dataDepth - 1 : "depth" in params ? params.depth : dataDepth;

                if (depth < 0) depth = 0

                depth = vars.id.nesting[depth]

                if (typeof vars.icon.style.value == "string") {
                    var icon_style = vars.icon.style.value
                }
                else if (typeof vars.icon.style.value == "object" && vars.icon.style.value[depth]) {
                    var icon_style = vars.icon.style.value[depth]
                }
                else {
                    var icon_style = "default"
                }

                var width = vars.tooltip.small;
                if (params.width) {
                    width = params.width;
                }
                else if (fullscreen) {
                    width = vars.tooltip.large;
                }

                var parent = (!fullscreen && params.length !== "long") || (fullscreen && vars.tooltip.fullscreen.value) ? d3.select("body") : vars.container.value;

                if (!params.description && d && vars.tooltip.sub.value) {
                    params.description = fetchValue(vars, d, vars.tooltip.sub.value);
                }

                createTooltip({
                    "align": align,
                    "arrow": arrow,
                    "locale": vars.format.locale.value,
                    "background": vars.tooltip.background,
                    "curtain": vars.tooltip.curtain.color,
                    "curtainopacity": vars.tooltip.curtain.opacity,
                    "fontcolor": vars.tooltip.font.color,
                    "fontfamily": vars.tooltip.font.family.value,
                    "fontsize": vars.tooltip.font.size,
                    "fontweight": vars.tooltip.font.weight,
                    "data": tooltip_data,
                    "color": fetchColor(vars, d),
                    "allColors": true,
                    "footer": params.footer === false ? params.footer : footer,
                    "fullscreen": fullscreen,
                    "html": html,
                    "js": params.js,
                    "icon": icon,
                    "id": tooltip_id,
                    "max_height": params.maxheight,
                    "max_width": width,
                    "mouseevents": mouse,
                    "offset": offset,
                    "parent": parent,
                    "stacked": vars.tooltip.stacked.value,
                    "style": icon_style,
                    "title": title,
                    "description": params.description,
                    "width": !params.width && !fullscreen && tooltip_data.length == 0 ? "auto" : width,
                    "x": x,
                    "y": y
                })

            }
            else {
                removeTooltip(tooltip_id)
            }

        }

        if (fullscreen || params.length === "long") {

            if (typeof vars.tooltip.html.value == "string") {
                make_tooltip(vars.tooltip.html.value)
            }
            else if (typeof vars.tooltip.html.value == "function") {
                make_tooltip(vars.tooltip.html.value(id))
            }
            else if (vars.tooltip.html.value && typeof vars.tooltip.html.value == "object" && vars.tooltip.html.value.url) {
                var tooltip_url = vars.tooltip.html.value.url;
                if (typeof tooltip_url === "function") tooltip_url = tooltip_url(id);
                d3.json(tooltip_url,function(data){
                    var html = vars.tooltip.html.value.callback ? vars.tooltip.html.value.callback(data) : data
                    make_tooltip(html)
                })
            }
            else {
                make_tooltip(params.html)
            }

        }
        else {
            make_tooltip(params.html)
        }

    }

},{"../../../array/sort.coffee":36,"../../../client/scroll.js":43,"../../../core/data/nest.js":62,"../../../core/fetch/color.coffee":65,"../../../core/fetch/text.js":68,"../../../core/fetch/value.coffee":69,"../../../object/merge.coffee":173,"../../../object/validate.coffee":174,"../../../tooltip/create.js":203,"../../../tooltip/remove.coffee":205,"../../../util/uniques.coffee":212,"../shapes/segments.coffee":235,"../zoom/direction.coffee":252,"./data.js":243}],243:[function(require,module,exports){
    var copy = require("../../../util/copy.coffee"),
        fetchValue   = require("../../../core/fetch/value.coffee"),
        fetchColor   = require("../../../core/fetch/color.coffee"),
        fetchText    = require("../../../core/fetch/text.js"),
        legible      = require("../../../color/legible.coffee"),
        mergeObject  = require("../../../object/merge.coffee"),
        prefix       = require("../../../client/prefix.coffee"),
        stringFormat = require("../../../string/format.js"),
        validObject  = require("../../../object/validate.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates a data object for the Tooltip
//------------------------------------------------------------------------------
    module.exports = function(vars, id, length, extras, children, depth) {

        if (vars.small) {
            return []
        }

        if (!length) var length = "long"
        if (length == "long") {
            var other_length = "short"
        }
        else {
            var other_length = "long"
        }

        var extra_data = {}
        if (extras && typeof extras == "string") extras = [extras]
        else if (extras && typeof extras == "object") {
            extra_data = mergeObject(extra_data,extras)
            var extras = []
            for ( var k in extra_data ) {
                extras.push(k)
            }
        }
        else if (!extras) var extras = []

        var tooltip_highlights = []

        if (vars.tooltip.value instanceof Array) {
            var a = vars.tooltip.value
        }
        else if (typeof vars.tooltip.value == "string") {
            var a = [vars.tooltip.value]
        }
        else {

            if (vars.tooltip.value[vars.id.nesting[depth]]) {
                var a = vars.tooltip.value[vars.id.nesting[depth]]
            }
            else {
                var a = vars.tooltip.value
            }

            if (!(a instanceof Array)) {

                if (a[length]) {
                    a = a[length]
                }
                else if (a[other_length]) {
                    a = []
                }
                else {
                    a = mergeObject({"":[]},a)
                }

            }

            if (typeof a == "string") {
                a = [a]
            }
            else if (!(a instanceof Array)) {
                a = mergeObject({"":[]},a)
            }

        }

        function format_key(key,group) {

            if (vars.attrs.value[group]) var id_var = group
            else var id_var = null

            if (group) group = vars.format.value(group)

            var value = extra_data[key] || fetchValue(vars,id,key,id_var)

            if (validObject(value)) {
                tooltip_data.push({
                    "name": vars.format.value(key),
                    "value": vars.format.value(value.value, {"key": value.key, "vars": vars}),
                    "group": group
                })
            }
            else if (value != null && value != "undefined" && !(value instanceof Array) && ((typeof value === "string" && value.indexOf("d3plus_other") < 0) || !(typeof value === "string"))) {
                var name = vars.format.locale.value.ui[key]
                    ? vars.format.value(vars.format.locale.value.ui[key])
                    : vars.format.value(key),
                    h = tooltip_highlights.indexOf(key) >= 0

                if ( value instanceof Array ) {
                    value.forEach(function(v){
                        v = vars.format.value(v, {"key": key, "vars": vars, "data": id})
                    })
                }
                else {
                    value = vars.format.value(value, {"key": key, "vars": vars, "data": id})
                }

                var obj = {"name": name, "value": value, "highlight": h, "group": group}

                if ( vars.descs.value ) {

                    if ( typeof vars.descs.value === "function" ) {
                        var descReturn = vars.descs.value( key )
                        if ( typeof descReturn === "string" ) {
                            obj.desc = descReturn
                        }
                    }
                    else if ( key in vars.descs.value ) {
                        obj.desc = vars.descs.value[key]
                    }

                }

                tooltip_data.push(obj)

            }

        }

        var tooltip_data = []
        if (a.constructor === Array) a = {"": a};

        if (vars.id.nesting.length && depth < vars.id.nesting.length-1) {
            var a = copy(a)
            vars.id.nesting.forEach(function(n,i){
                if (i > depth && a[n]) delete a[n]
            })
        }

        for (var group in a) {
            if (a[group].constructor !== Array) a[group] = [a[group]]
            for (var i = extras.length; i > 0; i--) {
                if (a[group].indexOf(extras[i-1]) >= 0) {
                    extras.splice(i-1, 1);
                }
            }
        }

        if (vars.tooltip.value.long && typeof vars.tooltip.value.long == "object") {
            var placed = []

            for (var group in vars.tooltip.value.long) {

                for (var i = extras.length; i > 0; i--) {
                    var e = extras[i-1];
                    if (vars.tooltip.value.long[group].indexOf(e) >= 0) {
                        if (!a[group]) a[group] = [];
                        a[group].push(e);
                        extras.splice(i-1, 1);
                    }
                }

            }

        }

        if (extras.length) {
            if (!a[""]) a[""] = []
            a[""] = a[""].concat(extras);
        }

        for (var group in a) {
            a[group].forEach(function(t){
                format_key(t, group);
            });
        }

        if ( children ) {

            var title  = vars.format.locale.value.ui.including
                , colors = children.d3plus_colors

            children.values.forEach(function(child) {
                var name = d3.keys(child)[0];
                tooltip_data.push({
                    "group": vars.format.value(title),
                    "highlight": colors && colors[name] ? colors[name] : false,
                    "name": name,
                    "value": child[name]
                })
            });

            if (children.d3plusMore) {

                tooltip_data.push({
                    "group": vars.format.value(title),
                    "highlight": true,
                    "name": stringFormat(vars.format.locale.value.ui.more, children.d3plusMore),
                    "value": ""
                })

            }

        }

        if ( vars.tooltip.connections.value && length === "long" ) {

            var connections = vars.edges.connections( id[vars.id.value] , vars.id.value , true )

            if ( connections.length ) {
                connections.forEach(function(conn){

                    var c = vars.data.viz.filter(function(d){
                        return d[vars.id.value] === conn[vars.id.value]
                    })

                    var c = c.length ? c[0] : conn

                    var name = fetchText(vars,c)[0],
                        color = fetchColor(vars,c),
                        size = vars.tooltip.font.size,
                        radius = vars.shape.value == "square" ? 0 : size
                    styles = [
                        "background-color: "+color,
                        "border-color: "+legible(color),
                        "border-style: solid",
                        "border-width: "+vars.data.stroke.width+"px",
                        "display: inline-block",
                        "height: "+size+"px",
                        "left: 0px",
                        "position: absolute",
                        "width: "+size+"px",
                        "top: 0px",
                        prefix()+"border-radius: "+radius+"px",
                    ]
                    node = "<div style='"+styles.join("; ")+";'></div>"

                    var nodeClick = function() {
                        vars.self.focus([c[vars.id.value]]).draw()
                    }

                    tooltip_data.push({
                        "group": vars.format.value(vars.format.locale.value.ui.primary),
                        "highlight": false,
                        "link": nodeClick,
                        "name": "<div id='d3plustooltipfocuslink_"+c[vars.id.value]+"' class='d3plus_tooltip_focus_link' style='position:relative;padding-left:"+size*1.5+"px;'>"+node+name+"</div>"
                    })

                })
            }

        }

        return tooltip_data

    }

},{"../../../client/prefix.coffee":41,"../../../color/legible.coffee":46,"../../../core/fetch/color.coffee":65,"../../../core/fetch/text.js":68,"../../../core/fetch/value.coffee":69,"../../../object/merge.coffee":173,"../../../object/validate.coffee":174,"../../../string/format.js":175,"../../../util/copy.coffee":209}],244:[function(require,module,exports){
    var print;

    print = require("../../../core/console/print.coffee");

    module.exports = function(vars) {
        var app, d, dataRequired, drawable, i, len, ref, requirements, returned, visualization;
        vars.group = vars.g.apps[vars.type.value];
        vars.mouse.viz = false;
        vars.edges.path = false;
        visualization = vars.types[vars.type.value];
        requirements = visualization.requirements || [];
        dataRequired = requirements.indexOf("data") >= 0;
        drawable = !dataRequired || (dataRequired && vars.data.viz.length);
        if (!vars.error.internal && drawable) {
            app = vars.format.locale.value.visualization[vars.type.value];
            if (vars.dev.value) {
                print.time("running " + app);
            }
            ref = vars.data.viz;
            for (i = 0, len = ref.length; i < len; i++) {
                d = ref[i];
                if (d.d3plus) {
                    delete d.d3plus.shape;
                    delete d.d3plus.label;
                    delete d.d3plus.rotate;
                    delete d.d3plus.share;
                }
            }
            returned = visualization(vars);
            if (vars.dev.value) {
                print.timeEnd("running " + app);
            }
        } else {
            returned = null;
        }
        vars.returned = {
            nodes: [],
            edges: null
        };
        if (returned instanceof Array) {
            vars.returned.nodes = returned;
        } else if (returned) {
            if (returned.nodes) {
                vars.returned.nodes = returned.nodes;
            }
            if (returned.edges) {
                vars.returned.edges = returned.edges;
            }
        }
    };


},{"../../../core/console/print.coffee":54}],245:[function(require,module,exports){
    var copy        = require("../../../util/copy.coffee"),
        form        = require("../../../form/form.js"),
        print       = require("../../../core/console/print.coffee"),
        validObject = require("../../../object/validate.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws a UI drawer, if defined.
//------------------------------------------------------------------------------
    module.exports = function( vars ) {

        var enabled = vars.ui.value && vars.ui.value.length,
            position = vars.ui.position.value;

        if ( vars.dev.value && enabled ) print.time("drawing custom UI elements");

        var drawer = vars.container.value.selectAll("div#d3plus_drawer")
            .data(["d3plus_drawer"]);

        drawer.enter().append("div")
            .attr("id","d3plus_drawer");

        var positionStyles = {};
        vars.ui.position.accepted.forEach(function(p){
            positionStyles[p] = p == position ? vars.margin.bottom+"px" : "auto";
        });

        drawer
            .style("text-align",vars.ui.align.value)
            .style("position","absolute")
            .style("width",vars.width.value-(vars.ui.padding*2)+"px")
            .style("height","auto")
            .style(positionStyles);

        var ui = drawer.selectAll("div.d3plus_drawer_ui")
            .data(enabled ? vars.ui.value : [], function(d){
                return d.method || false;
            });

        ui.exit().remove();

        ui.enter().append("div")
            .attr("class","d3plus_drawer_ui")
            .style("display","inline-block");

        ui.style("padding",vars.ui.padding+"px")
            .each(function(d){

                if (!d.form) {

                    d.form = form()
                        .container(d3.select(this))
                        .data({"sort": false})
                        .id("id")
                        .text("text");

                }

                var focus, callback;

                if (typeof d.method === "string" && d.method in vars) {
                    focus = vars[d.method].value;
                    callback = function(value) {
                        if ( value !== vars[d.method].value ) {
                            vars.self[d.method](value).draw();
                        }
                    };
                }
                else {
                    focus = d.value[0];
                    if (validObject(focus)) focus = focus[d3.keys(focus)[0]];
                    if (typeof d.method === "function") {
                        callback = function(value) {
                            d.method(value, vars.self);
                        };
                    }
                }

                var data = [], title;

                if (d.label) {
                    title = d.label;
                }
                else if (typeof d.method === "string" && d.method in vars) {
                    title = vars.format.locale.value.method[d.method] || d.method;
                }

                d.value.forEach(function(o){

                    var obj = {};

                    if (validObject(o)) {
                        obj.id   = o[d3.keys(o)[0]];
                        obj.text = vars.format.value(d3.keys(o)[0]);
                    }
                    else {
                        obj.id   = o;
                        obj.text = vars.format.value(o);
                    }

                    data.push(obj);

                });

                var font = copy(vars.ui.font);
                font.align = copy(vars.font.align);
                font.secondary = copy(font);

                d.form
                    .data(data)
                    .font(font)
                    .focus(d.value.length > 1 ? focus : false)
                    .focus({"callback": callback})
                    .format(vars.format.locale.language)
                    .format({
                        "number": vars.format.number.value,
                        "text": vars.format.text.value
                    })
                    .title(vars.format.value(title))
                    .type(d.type || "auto")
                    .ui({
                        "align": vars.ui.align.value,
                        "border": vars.ui.border,
                        "color": {
                            "primary": vars.ui.color.primary.value,
                            "secondary": vars.ui.color.secondary.value
                        },
                        "padding": vars.ui.padding,
                        "margin": 0
                    })
                    .width(d.width || false)
                    .draw();

            });

        var drawerHeight = drawer.node().offsetHeight || drawer.node().getBoundingClientRect().height;

        if ( drawerHeight ) {
            vars.margin[position] += drawerHeight;
        }

        if ( vars.dev.value && enabled ) print.timeEnd("drawing custom UI elements");

    };

},{"../../../core/console/print.coffee":54,"../../../form/form.js":105,"../../../object/validate.coffee":174,"../../../util/copy.coffee":209}],246:[function(require,module,exports){
    var events, lighter, print, stylesheet;

    events = require("../../../client/pointer.coffee");

    lighter = require("../../../color/lighter.coffee");

    print = require("../../../core/console/print.coffee");

    stylesheet = require("../../../client/css.coffee");

    module.exports = function(vars) {
        var button, color, containerPadding, enter, family, left, min_height, padding, size, stripY, style, titleClass, titleGroup, top, weight;
        if (!vars.small && vars.history.states.length > 0) {
            if (vars.dev.value) {
                print.time("drawing back button");
            }
            button = vars.container.value.selectAll("div#d3plus_back_button").data(["d3plus_back_button"]).style("position", "relative").style("z-index", 1900);
            size = vars.title.sub.font.size;
            color = vars.title.sub.font.color;
            family = vars.title.sub.font.family.value;
            weight = vars.title.sub.font.weight;
            padding = vars.title.sub.padding;
            titleClass = false;
            if (vars.title.sub.value && ["start", "left"].indexOf(vars.title.sub.font.align) < 0) {
                titleClass = "sub";
            } else if (vars.title.total.value && ["start", "left"].indexOf(vars.title.total.font.align) < 0) {
                titleClass = "total";
            } else if (vars.title.value && ["start", "left"].indexOf(vars.title.font.align) < 0) {
                titleClass = "title";
            }
            if (titleClass) {
                stripY = function(elem) {
                    var y;
                    y = elem.attr("transform").match(/translate\(([^a-z]+)\)/gi)[0];
                    y = y.replace(/([^a-z])\s([^a-z])/gi, "$1,$2");
                    y = y.split(",");
                    y = y[y.length - 1];
                    return parseFloat(y.substring(0, y.length - 1));
                };
                titleGroup = vars.svg.select(".d3plus_title." + titleClass);
                top = stripY(titleGroup) + stripY(titleGroup.select("text"));
            } else {
                top = vars.margin.top - vars.title.padding;
                min_height = size + padding * 2;
                vars.margin.top += min_height;
            }
            containerPadding = parseFloat(vars.container.value.style("padding-top"), 10);
            top += containerPadding;
            containerPadding = parseFloat(vars.container.value.style("padding-left"), 10);
            left = vars.margin.left + size / 2 + containerPadding;
            style = function(elem) {
                return elem.style("position", "absolute").style("left", left + "px").style("top", top + "px").style("color", color).style("font-family", family).style("font-weight", weight).style("font-size", size + "px");
            };
            enter = button.enter().append("div").attr("id", "d3plus_back_button").style("opacity", 0).call(style).html(function() {
                var arrow;
                if (stylesheet("font-awesome") && vars.icon.back.value.indexOf("fa-") === 0) {
                    arrow = "<i class='fa " + vars.icon.back.value;
                    arrow += "' style='margin-top:2px;margin-right:4px;'></i>";
                } else {
                    arrow = vars.icon.back.value + " ";
                }
                return arrow + vars.format.value(vars.format.locale.value.ui.back);
            });
            button.on(events.over, function() {
                if (!vars.small && vars.history.states.length > 0) {
                    return d3.select(this).style("cursor", "pointer").transition().duration(vars.timing.mouseevents).style("color", lighter(color, .25));
                }
            }).on(events.out, function() {
                if (!vars.small && vars.history.states.length > 0) {
                    return d3.select(this).style("cursor", "auto").transition().duration(vars.timing.mouseevents).style("color", color);
                }
            }).on(events.click, function() {
                return vars.history.back();
            }).transition().duration(vars.draw.timing).style("opacity", 1).call(style);
            if (vars.dev.value) {
                return print.timeEnd("drawing back button");
            }
        } else {
            return vars.container.value.selectAll("div#d3plus_back_button").transition().duration(vars.draw.timing).style("opacity", 0).remove();
        }
    };


},{"../../../client/css.coffee":38,"../../../client/pointer.coffee":40,"../../../color/lighter.coffee":47,"../../../core/console/print.coffee":54}],247:[function(require,module,exports){
    var arraySort = require("../../../array/sort.coffee"),
        buckets       = require("../../../util/buckets.coffee"),
        copy          = require("../../../util/copy.coffee"),
        createTooltip = require("../tooltip/create.js"),
        dataNest      = require("../../../core/data/nest.js"),
        dataURL       = require("../../../util/dataURL.coffee"),
        events        = require("../../../client/pointer.coffee"),
        fetchValue    = require("../../../core/fetch/value.coffee"),
        fetchColor    = require("../../../core/fetch/color.coffee"),
        fetchText     = require("../../../core/fetch/text.js"),
        print         = require("../../../core/console/print.coffee"),
        removeTooltip = require("../../../tooltip/remove.coffee"),
        textColor     = require("../../../color/text.coffee"),
        uniqueValues  = require("../../../util/uniques.coffee"),
        scroll        = require("../../../client/scroll.js"),
        stringStrip   = require("../../../string/strip.js"),
        textWrap      = require("../../../textwrap/textwrap.coffee"),
        touch         = require("../../../client/touch.coffee"),
        validObject   = require("../../../object/validate.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates color key
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        var key_display = true,
            square_size = 0;

        if (!vars.error.internal && vars.color.value && !vars.small && vars.legend.value) {

            if (!vars.color.valueScale) {

                if ( vars.dev.value ) print.time("grouping data by colors");

                var data;
                if ( vars.nodes.value && vars.types[vars.type.value].requirements.indexOf("nodes") >= 0 ) {
                    data = copy(vars.nodes.restriced || vars.nodes.value);
                    if ( vars.data.viz.length ) {
                        for (var i = 0 ; i < data.length ; i++) {
                            var appData = vars.data.viz.filter(function(a){
                                return a[vars.id.value] === data[i][vars.id.value];
                            });
                            if (appData.length) {
                                data[i] = appData[0];
                            }
                        }
                    }
                }
                else {
                    data = vars.data.viz;
                }

                if (data.length && "key" in data[0] && "values" in data[0]) {
                    data = d3.merge(data.map(function(d){
                        return d.values;
                    }));
                }

                var colorFunction = function(d){
                        return fetchColor(vars, d, colorDepth);
                    },
                    colorDepth = 0,
                    colorKey = vars.id.value;

                var colorIndex = vars.id.nesting.indexOf(vars.color.value);
                if (colorIndex >= 0) {
                    colorDepth = colorIndex;
                    colorKey = vars.id.nesting[colorIndex];
                }
                else {

                    for (var n = 0; n <= vars.depth.value; n++) {

                        colorDepth = n;
                        colorKey   = vars.id.nesting[n];

                        var uniqueIDs = uniqueValues(data , function(d){
                                return fetchValue(vars, d, colorKey);
                            }),
                            uniqueColors = uniqueValues(data, colorFunction);

                        if (uniqueIDs.length >= uniqueColors.length && uniqueColors.length > 1) {
                            break;
                        }

                    }

                }

                var legendNesting = [vars.color.value];
                // if (vars.icon.value && vars.legend.icons.value) legendNesting.push(vars.icon.value);
                var colors = dataNest(vars, data, legendNesting, false);

                if ( vars.dev.value ) print.timeEnd("grouping data by color")

                var available_width = vars.width.value;

                square_size = vars.legend.size;

                var key_width = square_size*colors.length+vars.ui.padding*(colors.length+1)

                if (square_size instanceof Array) {

                    if ( vars.dev.value ) print.time("calculating legend size")

                    for (var i = square_size[1]; i >= square_size[0]; i--) {
                        key_width = i*colors.length+vars.ui.padding*(colors.length+1)
                        if (available_width >= key_width) {
                            square_size = i;
                            break;
                        }
                    }

                    if ( vars.dev.value ) print.timeEnd("calculating legend size");

                }
                else if (typeof square_size != "number" && square_size !== false) {
                    square_size = 30;
                }

                if (available_width < key_width || colors.length == 1) {
                    key_display = false;
                }
                else {

                    key_width -= vars.ui.padding*2;

                    if ( vars.dev.value ) print.time("sorting legend");

                    var order = vars[vars.legend.order.value].value;

                    var sort_color = vars.color.value;
                    if (!order) {
                        order = vars[vars.color.value].value;
                    }
                    else if (vars.legend.order.value !== "color") {
                        sort_color = [];
                    }

                    arraySort(colors, order, vars.legend.order.sort.value, sort_color, vars, colorDepth);

                    if ( vars.dev.value ) print.timeEnd("sorting legend");

                    if ( vars.dev.value ) print.time("drawing legend");

                    var start_x;

                    if (vars.legend.align == "start") {
                        start_x = vars.ui.padding;
                    }
                    else if (vars.legend.align == "end") {
                        start_x = available_width - vars.ui.padding - key_width;
                    }
                    else {
                        start_x = available_width/2 - key_width/2;
                    }

                    vars.g.legend.selectAll("g.d3plus_scale")
                        .transition().duration(vars.draw.timing)
                        .attr("opacity",0)
                        .remove();

                    function position(group) {

                        group
                            .attr("transform",function(g,i){
                                var x = start_x + (i*(vars.ui.padding+square_size))
                                return "translate("+x+","+vars.ui.padding+")"
                            })

                    }

                    function style(rect) {

                        rect
                            .attr("width", square_size)
                            .attr("height", square_size)
                            .attr("fill",function(g){

                                d3.select(this.parentNode).select("text").remove();

                                var icon = uniqueValues(g, vars.icon.value, fetchValue, vars, colorKey),
                                    color = fetchColor(vars, g, colorKey);

                                if (vars.legend.icons.value && icon.length === 1 &&
                                    typeof icon[0] === "string") {
                                    icon = icon[0];
                                    var short_url = stringStrip(icon+"_"+color),
                                        iconStyle = vars.icon.style.value,
                                        icon_style,
                                        pattern = vars.defs.selectAll("pattern#"+short_url)
                                            .data([short_url]);

                                    if (typeof iconStyle === "string") {
                                        icon_style = vars.icon.style.value;
                                    }
                                    else if (validObject(iconStyle) && iconStyle[colorKey]) {
                                        icon_style = iconStyle[colorKey];
                                    }
                                    else {
                                        icon_style = "default";
                                    }

                                    color = icon_style == "knockout" ? color : "none";

                                    pattern.select("rect").transition().duration(vars.draw.timing)
                                        .attr("fill",color)
                                        .attr("width",square_size)
                                        .attr("height",square_size);

                                    pattern.select("image").transition().duration(vars.draw.timing)
                                        .attr("width",square_size)
                                        .attr("height",square_size);

                                    var pattern_enter = pattern.enter().append("pattern")
                                        .attr("id",short_url)
                                        .attr("width",square_size)
                                        .attr("height",square_size);

                                    pattern_enter.append("rect")
                                        .attr("fill",color)
                                        .attr("width",square_size)
                                        .attr("height",square_size);

                                    pattern_enter.append("image")
                                        .attr("xlink:href",icon)
                                        .attr("width",square_size)
                                        .attr("height",square_size)
                                        .each(function(d){

                                            if (icon.indexOf("/") === 0 || icon.indexOf(window.location.hostname) >= 0) {
                                                dataURL(icon,function(base64){
                                                    pattern.select("image").attr("xlink:href",base64);
                                                });
                                            }
                                            else {
                                                pattern.select("image").attr("xlink:href",icon);
                                            }

                                        });

                                    return "url(#"+short_url+")";
                                }
                                else {

                                    if (vars.legend.labels.value) {

                                        var names;
                                        if (vars.legend.text.value) {
                                            names = [fetchValue(vars, g, vars.legend.text.value, colorDepth)];
                                        }
                                        else {
                                            names = fetchText(vars, g, colorDepth);
                                        }

                                        if (names.length === 1 && !(names[0] instanceof Array) && names[0].length) {

                                            var text = d3.select(this.parentNode).append("text"),
                                                size = vars.legend.font.size;

                                            if (!(size instanceof Array)) {
                                                size = [size]
                                            }

                                            text
                                                .attr("font-size", size[size.length-1]+"px")
                                                .attr("font-weight", vars.legend.font.weight)
                                                .attr("font-family", vars.legend.font.family.value)
                                                .attr("stroke", "none")
                                                .attr("fill", textColor(color))
                                                .attr("x", 0)
                                                .attr("y", 0)
                                                .each(function(t){

                                                    textWrap()
                                                        .align("middle")
                                                        .container( d3.select(this) )
                                                        .height(square_size)
                                                        .padding(vars.ui.padding)
                                                        .resize(size.length > 1)
                                                        .size(size)
                                                        .text( names[0] )
                                                        .width(square_size)
                                                        .valign("middle")
                                                        .draw();

                                                })

                                            if (text.select("tspan").empty()) {
                                                text.remove();
                                            }

                                        }

                                    }

                                    return color;
                                }

                            });

                    }

                    var colorInt = {};
                    var keys = vars.g.legend.selectAll("g.d3plus_color")
                        .data(colors,function(d){
                            var c = fetchColor(vars, d, colorKey);
                            if (!(c in colorInt)) colorInt[c] = -1;
                            colorInt[c]++;
                            return colorInt[c]+"_"+c;
                        });

                    keys.enter().append("g")
                        .attr("class","d3plus_color")
                        .attr("opacity",0)
                        .call(position)
                        .append("rect")
                        .attr("class","d3plus_color")
                        .call(style);

                    keys.order()
                        .transition().duration(vars.draw.timing)
                        .call(position)
                        .attr("opacity", 1)
                        .selectAll("rect.d3plus_color")
                        .call(style);

                    keys.exit()
                        .transition().duration(vars.draw.timing)
                        .attr("opacity",0)
                        .remove();

                    if (vars.legend.tooltip.value) {

                        keys
                            .on(events.over,function(d,i){

                                d3.select(this).style("cursor","pointer");

                                var bounds = this.getBoundingClientRect(),
                                    x = bounds.left + square_size/2 + scroll.x(),
                                    y = bounds.top + square_size/2 + scroll.y() + 5;

                                var id = fetchValue(vars, d, colorKey),
                                    idIndex = vars.id.nesting.indexOf(colorKey),
                                    title = idIndex >= 0 ? fetchText(vars,d,idIndex)[0] :
                                        vars.format.value(fetchValue(vars,d,vars.color.value,colorKey), {"key": vars.color.value, "vars": vars, "data": d});

                                var html, js;
                                if (vars.legend.filters.value && !(id instanceof Array)) {
                                    html = "<div style='text-align:center;'>";
                                    var loc = vars.format.locale.value;
                                    html += "<div class='mute'>"+vars.format.value(loc.method.mute)+"</div>";
                                    html += "<div class='solo'>"+vars.format.value(loc.method.solo)+"</div>";
                                    html += "</div>"
                                    js = function(tooltip) {
                                        var style = {
                                            "border": "1px solid #ccc",
                                            "display": "inline-block",
                                            "margin": "1px 2px",
                                            "padding": "3px 5px"
                                        }
                                        tooltip.select(".mute")
                                            .style(style)
                                            .on(events.over, function(){
                                                d3.select(this).style("cursor", "pointer");
                                            })
                                            .on(events.click, function(){
                                                var mute = vars.id.mute.value;
                                                vars.history.states.push(function(){
                                                    vars.self.id({"mute": mute}).draw();
                                                })
                                                vars.self.id({"mute": id}).draw();
                                            });
                                        tooltip.select(".solo")
                                            .style(style)
                                            .on(events.over, function(){
                                                d3.select(this).style("cursor", "pointer");
                                            })
                                            .on(events.click, function(){
                                                var solo = vars.id.solo.value;
                                                vars.history.states.push(function(){
                                                    vars.self.id({"solo": solo}).draw();
                                                })
                                                vars.self.id({"solo": id}).draw();
                                            });
                                    }
                                }

                                createTooltip({
                                    "data": d,
                                    "html": html,
                                    "js": js,
                                    "depth": colorDepth,
                                    "footer": false,
                                    "vars": vars,
                                    "x": x,
                                    "y": y,
                                    "mouseevents": this,
                                    "title": title,
                                    "offset": square_size*0.4
                                });

                            })
                            .on(events.out,function(d){
                                removeTooltip(vars.type.value);
                            });

                    }

                    if ( vars.dev.value ) print.timeEnd("drawing legend");

                }

            }
            else if (vars.color.valueScale) {

                if ( vars.dev.value ) print.time("drawing color scale");

                vars.g.legend.selectAll("g.d3plus_color")
                    .transition().duration(vars.draw.timing)
                    .attr("opacity",0)
                    .remove();

                var values = vars.color.valueScale.domain(),
                    colors = vars.color.valueScale.range();

                if (values.length <= 2) {
                    values = buckets(values,6);
                }

                var scale = vars.g.legend.selectAll("g.d3plus_scale")
                    .data(["scale"]);

                scale.enter().append("g")
                    .attr("class","d3plus_scale")
                    .attr("opacity",0);

                var heatmap = scale.selectAll("#d3plus_legend_heatmap")
                    .data(["heatmap"]);

                heatmap.enter().append("linearGradient")
                    .attr("id", "d3plus_legend_heatmap")
                    .attr("x1", "0%")
                    .attr("y1", "0%")
                    .attr("x2", "100%")
                    .attr("y2", "0%")
                    .attr("spreadMethod", "pad");

                var stops = heatmap.selectAll("stop")
                    .data(d3.range(0,colors.length));

                stops.enter().append("stop")
                    .attr("stop-opacity",1);

                stops
                    .attr("offset",function(i){
                        return Math.round((i/(colors.length-1))*100)+"%";
                    })
                    .attr("stop-color",function(i){
                        return colors[i];
                    });

                stops.exit().remove();

                var gradient = scale.selectAll("rect#gradient")
                    .data(["gradient"]);

                gradient.enter().append("rect")
                    .attr("id","gradient")
                    .attr("x",function(d){
                        if (vars.legend.align == "middle") {
                            return vars.width.value/2;
                        }
                        else if (vars.legend.align == "end") {
                            return vars.width.value;
                        }
                        else {
                            return 0;
                        }
                    })
                    .attr("y",vars.ui.padding)
                    .attr("width", 0)
                    .attr("height", vars.legend.gradient.height)
                    .attr("stroke",vars.legend.font.color)
                    .attr("stroke-width",1)
                    .style("fill", "url(#d3plus_legend_heatmap)");

                var text = scale.selectAll("text.d3plus_tick")
                    .data(d3.range(0,values.length));

                text.enter().append("text")
                    .attr("class","d3plus_tick")
                    .attr("stroke", "none")
                    .attr("x",function(d){
                        if (vars.legend.align == "middle") {
                            return vars.width.value/2;
                        }
                        else if (vars.legend.align == "end") {
                            return vars.width.value;
                        }
                        else {
                            return 0;
                        }
                    })
                    .attr("y",function(d){
                        return this.getBBox().height+vars.legend.gradient.height+vars.ui.padding*2;
                    });

                var label_width = 0;

                text
                    .order()
                    .attr("font-weight",vars.legend.font.weight)
                    .attr("font-family",vars.legend.font.family.value)
                    .attr("font-size",vars.legend.font.size+"px")
                    .style("text-anchor",vars.legend.font.align)
                    .attr("fill",vars.legend.font.color)
                    .text(function(d){
                        return vars.format.value(values[d], {"key": vars.color.value, "vars": vars});
                    })
                    .attr("y",function(d){
                        return this.getBBox().height+vars.legend.gradient.height+vars.ui.padding*2;
                    })
                    .each(function(d){
                        var w = Math.ceil(this.getBBox().width);
                        if (w > label_width) label_width = w;
                    });

                label_width += vars.labels.padding*2;

                var key_width = label_width * (values.length-1);

                if (key_width+label_width < vars.width.value) {

                    if (key_width+label_width < vars.width.value/2) {
                        key_width = vars.width.value/2;
                        label_width = key_width/values.length;
                        key_width -= label_width;
                    }

                    var start_x;
                    if (vars.legend.align == "start") {
                        start_x = vars.ui.padding;
                    }
                    else if (vars.legend.align == "end") {
                        start_x = vars.width.value - vars.ui.padding - key_width;
                    }
                    else {
                        start_x = vars.width.value/2 - key_width/2;
                    }

                    text.transition().duration(vars.draw.timing)
                        .attr("x",function(d){
                            return start_x + (label_width*d);
                        });

                    text.exit().transition().duration(vars.draw.timing)
                        .attr("opacity",0)
                        .remove();

                    var ticks = scale.selectAll("rect.d3plus_tick")
                        .data(d3.range(0,values.length));

                    ticks.enter().append("rect")
                        .attr("class","d3plus_tick")
                        .attr("x",function(d){
                            if (vars.legend.align == "middle") {
                                return vars.width.value/2;
                            }
                            else if (vars.legend.align == "end") {
                                return vars.width.value;
                            }
                            else {
                                return 0;
                            }
                        })
                        .attr("y",vars.ui.padding)
                        .attr("width",0)
                        .attr("height",vars.ui.padding+vars.legend.gradient.height)
                        .attr("fill",vars.legend.font.color);

                    ticks.transition().duration(vars.draw.timing)
                        .attr("x",function(d){
                            var mod = d === 0 ? 1 : 0;
                            return start_x + (label_width*d) - mod;
                        })
                        .attr("y",vars.ui.padding)
                        .attr("width",1)
                        .attr("height",vars.ui.padding+vars.legend.gradient.height)
                        .attr("fill",vars.legend.font.color);

                    ticks.exit().transition().duration(vars.draw.timing)
                        .attr("width",0)
                        .remove();

                    gradient.transition().duration(vars.draw.timing)
                        .attr("x",function(d){
                            if (vars.legend.align == "middle") {
                                return vars.width.value/2 - key_width/2;
                            }
                            else if (vars.legend.align == "end") {
                                return vars.width.value - key_width - vars.ui.padding;
                            }
                            else {
                                return vars.ui.padding;
                            }
                        })
                        .attr("y",vars.ui.padding)
                        .attr("width", key_width)
                        .attr("height", vars.legend.gradient.height);

                    scale.transition().duration(vars.draw.timing)
                        .attr("opacity",1);

                    if ( vars.dev.value ) print.timeEnd("drawing color scale");

                }
                else {
                    key_display = false;
                }

            }
            else {
                key_display = false;
            }

        }
        else {
            key_display = false;
        }
        if (vars.legend.value && key && key_display) {

            if ( vars.dev.value ) print.time("positioning legend");

            if (square_size) {
                var key_height = square_size+vars.ui.padding;
            }
            else {
                var key_box = vars.g.legend.node().getBBox(),
                    key_height = key_box.height+key_box.y;
            }

            if (vars.margin.bottom === 0) {
                vars.margin.bottom += vars.ui.padding;
            }
            vars.margin.bottom += key_height;

            vars.g.legend.transition().duration(vars.draw.timing)
                .attr("transform","translate(0,"+(vars.height.value-vars.margin.bottom)+")")

            if ( vars.dev.value ) print.timeEnd("positioning legend")

        }
        else {

            if ( vars.dev.value ) print.time("hiding legend")

            vars.g.legend.transition().duration(vars.draw.timing)
                .attr("transform","translate(0,"+vars.height.value+")")

            if ( vars.dev.value ) print.timeEnd("hiding legend")

        }

    }

},{"../../../array/sort.coffee":36,"../../../client/pointer.coffee":40,"../../../client/scroll.js":43,"../../../client/touch.coffee":45,"../../../color/text.coffee":52,"../../../core/console/print.coffee":54,"../../../core/data/nest.js":62,"../../../core/fetch/color.coffee":65,"../../../core/fetch/text.js":68,"../../../core/fetch/value.coffee":69,"../../../object/validate.coffee":174,"../../../string/strip.js":177,"../../../textwrap/textwrap.coffee":202,"../../../tooltip/remove.coffee":205,"../../../util/buckets.coffee":206,"../../../util/copy.coffee":209,"../../../util/dataURL.coffee":211,"../../../util/uniques.coffee":212,"../tooltip/create.js":242}],248:[function(require,module,exports){
    var events = require("../../../client/pointer.coffee"),
        textColor = require("../../../color/text.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Creates Centered Server Message
//------------------------------------------------------------------------------
    module.exports = function(vars,message) {

        message = vars.messages.value ? message : null;

        var size = vars.messages.style.value || (message === vars.error.internal ?
            "large" : vars.messages.style.backup);

        if (size === "large") {
            var font = vars.messages,
                position = "center"
        }
        else {

            if (vars.footer.value) {
                var font = vars.footer
            }
            else if (vars.title.value) {
                var font = vars.title
            }
            else if (vars.title.sub.value) {
                var font = vars.title.sub
            }
            else if (vars.title.total.value) {
                var font = vars.title.total
            }
            else {
                var font = vars.title.sub
            }

            var position = font.position

        }

        var font = {
            "color": font.font.color,
            "font-family": font.font.family.value,
            "font-weight": font.font.weight,
            "font-size": font.font.size+"px",
            "padding": font.padding+"px"
        }

        var bg = vars.messages.background.value;
        if (!bg) {
            bg = vars.background.value;
            if (bg === "none" || bg === "transparent") {
                bg = textColor(font.color);
            }
        }

        function style(elem) {

            elem
                .style(font)
                .style("position", "absolute")
                .style("background-color", bg)
                .style("text-align", "center")
                .style("left",function(){
                    return position == "center" ? "50%" : "0px"
                })
                .style("width",function(){
                    return position == "center" ? "auto" : vars.width.value+"px"
                })
                .style("margin-left",function(){
                    return position == "center" ? -(this.offsetWidth/2)+"px" : "0px";
                })
                .style("top",function(){
                    if (position == "center") {
                        return "50%";
                    }
                    else if (position == "top") {
                        return "0px"
                    }
                    else {
                        return "auto"
                    }
                })
                .style("bottom",function(){
                    if (position == "bottom") {
                        return "0px"
                    }
                    else {
                        return "auto"
                    }
                })
                .style("margin-top",function(){
                    if (size == "large") {
                        var height = this.offsetHeight || this.getBoundingClientRect().height
                        return -height/2+"px"
                    }
                    return "0px"
                })

        }

        // Enter Message Group
        vars.g.message = vars.container.value.selectAll("div#d3plus_message")
            .data(["message"])

        var enter = vars.g.message.enter().append("div")
            .attr("id","d3plus_message")
            .attr("opacity",0);

        enter.append("div")
            .attr("class", "d3plus_message_text")
            .style("display", "block");

        vars.g.message.select(".d3plus_message_text")
            .text(message ? message : vars.g.message.text())

        var online = navigator.onLine, square = 75;

        var branding = vars.g.message.selectAll(".d3plus_message_branding")
            .data(vars.messages.branding.value && position === "center" ? [0] : []);

        branding.enter().append("div")
            .attr("class", "d3plus_message_branding")
            .style("margin-top", "15px")
            .style("padding-top", "0px")
            .style("display", "block")
            .style("font-size", "11px")
            .style("background-size", square + "px")
            .style("background-position", "center 10px")
            .style("background-repeat", "no-repeat")
            .style("cursor", "pointer")
            .on(events.click, function(){
                window.open("http://www.d3plus.org/", "_blank");
            });

        var logo = d3.hsl(bg).l < 0.5 ? vars.messages.branding.image.dark : vars.messages.branding.image.light;

        branding
            .text(online ? "Powered by:" : "Powered by D3plus")
            .style("background-color", online ? bg : "transparent")
            .style("background-image", online ? "url('" + logo + "')" : "none")
            .style("min-width", online ? square + "px" : "auto")
            .style("height", online ? square + "px" : "auto");

        branding.exit().remove();

        vars.g.message
            .style("display", message ? "inline-block" : "none")
            .call(style).style("opacity", message ? 1 : 0)

    }

},{"../../../client/pointer.coffee":40,"../../../color/text.coffee":52}],249:[function(require,module,exports){
    var closest, css, events, fontSizes, mix, playInterval, prefix, print, textColor, timeDetect;

    closest = require("../../../util/closest.coffee");

    css = require("../../../client/css.coffee");

    fontSizes = require("../../../font/sizes.coffee");

    events = require("../../../client/pointer.coffee");

    mix = require("../../../color/mix.coffee");

    prefix = require("../../../client/prefix.coffee");

    print = require("../../../core/console/print.coffee");

    textColor = require("../../../color/text.coffee");

    timeDetect = require("../../../core/data/time.coffee");

    playInterval = false;

    module.exports = function(vars) {
        var availableWidth, background, brush, brushExtent, brush_group, brushed, brushend, d, end, handles, i, init, j, labelWidth, labels, len, max_index, min, min_index, oldWidth, playButton, playIcon, playIconChar, playIconStyle, playStyle, playUpdate, playbackWidth, setYears, start, start_x, step, stopPlayback, tallEnough, text, textFill, textStyle, tickColor, tickStep, ticks, timeFormat, timeReturn, timelineBox, timelineHeight, timelineOffset, timelineWidth, visible, x, yearHeight, yearMS, year_ticks, years;
        if (vars.timeline.value && (!vars.error.internal || !vars.data.missing) && !vars.small && vars.data.time && vars.data.time.values.length > 1) {
            if (vars.dev.value) {
                print.time("drawing timeline");
            }
            textStyle = {
                "font-weight": vars.ui.font.weight,
                "font-family": vars.ui.font.family.value,
                "font-size": vars.ui.font.size + "px",
                "text-anchor": "middle"
            };
            years = vars.data.time.ticks.map(function(d) {
                return new Date(d);
            });
            timeReturn = timeDetect(vars, {
                values: years,
                style: textStyle
            });
            visible = timeReturn.values.map(Number);
            timeFormat = timeReturn.format;
            if (vars.time.solo.value.length) {
                init = d3.extent(vars.time.solo.value);
                for (i = j = 0, len = init.length; j < len; i = ++j) {
                    d = init[i];
                    if (d.constructor !== Date) {
                        d += "";
                        if (d.length === 4 && parseInt(d) + "" === d) {
                            d += "/01/01";
                        }
                        d = new Date(d);
                        init[i] = d;
                    }
                }
            } else {
                init = d3.extent(years);
            }
            year_ticks = years.slice();
            yearHeight = d3.max(timeReturn.sizes.map(function(t) {
                return t.height;
            }));
            labelWidth = ~~(d3.max(timeReturn.sizes.map(function(t) {
                return t.width;
            }))) + 1;
            labelWidth += vars.ui.padding * 2;
            timelineHeight = vars.timeline.height.value || yearHeight + vars.ui.padding * 2;
            timelineWidth = labelWidth * years.length;
            playbackWidth = timelineHeight;
            tallEnough = timelineHeight - vars.ui.padding * 2 >= yearHeight;
            availableWidth = vars.width.value - vars.ui.padding * 2;
            if (tallEnough && vars.timeline.play.value) {
                availableWidth -= playbackWidth + vars.ui.padding;
            }
            if (!tallEnough || visible.length < years.length || availableWidth < labelWidth * visible.length) {
                oldWidth = labelWidth;
                labelWidth = (availableWidth - labelWidth) / years.length;
                timelineWidth = labelWidth * years.length;
                timelineOffset = 1;
                tickStep = ~~(oldWidth / (timelineWidth / visible.length)) + 1;
                while (tickStep < visible.length - 1) {
                    if ((visible.length - 1) % tickStep === 0) {
                        break;
                    }
                    tickStep++;
                }
                visible = visible.filter(function(t, i) {
                    return i % tickStep === 0;
                });
            } else {
                timelineOffset = 0;
                min = new Date(years[0]);
                step = vars.data.time.stepType;
                min["set" + step](min["get" + step]() + years.length);
                year_ticks.push(min);
            }
            start = new Date(init[0]);
            start = closest(year_ticks, start);
            end = new Date(init[1]);
            if (!timelineOffset) {
                end["set" + vars.data.time.stepType](end["get" + vars.data.time.stepType]() + 1);
            }
            end = closest(year_ticks, end);
            yearMS = year_ticks.map(Number);
            min_index = yearMS.indexOf(+start);
            max_index = yearMS.indexOf(+end);
            brushExtent = [start, end];
            if (vars.timeline.align === "start") {
                start_x = vars.ui.padding;
            } else if (vars.timeline.align === "end") {
                start_x = vars.width.value - vars.ui.padding - timelineWidth;
            } else {
                start_x = vars.width.value / 2 - timelineWidth / 2;
            }
            if (tallEnough && vars.timeline.play.value) {
                start_x += (playbackWidth + vars.ui.padding) / 2;
            }
            stopPlayback = function() {
                clearInterval(playInterval);
                playInterval = false;
                return playIcon.call(playIconChar, "icon");
            };
            brushed = function() {
                var extent, max_val, min_val;
                if (d3.event.sourceEvent !== null) {
                    if (playInterval) {
                        stopPlayback();
                    }
                    brushExtent = brush.extent();
                    min_val = closest(year_ticks, brushExtent[0]);
                    max_val = closest(year_ticks, brushExtent[1]);
                    if (min_val === max_val) {
                        min_index = yearMS.indexOf(+min_val);
                        if (min_val < brushExtent[0] || min_index === 0) {
                            max_val = year_ticks[min_index + 1];
                        } else {
                            min_val = year_ticks[min_index - 1];
                        }
                    }
                    min_index = yearMS.indexOf(+min_val);
                    max_index = yearMS.indexOf(+max_val);
                    if (max_index - min_index >= 1) {
                        extent = [min_val, max_val];
                    } else if (min_index + 1 <= years.length) {
                        extent = [min_val, year_ticks[min_index + 1]];
                    } else {
                        extent = [min_val];
                        i = 1;
                        while (i <= 1) {
                            if (min_index + i <= years.length) {
                                extent.push(year_ticks[min_index + i]);
                            } else {
                                extent.unshift(year_ticks[min_index - ((min_index + i) - years.length)]);
                            }
                            i++;
                        }
                        extent = [extent[0], extent[extent.length - 1]];
                    }
                    brushExtent = extent;
                    text.attr("fill", textFill);
                    return d3.select(this).call(brush.extent(extent));
                }
            };
            setYears = function() {
                var newYears;
                if (max_index - min_index === years.length - timelineOffset) {
                    newYears = [];
                } else {
                    newYears = yearMS.filter(function(t, i) {
                        return i >= min_index && i < (max_index + timelineOffset);
                    });
                    newYears = newYears.map(function(t) {
                        return new Date(t);
                    });
                }
                playUpdate();
                return vars.self.time({
                    "solo": newYears
                }).draw();
            };
            brushend = function() {
                var change, old_max, old_min, solo;
                if (d3.event.sourceEvent !== null) {
                    if (vars.time.solo.value.length) {
                        solo = d3.extent(vars.time.solo.value);
                        old_min = yearMS.indexOf(+closest(year_ticks, solo[0]));
                        old_max = yearMS.indexOf(+closest(year_ticks, solo[1]));
                        change = old_min !== min_index || old_max !== max_index;
                    } else {
                        change = max_index - min_index !== years.length - timelineOffset;
                    }
                    if (change) {
                        return setYears();
                    }
                }
            };
            playButton = vars.g.timeline.selectAll("rect.d3plus_timeline_play").data(tallEnough && vars.timeline.play.value ? [0] : []);
            playStyle = function(btn) {
                return btn.attr("width", playbackWidth + 1).attr("height", timelineHeight + 1).attr("fill", vars.ui.color.primary.value).attr("stroke", vars.ui.color.primary.value).attr("stroke-width", 1).attr("x", start_x - playbackWidth - 1 - vars.ui.padding).attr("y", vars.ui.padding);
            };
            playButton.enter().append("rect").attr("class", "d3plus_timeline_play").attr("shape-rendering", "crispEdges").attr("opacity", 0).call(playStyle);
            playButton.transition().duration(vars.draw.timing).call(playStyle);
            playButton.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
            playIcon = vars.g.timeline.selectAll("text.d3plus_timeline_playIcon").data(tallEnough && vars.timeline.play.value ? [0] : []);
            playIconChar = function(text, char) {
                var font;
                char = vars.timeline.play[char];
                if (css("font-awesome")) {
                    char = char.awesome;
                    font = "FontAwesome";
                } else {
                    char = char.fallback;
                    font = "inherit";
                }
                return text.style("font-family", font).text(char);
            };
            playIconStyle = function(text) {
                var y;
                y = timelineHeight / 2 + vars.ui.padding + 1;
                return text.attr("fill", textColor(vars.ui.color.primary.value)).attr("stroke", "none").attr(textStyle).attr("x", start_x - (playbackWidth - 1) / 2 - vars.ui.padding).attr("y", y).attr("dy", "0.5ex").call(playIconChar, playInterval ? "pause" : "icon");
            };
            playIcon.enter().append("text").attr("class", "d3plus_timeline_playIcon").call(playIconStyle).style("pointer-events", "none").attr("opacity", 0);
            playIcon.call(playIconStyle).transition().duration(vars.draw.timing).attr("opacity", 1);
            playIcon.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
            playUpdate = function() {
                if (max_index - min_index === years.length - timelineOffset) {
                    playButton.on(events.hover, null).on(events.click, null).transition().duration(vars.draw.timing).attr("opacity", 0.3);
                    return playIcon.transition().duration(vars.draw.timing).attr("opacity", 0.3);
                } else {
                    playButton.on(events.over, function() {
                        return d3.select(this).style("cursor", "pointer");
                    }).on(events.out, function() {
                        return d3.select(this).style("cursor", "auto");
                    }).on(events.click, function() {
                        if (playInterval) {
                            return stopPlayback();
                        } else {
                            playIcon.call(playIconChar, "pause");
                            if (max_index === years.length) {
                                max_index = max_index - min_index;
                                min_index = 0;
                            } else {
                                min_index++;
                                max_index++;
                            }
                            setYears();
                            return playInterval = setInterval(function() {
                                if (max_index === years.length - timelineOffset) {
                                    return stopPlayback();
                                } else {
                                    min_index++;
                                    max_index++;
                                    return setYears();
                                }
                            }, vars.timeline.play.timing.value);
                        }
                    }).transition().duration(vars.draw.timing).attr("opacity", 1);
                    return playIcon.transition().duration(vars.draw.timing).attr("opacity", 1);
                }
            };
            playUpdate();
            textFill = function(d) {
                var color, less, opacity;
                less = timelineOffset ? d <= brushExtent[1] : d < brushExtent[1];
                if (d >= brushExtent[0] && less) {
                    opacity = 1;
                    color = textColor(vars.ui.color.secondary.value);
                } else {
                    opacity = 0.5;
                    color = textColor(vars.ui.color.primary.value);
                }
                if (timelineOffset && vars.background.value && vars.background.value !== "none") {
                    color = d3.rgb(textColor(vars.background.value));
                }
                color = d3.rgb(color);
                return "rgba(" + color.r + "," + color.g + "," + color.b + "," + opacity + ")";
            };
            background = vars.g.timeline.selectAll("rect.d3plus_timeline_background").data(["background"]);
            background.enter().append("rect").attr("class", "d3plus_timeline_background").attr("shape-rendering", "crispEdges").attr("width", timelineWidth + 2).attr("height", timelineHeight + 2).attr("fill", vars.ui.color.primary.value).attr("x", start_x - 1).attr("y", vars.ui.padding);
            background.transition().duration(vars.draw.timing).attr("width", timelineWidth + 2).attr("height", timelineHeight + 2).attr("fill", vars.ui.color.primary.value).attr("x", start_x - 1).attr("y", vars.ui.padding);
            ticks = vars.g.timeline.selectAll("g#ticks").data(["ticks"]);
            ticks.enter().append("g").attr("id", "ticks").attr("transform", "translate(" + vars.width.value / 2 + "," + vars.ui.padding + ")");
            brush_group = vars.g.timeline.selectAll("g#brush").data(["brush"]);
            brush_group.enter().append("g").attr("id", "brush");
            labels = vars.g.timeline.selectAll("g#labels").data(["labels"]);
            labels.enter().append("g").attr("id", "labels");
            text = labels.selectAll("text").data(years, function(d, i) {
                return i;
            });
            text.enter().append("text").attr("stroke", "none").attr("y", 0).attr("dy", "0.5ex").attr("x", 0);
            x = d3.time.scale().domain(d3.extent(year_ticks)).rangeRound([0, timelineWidth]);
            text.order().attr(textStyle).text(function(d, i) {
                if (visible.indexOf(+d) >= 0) {
                    return timeFormat(d);
                } else {
                    return "";
                }
            }).attr("opacity", function(d, i) {
                if (vars.data.time.dataSteps.indexOf(i) >= 0) {
                    return 1;
                } else {
                    return 0.4;
                }
            }).attr("fill", textFill).attr("transform", function(d, i) {
                var dx, dy;
                dx = start_x + x(d);
                if (!timelineOffset) {
                    dx += labelWidth / 2;
                }
                dy = timelineHeight / 2 + vars.ui.padding + 1;
                if (timelineOffset) {
                    dy += timelineHeight / 2 + yearHeight;
                }
                return "translate(" + Math.round(dx) + "," + Math.round(dy) + ")";
            });
            text.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
            brush = d3.svg.brush().x(x).extent(brushExtent).on("brush", brushed).on("brushend", brushend);
            if (vars.axes.discrete && vars[vars.axes.discrete].value === vars.time.value) {
                tickColor = vars[vars.axes.discrete].ticks.color;
            } else {
                tickColor = vars.x.ticks.color;
            }
            ticks.attr("transform", "translate(" + start_x + "," + (vars.ui.padding + 1) + ")").transition().duration(vars.draw.timing).call(d3.svg.axis().scale(x).orient("top").ticks(function() {
                return year_ticks;
            }).tickFormat("").tickSize(-timelineHeight).tickPadding(0)).selectAll("line").attr("stroke-width", 1).attr("shape-rendering", "crispEdges").attr("stroke", function(d) {
                if (visible.indexOf(+d) >= 0) {
                    return tickColor;
                } else {
                    return mix(tickColor, vars.background.value, 0.4, 1);
                }
            });
            ticks.selectAll("path").attr("fill", "none");
            brush_group.attr("transform", "translate(" + start_x + "," + (vars.ui.padding + 1) + ")").attr("opacity", 1).call(brush);
            text.attr("pointer-events", "none");
            brush_group.selectAll("rect.background").attr("fill", "none").style("visibility", "visible").attr("height", timelineHeight).attr("shape-rendering", "crispEdges").on(events.move, function() {
                var c;
                c = vars.timeline.hover.value;
                if (["grab", "grabbing"].indexOf(c) >= 0) {
                    c = prefix() + c;
                }
                return d3.select(this).style("cursor", c);
            });
            brush_group.selectAll("rect.extent").attr("opacity", 0.75).attr("height", timelineHeight).attr("fill", vars.ui.color.secondary.value).attr("shape-rendering", "crispEdges").on(events.move, function() {
                var c;
                c = vars.timeline.hover.value;
                if (["grab", "grabbing"].indexOf(c) >= 0) {
                    c = prefix() + c;
                }
                return d3.select(this).style("cursor", c);
            });
            if (vars.timeline.handles.value) {
                handles = brush_group.selectAll("g.resize").selectAll("rect.d3plus_handle").data(["d3plus_handle"]);
                handles.enter().insert("rect", "rect").attr("class", "d3plus_handle");
                handles.attr("fill", vars.timeline.handles.color).attr("transform", function(d) {
                    var mod;
                    if (this.parentNode.className.baseVal === "resize e") {
                        mod = -vars.timeline.handles.size;
                    } else {
                        mod = 0;
                    }
                    return "translate(" + mod + ",0)";
                }).attr("width", vars.timeline.handles.size).style("visibility", "visible").attr("shape-rendering", "crispEdges").attr("opacity", vars.timeline.handles.opacity);
                brush_group.selectAll("g.resize").selectAll("rect").attr("height", timelineHeight);
            } else {
                brush_group.selectAll("g.resize").remove();
            }
            timelineBox = vars.g.timeline.node().getBBox();
            if (vars.margin.bottom === 0) {
                vars.margin.bottom += vars.ui.padding;
            }
            vars.margin.bottom += timelineBox.height + timelineBox.y;
            vars.g.timeline.transition().duration(vars.draw.timing).attr("transform", "translate(0," + Math.round(vars.height.value - vars.margin.bottom - vars.ui.padding / 2) + ")");
            vars.margin.bottom += vars.ui.padding;
            if (vars.dev.value) {
                return print.time("drawing timeline");
            }
        } else {
            return vars.g.timeline.transition().duration(vars.draw.timing).attr("transform", "translate(0," + vars.height.value + ")");
        }
    };


},{"../../../client/css.coffee":38,"../../../client/pointer.coffee":40,"../../../client/prefix.coffee":41,"../../../color/mix.coffee":48,"../../../color/text.coffee":52,"../../../core/console/print.coffee":54,"../../../core/data/time.coffee":64,"../../../font/sizes.coffee":103,"../../../util/closest.coffee":208}],250:[function(require,module,exports){
    var events = require("../../../client/pointer.coffee"),
        fetchValue = require("../../../core/fetch/value.coffee"),
        print      = require("../../../core/console/print.coffee"),
        rtl        = require("../../../client/rtl.coffee"),
        textWrap   = require("../../../textwrap/textwrap.coffee")
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Draws appropriate titles
//------------------------------------------------------------------------------
    module.exports = function(vars) {

        var total_key = vars.size.value ? vars.size.value
            : vars.color.type === "number" ? vars.color.value : false

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If there is no data or the title bar is not needed,
        // set the total value to 'null'
        //----------------------------------------------------------------------------
        if (!vars.data.viz || !vars.title.total.value || vars.small) {
            var total = false
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Otherwise, let's calculate it!
        //----------------------------------------------------------------------------
        else if (total_key) {

            if ( vars.dev.value ) {
                print.time("calculating total value")
            }

            var total_data = vars.data.pool;
            if (vars.focus.value.length) {
                total_data = vars.data.viz.filter(function(d){
                    return d[vars.id.value] == vars.focus.value[0];
                });
            }

            var agg = vars.aggs.value[total_key] || "sum";
            var total;
            if (agg.constructor === Function) {
                total = agg(total_data);
            }
            else {

                total_data = total_data.reduce(function(arr, d){
                    var vals = fetchValue(vars, d, total_key);
                    if (vals instanceof Array) arr = arr.concat(vals);
                    else arr.push(vals);
                    return arr;
                }, []);

                total = d3[agg](total_data);
            }

            if (total === 0 || total === null || total === undefined) {
                total = false
            }

            if (typeof total === "number") {

                var pct = ""

                if (vars.data.mute.length || vars.data.solo.length || vars.focus.value.length) {

                    var overall_total = d3.sum(vars.data.value, function(d){
                        if (vars.time.solo.value.length > 0) {
                            var match = vars.time.solo.value.indexOf(fetchValue(vars,d,vars.time.value)) >= 0
                        }
                        else if (vars.time.mute.value.length > 0) {
                            var match = vars.time.solo.value.indexOf(fetchValue(vars,d,vars.time.value)) < 0
                        }
                        else {
                            var match = true
                        }
                        if (match) {
                            return fetchValue(vars,d,total_key)
                        }
                    })

                    if (overall_total > total) {

                        var pct = (total/overall_total)*100,
                            ot = vars.format.value(overall_total, {"key": vars.size.value, "vars": vars});

                        pct = " ("+vars.format.value(pct,{"key": "share", "vars": vars})+" of "+ot+")";

                    }
                }

                total = vars.format.value(total, {"key": vars.size.value, "vars": vars})
                var obj = vars.title.total.value
                    , prefix = obj.prefix || vars.format.value(vars.format.locale.value.ui.total)+": "
                total = prefix + total
                obj.suffix ? total = total + obj.suffix : null
                total += pct

            }

            if ( vars.dev.value ) {
                print.timeEnd("calculating total value")
            }

        }
        else {
            var total = false
        }


        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Initialize titles and detect footer
        //----------------------------------------------------------------------------
        var title_data = []

        if (vars.footer.value) {
            title_data.push({
                "link": vars.footer.link,
                "style": vars.footer,
                "type": "footer",
                "value": vars.footer.value
            })
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // If not in "small" mode, detect titles available
        //----------------------------------------------------------------------------
        if (!vars.small) {

            if (vars.title.value) {
                var title = vars.title.value;
                if (typeof title === "function") title = title(vars.self);
                title_data.push({
                    "link": vars.title.link,
                    "style": vars.title,
                    "type": "title",
                    "value": title
                })
            }
            if (vars.title.sub.value) {
                var title = vars.title.sub.value;
                if (typeof title === "function") title = title(vars.self);
                title_data.push({
                    "link": vars.title.sub.link,
                    "style": vars.title.sub,
                    "type": "sub",
                    "value": title
                })
            }
            if (vars.title.total.value && total) {
                title_data.push({
                    "link": vars.title.total.link,
                    "style": vars.title.total,
                    "type": "total",
                    "value": total
                })
            }

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Enter Titles
        //----------------------------------------------------------------------------
        function style(title) {

            title
                .attr("font-size",function(t){
                    return t.style.font.size
                })
                .attr("fill",function(t){
                    return t.link ? vars.links.font.color : t.style.font.color
                })
                .attr("font-family",function(t){
                    return t.link ? vars.links.font.family.value : t.style.font.family.value
                })
                .attr("font-weight",function(t){
                    return t.link ? vars.links.font.weight : t.style.font.weight
                })
                .style("text-decoration",function(t){
                    return t.link ? vars.links.font.decoration.value : t.style.font.decoration.value
                })
                .style("text-transform",function(t){
                    return t.link ? vars.links.font.transform.value : t.style.font.transform.value
                })

        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Enter Titles
        //----------------------------------------------------------------------------
        if ( vars.dev.value ) print.time("drawing titles")
        var titles = vars.svg.selectAll("g.d3plus_title")
            .data(title_data,function(t){
                return t.type
            })

        var titleWidth = vars.title.width || vars.width.value-vars.margin.left-vars.margin.right;

        titles.enter().append("g")
            .attr("class", function(t){
                return "d3plus_title " + t.type;
            })
            .attr("opacity",0)
            .append("text")
            .attr("stroke", "none")
            .call(style)

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Wrap text and calculate positions, then transition style and opacity
        //----------------------------------------------------------------------------
        function getAlign(d) {
            var align = d.style.font.align;
            if (align == "center") {
                return "middle";
            }
            else if ((align == "left" && !rtl) || (align == "right" && rtl)) {
                return "start";
            }
            else if ((align == "left" && rtl) || (align == "right" && !rtl)) {
                return "end";
            }
            return align;
        }
        titles
            .each(function(d){

                var container = d3.select(this).select("text").call(style);

                var align = getAlign(d);

                textWrap()
                    .align(align)
                    .container(container)
                    .height(vars.height.value / 2)
                    .size(false)
                    .text(d.value)
                    .width(titleWidth)
                    .draw()

                d.y = vars.margin[d.style.position]
                vars.margin[d.style.position] += this.getBBox().height + d.style.padding*2

            })
            .on(events.over,function(t){
                if (t.link) {
                    d3.select(this)
                        .transition().duration(vars.timing.mouseevents)
                        .style("cursor","pointer")
                        .select("text")
                        .attr("fill",vars.links.hover.color)
                        .attr("font-family",vars.links.hover.family.value)
                        .attr("font-weight",vars.links.hover.weight)
                        .style("text-decoration",vars.links.hover.decoration.value)
                        .style("text-transform",vars.links.hover.transform.value)
                }
            })
            .on(events.out,function(t){
                if (t.link) {
                    d3.select(this)
                        .transition().duration(vars.timing.mouseevents)
                        .style("cursor","auto")
                        .select("text")
                        .call(style)
                }
            })
            .on(events.click,function(t){
                if (t.link) {
                    var target = t.link.charAt(0) != "/" ? "_blank" : "_self"
                    window.open(t.link,target)
                }
            })
            .attr("opacity",1)
            .attr("transform",function(t){
                var pos = t.style.position,
                    y = pos == "top" ? 0+t.y : vars.height.value-t.y
                if (pos == "bottom") {
                    y -= this.getBBox().height+t.style.padding
                }
                else {
                    y += t.style.padding
                }
                var align = getAlign(t);
                if (align === "start") {
                    var x = vars.margin.left + vars.title.padding;
                }
                else {
                    var w = d3.select(this).select("text").node().getBBox().width;
                    if (align === "middle") {
                        x = vars.width.value/2 - titleWidth/2;
                    }
                    else {
                        x = vars.width.value - titleWidth - vars.margin.right - vars.title.padding;
                    }
                }
                return "translate("+x+","+y+")";
            })

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Exit unused titles
        //----------------------------------------------------------------------------
        titles.exit().transition().duration(vars.draw.timing)
            .attr("opacity",0)
            .remove()

        if ( vars.margin.top > 0 ) {
            vars.margin.top += vars.title.padding
        }

        if ( vars.margin.bottom > 0 ) {
            vars.margin.bottom += vars.title.padding
        }

        var min = vars.title.height
        if (min && vars.margin[vars.title.position] < min) {
            vars.margin[vars.title.position] = min
        }

        if ( vars.dev.value ) print.timeEnd("drawing titles")

    }

},{"../../../client/pointer.coffee":40,"../../../client/rtl.coffee":42,"../../../core/console/print.coffee":54,"../../../core/fetch/value.coffee":69,"../../../textwrap/textwrap.coffee":202}],251:[function(require,module,exports){
    var labels, transform;

    labels = require("./labels.coffee");

    transform = require("./transform.coffee");

    module.exports = function(vars, b, timing) {
        var aspect, extent, fit, max_scale, min, padding, scale, translate, type;
        if (!b) {
            b = vars.zoom.bounds;
        }
        if (typeof timing !== "number") {
            timing = vars.timing.transitions;
        }
        vars.zoom.size = {
            height: b[1][1] - b[0][1],
            width: b[1][0] - b[0][0]
        };
        type = vars.types[vars.type.value];
        fit = vars.coords.fit.value;
        if (fit === "auto" || type.requirements.indexOf("coords") < 0) {
            aspect = d3.max([vars.zoom.size.width / vars.width.viz, vars.zoom.size.height / vars.height.viz]);
        } else {
            aspect = vars.zoom.size[fit] / vars["app_" + fit];
        }
        min = d3.min([vars.width.viz, vars.height.viz]);
        padding = type.zoom ? vars.coords.padding * 2 : 0;
        scale = ((min - padding) / min) / aspect;
        extent = vars.zoom.behavior.scaleExtent();
        if (extent[0] === extent[1] || b === vars.zoom.bounds) {
            vars.zoom.behavior.scaleExtent([scale, scale * 16]);
        }
        max_scale = vars.zoom.behavior.scaleExtent()[1];
        if (scale > max_scale) {
            scale = max_scale;
        }
        vars.zoom.scale = scale;
        translate = [vars.width.viz / 2 - (vars.zoom.size.width * scale) / 2 - (b[0][0] * scale), vars.height.viz / 2 - (vars.zoom.size.height * scale) / 2 - (b[0][1] * scale)];
        vars.zoom.translate = translate;
        vars.zoom.behavior.translate(translate).scale(scale);
        vars.zoom.size = {
            height: vars.zoom.bounds[1][1] - vars.zoom.bounds[0][1],
            width: vars.zoom.bounds[1][0] - vars.zoom.bounds[0][0]
        };
        vars.zoom.reset = false;
        if (vars.labels.value || vars.labels.changed) {
            labels(vars);
        }
        return transform(vars, timing);
    };


},{"./labels.coffee":253,"./transform.coffee":256}],252:[function(require,module,exports){
    module.exports = function(data, vars) {
        var depth, max_depth, nextDepth;
        max_depth = vars.id.nesting.length - 1;
        depth = vars.depth.value;
        nextDepth = vars.id.nesting[depth + 1];
        if (vars.types[vars.type.value].nesting === false) {
            return 0;
        } else if ((data.d3plus.merged || (nextDepth in data && depth < max_depth)) && (!data || nextDepth in data)) {
            return 1;
        } else if (((depth === max_depth && depth > 0) || (data && nextDepth && (!(nextDepth in data)))) && (vars.small || !vars.tooltip.html.value)) {
            return -1;
        } else {
            return 0;
        }
    };


},{}],253:[function(require,module,exports){
    var print;

    print = require("../../../core/console/print.coffee");

    module.exports = function(vars) {
        var opacity, scale;
        if (vars.dev.value) {
            print.time("determining label visibility");
        }
        scale = vars.zoom.behavior.scaleExtent();
        opacity = function(text) {
            return text.attr("opacity", function(d) {
                var size;
                if (!d) {
                    d = {};
                }
                size = parseFloat(d3.select(this).attr("font-size"), 10);
                d.visible = size * (vars.zoom.scale / scale[1]) >= 2;
                if (d.visible) {
                    return 1;
                } else {
                    return 0;
                }
            });
        };
        if (vars.draw.timing) {
            vars.g.viz.selectAll("text.d3plus_label").transition().duration(vars.draw.timing).call(opacity);
        } else {
            vars.g.viz.selectAll("text.d3plus_label").call(opacity);
        }
        if (vars.dev.value) {
            return print.timeEnd("determining label visibility");
        }
    };


},{"../../../core/console/print.coffee":54}],254:[function(require,module,exports){
    var labels, removeTooltip, transform;

    labels = require("./labels.coffee");

    removeTooltip = require("../../../tooltip/remove.coffee");

    transform = require("./transform.coffee");

    module.exports = function(vars) {
        var delay, eventType, limits, scale, translate, xmax, xmin, xoffset, ymax, ymin, yoffset;
        eventType = d3.event.sourceEvent ? d3.event.sourceEvent.type : null;
        translate = d3.event.translate;
        scale = d3.event.scale;
        limits = vars.zoom.bounds;
        xoffset = (vars.width.viz - (vars.zoom.size.width * scale)) / 2;
        xmin = (xoffset > 0 ? xoffset : 0);
        xmax = (xoffset > 0 ? vars.width.viz - xoffset : vars.width.viz);
        yoffset = (vars.height.viz - (vars.zoom.size.height * scale)) / 2;
        ymin = (yoffset > 0 ? yoffset : 0);
        ymax = (yoffset > 0 ? vars.height.viz - yoffset : vars.height.viz);
        if (translate[0] + limits[0][0] * scale > xmin) {
            translate[0] = -limits[0][0] * scale + xmin;
        } else if (translate[0] + limits[1][0] * scale < xmax) {
            translate[0] = xmax - (limits[1][0] * scale);
        }
        if (translate[1] + limits[0][1] * scale > ymin) {
            translate[1] = -limits[0][1] * scale + ymin;
        } else if (translate[1] + limits[1][1] * scale < ymax) {
            translate[1] = ymax - (limits[1][1] * scale);
        }
        vars.zoom.behavior.translate(translate).scale(scale);
        vars.zoom.translate = translate;
        vars.zoom.scale = scale;
        if (eventType === "wheel") {
            removeTooltip(vars.type.value);
        }
        if (vars.labels.value || vars.labels.changed) {
            if (eventType === "wheel") {
                delay = (vars.draw.timing ? 100 : 250);
                clearTimeout(vars.zoom.wheel);
                vars.zoom.wheel = setTimeout(function() {
                    return labels(vars);
                }, delay);
            } else {
                labels(vars);
            }
        }
        if (eventType === "dblclick") {
            return transform(vars, vars.timing.transitions);
        } else {
            return transform(vars, 0);
        }
    };


},{"../../../tooltip/remove.coffee":205,"./labels.coffee":253,"./transform.coffee":256}],255:[function(require,module,exports){
    module.exports = function(vars, event) {
        var enabled, zoom, zoomable, zoomed;
        zoom = vars.zoom;
        if (!event) {
            event = d3.event;
        }
        zoomed = zoom.scale > zoom.behavior.scaleExtent()[0];
        enabled = vars.types[vars.type.value].zoom && zoom.value && zoom.scroll.value;
        zoomable = event.touches && event.touches.length > 1 && enabled;
        if (!zoomable && !zoomed) {
            event.stopPropagation();
        }
    };


},{}],256:[function(require,module,exports){
    module.exports = function(vars, timing) {
        var translate;
        if (typeof timing !== "number") {
            timing = vars.timing.transitions;
        }
        translate = "translate(" + vars.zoom.translate + ")";
        translate += "scale(" + vars.zoom.scale + ")";
        if (timing) {
            return vars.g.viz.transition().duration(timing).attr("transform", translate);
        } else {
            return vars.g.viz.attr("transform", translate);
        }
    };


},{}],257:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Function, Object, String],
        deprecates: "active_var",
        mute: filter(true),
        solo: filter(true),
        spotlight: {
            accepted: [Boolean],
            deprecates: "spotlight",
            value: false
        },
        value: false
    };


},{"../../core/methods/filter.coffee":82}],258:[function(require,module,exports){
    module.exports = {
        accepted: [Object],
        deprecated: "nesting_aggs",
        objectAccess: false,
        value: {}
    };


},{}],259:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/data.coffee");

    module.exports = {
        accepted: [false, Array, Object, String],
        delimiter: {
            accepted: String,
            value: "|"
        },
        filetype: {
            accepted: [false, "json", "xml", "html", "csv", "dsv", "tsv", "txt"],
            value: false
        },
        keys: {},
        process: process,
        value: false
    };


},{"../../core/methods/process/data.coffee":88}],260:[function(require,module,exports){
    var rendering;

    rendering = require("../../core/methods/rendering.coffee");

    module.exports = {
        background: {
            color: "#fafafa",
            rendering: rendering(),
            stroke: {
                color: "#ccc",
                width: 1
            }
        },
        mirror: {
            accepted: [Boolean],
            deprecates: ["mirror_axis", "mirror_axes"],
            value: false
        },
        ticks: {
            accepted: [Boolean],
            value: true
        }
    };


},{"../../core/methods/rendering.coffee":93}],261:[function(require,module,exports){
    module.exports = {
        accepted: [String],
        value: "#ffffff"
    };


},{}],262:[function(require,module,exports){
    module.exports = {
        accepted: [Function, String],
        value: false
    };


},{}],263:[function(require,module,exports){
    var filter, scale;

    filter = require("../../core/methods/filter.coffee");

    scale = require("../../color/scale.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        deprecates: "color_var",
        focus: "#444444",
        heatmap: ["#282F6B", "#419391", "#AFD5E8", "#EACE3F", "#B35C1E", "#B22200"],
        missing: "#eeeeee",
        mute: filter(true),
        primary: "#d74b03",
        range: ["#B22200", "#FFEE8D", "#759143"],
        scale: {
            accepted: [Array, Function, "d3plus", "category10", "category20", "category20b", "category20c"],
            process: function(value) {
                if (value instanceof Array) {
                    return d3.scale.ordinal().range(value);
                } else if (value === "d3plus") {
                    return scale;
                } else if (typeof value === "string") {
                    return d3.scale[value]();
                } else {
                    return value;
                }
            },
            value: "d3plus"
        },
        solo: filter(true),
        secondary: "#e5b3bb",
        value: false
    };


},{"../../color/scale.coffee":50,"../../core/methods/filter.coffee":82}],264:[function(require,module,exports){
    module.exports = {
        "accepted": [Array, Function, String],
        "index": {
            "accepted": [Boolean],
            "value": true
        },
        "process": function(value, vars) {
            if (typeof value === "string") value = [value]
            return value
        },
        "value": false
    }

},{}],265:[function(require,module,exports){
    arguments[4][109][0].apply(exports,arguments)
},{"dup":109}],266:[function(require,module,exports){
    var d3selection;

    d3selection = require("../../util/d3selection.coffee");

    module.exports = {
        accepted: [false, Array, Object, String],
        id: "default",
        process: function(value, vars) {
            if (value === false) {
                return false;
            }
            if (vars.container.id === "default") {
                vars.self.container({
                    id: "d3plus_" + +new Date()
                });
            }
            if (d3selection(value)) {
                return value.append("div");
            } else if (value instanceof Array) {
                return d3.select(value[0][0]).append("div");
            } else {
                return d3.select(value).append("div");
            }
        },
        value: false
    };


},{"../../util/d3selection.coffee":210}],267:[function(require,module,exports){
    var filter, process;

    filter = require("../../core/methods/filter.coffee");

    process = require("../../core/methods/process/data.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        center: [0, 0],
        filetype: {
            accepted: ["json"],
            value: "json"
        },
        fit: {
            accepted: ["auto", "height", "width"],
            value: "auto"
        },
        key: false,
        mute: filter(false),
        padding: 20,
        process: process,
        projection: {
            accepted: ["albers", "albersUsa", "azimuthalEqualArea", "azimuthalEquidistant", "conicConformal", "conicEqualArea", "conicEquidistant", "equirectangular", "gnomonic", "mercator", "orthographic", "stereographic", "transverseMercator", Function],
            value: "mercator"
        },
        simplify: {
            accepted: [Boolean],
            value: true
        },
        solo: filter(false),
        threshold: {
            accepted: [Number],
            value: 0.9
        },
        value: false
    };


},{"../../core/methods/filter.coffee":82,"../../core/methods/process/data.coffee":88}],268:[function(require,module,exports){
    var fetchValue, ie, stringStrip;

    fetchValue = require("../../core/fetch/value.coffee");

    ie = require("../../client/ie.js");

    stringStrip = require("../../string/strip.js");

    module.exports = {
        accepted: [void 0, true, Array, String],
        chainable: false,
        data: [],
        process: function(value, vars) {
            var blob, c, col, columns, csv_data, csv_to_return, d, dataString, encodedUri, i, j, k, l, len, len1, len2, len3, len4, len5, len6, len7, link, m, max_filename_len, n, node, o, p, q, ref, ref1, ref2, row, title, titles, val;

            window.d3plusResized = typeof(window.d3plusResized) != 'undefined' ? window.d3plusResized : false;

            if (vars.returned === void 0) {
                return [];
            }
            value = value || vars.cols.value;
            if (value instanceof Array) {
                columns = value;
            } else if (typeof value === "string") {
                columns = [value];
            }
            csv_to_return = [];
            titles = [];
            if (vars.title.value) {
                title = vars.title.value;
                if (typeof title === "function") {
                    title = title(vars.self);
                }
                title = stringStrip(title);
                max_filename_len = 250;
                title = title.substr(0, max_filename_len);
            } else {
                title = "D3plus Visualization Data";
            }
            if (value === true) {
                columns = d3.keys(vars.data.keys);
                csv_to_return.push(columns);
                ref = vars.data.value;
                for (j = 0, len = ref.length; j < len; j++) {
                    d = ref[j];
                    row = [];
                    for (k = 0, len1 = columns.length; k < len1; k++) {
                        c = columns[k];
                        val = d[c];
                        if (vars.data.keys[c] === "string") {
                            val = '"' + val + '"';
                        }
                        row.push(val);
                    }
                    csv_to_return.push(row);
                }
            } else {
                if (!columns) {
                    columns = [vars.id.value];
                    if (vars.time.value) {
                        columns.push(vars.time.value);
                    }
                    if (vars.size.value) {
                        columns.push(vars.size.value);
                    }
                    if (vars.text.value) {
                        columns.push(vars.text.value);
                    }
                }
                for (l = 0, len2 = columns.length; l < len2; l++) {
                    c = columns[l];
                    titles.push(vars.format.value(c));
                }
                csv_to_return.push(titles);
                ref1 = vars.returned.nodes;
                for (m = 0, len3 = ref1.length; m < len3; m++) {
                    node = ref1[m];
                    if ((node.values != null) && node.values instanceof Array) {
                        ref2 = node.values;
                        for (n = 0, len4 = ref2.length; n < len4; n++) {
                            val = ref2[n];
                            row = [];
                            for (o = 0, len5 = columns.length; o < len5; o++) {
                                col = columns[o];
                                val = fetchValue(vars, val, col);
                                if (typeof val === "string") {
                                    val = '"' + val + '"';
                                }
                                row.push(val);
                            }
                            csv_to_return.push(row);
                        }
                    } else {
                        row = [];
                        for (p = 0, len6 = columns.length; p < len6; p++) {
                            col = columns[p];
                            row.push(fetchValue(vars, node, col));
                        }
                        csv_to_return.push(row);
                    }
                }
            }
            // csv_data = "data:text/csv;charset=utf-8,";
            csv_data = "";
            for (i = q = 0, len7 = csv_to_return.length; q < len7; i = ++q) {
                c = csv_to_return[i];
                dataString = c.join(",");
                csv_data += (i < csv_to_return.length ? dataString + "\n" : dataString);
            }
            if (ie) {
                blob = new Blob([csv_data], {
                    type: "text/csv;charset=utf-8;"
                });
                if(window.d3plusResized == false) {
                    navigator.msSaveBlob(blob, title + ".csv");
                }
            } else {
                var blob = new Blob([csv_data], {type: "text/csv;charset=utf-8;"});
                var link = document.createElement("a");
                if (link.download !== undefined && window.d3plusResized == false) {
                    var url = URL.createObjectURL(blob);
                    link.setAttribute("href", url);
                    link.setAttribute("download", title + ".csv");
                    link.style = "visibility:hidden";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            }

            window.d3plusResized = false;

            this.data = csv_to_return;
            return columns;
        },
        value: void 0
    };


},{"../../client/ie.js":39,"../../core/fetch/value.coffee":69,"../../string/strip.js":177}],269:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/data.coffee");

    module.exports = {
        accepted: [false, Array, Function, String],
        cache: {},
        delimiter: {
            accepted: [String],
            value: "|"
        },
        donut: {
            size: 0.35
        },
        filetype: {
            accepted: [false, "json", "xml", "html", "csv", "dsv", "tsv", "txt"],
            value: false
        },
        filters: [],
        keys: {},
        mute: [],
        large: 400,
        opacity: 0.9,
        padding: {
            accepted: [Number],
            value: 1
        },
        process: function(value, vars) {
            return process(value, vars, this);
        },
        solo: [],
        stroke: {
            width: 1
        },
        value: false
    };


},{"../../core/methods/process/data.coffee":88}],270:[function(require,module,exports){
    module.exports = {
        accepted: [Function, Number],
        value: 0
    };


},{}],271:[function(require,module,exports){
    module.exports = {
        accepted: [false, Function, Object],
        value: false
    };


},{}],272:[function(require,module,exports){
    arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],273:[function(require,module,exports){
    var print        = require("../../core/console/print.coffee"),
        stringFormat = require("../../string/format.js")

    module.exports = {
        "accepted" : [ undefined , Function ],
        "first"    : true,
        "frozen"   : false,
        "process"  : function (value, vars) {

            if ( this.initialized === false ) {
                this.initialized = true
                return value
            }

            if ( value === undefined && typeof this.value === "function" ) {
                value = this.value
            }

            if ( vars.container.value === false ) {

                var str = vars.format.locale.value.dev.setContainer
                print.warning( str , "container" )

            }
            else if ( vars.container.value.empty() ) {

                var str = vars.format.locale.value.dev.noContainer
                print.warning( stringFormat(str,"\""+vars.container.value+"\"") , "container" )

            }
            else {

                if ( vars.dev.value ) print.time("total draw time");

                vars.container.value.call(vars.self);

            }

            if ( typeof value === "function" && vars.history.chain.length ) {

                var changesObject = {}
                changes.forEach(function(c){
                    var method = c.method
                    delete c.method
                    changesObject[method] = c
                })

                value(changesObject)

                vars.history.chain = []

            }

            return value

        },
        "update"   : true,
        "value"    : undefined
    }

},{"../../core/console/print.coffee":54,"../../string/format.js":175}],274:[function(require,module,exports){
    var process = require("../../core/methods/process/data.coffee");

    module.exports = {
        "accepted": [false, Array, Function, String],
        "arrows":   {
            "accepted":  [ Boolean , Number ],
            "direction": {
                "accepted": [ "source" , "target" ],
                "value":    "target"
            },
            "value": false
        },
        "color":       "#d0d0d0",
        "connections": function(focus,id,objects) {

            var self = this

            if (!self.value) {
                return []
            }

            if (!id) var id = "id"

            var edges = self.restricted || self.value,
                targets = []

            if (!focus) {
                return edges
            }

            var connections = edges.filter(function(edge){

                var match = false

                if (edge[self.source][id] == focus) {
                    match = true
                    if (objects) {
                        targets.push(edge[self.target])
                    }
                }
                else if (edge[self.target][id] == focus) {
                    match = true
                    if (objects) {
                        targets.push(edge[self.source])
                    }
                }

                return match

            })

            return objects ? targets : connections

        },
        "delimiter": {
            "accepted": [ String ],
            "value":    "|"
        },
        "filetype": {
            "accepted": [false, "json", "xml","html", "csv", "dsv", "tsv", "txt"],
            "value":    false
        },
        "interpolate": {
            "accepted": ["basis", "cardinal", "linear", "monotone", "step"],
            "value":    "basis"
        },
        "label": false,
        "large": 100,
        "limit": {
            "accepted": [false, Function, Number],
            "value":    false
        },
        "opacity": {
            "accepted": [Function, Number, String],
            "min": {
                "accepted": [Number],
                "value": 0.25
            },
            "scale": {
                "accepted": [Function],
                "value": d3.scale.linear()
            },
            "value": 1
        },
        "process":  process,
        "size": {
            "accepted": [false, Number, String],
            "min": 1,
            "scale": 0.5,
            "value": false
        },
        "source":   "source",
        "strength": {
            "accepted": [false, Function, Number, String],
            "value":    false
        },
        "target": "target",
        "value":  false
    };

},{"../../core/methods/process/data.coffee":88}],275:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean, String],
        value: false
    };


},{}],276:[function(require,module,exports){
    module.exports = {
        accepted: [false, Array, Function, Number, String],
        deprecates: "highlight",
        process: function(value) {
            if (value === false) {
                return [];
            } else if (value instanceof Array) {
                return value;
            } else {
                return [value];
            }
        },
        tooltip: {
            accepted: [Boolean],
            value: true
        },
        value: []
    };


},{}],277:[function(require,module,exports){
    var align, decoration, family, transform;

    align = require("../../core/methods/font/align.coffee");

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        align: align(),
        color: "#444444",
        decoration: decoration(),
        family: family(),
        secondary: {
            align: align(),
            color: "#444444",
            decoration: decoration(),
            family: family(),
            size: 12,
            spacing: 0,
            transform: transform(),
            weight: 200
        },
        size: 12,
        spacing: 0,
        transform: transform(),
        weight: 200
    };


},{"../../core/methods/font/align.coffee":83,"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],278:[function(require,module,exports){
    var decoration, family, transform;

    family = require("../../core/methods/font/family.coffee");

    decoration = require("../../core/methods/font/decoration.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        accepted: [false, Number, String],
        font: {
            align: "center",
            color: "#444",
            decoration: decoration(),
            family: family(),
            size: 11,
            transform: transform(),
            weight: 200
        },
        link: false,
        padding: 0,
        position: "bottom",
        value: false
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],279:[function(require,module,exports){
    var formatNumber, locale, mergeObject, titleCase;

    formatNumber = require("../../number/format.coffee");

    locale = require("../../core/locale/locale.coffee");

    mergeObject = require("../../object/merge.coffee");

    titleCase = require("../../string/title.coffee");

    module.exports = {
        accepted: [Function, String],
        affixes: {
            accepted: [Object],
            objectAccess: false,
            value: {}
        },
        deprecates: ["number_format", "text_format"],
        locale: {
            accepted: function() {
                return d3.keys(locale);
            },
            process: function(value) {
                var defaultLocale, returnObject;
                defaultLocale = "en_US";
                returnObject = locale[defaultLocale];
                if (value !== defaultLocale) {
                    returnObject = mergeObject(returnObject, locale[value]);
                }
                this.language = value;
                return returnObject;
            },
            value: "en_US"
        },
        number: {
            accepted: [false, Function],
            value: false
        },
        process: function(value, vars) {
            if (typeof value === "string") {
                vars.self.format({
                    locale: value
                });
            } else {
                if (typeof value === "function") {
                    return value;
                }
            }
            return this.value;
        },
        text: {
            accepted: [false, Function],
            value: false
        },
        value: function(value, opts) {
            var f, v, vars;
            if (!opts) {
                opts = {};
            }
            if (!opts.locale) {
                opts.locale = this.locale.value;
            }
            vars = opts.vars || {};
            if (vars.time && vars.time.value && opts.key === vars.time.value) {
                v = value.constructor === Date ? value : new Date(value);
                return vars.data.time.format(v);
            } else if (typeof value === "number") {
                f = this.number.value || formatNumber;
                return f(value, opts);
            } else if (typeof value === "string") {
                f = this.text.value || titleCase;
                return f(value, opts);
            } else {
                return JSON.stringify(value);
            }
        }
    };


},{"../../core/locale/locale.coffee":80,"../../number/format.coffee":172,"../../object/merge.coffee":173,"../../string/title.coffee":178}],280:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number],
        max: 600,
        secondary: false,
        small: 200,
        value: false
    };


},{}],281:[function(require,module,exports){
    var align, decoration, family, filter, orientMap, position, rendering, transform;

    align = require("../../../core/methods/font/align.coffee");

    decoration = require("../../../core/methods/font/decoration.coffee");

    family = require("../../../core/methods/font/family.coffee");

    filter = require("../../../core/methods/filter.coffee");

    position = require("../../../core/methods/font/position.coffee");

    rendering = require("../../../core/methods/rendering.coffee");

    transform = require("../../../core/methods/font/transform.coffee");

    orientMap = {
        x: "bottom",
        x2: "top",
        y: "left",
        y2: "right"
    };

    module.exports = function(axis) {
        return {
            accepted: [Array, Boolean, Function, Object, String],
            affixes: {
                accepted: [Boolean],
                separator: {
                    accepted: [Boolean, Array],
                    value: true
                },
                value: false
            },
            axis: {
                accepted: [Boolean],
                color: "#444",
                font: {
                    color: false,
                    decoration: decoration(false),
                    family: family(""),
                    size: false,
                    spacing: 0,
                    transform: transform(false),
                    weight: false
                },
                rendering: rendering(),
                value: true
            },
            dataFilter: true,
            deprecates: [axis + "axis", axis + "axis_val", axis + "axis_var"],
            domain: {
                accepted: [false, Array],
                value: false
            },
            grid: {
                accepted: [Boolean],
                color: "#ccc",
                rendering: rendering(),
                value: true
            },
            label: {
                accepted: [Boolean, String],
                fetch: function(vars) {
                    if (this.value === true) {
                        return vars.format.value(vars[axis].value, {
                            key: axis,
                            vars: vars
                        });
                    }
                    return this.value;
                },
                font: {
                    color: "#444",
                    decoration: decoration(),
                    family: family(),
                    size: 12,
                    spacing: 0,
                    transform: transform(),
                    weight: 200
                },
                padding: 3,
                value: true
            },
            lines: {
                accept: [false, Array, Number, Object],
                dasharray: {
                    accepted: [Array, String],
                    process: function(value) {
                        if (value instanceof Array) {
                            value = value.filter(function(d) {
                                return !isNaN(d);
                            });
                            value = value.length ? value.join(", ") : "none";
                        }
                        return value;
                    },
                    value: "10, 10"
                },
                color: "#888",
                font: {
                    align: align("right"),
                    color: "#444",
                    background: {
                        accepted: [Boolean],
                        value: true
                    },
                    decoration: decoration(),
                    family: family(),
                    padding: {
                        accepted: [Number],
                        value: 10
                    },
                    position: position("middle"),
                    size: 12,
                    transform: transform(),
                    weight: 200
                },
                process: Array,
                rendering: rendering(),
                width: 1,
                value: []
            },
            mouse: {
                accept: [Boolean],
                dasharray: {
                    accepted: [Array, String],
                    process: function(value) {
                        if (value instanceof Array) {
                            value = value.filter(function(d) {
                                return !isNaN(d);
                            });
                            value = value.length ? value.join(", ") : "none";
                        }
                        return value;
                    },
                    value: "none"
                },
                rendering: rendering(),
                width: 2,
                value: true
            },
            mute: filter(true),
            orient: {
                accepted: ["top", "right", "bottom", "left"],
                value: orientMap[axis]
            },
            padding: {
                accepted: [Number],
                value: 0.1
            },
            persist: {
                position: {
                    accepted: [Boolean],
                    value: false
                },
                size: {
                    accepted: [Boolean],
                    value: true
                }
            },
            range: {
                accepted: [false, Array],
                value: false
            },
            scale: {
                accepted: ["linear", "log", "discrete", "share"],
                deprecates: ["layout", "unique_axis", axis + "axis_scale"],
                process: function(value, vars) {
                    var i, len, ref, scale;
                    ref = ["log", "discrete", "share"];
                    for (i = 0, len = ref.length; i < len; i++) {
                        scale = ref[i];
                        if (scale === value) {
                            vars.axes[scale] = axis;
                        } else {
                            if (vars.axes[scale] === axis) {
                                vars.axes[scale] = false;
                            }
                        }
                    }
                    if (value === "discrete") {
                        vars.axes.opposite = (axis.indexOf("x") === 0 ? "y" : "x");
                    }
                    return value;
                },
                value: "linear"
            },
            solo: filter(true),
            stacked: {
                accepted: [Boolean],
                process: function(value, vars) {
                    if (!value && vars.axes.stacked === axis) {
                        vars.axes.stacked = false;
                    } else {
                        if (value) {
                            vars.axes.stacked = axis;
                        }
                    }
                    return value;
                },
                value: false
            },
            ticks: {
                accepted: [false, Array],
                color: "#ccc",
                font: {
                    color: "#666",
                    decoration: decoration(),
                    family: family(),
                    size: 10,
                    spacing: 0,
                    transform: transform(),
                    weight: 200
                },
                labels: {
                    accepted: [Boolean, Array],
                    value: true
                },
                rendering: rendering(),
                size: 10,
                width: 1,
                value: false
            },
            value: false,
            zerofill: {
                accepted: [Boolean],
                value: false
            }
        };
    };


},{"../../../core/methods/filter.coffee":82,"../../../core/methods/font/align.coffee":83,"../../../core/methods/font/decoration.coffee":84,"../../../core/methods/font/family.coffee":85,"../../../core/methods/font/position.coffee":86,"../../../core/methods/font/transform.coffee":87,"../../../core/methods/rendering.coffee":93}],282:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean],
        back: function() {
            if (this.states.length) {
                return this.states.pop()();
            }
        },
        chain: [],
        reset: function() {
            var results;
            results = [];
            while (this.states.length) {
                results.push(this.states.pop()());
            }
            return results;
        },
        states: [],
        value: true
    };


},{}],283:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/icon.coffee");

    module.exports = {
        accepted: [false, Array, Function, Object, String],
        back: {
            accepted: [false, String],
            fallback: "&#x276e;",
            opacity: 1,
            process: process,
            rotate: 0,
            value: "fa-angle-left"
        },
        deprecates: "icon_var",
        style: {
            accepted: [Object, String],
            deprecates: "icon_style",
            value: "default"
        },
        value: false
    };


},{"../../core/methods/process/icon.coffee":90}],284:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [Array, String],
        dataFilter: true,
        deprecates: ["id_var", "nesting"],
        grouping: {
            accepted: [Boolean],
            value: true
        },
        mute: filter(true),
        nesting: ["id"],
        solo: filter(true),
        value: "id"
    };


},{"../../core/methods/filter.coffee":82}],285:[function(require,module,exports){
    var decoration, family, transform;

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        accepted: [Boolean],
        align: {
            accepted: ["start", "middle", "end", "left", "center", "right"],
            process: function(value) {
                var css;
                css = ["left", "center", "right"].indexOf(value);
                if (css >= 0) {
                    value = this.accepted[css];
                }
                return value;
            },
            value: "middle"
        },
        color: {
            accepted: [false, String],
            value: false
        },
        font: {
            decoration: decoration(),
            family: family(),
            size: 11,
            transform: transform(),
            weight: 200
        },
        padding: 7,
        resize: {
            accepted: [Boolean],
            value: true
        },
        text: {
            accepted: [false, Function, String],
            value: false
        },
        segments: 2,
        valign: {
            accepted: [false, "top", "middle", "bottom"],
            value: "middle"
        },
        value: true
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],286:[function(require,module,exports){
    var family;

    family = require("../../core/methods/font/family.coffee");

    module.exports = {
        accepted: [Boolean],
        align: "middle",
        filters: {
            accepted: [Boolean],
            value: false
        },
        font: {
            align: "middle",
            color: "#444444",
            family: family(),
            size: [8, 14],
            weight: 200
        },
        gradient: {
            height: 10
        },
        icons: {
            accepted: [Boolean],
            value: true
        },
        labels: {
            accepted: [Boolean],
            value: true
        },
        order: {
            accepted: ["color", "id", "size", "text"],
            sort: {
                accepted: ["asc", "desc"],
                value: "asc"
            },
            value: "color"
        },
        size: [8, 30],
        tooltip: {
            accepted: [Boolean],
            value: true
        },
        text: {
            accepted: [false, Function, String],
            value: false
        },
        value: true
    };


},{"../../core/methods/font/family.coffee":85}],287:[function(require,module,exports){
    var decoration, family, transform;

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        font: {
            color: "#444444",
            decoration: decoration(),
            family: family(),
            transform: transform(),
            weight: 200
        },
        hover: {
            color: "#444444",
            decoration: decoration(),
            family: family(),
            transform: transform(),
            weight: 200
        }
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],288:[function(require,module,exports){
    arguments[4][124][0].apply(exports,arguments)
},{"../../core/methods/process/margin.coffee":91,"dup":124}],289:[function(require,module,exports){
    var decoration, family, transform;

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        accepted: [Boolean, String],
        background: {
            accepted: [false, String],
            value: false
        },
        branding: {
            accepted: [Boolean],
            image: {
                dark: "http://d3plus.org/assets/img/icon-transparent-invert.png",
                light: "http://d3plus.org/assets/img/icon-transparent.png"
            },
            value: false
        },
        font: {
            color: "#444",
            decoration: decoration(),
            family: family(),
            size: 16,
            transform: transform(),
            weight: 200
        },
        padding: 5,
        style: {
            accepted: [false, "small", "large"],
            value: false
        },
        value: true
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],290:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean],
        click: {
            accepted: [Boolean, Function],
            value: true
        },
        move: {
            accepted: [Boolean, Function],
            value: true
        },
        out: {
            accepted: [Boolean, Function],
            value: true
        },
        over: {
            accepted: [Boolean, Function],
            value: true
        },
        value: true
    };


},{}],291:[function(require,module,exports){
    var process;

    process = require("../../core/methods/process/data.coffee");

    module.exports = {
        accepted: [false, Array, Function, String],
        delimiter: {
            accepted: [String],
            value: "|"
        },
        filetype: {
            accepted: [false, "json", "xml", "html", "csv", "dsv", "tsv", "txt"],
            value: false
        },
        overlap: 0.6,
        process: process,
        value: false
    };


},{"../../core/methods/process/data.coffee":88}],292:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean, Function, String],
        agg: {
            accepted: [false, Function, "sum", "min", "max", "mean", "median"],
            value: false
        },
        deprecates: ["sort"],
        sort: {
            accepted: ["asc", "desc"],
            value: "desc"
        },
        value: false
    };


},{}],293:[function(require,module,exports){
    module.exports = {
        "accepted": [Boolean],
        "value": false,
        "timeout": 400,
        "process": function(value, vars) {
            var resize, resizeEnd;
            if (!value) {
                return false;
            }
            resize = null;
            resizeEnd = function() {
                var height, mainNode, width;
                mainNode = vars.container.value.node().parentNode.getBoundingClientRect();
                width = mainNode.width;
                height = mainNode.height;
                vars.width.value = width;
                vars.height.value = height;
                window.d3plusResized = true;
                return vars.self(vars.container.value);
            };
            d3.select(window).on("resize." + vars.container.id, (function(_this) {
                return function(e) {
                    clearTimeout(resize);
                    return resize = setTimeout(resizeEnd, _this.timeout);
                };
            })(this));
            return value;
        }
    };


},{}],294:[function(require,module,exports){
    var rendering;

    rendering = require("../../core/methods/rendering.coffee");

    module.exports = {
        accepted: function(vars) {
            var list;
            list = vars.types[vars.type.value].shapes;
            if (list && !(list instanceof Array)) {
                list = [list];
            }
            if (list.length) {
                return list;
            } else {
                return ["square"];
            }
        },
        interpolate: {
            accepted: ["basis", "basis-open", "cardinal", "cardinal-open", "linear", "monotone", "step", "step-before", "step-after"],
            deprecates: "stack_type",
            value: "linear"
        },
        rendering: rendering(),
        value: false
    };


},{"../../core/methods/rendering.coffee":93}],295:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Function, Number, Object, String],
        dataFilter: true,
        deprecates: ["value", "value_var"],
        mute: filter(true),
        scale: {
            accepted: [Function],
            deprecates: "size_scale",
            max: {
                accepted: [Function, Number],
                value: function(vars) {
                    return Math.floor(d3.max([d3.min([vars.width.viz, vars.height.viz]) / 15, 6]));
                }
            },
            min: {
                accepted: [Function, Number],
                value: 3
            },
            value: d3.scale.sqrt()
        },
        solo: filter(true),
        threshold: {
            accepted: [Boolean, Function, Number],
            value: false
        },
        value: false
    };


},{"../../core/methods/filter.coffee":82}],296:[function(require,module,exports){
    module.exports = {
        value: false
    };


},{}],297:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Function, Object, String],
        deprecates: ["else_var", "else"],
        mute: filter(true),
        solo: filter(true),
        value: false
    };


},{"../../core/methods/filter.coffee":82}],298:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [Array, Boolean, Function, Object, String],
        deprecates: ["name_array", "text_var"],
        nesting: true,
        mute: filter(true),
        solo: filter(true),
        value: false
    };


},{"../../core/methods/filter.coffee":82}],299:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [Array, Boolean, Function, Object, String],
        dataFilter: true,
        deprecates: ["year", "year_var"],
        fixed: {
            accepted: [Boolean],
            deprecates: ["static_axis", "static_axes"],
            value: true
        },
        format: {
            accepted: [false, Array, Function, String],
            value: false
        },
        mute: filter(false),
        solo: filter(false),
        value: false
    };


},{"../../core/methods/filter.coffee":82}],300:[function(require,module,exports){
    module.exports = {
        accepted: [Boolean],
        align: "middle",
        hover: {
            accepted: ["all-scroll", "col-resize", "crosshair", "default", "grab", "grabbing", "move", "pointer"],
            value: "pointer"
        },
        handles: {
            accepted: [Boolean],
            color: "#666",
            opacity: 1,
            size: 3,
            stroke: "#666",
            value: true
        },
        height: {
            accepted: [false, Number],
            value: false
        },
        play: {
            accepted: [Boolean],
            icon: {
                accepted: [false, String],
                awesome: "",
                fallback: "►"
            },
            pause: {
                accepted: [false, String],
                awesome: "",
                fallback: "❚❚"
            },
            timing: {
                accepted: [Number],
                value: 1500
            },
            value: true
        },
        value: true
    };


},{}],301:[function(require,module,exports){
    module.exports = {
        mouseevents: 60,
        transitions: 600,
        ui: 200
    };


},{}],302:[function(require,module,exports){
    var decoration, family, stringStrip, transform;

    decoration = require("../../core/methods/font/decoration.coffee");

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    stringStrip = require("../../string/strip.js");

    module.exports = {
        accepted: [false, Function, String],
        font: {
            align: "center",
            color: "#444444",
            decoration: decoration(),
            family: family(),
            size: 16,
            transform: transform(),
            weight: 400
        },
        height: false,
        link: false,
        padding: 2,
        position: "top",
        process: function(value, vars) {
            var id;
            if (vars.container.id.indexOf("default") === 0 && value) {
                id = stringStrip(value).toLowerCase();
                vars.self.container({
                    id: id
                });
            }
            return value;
        },
        sub: {
            accepted: [false, Function, String],
            deprecates: "sub_title",
            font: {
                align: "center",
                color: "#444444",
                decoration: decoration(),
                family: family(),
                size: 12,
                transform: transform(),
                weight: 200
            },
            link: false,
            padding: 1,
            position: "top",
            value: false
        },
        total: {
            accepted: [Boolean, Object],
            deprecates: "total_bar",
            font: {
                align: "center",
                color: "#444444",
                decoration: decoration(),
                family: family(),
                size: 12,
                transform: transform(),
                weight: 200,
                value: false
            },
            link: false,
            padding: 1,
            position: "top",
            value: false
        },
        width: false,
        value: false
    };


},{"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87,"../../string/strip.js":177}],303:[function(require,module,exports){
    var family, transform;

    family = require("../../core/methods/font/family.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        accepted: [Boolean, Array, Function, Object, String],
        anchor: "top center",
        background: "#ffffff",
        children: {
            accepted: [Boolean],
            value: true
        },
        connections: {
            accepted: [Boolean],
            value: true
        },
        curtain: {
            color: "#ffffff",
            opacity: 0.8
        },
        deprecates: "tooltip_info",
        extent: {
            accepted: [Boolean],
            value: true
        },
        font: {
            color: "#444",
            family: family(),
            size: 12,
            transform: transform(),
            weight: 200
        },
        fullscreen: {
            accepted: [Boolean],
            value: false
        },
        html: {
            accepted: [false, Function, Object, String],
            deprecates: "click_function",
            value: false
        },
        iqr: {
            accepted: [Boolean],
            value: true
        },
        large: 250,
        share: {
            accepted: [Boolean],
            value: true
        },
        size: {
            accepted: [Boolean],
            value: true
        },
        small: 225,
        stacked: {
            accepted: [Boolean],
            value: false
        },
        sub: {
            accepted: [false, Function, String],
            value: false
        },
        value: true
    };


},{"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],304:[function(require,module,exports){
    var filter;

    filter = require("../../core/methods/filter.coffee");

    module.exports = {
        accepted: [false, Function, Object, String],
        deprecates: ["total_var"],
        mute: filter(true),
        solo: filter(true),
        value: false
    };


},{"../../core/methods/filter.coffee":82}],305:[function(require,module,exports){
    module.exports = {
        accepted: function(vars) {
            return d3.keys(vars.types);
        },
        mode: {
            accepted: function(vars) {
                return vars.types[vars.type.value].modes || [false];
            },
            value: false
        },
        value: "tree_map"
    };


},{}],306:[function(require,module,exports){
    var align, decoration, family, transform;

    family = require("../../core/methods/font/family.coffee");

    align = require("../../core/methods/font/align.coffee");

    decoration = require("../../core/methods/font/decoration.coffee");

    transform = require("../../core/methods/font/transform.coffee");

    module.exports = {
        accepted: [Array, Boolean],
        align: align("center"),
        border: 1,
        color: {
            primary: {
                process: function(value, vars) {
                    var primary;
                    primary = this.value;
                    if (!vars.ui.color.secondary.value) {
                        vars.ui.color.secondary.value = d3.rgb(primary).darker(0.75).toString();
                    }
                    return value;
                },
                value: "#ffffff"
            },
            secondary: {
                value: false
            }
        },
        display: {
            acceped: ["block", "inline-block"],
            value: "inline-block"
        },
        font: {
            align: "center",
            color: "#444",
            decoration: decoration(),
            family: family(),
            size: 11,
            transform: transform(),
            weight: 200
        },
        margin: 5,
        padding: 5,
        position: {
            accepted: ["top", "right", "bottom", "left"],
            value: "bottom"
        },
        value: false
    };


},{"../../core/methods/font/align.coffee":83,"../../core/methods/font/decoration.coffee":84,"../../core/methods/font/family.coffee":85,"../../core/methods/font/transform.coffee":87}],307:[function(require,module,exports){
    module.exports = {
        accepted: [false, Number],
        secondary: false,
        small: 200,
        value: false
    };


},{}],308:[function(require,module,exports){
    module.exports = {
        "accepted"   : [ Boolean ],
        "behavior"   : d3.behavior.zoom().scaleExtent([ 1 , 1 ]).duration(0),
        "click"      : {
            "accepted" : [ Boolean ],
            "value"    : true
        },
        "pan"        : {
            "accepted" : [ Boolean ],
            "value"    : true
        },
        "scroll"     : {
            "accepted"   : [ Boolean ],
            "deprecates" : "scroll_zoom",
            "value"      : true
        },
        "value"      : true
    }

},{}],309:[function(require,module,exports){
    var area, closest, fetchValue, graph, nest, sort, stack, threshold;

    closest = require("../../util/closest.coffee");

    fetchValue = require("../../core/fetch/value.coffee");

    graph = require("./helpers/graph/draw.coffee");

    nest = require("./helpers/graph/nest.coffee");

    sort = require("../../array/sort.coffee");

    stack = require("./helpers/graph/stack.coffee");

    threshold = require("../../core/data/threshold.js");

    area = function(vars) {
        var d, data, discrete, domains, i, j, len, len1, opposite, point, ref;
        graph(vars, {
            buffer: vars.axes.opposite,
            zero: true
        });
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return [];
        }
        data = sort(vars.data.viz, null, null, null, vars);
        discrete = vars[vars.axes.discrete];
        opposite = vars[vars.axes.opposite];
        for (i = 0, len = data.length; i < len; i++) {
            point = data[i];
            if (!point.d3plus) {
                point.d3plus = {};
            }
            ref = point.values;
            for (j = 0, len1 = ref.length; j < len1; j++) {
                d = ref[j];
                if (!d.d3plus) {
                    d.d3plus = {};
                }
                d.d3plus.x = discrete.scale.viz(fetchValue(vars, d, discrete.value));
                d.d3plus.x += vars.axes.margin.left;
                d.d3plus.y = opposite.scale.viz(fetchValue(vars, d, opposite.value));
                d.d3plus.y += vars.axes.margin.top;
                if (d.d3plus.merged instanceof Array) {
                    if (!point.d3plus.merged) {
                        point.d3plus.merged = [];
                    }
                    point.d3plus.merged = point.d3plus.merged.concat(d.d3plus.merged);
                }
                if (d.d3plus.text && !point.d3plus.text) {
                    point.d3plus.text = d.d3plus.text;
                }
            }
        }
        return stack(vars, data);
    };

    area.filter = function(vars, data) {
        return nest(vars, threshold(vars, data, vars[vars.axes.discrete].value));
    };

    area.requirements = ["data", "x", "y"];

    area.setup = function(vars) {
        var axis, size, y;
        if (!vars.axes.discrete) {
            axis = vars.time.value === vars.y.value ? "y" : "x";
            vars.self[axis]({
                scale: "discrete"
            });
        }
        if (!vars[vars.axes.discrete].zerofill.value) {
            vars.self[vars.axes.discrete]({
                zerofill: true
            });
        }
        if (!vars[vars.axes.opposite].stacked.value && vars.type.value === "stacked") {
            vars.self[vars.axes.opposite]({
                stacked: true
            });
        }
        y = vars[vars.axes.opposite];
        size = vars.size;
        if ((!y.value && size.value) || (size.changed && size.previous === y.value)) {
            return vars.self[vars.axes.opposite](size.value);
        } else if ((!size.value && y.value) || (y.changed && y.previous === size.value)) {
            return vars.self.size(y.value);
        }
    };

    area.shapes = ["area"];

    area.threshold = function(vars) {
        return 20 / vars.height.viz;
    };

    area.tooltip = "static";

    module.exports = area;


},{"../../array/sort.coffee":36,"../../core/data/threshold.js":63,"../../core/fetch/value.coffee":69,"../../util/closest.coffee":208,"./helpers/graph/draw.coffee":316,"./helpers/graph/nest.coffee":322,"./helpers/graph/stack.coffee":323}],310:[function(require,module,exports){
    var bar, buckets, fetchValue, graph, nest, stack, uniques,
        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    buckets = require("../../util/buckets.coffee");

    fetchValue = require("../../core/fetch/value.coffee");

    graph = require("./helpers/graph/draw.coffee");

    nest = require("./helpers/graph/nest.coffee");

    stack = require("./helpers/graph/stack.coffee");

    uniques = require("../../util/uniques.coffee");

    bar = function(vars) {
        var bars, base, cMargin, d, data, discrete, discreteVal, divisions, domains, h, i, ids, j, k, l, len, len1, len2, length, maxBars, maxSize, mod, nested, newSize, oMargin, offset, oppMethod, oppVal, opposite, p, padding, point, ref, ref1, space, value, w, x, zero;
        discrete = vars.axes.discrete;
        h = discrete === "x" ? "height" : "width";
        w = discrete === "x" ? "width" : "height";
        opposite = vars.axes.opposite;
        cMargin = discrete === "x" ? "left" : "top";
        oMargin = discrete === "x" ? "top" : "left";
        graph(vars, {
            buffer: true,
            zero: opposite
        });
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return [];
        }
        nested = vars.data.viz;
        if (vars.axes.stacked) {
            for (j = 0, len = nested.length; j < len; j++) {
                point = nested[j];
                stack(vars, point.values);
            }
        }
        space = vars.axes[w] / vars[vars.axes.discrete].ticks.values.length;
        padding = vars[vars.axes.discrete].padding.value;
        if (padding < 1) {
            padding *= space;
        }
        if (padding * 2 > space) {
            padding = space * 0.1;
        }
        maxSize = space - padding * 2;
        if (!vars.axes.stacked) {
            if (vars[discrete].persist.position.value) {
                if (ref = vars[discrete].value, indexOf.call(vars.id.nesting, ref) >= 0) {
                    divisions = d3.max(nested, function(b) {
                        return b.values.length;
                    });
                } else {
                    divisions = uniques(nested, vars.id.value, fetchValue, vars).length;
                }
                maxSize /= divisions;
                offset = space / 2 - maxSize / 2 - padding;
                x = d3.scale.ordinal();
                if (divisions === 1) {
                    x.domain([0]).range([0]);
                } else {
                    x.domain([0, divisions - 1]).range([-offset, offset]);
                }
            } else {
                x = d3.scale.linear();
            }
        }
        data = [];
        zero = 0;
        if (vars[discrete].persist.position.value && !vars.axes.stacked) {
            ids = uniques(d3.merge(nested.map(function(d) {
                return d.values;
            })), vars.id.value, fetchValue, vars, vars.id.value, false);
            x.domain(ids);
            if (ids.length === 1) {
                x.range([0]);
            } else {
                x.range(buckets(x.range(), ids.length));
            }
        }
        maxBars = d3.max(nested, function(b) {
            return b.values.length;
        });
        for (k = 0, len1 = nested.length; k < len1; k++) {
            p = nested[k];
            if (vars.axes.stacked) {
                bars = 1;
                newSize = maxSize;
            } else if (vars[discrete].persist.position.value) {
                bars = divisions;
                newSize = maxSize;
            } else {
                bars = p.values.length;
                if (vars[discrete].persist.size.value) {
                    newSize = maxSize / maxBars;
                    offset = space / 2 - ((maxBars - bars) * (newSize / 2)) - newSize / 2 - padding;
                } else {
                    newSize = maxSize / bars;
                    offset = space / 2 - newSize / 2 - padding;
                }
                x.domain([0, bars - 1]);
                x.range([-offset, offset]);
            }
            ref1 = p.values;
            for (i = l = 0, len2 = ref1.length; l < len2; i = ++l) {
                d = ref1[i];
                if (vars.axes.stacked) {
                    mod = 0;
                } else if (vars[discrete].persist.position.value) {
                    mod = x(fetchValue(vars, d, vars.id.value));
                } else {
                    mod = x(i % bars);
                }
                oppMethod = vars[opposite];
                if (vars.axes.stacked) {
                    value = d.d3plus[opposite];
                    base = d.d3plus[opposite + "0"];
                } else {
                    oppVal = fetchValue(vars, d, oppMethod.value);
                    if (oppVal === null) {
                        oppMethod = vars[opposite + "2"];
                        oppVal = fetchValue(vars, d, oppMethod.value);
                    }
                    if (oppVal === 0) {
                        continue;
                    }
                    if (oppMethod.scale.value === "log") {
                        zero = oppVal < 0 ? -1 : 1;
                    }
                    value = oppMethod.scale.viz(oppVal);
                    base = oppMethod.scale.viz(zero);
                }
                discreteVal = fetchValue(vars, d, vars[discrete].value);
                d.d3plus[discrete] = vars[discrete].scale.viz(discreteVal);
                d.d3plus[discrete] += vars.axes.margin[cMargin] + mod;
                length = base - value;
                d.d3plus[opposite] = base - length / 2;
                if (!vars.axes.stacked) {
                    d.d3plus[opposite] += vars.axes.margin[oMargin];
                }
                delete d.d3plus.r;
                d.d3plus[w] = newSize;
                d.d3plus[h] = Math.abs(length);
                d.d3plus.init = {};
                d.d3plus.init[opposite] = oppMethod.scale.viz(zero);
                d.d3plus.init[opposite] -= d.d3plus[opposite];
                d.d3plus.init[opposite] += vars.axes.margin[oMargin];
                d.d3plus.init[w] = d.d3plus[w];
                if (vars.text.value) {
                    delete d.d3plus.label;
                } else {
                    d.d3plus.label = false;
                }
                data.push(d);
            }
        }
        return data;
    };

    bar.filter = function(vars, data) {
        return nest(vars, data, vars[vars.axes.discrete].value);
    };

    bar.requirements = ["data", "x", "y"];

    bar.setup = function(vars) {
        var axis, size, y;
        if (!vars.axes.discrete) {
            axis = vars.time.value === vars.y.value ? "y" : "x";
            vars.self[axis]({
                scale: "discrete"
            });
        }
        y = vars[vars.axes.opposite];
        size = vars.size;
        if ((!y.value && size.value) || (size.changed && size.previous === y.value)) {
            return vars.self[vars.axes.opposite](size.value);
        } else if ((!size.value && y.value) || (y.changed && y.previous === size.value)) {
            return vars.self.size(y.value);
        }
    };

    bar.shapes = ["square"];

    module.exports = bar;


},{"../../core/fetch/value.coffee":69,"../../util/buckets.coffee":206,"../../util/uniques.coffee":212,"./helpers/graph/draw.coffee":316,"./helpers/graph/nest.coffee":322,"./helpers/graph/stack.coffee":323}],311:[function(require,module,exports){
    var box, fetchValue, graph, strip, uniques;

    fetchValue = require("../../core/fetch/value.coffee");

    graph = require("./helpers/graph/draw.coffee");

    strip = require("../../string/strip.js");

    uniques = require("../../util/uniques.coffee");

    box = function(vars) {
        var disMargin, discrete, domains, h, medians, mergeData, mode, noData, oppMargin, opposite, returnData, size, space, w;
        graph(vars, {
            buffer: true
        });
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return [];
        }
        discrete = vars.axes.discrete;
        opposite = vars.axes.opposite;
        disMargin = discrete === "x" ? vars.axes.margin.left : vars.axes.margin.top;
        oppMargin = opposite === "x" ? vars.axes.margin.left : vars.axes.margin.top;
        h = discrete === "x" ? "height" : "width";
        w = discrete === "x" ? "width" : "height";
        space = vars.axes[w] / vars[discrete].ticks.values.length;
        size = vars.size.value;
        size = typeof size === "number" ? size : 100;
        space = d3.min([space - vars.labels.padding * 2, size]);
        mode = vars.type.mode.value;
        if (!(mode instanceof Array)) {
            mode = [mode, mode];
        }
        mergeData = function(arr) {
            var key, obj, vals;
            obj = {};
            for (key in vars.data.keys) {
                vals = uniques(arr, key, fetchValue, vars);
                obj[key] = vals.length === 1 ? vals[0] : vals;
            }
            return obj;
        };
        noData = false;
        medians = [];
        returnData = [];
        d3.nest().key(function(d) {
            return fetchValue(vars, d, vars[discrete].value);
        }).rollup(function(leaves) {
            var bottom, bottomLabel, bottomWhisker, boxData, d, diff1, diff2, first, i, iqr, j, key, label, len, len1, median, medianBuffer, medianData, medianHeight, medianText, outliers, scale, second, tooltipData, top, topLabel, topWhisker, uniqs, val, values, x, y;
            scale = vars[opposite].scale.viz;
            values = leaves.map(function(d) {
                return fetchValue(vars, d, vars[opposite].value);
            });
            values.sort(function(a, b) {
                return a - b;
            });
            uniqs = uniques(values);
            first = d3.quantile(values, 0.25);
            median = d3.quantile(values, 0.50);
            second = d3.quantile(values, 0.75);
            tooltipData = {};
            if (mode[1] === "tukey") {
                iqr = first - second;
                top = second - iqr * 1.5;
                topLabel = "top tukey";
            } else if (mode[1] === "extent") {
                top = d3.max(values);
                topLabel = "maximum";
            } else if (typeof mode[1] === "number") {
                top = d3.quantile(values, (100 - mode[1]) / 100);
                topLabel = mode[1] + " percentile";
            }
            top = d3.min([d3.max(values), top]);
            if (vars.tooltip.extent.value) {
                tooltipData[topLabel] = {
                    key: vars[opposite].value,
                    value: top
                };
            }
            if (vars.tooltip.iqr.value) {
                tooltipData["third quartile"] = {
                    key: vars[opposite].value,
                    value: second
                };
                tooltipData["median"] = {
                    key: vars[opposite].value,
                    value: median
                };
                tooltipData["first quartile"] = {
                    key: vars[opposite].value,
                    value: first
                };
            }
            if (mode[0] === "tukey") {
                iqr = first - second;
                bottom = first + iqr * 1.5;
                bottomLabel = "bottom tukey";
            } else if (mode[0] === "extent") {
                bottom = d3.min(values);
                bottomLabel = "minimum";
            } else if (typeof mode[0] === "number") {
                bottom = d3.quantile(values, mode[0] / 100);
                bottomLabel = mode[0] + " percentile";
            }
            bottom = d3.max([d3.min(values), bottom]);
            if (vars.tooltip.extent.value) {
                tooltipData[bottomLabel] = {
                    key: vars[opposite].value,
                    value: bottom
                };
            }
            boxData = [];
            bottomWhisker = [];
            topWhisker = [];
            outliers = [];
            for (i = 0, len = leaves.length; i < len; i++) {
                d = leaves[i];
                val = fetchValue(vars, d, vars[opposite].value);
                if (val >= first && val <= second) {
                    boxData.push(d);
                } else if (val >= bottom && val < first) {
                    bottomWhisker.push(d);
                } else if (val <= top && val > second) {
                    topWhisker.push(d);
                } else {
                    outliers.push(d);
                }
            }
            key = fetchValue(vars, leaves[0], vars[discrete].value);
            x = vars[discrete].scale.viz(key);
            x += disMargin;
            label = vars.format.value(key, {
                key: vars[discrete].value,
                vars: vars
            });
            if (key.constructor === Date) {
                key = key.getTime();
            }
            key = strip(key);
            boxData = mergeData(boxData);
            boxData.d3plus = {
                color: "white",
                id: "box_" + key,
                init: {},
                label: false,
                shape: "square",
                stroke: "#444",
                text: "Interquartile Range for " + label
            };
            boxData.d3plus[w] = space;
            boxData.d3plus.init[w] = space;
            boxData.d3plus[h] = Math.abs(scale(first) - scale(second));
            boxData.d3plus[discrete] = x;
            y = d3.min([scale(first), scale(second)]) + boxData.d3plus[h] / 2;
            y += oppMargin;
            boxData.d3plus[opposite] = y;
            boxData.d3plus.tooltip = tooltipData;
            returnData.push(boxData);
            medianData = {
                d3plus: {
                    id: "median_line_" + key,
                    position: h === "height" ? "top" : "right",
                    shape: "whisker",
                    "static": true
                }
            };
            medianText = vars.format.value(median, {
                key: vars[opposite].value,
                vars: vars
            });
            label = {
                background: "#fff",
                names: [medianText],
                padding: 0,
                resize: false,
                x: 0,
                y: 0
            };
            diff1 = Math.abs(scale(median) - scale(first));
            diff2 = Math.abs(scale(median) - scale(second));
            medianHeight = d3.min([diff1, diff2]) * 2;
            medianBuffer = vars.data.stroke.width * 2 + vars.labels.padding * 2;
            label[w === "width" ? "w" : "h"] = space - medianBuffer;
            label[h === "width" ? "w" : "h"] = medianHeight - medianBuffer;
            medianData.d3plus.label = label;
            medianData.d3plus[w] = space;
            medianData.d3plus[discrete] = x;
            medianData.d3plus[opposite] = scale(median) + oppMargin;
            returnData.push(medianData);
            bottomWhisker = mergeData(bottomWhisker);
            bottomWhisker.d3plus = {
                id: "bottom_whisker_line_" + key,
                offset: boxData.d3plus[h] / 2,
                position: h === "height" ? "bottom" : "left",
                shape: "whisker",
                "static": true
            };
            if (opposite === "x") {
                bottomWhisker.d3plus.offset *= -1;
            }
            bottomWhisker.d3plus[h] = Math.abs(scale(bottom) - scale(first));
            bottomWhisker.d3plus[w] = space;
            bottomWhisker.d3plus[discrete] = x;
            bottomWhisker.d3plus[opposite] = y;
            returnData.push(bottomWhisker);
            topWhisker = mergeData(topWhisker);
            topWhisker.d3plus = {
                id: "top_whisker_line_" + key,
                offset: boxData.d3plus[h] / 2,
                position: h === "height" ? "top" : "right",
                shape: "whisker",
                "static": true
            };
            if (opposite === "y") {
                topWhisker.d3plus.offset *= -1;
            }
            topWhisker.d3plus[h] = Math.abs(scale(top) - scale(second));
            topWhisker.d3plus[w] = space;
            topWhisker.d3plus[discrete] = x;
            topWhisker.d3plus[opposite] = y;
            returnData.push(topWhisker);
            for (j = 0, len1 = outliers.length; j < len1; j++) {
                d = outliers[j];
                d.d3plus[discrete] = x;
                d.d3plus[opposite] = scale(fetchValue(vars, d, vars.y.value));
                d.d3plus[opposite] += oppMargin;
                d.d3plus.r = 4;
                d.d3plus.shape = vars.shape.value;
            }
            noData = !outliers.length && top - bottom === 0;
            medians.push(median);
            returnData = returnData.concat(outliers);
            return leaves;
        }).entries(vars.data.viz);
        if (noData && uniques(medians).length === 1) {
            return [];
        } else {
            return returnData;
        }
    };

    box.modes = ["tukey", "extent", Array, Number];

    box.requirements = ["data", "x", "y"];

    box.shapes = ["circle", "check", "cross", "diamond", "square", "triangle", "triangle_up", "triangle_down"];

    box.setup = function(vars) {
        var axis;
        if (!vars.axes.discrete) {
            axis = vars.time.value === vars.y.value ? "y" : "x";
            return vars.self[axis]({
                scale: "discrete"
            });
        }
    };

    module.exports = box;


},{"../../core/fetch/value.coffee":69,"../../string/strip.js":177,"../../util/uniques.coffee":212,"./helpers/graph/draw.coffee":316}],312:[function(require,module,exports){
    var arraySort, bubbles, fetchColor, fetchText, fetchValue, groupData, legible;

    arraySort = require("../../array/sort.coffee");

    fetchValue = require("../../core/fetch/value.coffee");

    fetchColor = require("../../core/fetch/color.coffee");

    fetchText = require("../../core/fetch/text.js");

    legible = require("../../color/legible.coffee");

    groupData = require("../../core/data/group.coffee");

    bubbles = function(vars) {
        var column_height, column_width, columns, d, data, dataLength, domain, domainMax, domainMin, downscale, groupedData, i, j, k, l, labelHeight, len, len1, len2, obj, pack, padding, row, rows, screenRatio, size, size_max, size_min, t, temp, xPadding, xoffset, yMod, yPadding, yoffset;
        groupedData = groupData(vars, vars.data.viz);
        groupedData = arraySort(groupedData, null, null, null, vars);
        dataLength = groupedData.length;
        if (dataLength < 4) {
            columns = dataLength;
            rows = 1;
        } else {
            screenRatio = vars.width.viz / vars.height.viz;
            columns = Math.ceil(Math.sqrt(dataLength * screenRatio));
            rows = Math.ceil(Math.sqrt(dataLength / screenRatio));
        }
        if (dataLength > 0) {
            while ((rows - 1) * columns >= dataLength) {
                rows--;
            }
        }
        column_width = vars.width.viz / columns;
        column_height = vars.height.viz / rows;
        if (vars.size.value) {
            domainMin = d3.min(vars.data.viz, function(d) {
                return fetchValue(vars, d, vars.size.value, vars.id.value, "min");
            });
            domainMax = d3.max(vars.data.viz, function(d) {
                return fetchValue(vars, d, vars.size.value, vars.id.value);
            });
            domain = [domainMin, domainMax];
        } else {
            domain = [0, 0];
        }
        padding = 5;
        size_max = (d3.min([column_width, column_height]) / 2) - (padding * 2);
        labelHeight = vars.labels.value && !vars.small && size_max >= 40 ? d3.max([20, d3.min([size_max * 0.25, 50])]) : 0;
        size_max -= labelHeight;
        size_min = d3.min([size_max, vars.size.scale.min.value]);
        size = vars.size.scale.value.domain(domain).rangeRound([size_min, size_max]);
        pack = d3.layout.pack().children(function(d) {
            return d.values;
        }).padding(padding).radius(function(d) {
            return size(d);
        }).size([column_width - padding * 2, column_height - padding * 2 - labelHeight]).value(function(d) {
            return d.value;
        });
        data = [];
        row = 0;
        for (i = j = 0, len = groupedData.length; j < len; i = ++j) {
            d = groupedData[i];
            temp = pack.nodes(d);
            xoffset = (column_width * i) % vars.width.viz;
            yoffset = column_height * row;
            for (k = 0, len1 = temp.length; k < len1; k++) {
                t = temp[k];
                if (t.children) {
                    obj = {
                        d3plus: {}
                    };
                    obj[vars.id.value] = t.key;
                } else {
                    obj = t.d3plus;
                }
                obj.d3plus.depth = vars.id.grouping.value ? t.depth : vars.depth.value;
                obj.d3plus.x = t.x;
                obj.d3plus.xOffset = xoffset;
                obj.d3plus.y = t.y;
                obj.d3plus.yOffset = yoffset + labelHeight;
                obj.d3plus.r = t.r;
                data.push(obj);
            }
            if ((i + 1) % columns === 0) {
                row++;
            }
        }
        downscale = size_max / d3.max(data, function(d) {
            return d.d3plus.r;
        });
        xPadding = pack.size()[0] / 2;
        yPadding = pack.size()[1] / 2;
        for (l = 0, len2 = data.length; l < len2; l++) {
            d = data[l];
            d.d3plus.x = ((d.d3plus.x - xPadding) * downscale) + xPadding + d.d3plus.xOffset;
            d.d3plus.y = ((d.d3plus.y - yPadding) * downscale) + yPadding + d.d3plus.yOffset;
            d.d3plus.r = d.d3plus.r * downscale;
            delete d.d3plus.xOffset;
            delete d.d3plus.yOffset;
            d.d3plus["static"] = d.d3plus.depth < vars.depth.value && vars.id.grouping.value;
            if (labelHeight && (d.d3plus.depth === 0 || vars.id.grouping.value === false)) {
                d.d3plus.text = fetchText(vars, d[vars.id.value], d.d3plus.depth);
                yMod = labelHeight > vars.labels.padding * 3 ? vars.labels.padding : 0;
                d.d3plus.label = {
                    x: 0,
                    y: -(size_max + yMod + labelHeight / 2),
                    w: size_max * 2,
                    h: labelHeight - yMod,
                    padding: 0,
                    resize: true,
                    color: legible(fetchColor(vars, d, d.d3plus.depth)),
                    force: true
                };
            } else {
                delete d.d3plus.label;
            }
        }
        return data.sort(function(a, b) {
            return a.d3plus.depth - b.d3plus.depth;
        });
    };

    bubbles.fill = true;

    bubbles.requirements = ["data"];

    bubbles.scale = 1.05;

    bubbles.shapes = ["circle", "donut"];

    module.exports = bubbles;


},{"../../array/sort.coffee":36,"../../color/legible.coffee":46,"../../core/data/group.coffee":59,"../../core/fetch/color.coffee":65,"../../core/fetch/text.js":68,"../../core/fetch/value.coffee":69}],313:[function(require,module,exports){
    var chart, print;

    print = require("../../../core/console/print.coffee");

    chart = function(vars) {
        var type, types;
        types = {
            circle: "scatter",
            donut: "scatter",
            line: "line",
            square: "scatter",
            area: "stacked"
        };
        type = types[vars.shape.value];
        print.warning("The \"chart\" visualization type has been deprecated and will be removed in version 2.0. Please use the \"" + type + "\" visualization type.");
        vars.self.type(type).draw();
    };

    chart.shapes = ["circle", "donut", "line", "square", "area"];

    module.exports = chart;


},{"../../../core/console/print.coffee":54}],314:[function(require,module,exports){
    var geo_map;

    geo_map = function(vars) {
        var coords, features, key, mute, solo, topo;
        coords = vars.coords.value;
        key = vars.coords.key || d3.keys(coords.objects)[0];
        topo = topojson.feature(coords, coords.objects[key]);
        features = topo.features;
        solo = vars.coords.solo.value;
        mute = vars.coords.mute.value;
        features = features.filter(function(f) {
            f[vars.id.value] = f.id;
            if (solo.length) {
                return solo.indexOf(f.id) >= 0;
            } else if (mute.length) {
                return mute.indexOf(f.id) < 0;
            } else {
                return true;
            }
        });
        return features;
    };

    geo_map.libs = ["topojson"];

    geo_map.nesting = false;

    geo_map.requirements = ["coords"];

    geo_map.scale = 1;

    geo_map.shapes = ["coordinates"];

    geo_map.zoom = true;

    module.exports = geo_map;


},{}],315:[function(require,module,exports){
    var color, legible, print;

    color = require("../../../../core/fetch/color.coffee");

    legible = require("../../../../color/legible.coffee");

    print = require("../../../../core/console/print.coffee");

    module.exports = function(vars) {
        var axes, axis, axisData, data, i, len, ref, style, tick, ticks, timing;
        axes = vars.axes;
        data = axes.stacked || !axes.ticks.value ? [] : vars.data.viz;
        timing = data.length * 2 > vars.data.large ? 0 : vars.draw.timing;
        style = function(line, axis) {
            if (axis.indexOf("y") === 0) {
                line.attr("x1", -2).attr("x2", -8).attr("y1", function(d) {
                    return d.d3plus.y - axes.margin.top;
                }).attr("y2", function(d) {
                    return d.d3plus.y - axes.margin.top;
                });
            } else {
                line.attr("x1", function(d) {
                    return d.d3plus.x - axes.margin.left;
                }).attr("x2", function(d) {
                    return d.d3plus.x - axes.margin.left;
                }).attr("y1", axes.height + 2).attr("y2", axes.height + 8);
            }
            return line.style("stroke", function(d) {
                return legible(color(vars, d));
            }).style("stroke-width", vars.data.stroke.width).attr("shape-rendering", vars.shape.rendering.value);
        };
        if (vars.dev.value) {
            print.time("creating axis tick groups");
        }
        ticks = vars.group.select("g#d3plus_graph_plane").selectAll("g.d3plus_data_tick").data(data, function(d) {
            var mod;
            mod = axes.discrete ? "_" + d.d3plus[axes.discrete] : "";
            return "tick_" + d[vars.id.value] + "_" + d.d3plus.depth + mod;
        });
        ticks.enter().append("g").attr("class", "d3plus_data_tick").attr("opacity", 0);
        if (vars.dev.value) {
            print.timeEnd("creating axis tick groups");
        }
        ref = ["x", "y"];
        for (i = 0, len = ref.length; i < len; i++) {
            axis = ref[i];
            if (vars.dev.value && timing) {
                print.time("creating " + axis + " ticks");
            }
            axisData = timing && axis !== axes.discrete ? data : [];
            tick = ticks.selectAll("line.d3plus_data_" + axis).data(axisData, function(d) {
                return "tick_" + d[vars.id.value] + "_" + d.d3plus.depth;
            });
            if (vars.dev.value && timing) {
                print.timeEnd("creating " + axis + " ticks");
            }
            if (vars.dev.value && timing) {
                print.time("styling " + axis + " ticks");
            }
            if (timing > 0) {
                tick.transition().duration(timing).call(style, axis);
            } else {
                tick.call(style, axis);
            }
            tick.enter().append("line").attr("class", "d3plus_data_" + axis).call(style, axis);
            if (vars.dev.value && timing) {
                print.timeEnd("styling " + axis + " ticks");
            }
        }
        if (timing > 0) {
            ticks.transition().duration(timing).attr("opacity", 1);
            ticks.exit().transition().duration(timing).attr("opacity", 0).remove();
        } else {
            ticks.attr("opacity", 1);
            ticks.exit().remove();
        }
    };


},{"../../../../color/legible.coffee":46,"../../../../core/console/print.coffee":54,"../../../../core/fetch/color.coffee":65}],316:[function(require,module,exports){
    var axes, draw, mouse, plot;

    axes = require("./includes/axes.coffee");

    draw = require("./includes/svg.coffee");

    mouse = require("./includes/mouse.coffee");

    plot = require("./includes/plot.coffee");

    module.exports = function(vars, opts) {
        if (opts === void 0) {
            opts = {};
        }
        axes(vars, opts);
        plot(vars, opts);
        draw(vars, opts);
        vars.mouse.viz = opts.mouse === true ? mouse : false;
    };


},{"./includes/axes.coffee":317,"./includes/mouse.coffee":319,"./includes/plot.coffee":320,"./includes/svg.coffee":321}],317:[function(require,module,exports){
    var arraySort, axisRange, buckets, buffer, dataChange, fetchData, fetchValue, getData, getScale, print, sizeScale, uniques;

    arraySort = require("../../../../../array/sort.coffee");

    buffer = require("./buffer.coffee");

    buckets = require("../../../../../util/buckets.coffee");

    fetchData = require("../../../../../core/fetch/data.js");

    fetchValue = require("../../../../../core/fetch/value.coffee");

    print = require("../../../../../core/console/print.coffee");

    uniques = require("../../../../../util/uniques.coffee");

    module.exports = function(vars, opts) {
        var axes, axis, changed, domains, i, j, len, len1, oppAxis, range, reorder, zero;
        changed = dataChange(vars);
        if (changed || !vars.axes.dataset) {
            vars.axes.dataset = getData(vars);
        }
        vars.axes.scale = opts.buffer && opts.buffer !== true ? sizeScale(vars, opts.buffer) : false;
        axes = vars.width.viz > vars.height.viz ? ["y", "y2", "x", "x2"] : ["x", "x2", "y", "y2"];
        for (i = 0, len = axes.length; i < len; i++) {
            axis = axes[i];
            oppAxis = axis.indexOf("x") === 0 ? "y" : "x";
            reorder = vars.order.changed || vars.order.sort.changed || (vars.order.value === true && vars[oppAxis].changed);
            if (vars[axis].value && (!vars[axis].ticks.values || changed || reorder)) {
                if (vars.dev.value) {
                    print.time("calculating " + axis + " axis");
                }
                vars[axis].reset = true;
                vars[axis].ticks.values = false;
                if (axis === vars.axes.discrete && vars[axis].value !== vars.time.value) {
                    vars[axis].ticks.values = uniques(vars.axes.dataset, vars[axis].value, fetchValue, vars);
                }
                zero = opts.zero === true || axis.indexOf(opts.zero) === 0 ? true : false;
                range = axisRange(vars, axis, zero);
                if (axis.indexOf("y") === 0) {
                    range = range.reverse();
                }
                vars[axis].scale.viz = getScale(vars, axis, range);
                vars[axis].domain.viz = range;
                if (vars.dev.value) {
                    print.timeEnd("calculating " + axis + " axis");
                }
            }
        }
        if (vars.axes.mirror.value) {
            domains = d3.extent(vars.y.domain.viz.concat(vars.x.domain.viz));
            vars.x.domain.viz = domains;
            vars.x.scale.viz.domain(domains);
            domains = domains.slice().reverse();
            vars.y.domain.viz = domains;
            vars.y.scale.viz.domain(domains);
        }
        if (opts.buffer) {
            for (j = 0, len1 = axes.length; j < len1; j++) {
                axis = axes[j];
                if (axis !== vars.axes.discrete) {
                    buffer(vars, axis, opts.buffer);
                }
            }
        }
    };

    dataChange = function(vars) {
        var axis, changed, check, i, j, k, l, len, len1, len2, ref, sub, subs;
        changed = vars.time.fixed.value && (vars.time.solo.changed || vars.time.mute.changed);
        if (!changed) {
            changed = vars.id.solo.changed || vars.id.mute.changed;
        }
        if (changed) {
            return changed;
        }
        check = ["data", "time", "id", "depth", "type", "x", "y", "x2", "y2"];
        for (i = 0, len = check.length; i < len; i++) {
            k = check[i];
            if (vars[k].changed) {
                changed = true;
                break;
            }
        }
        if (changed) {
            return changed;
        }
        subs = ["mute", "range", "scale", "solo", "stacked", "zerofill"];
        ref = ["x", "y", "x2", "y2"];
        for (j = 0, len1 = ref.length; j < len1; j++) {
            axis = ref[j];
            for (l = 0, len2 = subs.length; l < len2; l++) {
                sub = subs[l];
                if (vars[axis][sub].changed) {
                    changed = true;
                    break;
                }
            }
        }
        return changed;
    };

    getData = function(vars) {
        var d, depths;
        if (vars.time.fixed.value) {
            return vars.data.viz;
        } else {
            depths = d3.range(0, vars.id.nesting.length);
            return d3.merge([
                (function() {
                    var i, len, results;
                    results = [];
                    for (i = 0, len = depths.length; i < len; i++) {
                        d = depths[i];
                        results.push(fetchData(vars, "all", d));
                    }
                    return results;
                })()
            ]);
        }
    };

    axisRange = function(vars, axis, zero, buffer) {
        var agg, aggType, allNegative, allPositive, axisSums, counts, d, group, i, j, k, l, len, len1, len2, len3, m, min, oppAxis, ref, ref1, ref2, ref3, sort, sortKey, splitData, v, val, values;
        oppAxis = axis.indexOf("x") === 0 ? "y" : "x";
        if (vars[axis].range.value && vars[axis].range.value.length === 2) {
            return vars[axis].range.value.slice();
        } else if (vars[axis].scale.value === "share") {
            vars[axis].ticks.values = d3.range(0, 1.1, 0.1);
            return [0, 1];
        } else if (vars[axis].stacked.value) {
            splitData = [];
            ref = vars.axes.dataset;
            for (i = 0, len = ref.length; i < len; i++) {
                d = ref[i];
                if (d.values) {
                    splitData = splitData.concat(d.values);
                } else {
                    splitData.push(d);
                }
            }
            axisSums = d3.nest().key(function(d) {
                return fetchValue(vars, d, vars[oppAxis].value);
            }).rollup(function(leaves) {
                var negatives, positives;
                positives = d3.sum(leaves, function(d) {
                    var val;
                    val = fetchValue(vars, d, vars[axis].value);
                    if (val > 0) {
                        return val;
                    } else {
                        return 0;
                    }
                });
                negatives = d3.sum(leaves, function(d) {
                    var val;
                    val = fetchValue(vars, d, vars[axis].value);
                    if (val < 0) {
                        return val;
                    } else {
                        return 0;
                    }
                });
                return [negatives, positives];
            }).entries(splitData);
            values = d3.merge(axisSums.map(function(d) {
                return d.values;
            }));
            return d3.extent(values);
        } else if (vars[axis].value === vars.time.value) {
            if (vars.time.solo.value.length) {
                return d3.extent(vars.time.solo.value).map(function(v) {
                    if (v.constructor !== Date) {
                        v = v + "";
                        if (v.length === 4 && parseInt(v) + "" === v) {
                            v += "/01/01";
                        }
                        return new Date(v);
                    } else {
                        return v;
                    }
                });
            } else {
                return d3.extent(vars.data.time.ticks);
            }
        } else {
            values = [];
            ref1 = vars.axes.dataset;
            for (j = 0, len1 = ref1.length; j < len1; j++) {
                d = ref1[j];
                val = fetchValue(vars, d, vars[axis].value);
                if (val instanceof Array) {
                    values = values.concat(val);
                } else {
                    values.push(val);
                }
            }
            values = values.filter(function(d) {
                return d !== null;
            });
            if (axis === vars.axes.discrete) {
                if (vars.order.value === true) {
                    sortKey = vars[oppAxis].value;
                } else {
                    sortKey = vars.order.value;
                }
                if (sortKey) {
                    sort = vars.order.sort.value;
                    agg = vars.order.agg.value || vars.aggs.value[sortKey] || "max";
                    aggType = typeof agg;
                    counts = values.reduce(function(obj, val) {
                        obj[val] = [];
                        return obj;
                    }, {});
                    ref2 = vars.axes.dataset;
                    for (l = 0, len2 = ref2.length; l < len2; l++) {
                        d = ref2[l];
                        if (d.values) {
                            ref3 = d.values;
                            for (m = 0, len3 = ref3.length; m < len3; m++) {
                                v = ref3[m];
                                group = fetchValue(vars, v, vars[axis].value);
                                counts[group].push(fetchValue(vars, v, sortKey));
                            }
                        } else {
                            group = fetchValue(vars, d, vars[axis].value);
                            counts[group].push(fetchValue(vars, d, sortKey));
                        }
                    }
                    for (k in counts) {
                        v = counts[k];
                        if (aggType === "string") {
                            counts[k] = d3[agg](v);
                        } else if (aggType === "function") {
                            counts[k] = agg(v, sortKey);
                        }
                    }
                    counts = arraySort(d3.entries(counts), "value", sort);
                    counts = counts.reduce(function(arr, v) {
                        arr.push(v.key);
                        return arr;
                    }, []);
                    return counts;
                } else {
                    return uniques(values).sort();
                }
            } else {
                values.sort(function(a, b) {
                    return a - b;
                });
                if (vars[axis].scale.value === "log") {
                    if (values[0] === 0) {
                        values[0] = 1;
                    }
                    if (values[values.length - 1] === 0) {
                        values[values.length - 1] = -1;
                    }
                }
                if (zero) {
                    allPositive = values.every(function(v) {
                        return v > 0;
                    });
                    allNegative = values.every(function(v) {
                        return v < 0;
                    });
                    if (allPositive || allNegative) {
                        min = allPositive ? 1 : -1;
                        values.push(vars[axis].scale.value === "log" ? min : 0);
                    }
                }
                return d3.extent(values);
            }
        }
    };

    getScale = function(vars, axis, range) {
        var rangeArray, rangeMax, scaleType, t;
        rangeMax = axis.indexOf("x") === 0 ? vars.width.viz : vars.height.viz;
        scaleType = vars[axis].scale.value;
        if (["discrete", "share"].indexOf(scaleType) >= 0) {
            scaleType = "linear";
        }
        t = 10;
        if (typeof range[0] === "string") {
            scaleType = "ordinal";
            rangeArray = buckets([0, rangeMax], range.length);
        } else {
            rangeArray = [0, rangeMax];
            if (vars[axis].scale.value === "linear") {
                t = Math.floor(rangeMax / (vars[axis].ticks.font.size * 4));
            }
        }
        vars[axis].scale.ticks = t;
        return d3.scale[scaleType]().domain(range).range(rangeArray);
    };

    sizeScale = function(vars, value) {
        var domain, max, min;
        if (value === true) {
            value = "size";
        }
        if (value in vars) {
            value = vars[value].value;
        }
        min = vars.size.scale.min.value;
        if (typeof min === "function") {
            min = min(vars);
        }
        max = vars.size.scale.max.value;
        if (typeof max === "function") {
            max = max(vars);
        }
        if (value === false) {
            return vars.size.scale.value.rangeRound([max, max]);
        } else if (typeof value === "number") {
            return vars.size.scale.value.rangeRound([value, value]);
        } else if (value) {
            if (vars.dev.value) {
                print.time("calculating buffer scale");
            }
            domain = d3.extent(vars.axes.dataset, function(d) {
                var val;
                val = fetchValue(vars, d, value);
                if (!val) {
                    return 0;
                } else {
                    return val;
                }
            });
            if (domain[0] === domain[1]) {
                min = max;
            }
            if (vars.dev.value) {
                print.timeEnd("calculating buffer scale");
            }
            return vars.size.scale.value.domain(domain).rangeRound([min, max]);
        }
    };


},{"../../../../../array/sort.coffee":36,"../../../../../core/console/print.coffee":54,"../../../../../core/fetch/data.js":66,"../../../../../core/fetch/value.coffee":69,"../../../../../util/buckets.coffee":206,"../../../../../util/uniques.coffee":212,"./buffer.coffee":318}],318:[function(require,module,exports){
    var buckets, closest;

    buckets = require("../../../../../util/buckets.coffee");

    closest = require("../../../../../util/closest.coffee");

    module.exports = function(vars, axis, buffer) {
        var add, additional, allNegative, allPositive, closestTime, copy, d, diff, difference, domain, domainCompare, domainHigh, domainLow, i, lowerDiff, lowerMod, lowerScale, lowerValue, maxSize, opp, orig_domain, range, rangeMax, second, strings, timeIndex, upperDiff, upperMod, upperScale, upperValue, zero;
        if (vars[axis].scale.value !== "share" && !vars[axis].range.value && vars[axis].reset) {
            if (axis === vars.axes.discrete) {
                domain = vars[axis].scale.viz.domain();
                if (typeof domain[0] === "string") {
                    i = domain.length;
                    while (i >= 0) {
                        domain.splice(i, 0, "d3plus_buffer_" + i);
                        i--;
                    }
                    range = vars[axis].scale.viz.range();
                    range = buckets(d3.extent(range), domain.length);
                    return vars[axis].scale.viz.domain(domain).range(range);
                } else {
                    if (axis.indexOf("y") === 0) {
                        domain = domain.slice().reverse();
                    }
                    if (vars[axis].ticks.values.length === 1) {
                        if (vars[axis].value === vars.time.value && vars.data.time.ticks.length !== 1) {
                            closestTime = closest(vars.data.time.ticks, domain[0]);
                            timeIndex = vars.data.time.ticks.indexOf(closestTime);
                            if (timeIndex > 0) {
                                domain[0] = vars.data.time.ticks[timeIndex - 1];
                            } else {
                                diff = vars.data.time.ticks[timeIndex + 1] - closestTime;
                                domain[0] = new Date(closestTime.getTime() - diff);
                            }
                            if (timeIndex < vars.data.time.ticks.length - 1) {
                                domain[1] = vars.data.time.ticks[timeIndex + 1];
                            } else {
                                diff = closestTime - vars.data.time.ticks[timeIndex - 1];
                                domain[1] = new Date(closestTime.getTime() + diff);
                            }
                        } else {
                            domain[0] -= 1;
                            domain[1] += 1;
                        }
                    } else if (vars.axes.scale) {
                        difference = Math.abs(domain[1] - domain[0]);
                        additional = difference / (vars[axis].ticks.values.length - 1);
                        additional = additional / 2;
                        rangeMax = vars[axis].scale.viz.range()[1];
                        maxSize = vars.axes.scale.range()[1] * 1.5;
                        domainLow = vars[axis].scale.viz.invert(-maxSize);
                        domainHigh = vars[axis].scale.viz.invert(rangeMax + maxSize);
                        if (domain[0] - additional < domainLow) {
                            domain[0] = domain[0] - additional;
                            domain[1] = domain[1] + additional;
                        } else {
                            domain = [domainLow, domainHigh];
                            if (axis.indexOf("y") === 0) {
                                domain = domain.reverse();
                            }
                            domainCompare = vars[axis].scale.viz.domain();
                            domainCompare = domainCompare[1] - domainCompare[0];
                            if (!domainCompare) {
                                domain[0] -= 1;
                                domain[1] += 1;
                            }
                        }
                    } else if (vars[axis].value === vars.time.value) {
                        difference = Math.abs(domain[1] - domain[0]);
                        additional = difference / (vars[axis].ticks.values.length - 1);
                        additional = additional / 2;
                        domain[0] = domain[0] - additional;
                        domain[1] = domain[1] + additional;
                    } else {
                        difference = Math.abs(domain[1] - domain[0]);
                        add = difference / 2;
                        i = domain.length;
                        orig_domain = domain.slice();
                        while (i >= 0) {
                            d = i ? orig_domain[i - 1] + add : orig_domain[i] - add;
                            domain.splice(i, 0, d);
                            i--;
                        }
                        range = vars[axis].scale.viz.range();
                        range = buckets(d3.extent(range), domain.length);
                        vars[axis].scale.viz.domain(domain).range(range);
                    }
                    if (axis.indexOf("y") === 0) {
                        domain = domain.reverse();
                    }
                    return vars[axis].scale.viz.domain(domain);
                }
            } else if ((buffer === "x" && axis.indexOf("x") === 0) || (buffer === "y" && axis.indexOf("y") === 0) || (buffer === true)) {
                domain = vars[axis].scale.viz.domain();
                allPositive = domain[0] >= 0 && domain[1] >= 0;
                allNegative = domain[0] <= 0 && domain[1] <= 0;
                if (vars[axis].scale.value === "log") {
                    zero = allPositive ? 1 : -1;
                    if (allPositive && axis.indexOf("y") === 0) {
                        domain = domain.slice().reverse();
                    }
                    lowerScale = Math.pow(10, parseInt(Math.abs(domain[0])).toString().length - 1) * zero;
                    lowerMod = domain[0] % lowerScale;
                    lowerDiff = lowerMod;
                    if (lowerMod && lowerDiff / lowerScale <= 0.1) {
                        lowerDiff += lowerScale * zero;
                    }
                    lowerValue = lowerMod === 0 ? lowerScale : lowerDiff;
                    domain[0] -= lowerValue;
                    if (domain[0] === 0) {
                        domain[0] = zero;
                    }
                    upperScale = Math.pow(10, parseInt(Math.abs(domain[1])).toString().length - 1) * zero;
                    upperMod = domain[1] % upperScale;
                    upperDiff = Math.abs(upperScale - upperMod);
                    if (upperMod && upperDiff / upperScale <= 0.1) {
                        upperDiff += upperScale * zero;
                    }
                    upperValue = upperMod === 0 ? upperScale : upperDiff;
                    domain[1] += upperValue;
                    if (domain[1] === 0) {
                        domain[1] = zero;
                    }
                    if (allPositive && axis.indexOf("y") === 0) {
                        domain = domain.reverse();
                    }
                } else {
                    zero = 0;
                    if (axis.indexOf("y") === 0) {
                        domain = domain.slice().reverse();
                    }
                    strings = domain.filter(function(d) {
                        return d.constructor === String;
                    });
                    additional = Math.abs(domain[1] - domain[0]) * 0.05 || 1;
                    if (!strings.length) {
                        domain[0] = domain[0] - additional;
                        domain[1] = domain[1] + additional;
                        if ((allPositive && domain[0] < zero) || (allNegative && domain[0] > zero)) {
                            domain[0] = zero;
                        }
                        if ((allPositive && domain[1] < zero) || (allNegative && domain[1] > zero)) {
                            domain[1] = zero;
                        }
                    }
                    if (axis.indexOf("y") === 0) {
                        domain = domain.reverse();
                    }
                }
                return vars[axis].scale.viz.domain(domain);
            } else if (vars.axes.scale) {
                copy = false;
                if (vars.axes.mirror.value) {
                    opp = axis.indexOf("y") === 0 ? "x" : "y";
                    copy = vars[opp].scale.viz;
                    second = vars.width.viz > vars.height.viz ? "x" : "y";
                }
                if (axis === second && copy) {
                    domain = copy.domain().slice().reverse();
                } else {
                    rangeMax = vars[axis].scale.viz.range()[1];
                    maxSize = vars.axes.scale.range()[1];
                    domainLow = vars[axis].scale.viz.invert(-maxSize * 1.5);
                    domainHigh = vars[axis].scale.viz.invert(rangeMax + maxSize * 1.5);
                    domain = [domainLow, domainHigh];
                    if (axis.indexOf("y") === 0) {
                        domain = domain.reverse();
                    }
                    domainCompare = vars[axis].scale.viz.domain();
                    domainCompare = domainCompare[1] - domainCompare[0];
                    if (!domainCompare) {
                        domain[0] -= 1;
                        domain[1] += 1;
                    }
                    if (axis.indexOf("y") === 0) {
                        domain = domain.reverse();
                    }
                }
                return vars[axis].scale.viz.domain(domain);
            }
        }
    };


},{"../../../../../util/buckets.coffee":206,"../../../../../util/closest.coffee":208}],319:[function(require,module,exports){
    var copy, events, fetchColor, fetchValue, legible, textColor;

    copy = require("../../../../../util/copy.coffee");

    events = require("../../../../../client/pointer.coffee");

    fetchColor = require("../../../../../core/fetch/color.coffee");

    fetchValue = require("../../../../../core/fetch/value.coffee");

    legible = require("../../../../../color/legible.coffee");

    textColor = require("../../../../../color/text.coffee");

    module.exports = function(node, vars) {
        var clickRemove, color, create, graph, lineData, lineInit, lineStyle, lineUpdate, lines, r, rectStyle, rects, s, textStyle, texts, timing, x, y;
        clickRemove = d3.event.type === events.click && (vars.tooltip.value.long || vars.tooltip.html.value);
        create = [events.over, events.move].indexOf(d3.event.type) >= 0;
        x = node.d3plus.x;
        y = node.d3plus.y;
        r = node.d3plus.r || 0;
        s = vars.types[vars.type.value].scale || 1;
        r = r * s;
        graph = vars.axes;
        timing = vars.draw.timing ? vars.timing.mouseevents : 0;
        if (!clickRemove && create) {
            color = legible(fetchColor(vars, node));
            lineData = ["x", "y", "x2", "y2"].filter(function(axis) {
                var val;
                val = fetchValue(vars, node, vars[axis].value);
                return val && !(val instanceof Array) && axis !== vars.axes.stacked && vars[axis].mouse.value && axis !== vars.axes.discrete;
            });
        } else {
            lineData = [];
        }
        lineInit = function(line) {
            return line.attr("x1", function(d) {
                if (d.indexOf("x") === 0) {
                    return x;
                } else {
                    return x - r;
                }
            }).attr("y1", function(d) {
                if (d.indexOf("y") === 0) {
                    return y;
                } else {
                    return y + r;
                }
            }).attr("x2", function(d) {
                if (d.indexOf("x") === 0) {
                    return x;
                } else {
                    return x - r;
                }
            }).attr("y2", function(d) {
                if (d.indexOf("y") === 0) {
                    return y;
                } else {
                    return y + r;
                }
            }).attr("opacity", 0);
        };
        lineStyle = function(line) {
            return line.style("stroke", function(d) {
                if (vars.shape.value === "area") {
                    return "white";
                } else {
                    return color;
                }
            }).attr("stroke-dasharray", function(d) {
                return vars[d].mouse.dasharray.value;
            }).attr("shape-rendering", function(d) {
                return vars[d].mouse.rendering.value;
            }).style("stroke-width", function(d) {
                return vars[d].mouse.width;
            });
        };
        lineUpdate = function(line) {
            return line.attr("x1", function(d) {
                if (d.indexOf("x") === 0) {
                    return x;
                } else {
                    return x - r;
                }
            }).attr("y1", function(d) {
                if (d.indexOf("y") === 0) {
                    return y;
                } else {
                    return y + r;
                }
            }).attr("x2", function(d) {
                if (d.indexOf("x") === 0) {
                    return x;
                } else if (node.d3plus.x0) {
                    return node.d3plus.x0;
                } else if (d === "y") {
                    return graph.margin.left - vars[d].ticks.size;
                } else {
                    return graph.margin.left + graph.width + vars[d].ticks.size;
                }
            }).attr("y2", function(d) {
                if (d.indexOf("y") === 0) {
                    return y;
                } else if (node.d3plus.y0) {
                    return node.d3plus.y0;
                } else if (d === "x") {
                    return graph.height + graph.margin.top + vars[d].ticks.size;
                } else {
                    return graph.margin.top - vars[d].ticks.size;
                }
            }).style("opacity", 1);
        };
        lines = vars.g.labels.selectAll("line.d3plus_mouse_axis_label").data(lineData);
        if (timing) {
            lines.enter().append("line").attr("class", "d3plus_mouse_axis_label").attr("pointer-events", "none").call(lineInit).call(lineStyle);
            lines.transition().duration(timing).call(lineUpdate).call(lineStyle);
            lines.exit().transition().duration(timing).call(lineInit).remove();
        } else {
            lines.call(lineUpdate).call(lineStyle);
            lines.enter().append("line").attr("class", "d3plus_mouse_axis_label").attr("pointer-events", "none").call(lineInit).call(lineStyle);
            lines.exit().remove();
        }
        textStyle = function(text) {
            return text.attr("font-size", function(d) {
                return vars[d].ticks.font.size + "px";
            }).attr("font-family", function(d) {
                return vars[d].ticks.font.family.value;
            }).attr("font-weight", function(d) {
                return vars[d].ticks.font.weight;
            }).attr("x", function(d) {
                if (d.indexOf("x") === 0) {
                    return x;
                } else if (d === "y") {
                    return graph.margin.left - 5 - vars[d].ticks.size;
                } else {
                    return graph.margin.left + graph.width + 5 + vars[d].ticks.size;
                }
            }).attr("y", function(d) {
                if (d.indexOf("y") === 0) {
                    return y;
                } else if (node.d3plus.y0) {
                    return node.d3plus.y + (node.d3plus.y0 - node.d3plus.y) / 2 + graph.margin.top - 6;
                } else if (d === "x") {
                    return graph.height + graph.margin.top + 5 + vars[d].ticks.size;
                } else {
                    return graph.margin.top - 5 - vars[d].ticks.size - (vars[d].ticks.font.size * 1.35);
                }
            }).attr("fill", vars.shape.value === "area" ? "white" : textColor(color));
        };
        texts = vars.g.labels.selectAll("text.d3plus_mouse_axis_label").data(lineData);
        texts.enter().append("text").attr("class", "d3plus_mouse_axis_label").attr("id", function(d) {
            return d + "_d3plusmouseaxislabel";
        }).attr("dy", function(d) {
            if (d.indexOf("y") === 0) {
                return vars[d].ticks.font.size * 0.35;
            } else {
                return vars[d].ticks.font.size;
            }
        }).style("text-anchor", function(d) {
            if (d === "y") {
                return "end";
            } else if (d === "y2") {
                return "start";
            } else {
                return "middle";
            }
        }).attr("opacity", 0).attr("pointer-events", "none").call(textStyle);
        texts.text(function(d) {
            var axis, val;
            axis = vars.axes.stacked || d;
            val = fetchValue(vars, node, vars[axis].value);
            return vars.format.value(val, {
                key: vars[axis].value,
                vars: vars,
                labels: vars[axis].affixes.value
            });
        });
        if (timing) {
            texts.transition().duration(timing).delay(timing).attr("opacity", 1).call(textStyle);
            texts.exit().transition().duration(timing).attr("opacity", 0).remove();
        } else {
            texts.attr("opacity", 1).call(textStyle);
            texts.exit().remove();
        }
        rectStyle = function(rect) {
            var getText;
            getText = function(axis) {
                var l;
                l = d3.select("text#" + axis + "_d3plusmouseaxislabel");
                if (l.size()) {
                    return l.node().getBBox();
                } else {
                    return {
                        "width": 0,
                        "height": 0
                    };
                }
            };
            return rect.attr("x", function(d) {
                var width;
                width = getText(d).width;
                if (d.indexOf("x") === 0) {
                    return x - width / 2 - 5;
                } else if (d === "y") {
                    return graph.margin.left - vars[d].ticks.size - width - 10;
                } else {
                    return graph.margin.left + graph.width + vars[d].ticks.size;
                }
            }).attr("y", function(d) {
                var height;
                height = getText(d).height;
                if (d.indexOf("y") === 0) {
                    return y - (height / 2 + 5);
                } else if (node.d3plus.y0) {
                    return node.d3plus.y + (node.d3plus.y0 - node.d3plus.y) / 2 + graph.margin.top - (height / 2 + 5);
                } else if (d === "x") {
                    return graph.height + graph.margin.top + vars[d].ticks.size;
                } else {
                    return graph.margin.top - vars[d].ticks.size - height - 10;
                }
            }).attr("width", function(d) {
                return getText(d).width + 10;
            }).attr("height", function(d) {
                return getText(d).height + 10;
            }).style("stroke", vars.shape.value === "area" ? "transparent" : color).attr("fill", color).attr("shape-rendering", function(d) {
                return vars[d].mouse.rendering.value;
            }).style("stroke-width", function(d) {
                return vars[d].mouse.width;
            });
        };
        rects = vars.g.labels.selectAll("rect.d3plus_mouse_axis_label").data(lineData);
        if (timing) {
            rects.enter().insert("rect", "text.d3plus_mouse_axis_label").attr("class", "d3plus_mouse_axis_label").attr("pointer-events", "none").attr("opacity", 0).call(rectStyle);
            rects.transition().duration(timing).delay(timing).attr("opacity", 1).call(rectStyle);
            return rects.exit().transition().duration(timing).attr("opacity", 0).remove();
        } else {
            rects.attr("opacity", 1).call(rectStyle);
            rects.enter().insert("rect", "text.d3plus_mouse_axis_label").attr("class", "d3plus_mouse_axis_label").attr("pointer-events", "none").call(rectStyle);
            return rects.exit().remove();
        }
    };


},{"../../../../../client/pointer.coffee":40,"../../../../../color/legible.coffee":46,"../../../../../color/text.coffee":52,"../../../../../core/fetch/color.coffee":65,"../../../../../core/fetch/value.coffee":69,"../../../../../util/copy.coffee":209}],320:[function(require,module,exports){
    var buckets, buffer, createAxis, fetchValue, fontSizes, formatPower, labelPadding, resetMargins, superscript, textwrap, timeDetect, uniques;

    buckets = require("../../../../../util/buckets.coffee");

    buffer = require("./buffer.coffee");

    fetchValue = require("../../../../../core/fetch/value.coffee");

    fontSizes = require("../../../../../font/sizes.coffee");

    textwrap = require("../../../../../textwrap/textwrap.coffee");

    timeDetect = require("../../../../../core/data/time.coffee");

    uniques = require("../../../../../util/uniques.coffee");

    module.exports = function(vars, opts) {
        var axes, axis, axisStyle, extent, j, k, len, len1, newtick, opp, otherScale, scale, step, tens, tick, ticks, timeReturn, values;
        vars.axes.margin = resetMargins(vars);
        vars.axes.height = vars.height.viz;
        vars.axes.width = vars.width.viz;
        axes = vars.width.viz > vars.height.viz ? ["y", "y2", "x", "x2"] : ["x", "x2", "y", "y2"];
        for (j = 0, len = axes.length; j < len; j++) {
            axis = axes[j];
            if (vars[axis].value) {
                if (vars[axis].ticks.values === false) {
                    if (vars[axis].value === vars.time.value) {
                        ticks = vars.time.solo.value;
                        if (ticks.length) {
                            ticks = ticks.map(function(d) {
                                if (d.constructor !== Date) {
                                    d = d + "";
                                    if (d.length === 4 && parseInt(d) + "" === d) {
                                        d += "/01/01";
                                    }
                                    d = new Date(d);
                                }
                                return d;
                            });
                        } else {
                            ticks = vars.data.time.values;
                        }
                        extent = d3.extent(ticks);
                        step = vars.data.time.stepType;
                        ticks = [extent[0]];
                        tick = extent[0];
                        while (tick < extent[1]) {
                            newtick = new Date(tick);
                            tick = new Date(newtick["set" + step](newtick["get" + step]() + 1));
                            ticks.push(tick);
                        }
                        vars[axis].ticks.values = ticks;
                    } else {
                        if (axis.indexOf("2") === 1) {
                            otherScale = vars[axis.slice(0, 1)].scale.viz;
                            scale = vars[axis].scale.viz;
                            ticks = vars[axis.slice(0, 1)].scale.ticks;
                            vars[axis].ticks.values = otherScale.ticks(ticks).map(function(t) {
                                return parseFloat(d3.format(".5f")(scale.invert(otherScale(t))));
                            });
                        } else {
                            vars[axis].ticks.values = vars[axis].scale.viz.ticks(vars[axis].scale.ticks);
                        }
                    }
                }
                if (!vars[axis].ticks.values.length) {
                    values = fetchValue(vars, vars.data.viz, vars[axis].value);
                    if (!(values instanceof Array)) {
                        values = [values];
                    }
                    vars[axis].ticks.values = values;
                }
                opp = axis.indexOf("x") === 0 ? "y" : "x";
                if (vars[axis].ticks.values.length === 1 || (opts.buffer && opts.buffer !== opp && axis === vars.axes.discrete && vars[axis].reset === true)) {
                    buffer(vars, axis, opts.buffer);
                }
                vars[axis].reset = false;
                if (vars[axis].value === vars.time.value) {
                    axisStyle = {
                        "font-family": vars[axis].ticks.font.family.value,
                        "font-weight": vars[axis].ticks.font.weight,
                        "font-size": vars[axis].ticks.font.size + "px",
                        "text-transform": vars[axis].ticks.font.transform.value,
                        "letter-spacing": vars[axis].ticks.font.spacing + "px"
                    };
                    timeReturn = timeDetect(vars, {
                        values: vars[axis].ticks.values,
                        limit: vars.width.viz,
                        style: axisStyle
                    });
                    if (vars[axis].ticks.value) {
                        vars[axis].ticks.visible = vars[axis].ticks.value.map(Number);
                    } else if (vars[axis].ticks.labels.value.constructor === Array) {
                        vars[axis].ticks.visible = vars[axis].ticks.labels.value.map(Number);
                    } else {
                        vars[axis].ticks.visible = timeReturn.values.map(Number);
                    }
                    vars[axis].ticks.format = timeReturn.format;
                } else if (vars[axis].ticks.value) {
                    vars[axis].ticks.values = vars[axis].ticks.value;
                    if (vars[axis].ticks.labels.value.constructor === Array) {
                        vars[axis].ticks.visible = vars[axis].ticks.labels.value;
                    } else {
                        vars[axis].ticks.visible = vars[axis].ticks.value;
                    }
                } else if (vars[axis].ticks.labels.value.constructor === Array) {
                    vars[axis].ticks.visible = vars[axis].ticks.labels.value;
                } else if (vars[axis].scale.value === "log") {
                    ticks = vars[axis].ticks.values;
                    tens = ticks.filter(function(t) {
                        return Math.abs(t).toString().charAt(0) === "1";
                    });
                    if (tens.length < 3) {
                        vars[axis].ticks.visible = ticks;
                    } else {
                        vars[axis].ticks.visible = tens;
                    }
                } else {
                    vars[axis].ticks.visible = vars[axis].ticks.values;
                }
            }
        }
        if (!vars.small) {
            labelPadding(vars);
        }
        for (k = 0, len1 = axes.length; k < len1; k++) {
            axis = axes[k];
            vars[axis].axis.svg = createAxis(vars, axis);
        }
    };

    resetMargins = function(vars) {
        if (vars.small) {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
        } else {
            return {
                top: 10,
                right: 10,
                bottom: 10,
                left: 10
            };
        }
    };

    labelPadding = function(vars) {
        var axis, j, k, lastTick, len, len1, margin, ref, ref1, rightLabel, rightMod, x2Domain, xAttrs, xAxisHeight, xAxisWidth, xDomain, xLabel, xLabelAttrs, xMaxWidth, xSizes, xText, xValues, y2Domain, yAttrs, yAxisWidth, yDomain, yLabel, yLabelAttrs, yText, yValues;
        xDomain = vars.x.scale.viz.domain();
        yDomain = vars.y.scale.viz.domain();
        if (vars.x2.value) {
            x2Domain = vars.x2.scale.viz.domain();
        }
        if (vars.y2.value) {
            y2Domain = vars.y2.scale.viz.domain();
        }
        ref = ["y", "y2"];
        for (j = 0, len = ref.length; j < len; j++) {
            axis = ref[j];
            if (vars[axis].value) {
                margin = axis === "y" ? "left" : "right";
                yAttrs = {
                    "font-size": vars[axis].ticks.font.size + "px",
                    "font-family": vars[axis].ticks.font.family.value,
                    "font-weight": vars[axis].ticks.font.weight,
                    "text-transform": vars[axis].ticks.font.transform.value,
                    "letter-spacing": vars[axis].ticks.font.spacing + "px"
                };
                yValues = vars[axis].ticks.visible;
                if (vars[axis].scale.value === "log") {
                    yText = yValues.map(function(d) {
                        return formatPower(d);
                    });
                } else if (vars[axis].scale.value === "share") {
                    yText = yValues.map(function(d) {
                        return vars.format.value(d * 100, {
                            key: "share",
                            vars: vars,
                            output: axis
                        });
                    });
                } else if (vars[axis].value === vars.time.value) {
                    yText = yValues.map(function(d, i) {
                        return vars[axis].ticks.format(new Date(d));
                    });
                } else {
                    if (typeof yValues[0] === "string") {
                        yValues = vars[axis].scale.viz.domain().filter(function(d) {
                            return d.indexOf("d3plus_buffer_") !== 0;
                        });
                    }
                    yText = yValues.map(function(d) {
                        return vars.format.value(d, {
                            key: vars[axis].value,
                            vars: vars,
                            labels: vars[axis].affixes.value,
                            output: axis
                        });
                    });
                }
                if (vars[axis].ticks.labels.value) {
                    vars[axis].ticks.hidden = false;
                    yAxisWidth = d3.max(fontSizes(yText, yAttrs), function(d) {
                        return d.width;
                    });
                    yAxisWidth = Math.ceil(yAxisWidth + vars.labels.padding);
                    vars.axes.margin[margin] += yAxisWidth;
                } else {
                    vars[axis].ticks.hidden = true;
                }
                yLabel = vars[axis].label.fetch(vars);
                if (yLabel) {
                    yLabelAttrs = {
                        "font-family": vars[axis].label.font.family.value,
                        "font-weight": vars[axis].label.font.weight,
                        "font-size": vars[axis].label.font.size + "px",
                        "text-transform": vars[axis].label.font.transform.value,
                        "letter-spacing": vars[axis].label.font.spacing + "px"
                    };
                    vars[axis].label.height = fontSizes([yLabel], yLabelAttrs)[0].height;
                } else {
                    vars[axis].label.height = 0;
                }
                if (vars[axis].label.value) {
                    vars.axes.margin[margin] += vars[axis].label.height;
                    vars.axes.margin[margin] += vars[axis].label.padding * 2;
                }
            }
        }
        vars.axes.width -= vars.axes.margin.left + vars.axes.margin.right;
        vars.x.scale.viz.range(buckets([0, vars.axes.width], xDomain.length));
        if (x2Domain) {
            vars.x2.scale.viz.range(buckets([0, vars.axes.width], x2Domain.length));
        }
        ref1 = ["x", "x2"];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
            axis = ref1[k];
            if (vars[axis].value) {
                margin = axis === "x" ? "bottom" : "top";
                if (vars[axis].ticks.labels.value) {
                    vars[axis].ticks.hidden = false;
                    xAttrs = {
                        "font-size": vars[axis].ticks.font.size + "px",
                        "font-family": vars[axis].ticks.font.family.value,
                        "font-weight": vars[axis].ticks.font.weight,
                        "text-transform": vars[axis].ticks.font.transform.value,
                        "letter-spacing": vars[axis].ticks.font.spacing + "px"
                    };
                    xValues = vars[axis].ticks.visible;
                    if (vars[axis].scale.value === "log") {
                        xText = xValues.map(function(d) {
                            return formatPower(d);
                        });
                    } else if (vars[axis].scale.value === "share") {
                        xText = xValues.map(function(d) {
                            return vars.format.value(d * 100, {
                                key: "share",
                                vars: vars,
                                output: axis
                            });
                        });
                    } else if (vars[axis].value === vars.time.value) {
                        xText = xValues.map(function(d, i) {
                            return vars[axis].ticks.format(new Date(d));
                        });
                    } else {
                        if (typeof xValues[0] === "string") {
                            xValues = vars[axis].scale.viz.domain().filter(function(d) {
                                return d.indexOf("d3plus_buffer_") !== 0;
                            });
                        }
                        xText = xValues.map(function(d) {
                            return vars.format.value(d, {
                                key: vars[axis].value,
                                vars: vars,
                                labels: vars[axis].affixes.value,
                                output: axis
                            });
                        });
                    }
                    xSizes = fontSizes(xText, xAttrs);
                    xAxisWidth = d3.max(xSizes, function(d) {
                        return d.width;
                    });
                    xAxisHeight = d3.max(xSizes, function(d) {
                        return d.height;
                    });
                    if (xValues.length === 1) {
                        xMaxWidth = vars.axes.width;
                    } else {
                        xMaxWidth = vars[axis].scale.viz(xValues[1]) - vars[axis].scale.viz(xValues[0]);
                        xMaxWidth = Math.abs(xMaxWidth);
                    }
                    if (xAxisWidth > xMaxWidth && xText.join("").indexOf(" ") > 0) {
                        vars[axis].ticks.wrap = true;
                        xSizes = fontSizes(xText, xAttrs, {
                            mod: function(elem) {
                                return textwrap().container(d3.select(elem)).height(vars.axes.height / 2).width(xMaxWidth).draw();
                            }
                        });
                        xAxisWidth = d3.max(xSizes, function(d) {
                            return d.width;
                        });
                        xAxisHeight = d3.max(xSizes, function(d) {
                            return d.height;
                        });
                    } else {
                        vars[axis].ticks.wrap = false;
                    }
                    vars[axis].ticks.baseline = "auto";
                    if (xAxisWidth <= xMaxWidth) {
                        vars[axis].ticks.rotate = 0;
                    } else if (xAxisWidth < vars.axes.height / 2) {
                        xSizes = fontSizes(xText, xAttrs, {
                            mod: function(elem) {
                                return textwrap().container(d3.select(elem)).width(vars.axes.height / 2).height(xMaxWidth).draw();
                            }
                        });
                        xAxisHeight = d3.max(xSizes, function(d) {
                            return d.width;
                        });
                        xAxisWidth = d3.max(xSizes, function(d) {
                            return d.height;
                        });
                        vars[axis].ticks.rotate = -90;
                    } else {
                        xAxisWidth = 0;
                        xAxisHeight = 0;
                    }
                    if (!(xAxisWidth && xAxisHeight)) {
                        vars[axis].ticks.hidden = true;
                        vars[axis].ticks.rotate = 0;
                    }
                    xAxisWidth = Math.ceil(xAxisWidth);
                    xAxisHeight = Math.ceil(xAxisHeight);
                    vars[axis].ticks.maxHeight = xAxisHeight;
                    vars[axis].ticks.maxWidth = xAxisWidth;
                    vars.axes.margin[margin] += xAxisHeight + vars.labels.padding;
                    lastTick = vars[axis].ticks.visible[vars[axis].ticks.visible.length - 1];
                    rightLabel = vars[axis].scale.viz(lastTick);
                    rightLabel += xAxisWidth / 2 + vars.axes.margin.left;
                    if (rightLabel > vars.width.value) {
                        rightMod = rightLabel - vars.width.value + vars.axes.margin.right;
                        vars.axes.width -= rightMod;
                        vars.axes.margin.right += rightMod;
                    }
                } else {
                    vars[axis].ticks.hidden = true;
                }
                xLabel = vars[axis].label.fetch(vars);
                if (xLabel) {
                    xLabelAttrs = {
                        "font-family": vars[axis].label.font.family.value,
                        "font-weight": vars[axis].label.font.weight,
                        "font-size": vars[axis].label.font.size + "px",
                        "text-transform": vars[axis].label.font.transform.value,
                        "letter-spacing": vars[axis].label.font.spacing + "px"
                    };
                    vars[axis].label.height = fontSizes([xLabel], xLabelAttrs)[0].height;
                } else {
                    vars[axis].label.height = 0;
                }
                if (vars[axis].label.value) {
                    vars.axes.margin[margin] += vars[axis].label.height;
                    vars.axes.margin[margin] += vars[axis].label.padding * 2;
                }
            }
        }
        vars.axes.height -= vars.axes.margin.top + vars.axes.margin.bottom;
        vars.x.scale.viz.range(buckets([0, vars.axes.width], xDomain.length));
        if (x2Domain) {
            vars.x2.scale.viz.range(buckets([0, vars.axes.width], x2Domain.length));
        }
        vars.y.scale.viz.range(buckets([0, vars.axes.height], yDomain.length));
        if (y2Domain) {
            return vars.y2.scale.viz.range(buckets([0, vars.axes.height], y2Domain.length));
        }
    };

    createAxis = function(vars, axis) {
        return d3.svg.axis().tickSize(vars[axis].ticks.size).tickPadding(5).orient(vars[axis].orient.value).scale(vars[axis].scale.viz).tickValues(vars[axis].ticks.values).tickFormat(function(d, i) {
            var c, scale;
            if (vars[axis].ticks.hidden) {
                return null;
            }
            scale = vars[axis].scale.value;
            c = d.constructor === Date ? +d : d;
            if (vars[axis].ticks.visible.indexOf(c) >= 0) {
                if (scale === "share") {
                    return vars.format.value(d * 100, {
                        key: "share",
                        vars: vars,
                        labels: vars[axis].affixes.value,
                        output: axis
                    });
                } else if (d.constructor === Date) {
                    return vars[axis].ticks.format(d);
                } else if (scale === "log") {
                    return formatPower(d);
                } else {
                    return vars.format.value(d, {
                        key: vars[axis].value,
                        vars: vars,
                        labels: vars[axis].affixes.value,
                        output: axis
                    });
                }
            } else {
                return null;
            }
        });
    };

    superscript = "⁰¹²³⁴⁵⁶⁷⁸⁹";

    formatPower = function(d) {
        var n, p, t;
        p = Math.round(Math.log(Math.abs(d)) / Math.LN10);
        t = Math.abs(d).toString().charAt(0);
        n = 10 + " " + (p + "").split("").map(function(c) {
            return superscript[c];
        }).join("");
        if (t !== "1") {
            n = t + " x " + n;
        }
        if (d < 0) {
            return "-" + n;
        } else {
            return n;
        }
    };


},{"../../../../../core/data/time.coffee":64,"../../../../../core/fetch/value.coffee":69,"../../../../../font/sizes.coffee":103,"../../../../../textwrap/textwrap.coffee":202,"../../../../../util/buckets.coffee":206,"../../../../../util/uniques.coffee":212,"./buffer.coffee":318}],321:[function(require,module,exports){
    var mix, textwrap, validObject;

    mix = require("../../../../../color/mix.coffee");

    textwrap = require("../../../../../textwrap/textwrap.coffee");

    validObject = require("../../../../../object/validate.coffee");

    module.exports = function(vars) {
        var affixes, alignMap, axis, axisData, axisGroup, axisLabel, bg, bgStyle, d, domain, domains, getFontStyle, grid, gridData, groupEnter, j, k, l, label, labelData, labelStyle, len, len1, len2, len3, len4, line, lineData, lineFont, lineGroup, lineRects, lineStyle, lines, linetexts, m, mirror, n, opp, plane, planeTrans, position, realData, rectData, rectStyle, ref, ref1, ref2, ref3, rotated, sep, style, textData, textPad, textPos, tickFont, tickPosition, tickStyle, userLines, valid, xStyle, yStyle;
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return null;
        }
        bgStyle = {
            width: vars.axes.width,
            height: vars.axes.height,
            fill: vars.axes.background.color,
            stroke: vars.axes.background.stroke.color,
            "stroke-width": vars.axes.background.stroke.width,
            "shape-rendering": vars.axes.background.rendering.value
        };
        alignMap = {
            left: "start",
            center: "middle",
            right: "end"
        };
        axisData = vars.small ? [] : [0];
        tickPosition = function(tick, axis) {
            return tick.attr("x1", function(d) {
                if (axis.indexOf("x") === 0) {
                    return vars.x.scale.viz(d);
                } else {
                    return 0;
                }
            }).attr("x2", function(d) {
                if (axis.indexOf("x") === 0) {
                    return vars.x.scale.viz(d);
                } else {
                    return vars.axes.width;
                }
            }).attr("y1", function(d) {
                if (axis.indexOf("y") === 0) {
                    return vars.y.scale.viz(d);
                } else {
                    return 0;
                }
            }).attr("y2", function(d) {
                if (axis.indexOf("y") === 0) {
                    return vars.y.scale.viz(d);
                } else {
                    return vars.axes.height;
                }
            });
        };
        tickStyle = function(tick, axis, grid) {
            var color, log;
            color = grid ? vars[axis].grid.color : vars[axis].ticks.color;
            log = vars[axis].scale.value === "log";
            return tick.attr("stroke", function(d) {
                var visible;
                if (d === 0) {
                    return vars[axis].axis.color;
                }
                if (d.constructor === Date) {
                    d = +d;
                }
                visible = vars[axis].ticks.visible.indexOf(d) >= 0;
                if (visible && (!log || Math.abs(d).toString().charAt(0) === "1")) {
                    return color;
                } else if (grid && vars.axes.background.color !== "transparent") {
                    return mix(color, vars.axes.background.color, 0.4, 1);
                } else if (vars.background.value !== "transparent") {
                    return mix(color, vars.background.value, 0.4, 1);
                } else {
                    return mix(color, "white", 0.4, 1);
                }
            }).attr("stroke-width", vars[axis].ticks.width).attr("shape-rendering", vars[axis].ticks.rendering.value);
        };
        getFontStyle = function(axis, val, style) {
            var type;
            type = val === 0 ? "axis" : "ticks";
            val = vars[axis][type].font[style];
            if (val && (val.length || typeof val === "number")) {
                return val;
            } else {
                return vars[axis].ticks.font[style];
            }
        };
        tickFont = function(tick, axis) {
            var log;
            log = vars[axis].scale.value === "log";
            return tick.attr("font-size", function(d) {
                return getFontStyle(axis, d, "size") + "px";
            }).attr("stroke", "none").attr("fill", function(d) {
                var color;
                color = getFontStyle(axis, d, "color");
                if (!log || Math.abs(d).toString().charAt(0) === "1") {
                    return color;
                } else {
                    return mix(color, vars.background.value, 0.4, 1);
                }
            }).attr("font-family", function(d) {
                return getFontStyle(axis, d, "family").value;
            }).attr("font-weight", function(d) {
                return getFontStyle(axis, d, "weight");
            }).style("text-transform", function(d) {
                return getFontStyle(axis, d, "transform").value;
            }).style("letter-spacing", function(d) {
                return getFontStyle(axis, d, "spacing") + "px";
            });
        };
        lineStyle = function(line, axis) {
            var max, opp;
            max = axis.indexOf("x") === 0 ? "height" : "width";
            opp = axis.indexOf("x") === 0 ? "y" : "x";
            return line.attr(opp + "1", 0).attr(opp + "2", vars.axes[max]).attr(axis + "1", function(d) {
                return d.coords.line;
            }).attr(axis + "2", function(d) {
                return d.coords.line;
            }).attr("stroke", function(d) {
                return d.color || vars[axis].lines.color;
            }).attr("stroke-width", vars[axis].lines.width).attr("shape-rendering", vars[axis].lines.rendering.value).attr("stroke-dasharray", vars[axis].lines.dasharray.value);
        };
        lineFont = function(text, axis) {
            var opp;
            opp = axis.indexOf("x") === 0 ? "y" : "x";
            return text.attr(opp, function(d) {
                return d.coords.text[opp] + "px";
            }).attr(axis, function(d) {
                return d.coords.text[axis] + "px";
            }).attr("dy", vars[axis].lines.font.position.value).attr("text-anchor", alignMap[vars[axis].lines.font.align.value]).attr("transform", function(d) {
                return d.transform;
            }).attr("font-size", vars[axis].lines.font.size + "px").attr("fill", function(d) {
                return d.color || vars[axis].lines.color;
            }).attr("font-family", vars[axis].lines.font.family.value).attr("font-weight", vars[axis].lines.font.weight);
        };
        planeTrans = "translate(" + vars.axes.margin.left + "," + vars.axes.margin.top + ")";
        plane = vars.group.selectAll("g#d3plus_graph_plane").data([0]);
        plane.transition().duration(vars.draw.timing).attr("transform", planeTrans);
        plane.enter().append("g").attr("id", "d3plus_graph_plane").attr("transform", planeTrans);
        bg = plane.selectAll("rect#d3plus_graph_background").data([0]);
        bg.transition().duration(vars.draw.timing).attr(bgStyle);
        bg.enter().append("rect").attr("id", "d3plus_graph_background").attr("x", 0).attr("y", 0).attr(bgStyle);
        mirror = plane.selectAll("path#d3plus_graph_mirror").data([0]);
        mirror.enter().append("path").attr("id", "d3plus_graph_mirror").attr("fill", "#000").attr("fill-opacity", 0.03).attr("stroke-width", 1).attr("stroke", "#ccc").attr("stroke-dasharray", "10,10").attr("opacity", 0);
        mirror.transition().duration(vars.draw.timing).attr("opacity", function() {
            if (vars.axes.mirror.value) {
                return 1;
            } else {
                return 0;
            }
        }).attr("d", function() {
            var h, w;
            w = bgStyle.width;
            h = bgStyle.height;
            return "M " + w + " " + h + " L 0 " + h + " L " + w + " 0 Z";
        });
        rotated = vars.x.ticks.rotate !== 0;
        xStyle = function(group, axis) {
            var groups, offset;
            offset = axis === "x" ? vars.axes.height : 0;
            groups = group.attr("transform", "translate(0," + offset + ")").call(vars[axis].axis.svg.scale(vars[axis].scale.viz)).selectAll("g.tick");
            groups.selectAll("line").attr("y2", function(d) {
                var y2;
                if (d.constructor === Date) {
                    d = +d;
                }
                y2 = d3.select(this).attr("y2");
                if (vars[axis].ticks.visible.indexOf(d) >= 0) {
                    return y2;
                } else {
                    return y2 / 2;
                }
            });
            return groups.select("text").style("text-anchor", rotated && axis === "x" ? "end" : rotated ? "start" : "middle").call(tickFont, axis).each(function(d) {
                d3.select(this).attr("dy", "0px").attr("font-size", function(d) {
                    return getFontStyle(axis, d, "size") + "px";
                });
                if (d.constructor === Date) {
                    d = +d;
                }
                if (!vars[axis].ticks.hidden && vars[axis].ticks.visible.indexOf(d) >= 0) {
                    return textwrap().container(d3.select(this)).rotate(vars[axis].ticks.rotate).align(rotated ? "end" : "center").valign(rotated ? "middle" : axis === "x" ? "top" : "bottom").width(vars[axis].ticks.maxWidth).height(vars[axis].ticks.maxHeight).padding(0).x(-vars[axis].ticks.maxWidth / 2).y(axis === "x2" ? -(vars[axis].ticks.maxHeight + vars.labels.padding * 2) : 0).draw();
                }
            });
        };
        yStyle = function(group, axis) {
            var groups, offset;
            offset = axis === "y2" ? vars.axes.width : 0;
            groups = group.attr("transform", "translate(" + offset + ", 0)").call(vars[axis].axis.svg.scale(vars[axis].scale.viz)).selectAll("g.tick");
            groups.selectAll("line").attr("y2", function(d) {
                var y2;
                if (d.constructor === Date) {
                    d = +d;
                }
                y2 = d3.select(this).attr("y2");
                if (vars.x.ticks.visible.indexOf(d) >= 0) {
                    return y2;
                } else {
                    return y2 / 2;
                }
            });
            return groups.select("text").call(tickFont, axis);
        };
        ref = ["x", "x2", "y", "y2"];
        for (j = 0, len = ref.length; j < len; j++) {
            axis = ref[j];
            style = axis.indexOf("x") === 0 ? xStyle : yStyle;
            realData = axisData.length && vars[axis].value ? [0] : [];
            axisGroup = plane.selectAll("g#d3plus_graph_" + axis + "ticks").data(realData);
            axisGroup.transition().duration(vars.draw.timing).call(style, axis);
            axisGroup.selectAll("line").transition().duration(vars.draw.timing).call(tickStyle, axis);
            groupEnter = axisGroup.enter().append("g").attr("id", "d3plus_graph_" + axis + "ticks").call(style, axis);
            groupEnter.selectAll("path").attr("fill", "none").attr("stroke", "none");
            groupEnter.selectAll("line").call(tickStyle, axis);
            axisGroup.exit().transition().duration(vars.data.timing).attr("opacity", 0).remove();
        }
        labelStyle = function(label, axis) {
            return label.attr("x", axis.indexOf("x") === 0 ? vars.width.viz / 2 : -(vars.axes.height / 2 + vars.axes.margin.top)).attr("y", axis === "x" ? vars.height.viz - vars[axis].label.height / 2 - vars[axis].label.padding : axis === "y2" ? vars.width.viz - vars[axis].label.height / 2 - vars[axis].label.padding : vars[axis].label.height / 2 + vars[axis].label.padding).attr("transform", axis.indexOf("y") === 0 ? "rotate(-90)" : null).attr("font-family", vars[axis].label.font.family.value).attr("font-weight", vars[axis].label.font.weight).attr("font-size", vars[axis].label.font.size + "px").attr("fill", vars[axis].label.font.color).style("text-anchor", "middle").attr("dominant-baseline", "central").style("text-transform", vars[axis].label.font.transform.value).style("letter-spacing", vars[axis].label.font.spacing + "px");
        };
        ref1 = ["x", "y"];
        for (k = 0, len1 = ref1.length; k < len1; k++) {
            axis = ref1[k];
            if (vars[axis].grid.value) {
                if (vars[axis].ticks.value) {
                    gridData = vars[axis].ticks.value;
                } else {
                    gridData = vars[axis].ticks.values;
                }
            } else {
                gridData = [];
                opp = axis === "x" ? "y" : "x";
                if (vars[axis].ticks.values.indexOf(0) >= 0 && vars[opp].axis.value) {
                    gridData = [0];
                }
            }
            grid = plane.selectAll("g#d3plus_graph_" + axis + "grid").data([0]);
            grid.enter().append("g").attr("id", "d3plus_graph_" + axis + "grid");
            lines = grid.selectAll("line").data(gridData, function(d, i) {
                if (d.constructor === Date) {
                    return d.getTime();
                } else {
                    return d;
                }
            });
            lines.transition().duration(vars.draw.timing).call(tickPosition, axis).call(tickStyle, axis, true);
            lines.enter().append("line").style("opacity", 0).call(tickPosition, axis).call(tickStyle, axis, true).transition().duration(vars.draw.timing).delay(vars.draw.timing / 2).style("opacity", 1);
            lines.exit().transition().duration(vars.draw.timing / 2).style("opacity", 0).remove();
        }
        ref2 = ["x", "x2", "y", "y2"];
        for (l = 0, len2 = ref2.length; l < len2; l++) {
            axis = ref2[l];
            if (vars[axis].value) {
                axisLabel = vars[axis].label.fetch(vars);
                labelData = axisData && axisLabel ? [0] : [];
                affixes = vars.format.affixes.value[vars[axis].value];
                if (axisLabel && !vars[axis].affixes.value && affixes) {
                    sep = vars[axis].affixes.separator.value;
                    if (sep === true) {
                        sep = ["[", "]"];
                    } else if (sep === false) {
                        sep = ["", ""];
                    }
                    axisLabel += " " + sep[0] + affixes[0] + " " + affixes[1] + sep[1];
                }
            } else {
                axisLabel = "";
                labelData = [];
            }
            label = vars.group.selectAll("text#d3plus_graph_" + axis + "label").data(labelData);
            label.text(axisLabel).transition().duration(vars.draw.timing).call(labelStyle, axis);
            label.enter().append("text").attr("stroke", "none").attr("id", "d3plus_graph_" + axis + "label").text(axisLabel).call(labelStyle, axis);
            label.exit().transition().duration(vars.data.timing).attr("opacity", 0).remove();
        }
        ref3 = ["x", "y", "x2", "y2"];
        for (m = 0, len3 = ref3.length; m < len3; m++) {
            axis = ref3[m];
            if (vars[axis].value) {
                lineGroup = plane.selectAll("g#d3plus_graph_" + axis + "_userlines").data([0]);
                lineGroup.enter().append("g").attr("id", "d3plus_graph_" + axis + "_userlines");
                domain = vars[axis].scale.viz.domain();
                if (axis.indexOf("y") === 0) {
                    domain = domain.slice().reverse();
                }
                textData = [];
                lineData = [];
                userLines = vars[axis].lines.value || [];
                for (n = 0, len4 = userLines.length; n < len4; n++) {
                    line = userLines[n];
                    d = validObject(line) ? line.position : line;
                    if (axis === vars.axes.discrete) {
                        valid = domain.indexOf(d) >= 0;
                    } else {
                        valid = d >= domain[0] && d <= domain[1];
                    }
                    if (valid) {
                        d = !validObject(line) ? {
                            "position": d
                        } : line;
                        d.coords = {
                            line: vars[axis].scale.viz(d.position)
                        };
                        lineData.push(d);
                        if (d.text) {
                            d.axis = axis;
                            d.padding = vars[axis].lines.font.padding.value * 0.5;
                            d.align = vars[axis].lines.font.align.value;
                            position = vars[axis].lines.font.position.text;
                            textPad = position === "middle" ? 0 : d.padding * 2;
                            if (position === "top") {
                                textPad = -textPad;
                            }
                            if (axis.indexOf("x") === 0) {
                                textPos = d.align === "left" ? vars.axes.height : d.align === "center" ? vars.axes.height / 2 : 0;
                                if (d.align === "left") {
                                    textPos -= d.padding * 2;
                                }
                                if (d.align === "right") {
                                    textPos += d.padding * 2;
                                }
                            } else {
                                textPos = d.align === "left" ? 0 : d.align === "center" ? vars.axes.width / 2 : vars.axes.width;
                                if (d.align === "right") {
                                    textPos -= d.padding * 2;
                                }
                                if (d.align === "left") {
                                    textPos += d.padding * 2;
                                }
                            }
                            d.coords.text = {};
                            d.coords.text[axis.indexOf("x") === 0 ? "y" : "x"] = textPos;
                            d.coords.text[axis] = vars[axis].scale.viz(d.position) + textPad;
                            d.transform = axis.indexOf("x") === 0 ? "rotate(-90," + d.coords.text.x + "," + d.coords.text.y + ")" : null;
                            textData.push(d);
                        }
                    }
                }
                lines = lineGroup.selectAll("line.d3plus_graph_" + axis + "line").data(lineData, function(d) {
                    return d.position;
                });
                lines.enter().append("line").attr("class", "d3plus_graph_" + axis + "line").attr("opacity", 0).call(lineStyle, axis);
                lines.transition().duration(vars.draw.timing).attr("opacity", 1).call(lineStyle, axis);
                lines.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
                linetexts = lineGroup.selectAll("text.d3plus_graph_" + axis + "line_text").data(textData, function(d) {
                    return d.position;
                });
                linetexts.enter().append("text").attr("class", "d3plus_graph_" + axis + "line_text").attr("id", function(d) {
                    var id;
                    id = d.position + "";
                    id = id.replace("-", "neg");
                    id = id.replace(".", "p");
                    return "d3plus_graph_" + axis + "line_text_" + id;
                }).attr("opacity", 0).call(lineFont, axis);
                linetexts.text(function(d) {
                    return d.text;
                }).transition().duration(vars.draw.timing).attr("opacity", 1).call(lineFont, axis);
                linetexts.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
                rectStyle = function(rect) {
                    var getText;
                    getText = function(d) {
                        var id;
                        id = d.position + "";
                        id = id.replace("-", "neg");
                        id = id.replace(".", "p");
                        return plane.select("text#d3plus_graph_" + d.axis + "line_text_" + id).node().getBBox();
                    };
                    return rect.attr("x", function(d) {
                        return getText(d).x - d.padding;
                    }).attr("y", function(d) {
                        return getText(d).y - d.padding;
                    }).attr("transform", function(d) {
                        return d.transform;
                    }).attr("width", function(d) {
                        return getText(d).width + (d.padding * 2);
                    }).attr("height", function(d) {
                        return getText(d).height + (d.padding * 2);
                    }).attr("fill", vars.axes.background.color !== "transparent" ? vars.axes.background.color : "white");
                };
                rectData = vars[axis].lines.font.background.value ? textData : [];
                lineRects = lineGroup.selectAll("rect.d3plus_graph_" + axis + "line_rect").data(rectData, function(d) {
                    return d.position;
                });
                lineRects.enter().insert("rect", "text.d3plus_graph_" + axis + "line_text").attr("class", "d3plus_graph_" + axis + "line_rect").attr("pointer-events", "none").attr("opacity", 0).call(rectStyle);
                lineRects.transition().delay(vars.draw.timing).each("end", function(d) {
                    return d3.select(this).transition().duration(vars.draw.timing).attr("opacity", 1).call(rectStyle);
                });
                lineRects.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
            }
        }
    };


},{"../../../../../color/mix.coffee":48,"../../../../../object/validate.coffee":174,"../../../../../textwrap/textwrap.coffee":202}],322:[function(require,module,exports){
    var fetchValue, stringStrip, uniqueValues;

    fetchValue = require("../../../../core/fetch/value.coffee");

    stringStrip = require("../../../../string/strip.js");

    uniqueValues = require("../../../../util/uniques.coffee");

    module.exports = function(vars, data, keys) {
        var discrete, extras, key, opposite, serialized, ticks, timeAxis;
        if (keys === void 0) {
            keys = vars.id.nesting.slice(0, vars.depth.value + 1);
        } else if (keys.constructor !== Array) {
            keys = [keys];
        }
        if (extras === void 0) {
            extras = [];
        }
        if (!data) {
            data = vars.data.viz;
        }
        discrete = vars[vars.axes.discrete];
        opposite = vars[vars.axes.opposite];
        timeAxis = discrete.value === vars.time.value;
        if (timeAxis) {
            ticks = vars.data.time.ticks;
            key = vars.time.solo.value.length ? "solo" : "mute";
            if (vars.time[key].value.length) {
                serialized = vars.time[key].value.slice().map(function(f) {
                    if (f.constructor !== Date) {
                        f = f + "";
                        if (f.length === 4 && parseInt(f) + "" === f) {
                            f += "/01/01";
                        }
                        f = new Date(f);
                    }
                    return +f;
                });
                ticks = ticks.filter(function(f) {
                    if (key === "solo") {
                        return serialized.indexOf(+f) >= 0;
                    } else {
                        return serialized.indexOf(+f) < 0;
                    }
                });
            }
        } else if (discrete.ticks.values) {
            ticks = discrete.ticks.values;
        } else {
            ticks = uniqueValues(data, discrete.value, fetchValue, vars);
        }
        return d3.nest().key(function(d) {
            var id, j, len, return_id, val;
            return_id = "nesting";
            for (j = 0, len = keys.length; j < len; j++) {
                id = keys[j];
                val = fetchValue(vars, d, id);
                if (val instanceof Array) {
                    val = val.join("_");
                }
                return_id += "_" + stringStrip(val);
            }
            return return_id;
        }).rollup(function(leaves) {
            var availables, filler, i, j, k, len, len1, obj, ref, tester, tick, timeVar;
            availables = uniqueValues(leaves, discrete.value, fetchValue, vars);
            timeVar = availables.length && availables[0].constructor === Date;
            if (timeVar) {
                availables = availables.map(Number);
            }
            if (discrete.zerofill.value) {
                if (discrete.scale.value === "log") {
                    if (opposite.scale.viz.domain().every(function(d) {
                            return d < 0;
                        })) {
                        filler = -1;
                    } else {
                        filler = 1;
                    }
                } else {
                    filler = 0;
                }
                for (i = j = 0, len = ticks.length; j < len; i = ++j) {
                    tick = ticks[i];
                    tester = timeAxis ? +tick : tick;
                    if (availables.indexOf(tester) < 0) {
                        obj = {
                            d3plus: {}
                        };
                        ref = vars.id.nesting;
                        for (k = 0, len1 = ref.length; k < len1; k++) {
                            key = ref[k];
                            if (key in leaves[0]) {
                                obj[key] = leaves[0][key];
                            }
                        }
                        obj[discrete.value] = tick;
                        obj[opposite.value] = 0;
                        obj[opposite.value] = filler;
                        leaves.splice(i, 0, obj);
                    }
                }
            }
            if (typeof leaves[0][discrete.value] === "string") {
                return leaves;
            } else {
                return leaves.sort(function(a, b) {
                    var ad, ao, bd, bo, xsort;
                    ad = fetchValue(vars, a, discrete.value);
                    bd = fetchValue(vars, b, discrete.value);
                    xsort = ad - bd;
                    if (xsort) {
                        return xsort;
                    }
                    ao = fetchValue(vars, a, opposite.value);
                    bo = fetchValue(vars, b, opposite.value);
                    return ao - bo;
                });
            }
        }).entries(data);
    };


},{"../../../../core/fetch/value.coffee":69,"../../../../string/strip.js":177,"../../../../util/uniques.coffee":212}],323:[function(require,module,exports){
    var fetchValue;

    fetchValue = require("../../../../core/fetch/value.coffee");

    module.exports = function(vars, data) {
        var d, flip, i, j, len, len1, margin, neg, negativeData, offset, opposite, positiveData, scale, stack, stacked, v, val;
        stacked = vars.axes.stacked || vars.axes.opposite;
        flip = vars[stacked].scale.viz(0);
        scale = vars[stacked].scale.value;
        opposite = stacked === "x" ? "y" : "x";
        margin = stacked === "y" ? vars.axes.margin.top : vars.axes.margin.left;
        offset = scale === "share" ? "expand" : "zero";
        stack = d3.layout.stack().values(function(d) {
            return d.values || [d];
        }).offset(offset).x(function(d) {
            return d.d3plus[opposite];
        }).y(function(d) {
            return flip - vars[stacked].scale.viz(fetchValue(vars, d, vars[stacked].value));
        }).out(function(d, y0, y) {
            var negative, value;
            value = fetchValue(vars, d, vars[stacked].value);
            negative = value < 0;
            if (scale === "share") {
                d.d3plus[stacked + "0"] = (1 - y0) * flip;
                d.d3plus[stacked] = d.d3plus[stacked + "0"] - (y * flip);
            } else {
                d.d3plus[stacked + "0"] = flip;
                if (vars.axes.stacked) {
                    d.d3plus[stacked + "0"] -= y0;
                }
                d.d3plus[stacked] = d.d3plus[stacked + "0"] - y;
            }
            d.d3plus[stacked] += margin;
            return d.d3plus[stacked + "0"] += margin;
        });
        positiveData = [];
        negativeData = [];
        for (i = 0, len = data.length; i < len; i++) {
            d = data[i];
            val = fetchValue(vars, d, vars[stacked].value);
            if (val instanceof Array) {
                neg = true;
                for (j = 0, len1 = val.length; j < len1; j++) {
                    v = val[j];
                    if (v >= 0) {
                        neg = false;
                        break;
                    }
                }
                if (neg) {
                    negativeData.push(d);
                } else {
                    positiveData.push(d);
                }
            } else {
                if (val >= 0) {
                    positiveData.push(d);
                }
                if (val < 0) {
                    negativeData.push(d);
                }
            }
        }
        if (positiveData.length === 0 || negativeData.length === 0) {
            return stack(data);
        } else {
            if (positiveData.length) {
                positiveData = stack(positiveData);
            }
            if (negativeData.length) {
                negativeData = stack(negativeData);
            }
            return positiveData.concat(negativeData);
        }
    };


},{"../../../../core/fetch/value.coffee":69}],324:[function(require,module,exports){
    var fetchValue, graph, line, nest, sort, stack;

    fetchValue = require("../../core/fetch/value.coffee");

    graph = require("./helpers/graph/draw.coffee");

    nest = require("./helpers/graph/nest.coffee");

    sort = require("../../array/sort.coffee");

    stack = require("./helpers/graph/stack.coffee");

    line = function(vars) {
        var d, data, domains, i, j, len, len1, point, ref, xval, yval;
        graph(vars, {
            buffer: vars.axes.opposite,
            mouse: true
        });
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return [];
        }
        data = sort(vars.data.viz, null, null, null, vars);
        for (i = 0, len = data.length; i < len; i++) {
            point = data[i];
            ref = point.values;
            for (j = 0, len1 = ref.length; j < len1; j++) {
                d = ref[j];
                xval = fetchValue(vars, d, vars.x.value);
                if (xval !== null) {
                    d.d3plus.x2 = false;
                    d.d3plus.x = vars.x.scale.viz(xval);
                } else {
                    d.d3plus.x2 = true;
                    d.d3plus.x = vars.x2.scale.viz(fetchValue(vars, d, vars.x2.value));
                }
                d.d3plus.x += vars.axes.margin.left;
                yval = fetchValue(vars, d, vars.y.value);
                if (yval !== null) {
                    d.d3plus.y2 = false;
                    d.d3plus.y = vars.y.scale.viz(yval);
                } else {
                    d.d3plus.y2 = true;
                    d.d3plus.y = vars.y2.scale.viz(fetchValue(vars, d, vars.y2.value));
                }
                d.d3plus.y += vars.axes.margin.top;
            }
        }
        if (vars.axes.stacked) {
            return stack(vars, data);
        } else {
            return data;
        }
    };

    line.filter = function(vars, data) {
        return nest(vars, data);
    };

    line.requirements = ["data", "x", "y"];

    line.setup = function(vars) {
        var axis;
        if (!vars.axes.discrete) {
            axis = vars.time.value === vars.y.value ? "y" : "x";
            vars.self[axis]({
                scale: "discrete"
            });
        }
    };

    line.shapes = ["line"];

    line.tooltip = "static";

    module.exports = line;


},{"../../array/sort.coffee":36,"../../core/fetch/value.coffee":69,"./helpers/graph/draw.coffee":316,"./helpers/graph/nest.coffee":322,"./helpers/graph/stack.coffee":323}],325:[function(require,module,exports){
    var smallestGap = require("../../network/smallestGap.coffee"),
        fetchValue = require("../../core/fetch/value.coffee");
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Network
//------------------------------------------------------------------------------
    var network = function(vars) {

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Use filtered lists if they are available
        //----------------------------------------------------------------------------
        var nodes = vars.nodes.restricted || vars.nodes.value,
            edges = vars.edges.restricted || vars.edges.value;

        var x_range = d3.extent(nodes,function(n){return n.x}),
            y_range = d3.extent(nodes,function(n){return n.y})

        var val_range = [ 1 , 1 ]
        if (typeof vars.size.value === "number"){
            val_range = [vars.size.value, vars.size.value]
        }
        else if (vars.size.value){
            val_range = d3.extent(nodes, function(d){
                var val = fetchValue( vars , d , vars.size.value )
                return val === 0 ? null : val
            })
        }
        if (typeof val_range[0] == "undefined") val_range = [1,1]

        if (typeof vars.size.value === "number"){
            var max_size = vars.size.value;
            var min_size = vars.size.value;
        }
        else {

            var max_size = smallestGap(nodes, {"accessor": function(n){
                return [n.x, n.y];
            }});

            var limit = max_size/2;

            var overlap = vars.size.value ? vars.nodes.overlap : 0.4
            max_size = max_size * overlap;

            if (vars.edges.arrows.value) {
                max_size = max_size * 0.5;
            }

            if (val_range[0] === val_range[1]) {
                var min_size = limit;
                max_size = limit;
            }
            else {

                var width = (x_range[1]+max_size*1.1)-(x_range[0]-max_size*1.1),
                    height = (y_range[1]+max_size*1.1)-(y_range[0]-max_size*1.1),
                    aspect = width/height,
                    app = vars.width.viz/vars.height.viz;

                if ( app > aspect ) {
                    var scale = vars.height.viz/height;
                }
                else {
                    var scale = vars.width.viz/width;
                }
                var min_size = max_size * 0.25;
                if ( min_size * scale < 2 ) {
                    min_size = 2/scale;
                }

            }
        }

        // Create size scale
        var radius = vars.size.scale.value
            .domain(val_range)
            .range([min_size, max_size])

        vars.zoom.bounds = [ [ x_range[0]-max_size*1.1 , y_range[0]-max_size*1.1 ]
            , [ x_range[1]+max_size*1.1 , y_range[1]+max_size*1.1 ] ]

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Match nodes to data
        //----------------------------------------------------------------------------
        var data = [], lookup = {}
        nodes.forEach(function(n){

            var d = vars.data.viz.filter(function(a){
                return a[vars.id.value] == n[vars.id.value]
            })[0]

            var obj = d || {}

            obj[vars.id.value] = n[vars.id.value]

            obj.d3plus = {}
            obj.d3plus.x = n.x
            obj.d3plus.y = n.y
            var val = fetchValue(vars,obj,vars.size.value)
            obj.d3plus.r = val ? radius(val) : radius.range()[0]
            lookup[obj[vars.id.value]] = {
                "x": obj.d3plus.x,
                "y": obj.d3plus.y,
                "r": obj.d3plus.r
            }

            data.push(obj)
        })

        data.sort(function(a,b){
            return b.d3plus.r - a.d3plus.r
        })

        edges.forEach(function(l,i){

            if (l.d3plus) {
                delete l.d3plus.spline
            }

            l[vars.edges.source].d3plus = {}
            var source = lookup[l[vars.edges.source][vars.id.value]]
            l[vars.edges.source].d3plus.r = source.r
            l[vars.edges.source].d3plus.x = source.x
            l[vars.edges.source].d3plus.y = source.y

            l[vars.edges.target].d3plus = {}
            var target = lookup[l[vars.edges.target][vars.id.value]]
            l[vars.edges.target].d3plus.r = target.r
            l[vars.edges.target].d3plus.x = target.x
            l[vars.edges.target].d3plus.y = target.y

        })

        return {"nodes": data, "edges": edges}

    }

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
    network.nesting      = false
    network.requirements = ["nodes","edges"]
    network.scale        = 1.05
    network.shapes       = [ "circle" , "square" , "donut" ]
    network.tooltip      = "static"
    network.zoom         = true

    module.exports = network

},{"../../core/fetch/value.coffee":69,"../../network/smallestGap.coffee":170}],326:[function(require,module,exports){
    var fetchValue, shortestPath, uniqueValues, viz,
        indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    shortestPath = require("../../network/shortestPath.coffee");

    fetchValue = require("../../core/fetch/value.coffee");

    uniqueValues = require("../../util/uniques.coffee");

    viz = function(vars) {
        var base, base1, base2, base3, col, colIndex, columnWidth, columns, edge, edgeInt, edges, i, id, j, k, l, labelSpace, lastDir, lastHop, len, len1, len2, len3, len4, len5, len6, len7, m, maxRadius, minRadius, n, newPath, next, nextDir, nextHop, nextIndex, node, o, p, path, pathInt, pathLookup, paths, prev, prevIndex, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, rowHeight, rows, size, sizeDomain, val, x, xDiff, y, yDomain;
        edges = [];
        pathLookup = {};
        pathLookup[vars.focus.value[0]] = 0;
        pathLookup[vars.focus.value[1]] = 0;
        paths = {
            all: [[vars.focus.value[0]], [vars.focus.value[1]]]
        };
        ref = viz.paths;
        for (pathInt = j = 0, len = ref.length; j < len; pathInt = ++j) {
            path = ref[pathInt];
            edges = edges.concat(path.edges);
            lastHop = vars.focus.value[0];
            paths[pathInt] = [lastHop];
            ref1 = path.edges;
            for (edgeInt = k = 0, len1 = ref1.length; k < len1; edgeInt = ++k) {
                edge = ref1[edgeInt];
                edge[vars.edges.source] = vars.data.viz.filter(function(d) {
                    return edge[vars.edges.source][vars.id.value] === d[vars.id.value];
                })[0];
                edge[vars.edges.target] = vars.data.viz.filter(function(d) {
                    return edge[vars.edges.target][vars.id.value] === d[vars.id.value];
                })[0];
                nextDir = edge[vars.edges.source][vars.id.value] === lastHop ? "target" : "source";
                nextHop = edge[vars.edges[nextDir]][vars.id.value];
                if (pathLookup[nextHop] === void 0) {
                    pathLookup[nextHop] = pathInt;
                }
                paths[pathInt].push(nextHop);
                lastHop = nextHop;
            }
        }
        rows = 0;
        for (pathInt in paths) {
            path = paths[pathInt];
            if (pathInt !== "all") {
                newPath = 0;
                for (i = l = 0, len2 = path.length; l < len2; i = ++l) {
                    id = path[i];
                    if ((i !== 0 && i !== (path.length - 1)) && pathLookup[id] === parseFloat(pathInt)) {
                        newPath = 1;
                        prev = path[i - 1];
                        next = path[i + 1];
                        prevIndex = null;
                        nextIndex = null;
                        ref2 = paths.all;
                        for (colIndex = m = 0, len3 = ref2.length; m < len3; colIndex = ++m) {
                            col = ref2[colIndex];
                            if (indexOf.call(col, prev) >= 0) {
                                prevIndex = colIndex;
                            }
                            if (indexOf.call(col, next) >= 0) {
                                nextIndex = colIndex;
                            }
                        }
                        if (prevIndex !== null && nextIndex === null) {
                            if (prevIndex + 1 === paths.all.length - 1) {
                                paths.all.splice(prevIndex + 1, 0, [id]);
                            } else {
                                paths.all[prevIndex + 1].push(id);
                            }
                        } else if (nextIndex - prevIndex === 1) {
                            paths.all.splice(nextIndex, 0, [id]);
                        } else if (nextIndex - prevIndex > 1) {
                            paths.all[nextIndex - 1].push(id);
                        }
                    }
                }
                rows += newPath;
            }
        }
        rowHeight = Math.floor(vars.height.viz / rows);
        yDomain = [];
        i = 0;
        while (i < rows) {
            if (i % 2 === 0) {
                yDomain.push(i);
            } else {
                yDomain.unshift(i);
            }
            i++;
        }
        labelSpace = vars.size.value && !vars.small ? 30 : 0;
        y = d3.scale.ordinal().domain(yDomain).range(d3.range(rowHeight / 2 - labelSpace, vars.height.viz + rowHeight / 2 - labelSpace, (vars.height.viz - rowHeight) / (rows - 1)));
        columns = paths["all"].length;
        columnWidth = Math.floor(vars.width.viz / columns);
        x = d3.scale.linear().domain([0, columns - 1]).rangeRound([columnWidth / 2, vars.width.viz - columnWidth / 2]);
        minRadius = 5;
        maxRadius = d3.min([columnWidth, rowHeight - labelSpace]) * 0.4;
        sizeDomain = d3.extent(vars.data.viz, function(node) {
            var val;
            val = fetchValue(vars, node, vars.size.value);
            return val || 0;
        });
        size = vars.size.scale.value.domain(sizeDomain).rangeRound([minRadius, maxRadius]);
        ref3 = vars.data.viz;
        for (n = 0, len4 = ref3.length; n < len4; n++) {
            node = ref3[n];
            if (node.d3plus == null) {
                node.d3plus = {};
            }
            ref4 = paths["all"];
            for (colIndex = o = 0, len5 = ref4.length; o < len5; colIndex = ++o) {
                col = ref4[colIndex];
                if (ref5 = node[vars.id.value], indexOf.call(col, ref5) >= 0) {
                    node.d3plus.x = x(colIndex);
                }
            }
            node.d3plus.y = y(pathLookup[node[vars.id.value]]);
            if (vars.size.value) {
                val = fetchValue(vars, node, vars.size.value);
                node.d3plus.r = val ? size(val) : minRadius;
            } else {
                node.d3plus.r = maxRadius;
            }
            if (node.d3plus.r < columnWidth * 0.1 && !vars.small) {
                node.d3plus.label = {
                    x: 0,
                    y: node.d3plus.r + vars.labels.padding * 2,
                    w: columnWidth * 0.6,
                    h: labelSpace + maxRadius - node.d3plus.r,
                    resize: false
                };
            } else {
                delete node.d3plus.label;
            }
        }
        ref6 = viz.paths;
        for (pathInt = p = 0, len6 = ref6.length; p < len6; pathInt = ++p) {
            path = ref6[pathInt];
            lastHop = vars.focus.value[0];
            ref7 = path.edges;
            for (edgeInt = q = 0, len7 = ref7.length; q < len7; edgeInt = ++q) {
                edge = ref7[edgeInt];
                nextDir = edge[vars.edges.source][vars.id.value] === lastHop ? "target" : "source";
                lastDir = nextDir === "target" ? "source" : "target";
                nextHop = edge[vars.edges[nextDir]][vars.id.value];
                if (pathLookup[lastHop] !== pathLookup[nextHop]) {
                    edge.d3plus = {
                        spline: true
                    };
                    if ((base = edge[vars.edges.source]).d3plus == null) {
                        base.d3plus = {};
                    }
                    if ((base1 = edge[vars.edges.source].d3plus).edges == null) {
                        base1.edges = {};
                    }
                    if ((base2 = edge[vars.edges.target]).d3plus == null) {
                        base2.d3plus = {};
                    }
                    if ((base3 = edge[vars.edges.target].d3plus).edges == null) {
                        base3.edges = {};
                    }
                    xDiff = edge[nextDir].d3plus.x - edge[lastDir].d3plus.x;
                    edge[lastDir].d3plus.edges[edge[nextDir][vars.id.value]] = {
                        angle: Math.PI,
                        radius: columnWidth / 2
                    };
                    edge[nextDir].d3plus.edges[edge[lastDir][vars.id.value]] = {
                        angle: 0,
                        radius: columnWidth / 2,
                        offset: xDiff - columnWidth
                    };
                } else {
                    delete edge.d3plus;
                }
                lastHop = nextHop;
            }
        }
        return {
            nodes: vars.data.viz,
            edges: edges
        };
    };

    viz.filter = function(vars, data) {
        var added, d, edge, edges, id, ids, j, k, l, len, len1, len2, obj, path, ref, ref1, returnData, source, target;
        edges = vars.edges.filtered || vars.edges.value;
        viz.paths = shortestPath(edges, vars.focus.value[0], {
            target: vars.focus.value[1],
            distance: vars.edges.size.value || void 0,
            nodeid: vars.id.value,
            startpoint: vars.edges.source,
            endpoint: vars.edges.target,
            K: vars.edges.limit.value || 5
        });
        viz.nodes = [];
        added = [];
        ref = viz.paths;
        for (j = 0, len = ref.length; j < len; j++) {
            path = ref[j];
            ref1 = path.edges;
            for (k = 0, len1 = ref1.length; k < len1; k++) {
                edge = ref1[k];
                source = edge[vars.edges.source];
                target = edge[vars.edges.target];
                if (added.indexOf(source[vars.id.value]) < 0) {
                    viz.nodes.push(source);
                    added.push(source[vars.id.value]);
                }
                if (added.indexOf(target[vars.id.value]) < 0) {
                    viz.nodes.push(target);
                    added.push(target[vars.id.value]);
                }
            }
        }
        ids = uniqueValues(viz.nodes, vars.id.value, fetchValue, vars);
        returnData = [];
        for (l = 0, len2 = ids.length; l < len2; l++) {
            id = ids[l];
            d = data.filter(function(d) {
                return d[vars.id.value] === id;
            });
            if (!d[0]) {
                obj = {
                    d3plus: {}
                };
                obj[vars.id.value] = id;
                returnData.push(obj);
            } else {
                returnData.push(d[0]);
            }
        }
        return returnData;
    };

    viz.nesting = false;

    viz.requirements = [
        function(vars) {
            return {
                status: vars.focus.value.length === 2,
                text: vars.format.locale.value.method.focus + " x 2"
            };
        }, "edges"
    ];

    viz.scale = 1;

    viz.shapes = ["circle", "square", "donut"];

    viz.tooltip = "static";

    module.exports = viz;


},{"../../core/fetch/value.coffee":69,"../../network/shortestPath.coffee":169,"../../util/uniques.coffee":212}],327:[function(require,module,exports){
    var comparator, dataThreshold, groupData, pie;

    comparator = require("../../array/comparator.coffee");

    dataThreshold = require("../../core/data/threshold.js");

    groupData = require("../../core/data/group.coffee");

    pie = function(vars) {
        var d, groupedData, i, item, len, pieData, pieLayout, radius, returnData;
        pieLayout = d3.layout.pie().value(function(d) {
            return d.value;
        }).sort(function(a, b) {
            if (vars.order.value) {
                return comparator(a.d3plus, b.d3plus, [vars.order.value], vars.order.sort.value, [], vars);
            } else if (vars.id.nesting.length > 1) {
                return comparator(a.d3plus, b.d3plus, vars.id.nesting.concat([vars.size.value]), void 0, [], vars);
            } else {
                return comparator(a.d3plus, b.d3plus, [vars.size.value], "desc", [], vars);
            }
        });
        groupedData = groupData(vars, vars.data.viz, []);
        pieData = pieLayout(groupedData);
        returnData = [];
        radius = d3.min([vars.width.viz, vars.height.viz]) / 2 - vars.labels.padding * 2;
        for (i = 0, len = pieData.length; i < len; i++) {
            d = pieData[i];
            item = d.data.d3plus;
            item.d3plus.startAngle = d.startAngle;
            item.d3plus.endAngle = d.endAngle;
            item.d3plus.r = radius;
            item.d3plus.x = vars.width.viz / 2;
            item.d3plus.y = vars.height.viz / 2;
            item.d3plus.share = (d.endAngle - d.startAngle) / (Math.PI * 2);
            returnData.push(item);
        }
        return returnData;
    };

    pie.filter = dataThreshold;

    pie.requirements = ["data", "size"];

    pie.shapes = ["arc"];

    pie.threshold = function(vars) {
        return (40 * 40) / (vars.width.viz * vars.height.viz);
    };

    module.exports = pie;


},{"../../array/comparator.coffee":34,"../../core/data/group.coffee":59,"../../core/data/threshold.js":63}],328:[function(require,module,exports){
    var buckets, comparator, dataThreshold, fetchText, fetchValue, fontSizes, offset, radar, sort, textwrap, uniques;

    comparator = require("../../array/comparator.coffee");

    sort = require("../../array/sort.coffee");

    dataThreshold = require("../../core/data/threshold.js");

    fetchText = require("../../core/fetch/text.js");

    fetchValue = require("../../core/fetch/value.coffee");

    fontSizes = require("../../font/sizes.coffee");

    offset = require("../../geom/offset.coffee");

    textwrap = require("../../textwrap/textwrap.coffee");

    buckets = require("../../util/buckets.coffee");

    uniques = require("../../util/uniques.coffee");

    radar = function(vars) {
        var a, a2, anchor, angle, buffer, c, center, children, d, data, first, grid, gridStyle, i, idIndex, ids, intervals, j, k, l, labelData, labelGroup, labelHeight, labelIndex, labelStyle, labelWidth, labels, len, len1, len2, len3, m, maxData, maxRadius, n, nextDepth, nextLevel, o, ov, radius, ref, ref1, righty, ringData, ringStyle, rings, second, sizes, text, textStyle, top, total, x, y;
        data = vars.data.viz;
        nextDepth = vars.depth.value + 1;
        nextLevel = vars.id.nesting[nextDepth];
        children = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = data.length; j < len; j++) {
                d = data[j];
                results.push(d[nextLevel]);
            }
            return results;
        })();
        total = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = data.length; j < len; j++) {
                d = data[j];
                results.push(uniques(data, nextLevel, fetchValue, vars, nextDepth));
            }
            return results;
        })();
        total = uniques(d3.merge(total)).length;
        angle = Math.PI * 2 / total;
        maxRadius = d3.min([vars.width.viz, vars.height.viz]) / 2;
        labelHeight = 0;
        labelWidth = 0;
        labels = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = children.length; j < len; j++) {
                c = children[j];
                results.push(fetchText(vars, c, nextDepth)[0]);
            }
            return results;
        })();
        labels = uniques(d3.merge(labels));
        if (vars.labels.value) {
            first = offset(Math.PI / 2, maxRadius);
            second = offset(angle + Math.PI / 2, maxRadius);
            labelHeight = (first.x - second.x) - vars.labels.padding * 2;
            textStyle = {
                "fill": vars.x.ticks.font.color,
                "font-family": vars.x.ticks.font.family.value,
                "font-weight": vars.x.ticks.font.weight,
                "font-size": vars.x.ticks.font.size + "px"
            };
            sizes = fontSizes(labels, textStyle, {
                mod: function(elem) {
                    return textwrap().container(d3.select(elem)).width(vars.height.viz / 8).height(labelHeight).draw();
                }
            });
            labelWidth = d3.max(sizes, function(d) {
                return d.width;
            });
            maxRadius -= labelWidth;
            maxRadius -= vars.labels.padding * 2;
        }
        maxData = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = children.length; j < len; j++) {
                c = children[j];
                results.push((function() {
                    var k, len1, results1;
                    results1 = [];
                    for (k = 0, len1 = c.length; k < len1; k++) {
                        d = c[k];
                        results1.push(fetchValue(vars, d, vars.size.value));
                    }
                    return results1;
                })());
            }
            return results;
        })();
        maxData = d3.max(d3.merge(maxData));
        radius = d3.scale.linear().domain([0, maxData]).range([0, maxRadius]);
        ids = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = children.length; j < len; j++) {
                c = children[j];
                results.push(fetchValue(vars, c, nextLevel));
            }
            return results;
        })();
        ids = uniques(d3.merge(ids));
        idIndex = d3.scale.ordinal().domain(ids).range(d3.range(0, ids.length));
        for (j = 0, len = data.length; j < len; j++) {
            d = data[j];
            d.d3plus.x = vars.width.viz / 2 + vars.margin.top;
            d.d3plus.y = vars.height.viz / 2 + vars.margin.left;
            ref = d[nextLevel];
            for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {
                a = ref[i];
                if (!a.d3plus) {
                    a.d3plus = {};
                }
                a.d3plus.r = radius(fetchValue(vars, a, vars.size.value));
                a.d3plus.a = idIndex(fetchValue(vars, a, nextLevel)) * angle;
            }
        }
        intervals = 1;
        ref1 = [10, 5, 4, 2];
        for (m = 0, len2 = ref1.length; m < len2; m++) {
            i = ref1[m];
            if (maxRadius / i >= 20) {
                intervals = i;
                break;
            }
        }
        ringData = buckets([maxRadius / intervals, maxRadius], intervals - 1).reverse();
        if (ringData.length === intervals) {
            ringData.shift();
        }
        rings = vars.group.selectAll(".d3plus_radar_rings").data(ringData, function(d, i) {
            return i;
        });
        ringStyle = function(ring) {
            return ring.attr("fill", function(d, i) {
                if (i === 0) {
                    return vars.axes.background.color;
                } else {
                    return "transparent";
                }
            }).attr("cx", vars.width.viz / 2 + vars.margin.top).attr("cy", vars.height.viz / 2 + vars.margin.left).attr("stroke", vars.x.grid.value ? vars.x.grid.color : "transparent");
        };
        rings.enter().append("circle").attr("class", "d3plus_radar_rings").call(ringStyle).attr("r", 0);
        rings.transition().duration(vars.draw.timing).call(ringStyle).attr("r", function(d) {
            return d;
        });
        rings.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
        labelIndex = d3.scale.ordinal().domain(labels).range(d3.range(0, labels.length));
        labelData = [];
        for (n = 0, len3 = labels.length; n < len3; n++) {
            l = labels[n];
            a2 = (angle * labelIndex(l)) - Math.PI / 2;
            a = a2 * (180 / Math.PI);
            if (a < -90 || a > 90) {
                a = a - 180;
                buffer = -(maxRadius + vars.labels.padding * 2 + labelWidth);
                anchor = "end";
            } else {
                buffer = maxRadius + vars.labels.padding * 2;
                anchor = "start";
            }
            top = a2 < 0 || a2 > Math.PI;
            righty = a2 < Math.PI / 2;
            ov = maxRadius;
            if (vars.labels.value) {
                ov += vars.labels.padding;
            }
            o = offset(a2, ov);
            x = o.x;
            y = o.y;
            if (!righty) {
                x -= labelWidth;
            }
            if (top) {
                y -= labelHeight;
            }
            center = [0, Math.PI].indexOf(angle * labelIndex(l)) >= 0;
            if (center) {
                x -= labelWidth / 2;
            }
            labelData.push({
                "text": l,
                "angle": a,
                "x": buffer,
                "anchor": anchor,
                "offset": o
            });
        }
        labelGroup = vars.group.selectAll("g.d3plus_radar_label_group").data([0]);
        labelGroup.enter().append("g").attr("class", "d3plus_radar_label_group").attr("transform", "translate(" + vars.width.viz / 2 + "," + vars.height.viz / 2 + ")");
        labelGroup.transition().duration(vars.draw.timing).attr("transform", "translate(" + vars.width.viz / 2 + "," + vars.height.viz / 2 + ")");
        text = labelGroup.selectAll(".d3plus_radar_labels").data((vars.labels.value ? labelData : []), function(d, i) {
            return i;
        });
        labelStyle = function(label) {
            return label.attr(textStyle).each(function(l, i) {
                return textwrap().container(d3.select(this)).height(labelHeight).width(labelWidth).align(l.anchor).text(l.text).padding(0).valign("middle").x(l.x).y(-labelHeight / 2).draw();
            }).attr("transform", function(t) {
                var translate;
                translate = d3.select(this).attr("transform") || "";
                if (translate.length) {
                    translate = translate.split(")").slice(-3).join(")");
                }
                return "rotate(" + t.angle + ")" + translate;
            });
        };
        text.call(labelStyle);
        text.enter().append("text").attr("class", "d3plus_radar_labels").attr("opacity", 0).call(labelStyle).transition().duration(vars.draw.timing).attr("opacity", 1);
        text.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
        grid = vars.group.selectAll(".d3plus_radar_lines").data(labelData, function(d, i) {
            return i;
        });
        gridStyle = function(grid) {
            return grid.attr("stroke", vars.x.grid.color).attr("x1", vars.width.viz / 2 + vars.margin.left).attr("y1", vars.height.viz / 2 + vars.margin.top);
        };
        grid.enter().append("line").attr("class", "d3plus_radar_lines").call(gridStyle).attr("x2", vars.width.viz / 2 + vars.margin.left).attr("y2", vars.height.viz / 2 + vars.margin.top);
        grid.transition().duration(vars.draw.timing).call(gridStyle).attr("x2", function(d) {
            return vars.width.viz / 2 + vars.margin.left + d.offset.x;
        }).attr("y2", function(d) {
            return vars.height.viz / 2 + vars.margin.top + d.offset.y;
        });
        grid.exit().transition().duration(vars.draw.timing).attr("opacity", 0).remove();
        vars.mouse.viz = {
            click: false
        };
        return data;
    };

    radar.requirements = ["data", "size"];

    radar.shapes = ["radial"];

    module.exports = radar;


},{"../../array/comparator.coffee":34,"../../array/sort.coffee":36,"../../core/data/threshold.js":63,"../../core/fetch/text.js":68,"../../core/fetch/value.coffee":69,"../../font/sizes.coffee":103,"../../geom/offset.coffee":162,"../../textwrap/textwrap.coffee":202,"../../util/buckets.coffee":206,"../../util/uniques.coffee":212}],329:[function(require,module,exports){
    var arraySort     = require("../../array/sort.coffee"),
        events        = require("../../client/pointer.coffee"),
        fetchValue    = require("../../core/fetch/value.coffee"),
        fetchColor    = require("../../core/fetch/color.coffee"),
        legible       = require("../../color/legible.coffee"),
        removeTooltip = require("../../tooltip/remove.coffee"),
        smallestGap   = require("../../network/smallestGap.coffee"),
        textColor     = require("../../color/text.coffee"),
        uniqueValues  = require("../../util/uniques.coffee")

    var rings = function(vars) {

        var radius = d3.min([vars.height.viz,vars.width.viz])/2
            , ring_width = vars.small || !vars.labels.value
            ? (radius-vars.labels.padding*2)/2 : radius/3
            , primaryRing = vars.small || !vars.labels.value
            ? ring_width*1.4 : ring_width
            , secondaryRing = ring_width*2
            , edges = []
            , nodes = []

        var center = vars.data.viz.filter(function(d){
            return d[vars.id.value] === vars.focus.value[0]
        })[0]

        if ( !center ) {
            center = { "d3plus" : {} }
            center[vars.id.value] = vars.focus.value[0]
        }

        center.d3plus.x = vars.width.viz/2
        center.d3plus.y = vars.height.viz/2
        center.d3plus.r = primaryRing*.65

        var primaries = [], claimed = [vars.focus.value[0]]
        vars.edges.connections(vars.focus.value[0],vars.id.value).forEach(function(edge){

            var c = edge[vars.edges.source][vars.id.value] == vars.focus.value[0] ? edge[vars.edges.target] : edge[vars.edges.source]
            var n = vars.data.viz.filter(function(d){
                return d[vars.id.value] === c[vars.id.value]
            })[0]

            if ( !n ) {
                n = { "d3plus" : {} }
                n[vars.id.value] = c[vars.id.value]
            }

            n.d3plus.edges = vars.edges.connections(n[vars.id.value],vars.id.value).filter(function(c){
                return c[vars.edges.source][vars.id.value] != vars.focus.value[0] && c[vars.edges.target][vars.id.value] != vars.focus.value[0]
            })
            n.d3plus.edge = edge
            claimed.push(n[vars.id.value])
            primaries.push(n)

        })

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Sort primary nodes by children (smallest to largest) and then by sort
        // order.
        //--------------------------------------------------------------------------
        var sort = vars.order.value || vars.color.value
            || vars.size.value || vars.id.value

        primaries.sort(function(a,b){

            var lengthdiff = a.d3plus.edges.length - b.d3plus.edges.length

            if ( lengthdiff ) {

                return lengthdiff

            }
            else {

                return arraySort( [a,b] , sort , vars.order.sort.value
                    , vars.color.value || [] , vars)

            }

        })

        if (typeof vars.edges.limit.value == "number") {
            primaries = primaries.slice(0,vars.edges.limit.value)
        }
        else if (typeof vars.edges.limit.value == "function") {
            primaries = vars.edges.limit.value(primaries)
        }

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Check for similar children and give preference to nodes with less
        // overall children.
        //----------------------------------------------------------------------------
        var secondaries = [], total = 0
        primaries.forEach(function(p){

            var primaryId = p[vars.id.value]

            p.d3plus.edges = p.d3plus.edges.filter(function(c){

                var source = c[vars.edges.source][vars.id.value]
                    , target = c[vars.edges.target][vars.id.value]
                return (claimed.indexOf(source) < 0 && target == primaryId)
                    || (claimed.indexOf(target) < 0 && source == primaryId)

            })

            total += p.d3plus.edges.length || 1

            p.d3plus.edges.forEach(function(c){

                var source = c[vars.edges.source]
                    , target = c[vars.edges.target]
                var claim = target[vars.id.value] == primaryId ? source : target
                claimed.push(claim[vars.id.value])

            })
        })

        arraySort( primaries , sort , vars.order.sort.value
            , vars.color.value || [] , vars)

        var offset = 0,
            radian = Math.PI*2,
            start = 0

        primaries.forEach(function(p,i){

            var children = p.d3plus.edges.length || 1,
                space = (radian/total)*children

            if (i == 0) {
                start = angle
                offset -= space/2
            }

            var angle = offset+(space/2)
            angle -= radian/4

            p.d3plus.radians = angle
            p.d3plus.x = vars.width.viz/2 + (primaryRing * Math.cos(angle))
            p.d3plus.y = vars.height.viz/2 + (primaryRing * Math.sin(angle))

            offset += space
            p.d3plus.edges.sort(function(a,b){

                var a = a[vars.edges.source][vars.id.value] == p[vars.id.value]
                    ? a[vars.edges.target] : a[vars.edges.source]
                    , b = b[vars.edges.source][vars.id.value] == p[vars.id.value]
                    ? b[vars.edges.target] : b[vars.edges.source]

                return arraySort( [a,b] , sort , vars.order.sort.value
                    , vars.color.value || [] , vars)

            })

            p.d3plus.edges.forEach(function(edge,i){

                var c = edge[vars.edges.source][vars.id.value] == p[vars.id.value]
                    ? edge[vars.edges.target] : edge[vars.edges.source]
                    , s = radian/total

                var d = vars.data.viz.filter(function(a){
                    return a[vars.id.value] === c[vars.id.value]
                })[0]

                if ( !d ) {
                    d = { "d3plus" : {} }
                    d[vars.id.value] = c[vars.id.value]
                }

                a = (angle-(s*children/2)+(s/2))+((s)*i)
                d.d3plus.radians = a
                d.d3plus.x = vars.width.viz/2 + ((secondaryRing) * Math.cos(a))
                d.d3plus.y = vars.height.viz/2 + ((secondaryRing) * Math.sin(a))
                secondaries.push(d)
            })

        })

        var primaryDistance = smallestGap(primaries,{"accessor": function(n){
            return [n.d3plus.x, n.d3plus.y]
        }})
            , secondaryDistance = smallestGap(secondaries,{"accessor": function(n){
            return [n.d3plus.x, n.d3plus.y]
        }})

        if (!primaryDistance) {
            primaryDistance = ring_width/2
        }

        if (!secondaryDistance) {
            secondaryDistance = ring_width/4
        }

        if (primaryDistance/2 - 4 < 8) {
            var primaryMax = d3.min([primaryDistance/2,8])
        }
        else {
            var primaryMax = primaryDistance/2 - 4
        }

        if (secondaryDistance/2 - 4 < 4) {
            var secondaryMax = d3.min([secondaryDistance/2,4])
        }
        else {
            var secondaryMax = secondaryDistance/2 - 4
        }

        if (secondaryMax > ring_width/10) {
            secondaryMax = ring_width/10
        }

        if (secondaryMax > primaryMax && secondaryMax > 10) {
            secondaryMax = primaryMax*.75
        }
        if (primaryMax > secondaryMax*1.5) {
            primaryMax = secondaryMax*1.5
        }

        primaryMax = Math.floor(primaryMax)
        secondaryMax = Math.floor(secondaryMax)

        var ids = uniqueValues(primaries, vars.id.value, fetchValue, vars)
        ids = ids.concat(uniqueValues(secondaries, vars.id.value, fetchValue, vars))
        ids.push(vars.focus.value[0])

        var data = vars.data.viz.filter(function(d){
            return ids.indexOf(d[vars.id.value]) >= 0
        })

        if (vars.size.value) {

            var domain = d3.extent(data,function(d){
                return fetchValue(vars,d,vars.size.value)
            })

            if (domain[0] == domain[1]) {
                domain[0] = 0
            }

            var radius = d3.scale.linear()
                .domain(domain)
                .rangeRound([3,d3.min([primaryMax,secondaryMax])])

            var val = fetchValue(vars,center,vars.size.value)
            center.d3plus.r = radius(val)

        }
        else {

            var radius = d3.scale.linear()
                .domain([1,2])
                .rangeRound([primaryMax,secondaryMax])


            if (vars.edges.label) {
                center.d3plus.r = radius(1)*1.5
            }

        }

        secondaries.forEach(function(s){
            s.d3plus.ring = 2
            var val = vars.size.value ? fetchValue(vars,s,vars.size.value) : 2
            s.d3plus.r = radius(val)
        })

        primaries.forEach(function(p){
            p.d3plus.ring = 1
            var val = vars.size.value ? fetchValue(vars,p,vars.size.value) : 1
            p.d3plus.r = radius(val)
        })

        nodes = [center].concat(primaries).concat(secondaries)

        primaries.forEach(function(p,i){

            var check = [vars.edges.source,vars.edges.target]
                , edge = p.d3plus.edge

            check.forEach(function(node){

                edge[node] = nodes.filter(function(n){
                    return n[vars.id.value] == edge[node][vars.id.value]
                })[0]

            })

            delete edge.d3plus
            edges.push(edge)

            vars.edges.connections(p[vars.id.value],vars.id.value).forEach(function(edge){

                var c = edge[vars.edges.source][vars.id.value] == p[vars.id.value]
                    ? edge[vars.edges.target] : edge[vars.edges.source]

                if (c[vars.id.value] != center[vars.id.value]) {

                    var target = secondaries.filter(function(s){
                        return s[vars.id.value] == c[vars.id.value]
                    })[0]

                    if (!target) {
                        var r = primaryRing
                        target = primaries.filter(function(s){
                            return s[vars.id.value] == c[vars.id.value]
                        })[0]
                    }
                    else {
                        var r = secondaryRing
                    }

                    if (target) {

                        edge.d3plus = {
                            "spline": true,
                            "translate": {
                                "x": vars.width.viz/2,
                                "y": vars.height.viz/2
                            }
                        }

                        var check = [vars.edges.source,vars.edges.target]

                        check.forEach(function(node,i){

                            edge[node] = nodes.filter(function(n){
                                return n[vars.id.value] == edge[node][vars.id.value]
                            })[0]

                            if (edge[node].d3plus.edges === undefined) edge[node].d3plus.edges = {}

                            var oppID = i === 0 ? edge[vars.edges.target][vars.id.value] : edge[vars.edges.source][vars.id.value]

                            if (edge[node][vars.id.value] == p[vars.id.value]) {

                                edge[node].d3plus.edges[oppID] = {
                                    "angle": p.d3plus.radians + Math.PI,
                                    "radius": ring_width/2
                                }

                            }
                            else {

                                edge[node].d3plus.edges[oppID] = {
                                    "angle": target.d3plus.radians,
                                    "radius": ring_width/2
                                }

                            }
                        })

                        edges.push(edge)

                    }

                }

            })

        })

        var labelColor = false;
        if (vars.background.value &&
            ["transparent", "none"].indexOf(vars.background.value) < 0 &&
            d3.hsl(vars.background.value).l < 0.5) {
            labelColor = textColor(vars.background.value);
        }

        nodes.forEach(function(n) {

            if (!vars.small && vars.labels.value) {

                if (n[vars.id.value] != vars.focus.value[0]) {

                    n.d3plus.rotate = n.d3plus.radians*(180/Math.PI)

                    var angle = n.d3plus.rotate,
                        width = ring_width-(vars.labels.padding*3)-n.d3plus.r

                    if (angle < -90 || angle > 90) {
                        angle = angle-180
                        var buffer = -(n.d3plus.r+width/2+vars.labels.padding),
                            anchor = "end"
                    }
                    else {
                        var buffer = n.d3plus.r+width/2+vars.labels.padding,
                            anchor = "start"
                    }

                    var background = primaries.indexOf(n) >= 0 ? true : false

                    var height = n.d3plus.ring == 1 ? primaryDistance : secondaryDistance

                    n.d3plus.label = {
                        "x": buffer,
                        "y": 0,
                        "w": width,
                        "h": height,
                        "angle": angle,
                        "anchor": anchor,
                        "valign": "center",
                        "color": labelColor || legible(fetchColor(vars,n)),
                        "resize": [8, vars.labels.font.size],
                        "background": background,
                        "mouse": true
                    }

                }
                else if (vars.size.value || vars.edges.label) {

                    var height = primaryRing-n.d3plus.r*2-vars.labels.padding*2

                    n.d3plus.label = {
                        "x": 0,
                        "y": n.d3plus.r+height/2,
                        "w": primaryRing,
                        "h": height,
                        "color": labelColor || legible(fetchColor(vars,n)),
                        "resize": [10,40],
                        "background": true,
                        "mouse": true
                    }

                }
                else {
                    delete n.d3plus.rotate
                    delete n.d3plus.label
                }

            }
            else {
                delete n.d3plus.rotate
                delete n.d3plus.label
            }

        })

        vars.mouse.viz = {};
        vars.mouse.viz[events.click] = function(d) {
            if (d[vars.id.value] != vars.focus.value[0]) {
                removeTooltip(vars.type.value);
                var old_focus = vars.focus.value[0];
                vars.history.states.push(function(){
                    vars.self.focus(old_focus).draw();
                })
                vars.self.focus(d[vars.id.value]).draw();
            }
        }

        return {"edges": edges, "nodes": nodes, "data": data}

    };

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
    rings.filter       = function( vars , data ) {

        var primaries = vars.edges.connections(vars.focus.value[0],vars.id.value,true)
            , secondaries = []

        primaries.forEach(function(p){
            secondaries = secondaries.concat(vars.edges.connections(p[vars.id.value],vars.id.value,true))
        })

        var connections = primaries.concat(secondaries)
            , ids = uniqueValues(connections, vars.id.value, fetchValue, vars)
            , returnData = []

        ids.forEach(function(id){

            var d = data.filter(function(d){
                return d[vars.id.value] == id
            })[0]

            if ( !d ) {
                var obj = {"d3plus": {}}
                obj[vars.id.value] = id
                returnData.push(obj)
            }
            else {
                returnData.push(d)
            }

        })

        return returnData

    }
    rings.nesting      = false
    rings.scale        = 1
    rings.shapes       = [ "circle" , "square" , "donut" ]
    rings.requirements = [ "edges" , "focus" ]
    rings.tooltip      = "static"

    module.exports = rings

},{"../../array/sort.coffee":36,"../../client/pointer.coffee":40,"../../color/legible.coffee":46,"../../color/text.coffee":52,"../../core/fetch/color.coffee":65,"../../core/fetch/value.coffee":69,"../../network/smallestGap.coffee":170,"../../tooltip/remove.coffee":205,"../../util/uniques.coffee":212}],330:[function(require,module,exports){
    var d3sankey, events, removeTooltip, sankey, uniques;

    d3sankey = require("./sankey.js");

    events = require("../../client/pointer.coffee");

    removeTooltip = require("../../tooltip/remove.coffee");

    uniques = require("../../util/uniques.coffee");

    sankey = function(vars) {
        var d, e, edges, focus, i, j, layout, len, len1, n, nodes, padding, placed, returnData, size;
        focus = vars.focus.value[0];
        padding = vars.data.stroke.width * 2;
        size = vars.size.value.constructor === Number ? vars.size.value : 20;
        edges = vars.edges.connections(focus, vars.id.value).filter(function(e) {
            return e[vars.edges.source][vars.id.value] !== focus || e[vars.edges.target][vars.id.value] !== focus;
        });
        nodes = [];
        placed = [];
        edges = edges.map(function(e) {
            var s, t;
            if (e[vars.edges.target][vars.id.value] === focus) {
                s = {
                    id: "left_" + e[vars.edges.source][vars.id.value],
                    dupe: "left",
                    data: e[vars.edges.source],
                    value: e[vars.edges.strength.value]
                };
                t = e[vars.edges.target];
            } else {
                s = e[vars.edges.source];
                t = {
                    id: "right_" + e[vars.edges.target][vars.id.value],
                    dupe: "right",
                    data: e[vars.edges.target],
                    value: e[vars.edges.strength.value]
                };
            }
            if (placed.indexOf(s.id) < 0) {
                nodes.push(s);
            }
            if (placed.indexOf(t.id) < 0) {
                nodes.push(t);
            }
            placed.push(s.id);
            placed.push(t.id);
            return {
                source: s,
                target: t,
                value: e[vars.edges.strength.value] || 1
            };
        });
        layout = d3sankey().nodeWidth(size).nodePadding(vars.data.padding.value).size([vars.width.viz - padding * 2, vars.height.viz - padding * 2]).nodes(nodes).links(edges).layout(2);
        returnData = [];
        for (i = 0, len = nodes.length; i < len; i++) {
            n = nodes[i];
            d = n.data || n;
            d = {
                id: d[vars.id.value]
            };
            d.d3plus = {
                x: n.x + n.dx / 2 + padding,
                y: n.y + n.dy / 2 + padding,
                width: n.dx,
                height: n.dy,
                suffix: n.dupe
            };
            if (d.id !== focus) {
                d[vars.edges.strength.value] = n.value;
            }
            returnData.push(d);
        }
        vars.edges.path = layout.link();
        for (j = 0, len1 = edges.length; j < len1; j++) {
            e = edges[j];
            e.d3plus = {
                x: padding,
                y: padding
            };
        }
        vars.mouse.viz = {};
        vars.mouse.viz[events.click] = function(d) {
            var old_focus;
            if (d[vars.id.value] !== vars.focus.value[0]) {
                removeTooltip(vars.type.value);
                old_focus = vars.focus.value[0];
                vars.history.states.push(function() {
                    return vars.self.focus(old_focus).draw();
                });
                return vars.self.focus(d[vars.id.value]).draw();
            }
        };
        return {
            nodes: returnData,
            edges: edges
        };
    };

    sankey.requirements = ["edges", "focus", "nodes"];

    sankey.shapes = ["square"];

    module.exports = sankey;


},{"../../client/pointer.coffee":40,"../../tooltip/remove.coffee":205,"../../util/uniques.coffee":212,"./sankey.js":331}],331:[function(require,module,exports){
    module.exports = function() {
        var sankey = {},
            nodeWidth = 24,
            nodePadding = 8,
            size = [1, 1],
            nodes = [],
            links = [];

        sankey.nodeWidth = function(_) {
            if (!arguments.length) return nodeWidth;
            nodeWidth = +_;
            return sankey;
        };

        sankey.nodePadding = function(_) {
            if (!arguments.length) return nodePadding;
            nodePadding = +_;
            return sankey;
        };

        sankey.nodes = function(_) {
            if (!arguments.length) return nodes;
            nodes = _;
            return sankey;
        };

        sankey.links = function(_) {
            if (!arguments.length) return links;
            links = _;
            return sankey;
        };

        sankey.size = function(_) {
            if (!arguments.length) return size;
            size = _;
            return sankey;
        };

        sankey.layout = function(iterations) {
            computeNodeLinks();
            computeNodeValues();
            computeNodeBreadths();
            computeNodeDepths(iterations);
            computeLinkDepths();
            return sankey;
        };

        sankey.relayout = function() {
            computeLinkDepths();
            return sankey;
        };

        sankey.link = function() {
            var curvature = .5;

            function link(d) {
                var x0 = d.source.x + d.source.dx,
                    x1 = d.target.x,
                    xi = d3.interpolateNumber(x0, x1),
                    x2 = xi(curvature),
                    x3 = xi(1 - curvature),
                    y0 = d.source.y + d.sy + d.dy / 2,
                    y1 = d.target.y + d.ty + d.dy / 2;
                return "M" + x0 + "," + y0
                    + "C" + x2 + "," + y0
                    + " " + x3 + "," + y1
                    + " " + x1 + "," + y1;
            }

            link.curvature = function(_) {
                if (!arguments.length) return curvature;
                curvature = +_;
                return link;
            };

            return link;
        };

        // Populate the sourceLinks and targetLinks for each node.
        // Also, if the source and target are not objects, assume they are indices.
        function computeNodeLinks() {
            nodes.forEach(function(node) {
                node.sourceLinks = [];
                node.targetLinks = [];
            });
            links.forEach(function(link) {
                var source = link.source,
                    target = link.target;
                if (typeof source === "number") source = link.source = nodes[link.source];
                if (typeof target === "number") target = link.target = nodes[link.target];
                source.sourceLinks.push(link);
                target.targetLinks.push(link);
            });
        }

        // Compute the value (size) of each node by summing the associated links.
        function computeNodeValues() {
            nodes.forEach(function(node) {
                node.value = Math.max(
                    d3.sum(node.sourceLinks, value),
                    d3.sum(node.targetLinks, value)
                );
            });
        }

        // Iteratively assign the breadth (x-position) for each node.
        // Nodes are assigned the maximum breadth of incoming neighbors plus one;
        // nodes with no incoming links are assigned breadth zero, while
        // nodes with no outgoing links are assigned the maximum breadth.
        function computeNodeBreadths() {
            var remainingNodes = nodes,
                nextNodes,
                x = 0;

            while (remainingNodes.length) {
                nextNodes = [];
                remainingNodes.forEach(function(node) {
                    node.x = x;
                    node.dx = nodeWidth;
                    node.sourceLinks.forEach(function(link) {
                        if (nextNodes.indexOf(link.target) < 0) {
                            nextNodes.push(link.target);
                        }
                    });
                });
                remainingNodes = nextNodes;
                ++x;
            }

            //
            moveSinksRight(x);
            scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
        }

        function moveSourcesRight() {
            nodes.forEach(function(node) {
                if (!node.targetLinks.length) {
                    node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
                }
            });
        }

        function moveSinksRight(x) {
            nodes.forEach(function(node) {
                if (!node.sourceLinks.length) {
                    node.x = x - 1;
                }
            });
        }

        function scaleNodeBreadths(kx) {
            nodes.forEach(function(node) {
                node.x *= kx;
            });
        }

        function computeNodeDepths(iterations) {
            var nodesByBreadth = d3.nest()
                .key(function(d) { return d.x; })
                .sortKeys(d3.ascending)
                .entries(nodes)
                .map(function(d) { return d.values; });

            //
            initializeNodeDepth();
            resolveCollisions();
            for (var alpha = 1; iterations > 0; --iterations) {
                relaxRightToLeft(alpha *= .99);
                resolveCollisions();
                relaxLeftToRight(alpha);
                resolveCollisions();
            }

            function initializeNodeDepth() {
                var ky = d3.min(nodesByBreadth, function(nodes) {
                    return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
                });

                nodesByBreadth.forEach(function(nodes) {
                    nodes.forEach(function(node, i) {
                        node.y = i;
                        node.dy = node.value * ky;
                    });
                });

                links.forEach(function(link) {
                    link.dy = link.value * ky;
                });
            }

            function relaxLeftToRight(alpha) {
                nodesByBreadth.forEach(function(nodes, breadth) {
                    nodes.forEach(function(node) {
                        if (node.targetLinks.length) {
                            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
                            node.y += (y - center(node)) * alpha;
                        }
                    });
                });

                function weightedSource(link) {
                    return center(link.source) * link.value;
                }
            }

            function relaxRightToLeft(alpha) {
                nodesByBreadth.slice().reverse().forEach(function(nodes) {
                    nodes.forEach(function(node) {
                        if (node.sourceLinks.length) {
                            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
                            node.y += (y - center(node)) * alpha;
                        }
                    });
                });

                function weightedTarget(link) {
                    return center(link.target) * link.value;
                }
            }

            function resolveCollisions() {
                nodesByBreadth.forEach(function(nodes) {
                    var node,
                        dy,
                        y0 = 0,
                        n = nodes.length,
                        i;

                    // Push any overlapping nodes down.
                    nodes.sort(ascendingDepth);
                    for (i = 0; i < n; ++i) {
                        node = nodes[i];
                        dy = y0 - node.y;
                        if (dy > 0) node.y += dy;
                        y0 = node.y + node.dy + nodePadding;
                    }

                    // If the bottommost node goes outside the bounds, push it back up.
                    dy = y0 - nodePadding - size[1];
                    if (dy > 0) {
                        y0 = node.y -= dy;

                        // Push any overlapping nodes back up.
                        for (i = n - 2; i >= 0; --i) {
                            node = nodes[i];
                            dy = node.y + node.dy + nodePadding - y0;
                            if (dy > 0) node.y -= dy;
                            y0 = node.y;
                        }
                    }
                });
            }

            function ascendingDepth(a, b) {
                return a.y - b.y;
            }
        }

        function computeLinkDepths() {
            nodes.forEach(function(node) {
                node.sourceLinks.sort(ascendingTargetDepth);
                node.targetLinks.sort(ascendingSourceDepth);
            });
            nodes.forEach(function(node) {
                var sy = 0, ty = 0;
                node.sourceLinks.forEach(function(link) {
                    link.sy = sy;
                    sy += link.dy;
                });
                node.targetLinks.forEach(function(link) {
                    link.ty = ty;
                    ty += link.dy;
                });
            });

            function ascendingSourceDepth(a, b) {
                return a.source.y - b.source.y;
            }

            function ascendingTargetDepth(a, b) {
                return a.target.y - b.target.y;
            }
        }

        function center(node) {
            return node.y + node.dy / 2;
        }

        function value(link) {
            return link.value;
        }

        return sankey;
    };

},{}],332:[function(require,module,exports){
    var fetchValue, graph, print, scatter, sort, ticks;

    fetchValue = require("../../core/fetch/value.coffee");

    graph = require("./helpers/graph/draw.coffee");

    print = require("../../core/console/print.coffee");

    sort = require("../../array/sort.coffee");

    ticks = require("./helpers/graph/dataTicks.coffee");

    scatter = function(vars) {
        var d, domains, i, len, ref;
        graph(vars, {
            buffer: "size",
            mouse: true
        });
        domains = vars.x.domain.viz.concat(vars.y.domain.viz);
        if (domains.indexOf(void 0) >= 0) {
            return [];
        }
        ref = vars.data.viz;
        for (i = 0, len = ref.length; i < len; i++) {
            d = ref[i];
            d.d3plus.x = vars.x.scale.viz(fetchValue(vars, d, vars.x.value));
            d.d3plus.x += vars.axes.margin.left;
            d.d3plus.y = vars.y.scale.viz(fetchValue(vars, d, vars.y.value));
            d.d3plus.y += vars.axes.margin.top;
            if (typeof vars.size.value === "number" || !vars.size.value) {
                d.d3plus.r = vars.axes.scale(0);
            } else {
                d.d3plus.r = vars.axes.scale(fetchValue(vars, d, vars.size.value));
            }
        }
        ticks(vars);
        return sort(vars.data.viz, vars.order.value || vars.size.value || vars.id.value, vars.order.sort.value === "desc" ? "asc" : "desc", vars.color.value || [], vars);
    };

    scatter.fill = true;

    scatter.requirements = ["data", "x", "y"];

    scatter.scale = 1.1;

    scatter.setup = function(vars) {
        if (vars.time.value && !vars.axes.discrete) {
            if (vars.time.value === vars.x.value) {
                vars.self.x({
                    scale: "discrete"
                });
            }
            if (vars.time.value === vars.y.value) {
                return vars.self.y({
                    scale: "discrete"
                });
            }
        }
    };

    scatter.shapes = ["circle", "square", "donut"];

    scatter.tooltip = "static";

    module.exports = scatter;


},{"../../array/sort.coffee":36,"../../core/console/print.coffee":54,"../../core/fetch/value.coffee":69,"./helpers/graph/dataTicks.coffee":315,"./helpers/graph/draw.coffee":316}],333:[function(require,module,exports){
    var fetchValue = require("../../core/fetch/value.coffee");
    var uniques    = require("../../util/uniques.coffee");
    var copy       = require("../../util/copy.coffee");
    var rand_col   = require("../../color/random.coffee");

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Table
//------------------------------------------------------------------------------

    var table = function(vars) {

        // get unique IDs and columns
        var ids = uniques(vars.data.viz, vars.id.value, fetchValue, vars);
        var cols = uniques(vars.cols.value);

        // if user wants to show the row labels (default behavior) add this as a col
        if (cols.indexOf("label") < 0 && vars.cols.index.value){
            cols.unshift("label");
        }

        // width/height are a function of number of IDs and columns
        var item_height = vars.height.viz / (ids.length+1); // add 1 for header offset
        var item_width = vars.width.viz / cols.length;

        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // Setup background
        //----------------------------------------------------------------------------
        vars.group.selectAll("rect").data([0]).enter()
            .append("rect")
            .attr("class", "background")
            .attr("height", vars.height.viz)
            .attr("width", vars.width.viz)
            .style("fill", vars.color.missing)
        // draw line separater w/ enter/update/exit
        var lines_horiz = vars.group.selectAll("line.horiz").data(vars.data.viz);
        lines_horiz.enter().append("line").attr("class", "horiz")
        lines_horiz
            .attr("x1", 0)
            .attr("y1", function(d, row_i){ return (item_height * row_i) + item_height })
            .attr("x2", vars.width.viz)
            .attr("y2", function(d, row_i){ return (item_height * row_i) + item_height })
            .style("fill", "#fff")
            .style("stroke", "#fff")
        lines_horiz.exit().remove()
        // draw line separater w/ enter/update/exit
        var lines_vert = vars.group.selectAll("line.vert").data(cols);
        lines_vert.enter().append("line").attr("class", "vert")
        lines_vert
            .attr("x1", function(d, col_i){ return (item_width * col_i) + item_width })
            .attr("y1", 0)
            .attr("x2", function(d, col_i){ return (item_width * col_i) + item_width })
            .attr("y2", vars.height.viz)
            .style("fill", "#fff")
            .style("stroke", "#fff")
        lines_vert.exit().remove()

        var ret = []
        var colors = {}

        // doing 2 things here, first we add our column headers to our ret array as
        // items dor d3plus to draw. We also compute the color scales for each column
        cols.forEach(function(col, col_i){
            // add columns
            var header = {"d3plus":{
                "x": (item_width * col_i) + item_width/2,
                "y": item_height/2,
                "width": item_width,
                "height": item_height,
                "id": "d3p_header_"+col.toString().replace(/ /g,"_"),
                "shape": "square",
                "color": "#fff",
                "text": vars.format.value(col)
            }}
            if(col == vars.id.value){
                header.d3plus.color = "#fff";
            }
            if(col == "label"){
                header.d3plus.label = false;
                header.d3plus.color = "#fff";
                header.d3plus.stroke = "#fff";
            }
            ret.push(header)

            // set up color scales
            if(vars.data.keys[col] == "number"){
                var domain_extent = d3.extent(vars.data.viz, function(d){ return d[col]; })
                if(domain_extent[0] == domain_extent[1]){
                    domain_extent = [domain_extent[0]-1, domain_extent[1]]
                }
                colors[col] = d3.scale.linear().domain(domain_extent).range([vars.color.missing,rand_col(col)])
            }
            else if(vars.data.keys[col] == "boolean"){
                colors[col] = function(bool){
                    return bool ? rand_col(col) : vars.color.missing;
                }
            }
        })

        vars.data.viz.forEach(function(d, row_i){
            // offset for column headers
            row_i += 1;

            // loop through each user defined column to create new "object" to draw
            cols.forEach(function(col, col_i){

                // need to clone data since we'll be dupliating it for each column
                var d_clone = copy(d);

                // set unique ID otherwise it'd be the same in each column
                d_clone.d3plus.id = "d3p_"+d_clone[vars.id.value].toString().replace(/ /g,"_")+"_"+col;
                d_clone.d3plus.x = (item_width * col_i) + item_width/2;
                d_clone.d3plus.y = (item_height * row_i) + item_height/2;
                d_clone.d3plus.width = item_width;
                d_clone.d3plus.height = item_height;

                if(col == "label"){
                    d_clone.d3plus.shape = "square";
                    d_clone.d3plus.color = "#fff";
                    // special case for top left corner
                    ret.push(d_clone)
                }

                // be sure that this column is actually in this data item
                if(d3.keys(d).indexOf(col) >= 0 && col in d){
                    if(colors[col]){
                        d_clone.d3plus.color = colors[col](d_clone[col]);
                    }
                    d_clone.d3plus.text = vars.format.value(d_clone[col]);
                    if(vars.data.keys[col] == "boolean"){
                        d_clone.d3plus.label = false;
                    }
                    else if(vars.data.keys[col] == "string"){
                        d_clone.d3plus.color = vars.color.missing;
                        d_clone.d3plus.stroke = "#fff";
                        d_clone.d3plus.shape = "square";
                    }
                    ret.push(d_clone)
                }
            })

        })

        return ret

    };

//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Visualization Settings and Helper Functions
//------------------------------------------------------------------------------
    table.shapes = ["check", "cross", "diamond", "square", "triangle", "triangle_up", "triangle_down"]
    table.requirements = ["data", "cols"]

    module.exports = table

},{"../../color/random.coffee":49,"../../core/fetch/value.coffee":69,"../../util/copy.coffee":209,"../../util/uniques.coffee":212}],334:[function(require,module,exports){
    var dataThreshold, groupData, mergeObject, tree_map;

    dataThreshold = require("../../core/data/threshold.js");

    groupData = require("../../core/data/group.coffee");

    mergeObject = require("../../object/merge.coffee");

    tree_map = function(vars) {
        var d, data, groupedData, i, len, returnData, root;
        groupedData = groupData(vars, vars.data.viz);
        data = d3.layout.treemap().mode(vars.type.mode.value).round(true).size([vars.width.viz, vars.height.viz]).children(function(d) {
            return d.values;
        }).padding(vars.data.padding.value).sort(function(a, b) {
            var sizeDiff;
            sizeDiff = a.value - b.value;
            if (sizeDiff === 0) {
                return a.id < b.id;
            } else {
                return sizeDiff;
            }
        }).nodes({
            name: "root",
            values: groupedData
        }).filter(function(d) {
            return !d.values && d.area;
        });
        if (data.length) {
            root = data[0];
            while (root.parent) {
                root = root.parent;
            }
            returnData = [];
            for (i = 0, len = data.length; i < len; i++) {
                d = data[i];
                d.d3plus.d3plus = mergeObject(d.d3plus.d3plus, {
                    x: d.x + d.dx / 2,
                    y: d.y + d.dy / 2,
                    width: d.dx,
                    height: d.dy,
                    share: d.value / root.value
                });
                returnData.push(d.d3plus);
            }
        }
        return returnData;
    };

    tree_map.filter = dataThreshold;

    tree_map.modes = ["squarify", "slice", "dice", "slice-dice"];

    tree_map.requirements = ["data", "size"];

    tree_map.shapes = ["square"];

    tree_map.threshold = function(vars) {
        return (40 * 40) / (vars.width.viz * vars.height.viz);
    };

    module.exports = tree_map;


},{"../../core/data/group.coffee":59,"../../core/data/threshold.js":63,"../../object/merge.coffee":173}],335:[function(require,module,exports){
    var attach, axis, container, flash, getSteps, print, validObject;

    attach = require("../core/methods/attach.coffee");

    axis = require("./methods/helpers/axis.coffee");

    flash = require("./helpers/ui/message.js");

    getSteps = require("./helpers/drawSteps.js");

    print = require("../core/console/print.coffee");

    container = require("./helpers/container.coffee");

    validObject = require("../object/validate.coffee");

    module.exports = function() {
        var vars;
        vars = {
            g: {
                apps: {}
            },
            types: {
                area: require("./types/area.coffee"),
                bar: require("./types/bar.coffee"),
                bubbles: require("./types/bubbles.coffee"),
                box: require("./types/box.coffee"),
                chart: require("./types/deprecated/chart.coffee"),
                geo_map: require("./types/geo_map.coffee"),
                line: require("./types/line.coffee"),
                network: require("./types/network.js"),
                paths: require("./types/paths.coffee"),
                pie: require("./types/pie.coffee"),
                radar: require("./types/radar.coffee"),
                rings: require("./types/rings.js"),
                sankey: require("./types/sankey.coffee"),
                scatter: require("./types/scatter.coffee"),
                stacked: require("./types/area.coffee"),
                table: require("./types/table.js"),
                tree_map: require("./types/tree_map.coffee")
            }
        };
        vars.self = function(selection) {
            selection.each(function() {
                var lastMessage, nextStep, runFunction, runStep, small_height, small_width, steps;
                vars.draw.frozen = true;
                vars.error.internal = null;
                if (!("timing" in vars.draw)) {
                    vars.draw.timing = vars.timing.transitions;
                }
                if (vars.error.value) {
                    vars.draw.timing = 0;
                }
                container(vars);
                small_width = vars.width.value <= vars.width.small;
                small_height = vars.height.value <= vars.height.small;
                vars.small = small_width || small_height;
                vars.width.viz = vars.width.value;
                vars.height.viz = vars.height.value;
                lastMessage = false;
                nextStep = function() {
                    if (steps.length) {
                        runStep();
                    } else {
                        if (vars.dev.value) {
                            print.groupEnd();
                            print.timeEnd("total draw time");
                            print.log("\n");
                        }
                    }
                };
                runFunction = function(step, name) {
                    name = name || "function";
                    if (step[name] instanceof Array) {
                        step[name].forEach(function(f) {
                            f(vars, nextStep);
                        });
                    } else {
                        if (typeof step[name] === "function") {
                            step[name](vars, nextStep);
                        }
                    }
                    if (!step.wait) {
                        nextStep();
                    }
                };
                runStep = function() {
                    var message, run, same, step;
                    step = steps.shift();
                    same = vars.g.message && lastMessage === step.message;
                    run = "check" in step ? step.check : true;
                    if (typeof run === "function") {
                        run = run(vars);
                    }
                    if (run) {
                        if (!same) {
                            if (vars.dev.value) {
                                if (lastMessage !== false) {
                                    print.groupEnd();
                                }
                                print.group(step.message);
                            }
                            if (typeof vars.messages.value === "string") {
                                lastMessage = vars.messages.value;
                                message = vars.messages.value;
                            } else {
                                lastMessage = step.message;
                                message = vars.format.value(step.message);
                            }
                            if (vars.draw.update) {
                                flash(vars, message);
                                if (vars.error.value) {
                                    runFunction(step);
                                } else {
                                    setTimeout((function() {
                                        return runFunction(step);
                                    }), 10);
                                }
                            } else {
                                runFunction(step);
                            }
                        } else {
                            runFunction(step);
                        }
                    } else {
                        if ("otherwise" in step) {
                            if (vars.error.value) {
                                runFunction(step, "otherwise");
                            } else {
                                setTimeout((function() {
                                    return runFunction(step, "otherwise");
                                }), 10);
                            }
                        } else {
                            nextStep();
                        }
                    }
                };
                vars.messages.style.backup = vars.group && vars.group.attr("opacity") === "1" ? "small" : "large";
                steps = getSteps(vars);
                runStep();
            });
            return vars.self;
        };
        attach(vars, {
            active: require("./methods/active.coffee"),
            aggs: require("./methods/aggs.coffee"),
            attrs: require("./methods/attrs.coffee"),
            axes: require("./methods/axes.coffee"),
            background: require("./methods/background.coffee"),
            "class": require("./methods/class.coffee"),
            color: require("./methods/color.coffee"),
            cols: require("./methods/cols.js"),
            config: require("./methods/config.coffee"),
            container: require("./methods/container.coffee"),
            coords: require("./methods/coords.coffee"),
            csv: require("./methods/csv.coffee"),
            data: require("./methods/data.coffee"),
            depth: require("./methods/depth.coffee"),
            descs: require("./methods/descs.coffee"),
            dev: require("./methods/dev.coffee"),
            draw: require("./methods/draw.js"),
            edges: require("./methods/edges.js"),
            error: require("./methods/error.coffee"),
            focus: require("./methods/focus.coffee"),
            font: require("./methods/font.coffee"),
            footer: require("./methods/footer.coffee"),
            format: require("./methods/format.coffee"),
            height: require("./methods/height.coffee"),
            history: require("./methods/history.coffee"),
            icon: require("./methods/icon.coffee"),
            id: require("./methods/id.coffee"),
            labels: require("./methods/labels.coffee"),
            legend: require("./methods/legend.coffee"),
            links: require("./methods/links.coffee"),
            margin: require("./methods/margin.coffee"),
            messages: require("./methods/messages.coffee"),
            mouse: require("./methods/mouse.coffee"),
            nodes: require("./methods/nodes.coffee"),
            order: require("./methods/order.coffee"),
            resize: require("./methods/resize.coffee"),
            shape: require("./methods/shape.coffee"),
            size: require("./methods/size.coffee"),
            style: require("./methods/style.coffee"),
            temp: require("./methods/temp.coffee"),
            text: require("./methods/text.coffee"),
            time: require("./methods/time.coffee"),
            timeline: require("./methods/timeline.coffee"),
            timing: require("./methods/timing.coffee"),
            title: require("./methods/title.coffee"),
            tooltip: require("./methods/tooltip.coffee"),
            total: require("./methods/total.coffee"),
            type: require("./methods/type.coffee"),
            ui: require("./methods/ui.coffee"),
            width: require("./methods/width.coffee"),
            x: axis("x"),
            x2: axis("x2"),
            y: axis("y"),
            y2: axis("y2"),
            zoom: require("./methods/zoom.js")
        });
        return vars.self;
    };


},{"../core/console/print.coffee":54,"../core/methods/attach.coffee":81,"../object/validate.coffee":174,"./helpers/container.coffee":213,"./helpers/drawSteps.js":214,"./helpers/ui/message.js":248,"./methods/active.coffee":257,"./methods/aggs.coffee":258,"./methods/attrs.coffee":259,"./methods/axes.coffee":260,"./methods/background.coffee":261,"./methods/class.coffee":262,"./methods/color.coffee":263,"./methods/cols.js":264,"./methods/config.coffee":265,"./methods/container.coffee":266,"./methods/coords.coffee":267,"./methods/csv.coffee":268,"./methods/data.coffee":269,"./methods/depth.coffee":270,"./methods/descs.coffee":271,"./methods/dev.coffee":272,"./methods/draw.js":273,"./methods/edges.js":274,"./methods/error.coffee":275,"./methods/focus.coffee":276,"./methods/font.coffee":277,"./methods/footer.coffee":278,"./methods/format.coffee":279,"./methods/height.coffee":280,"./methods/helpers/axis.coffee":281,"./methods/history.coffee":282,"./methods/icon.coffee":283,"./methods/id.coffee":284,"./methods/labels.coffee":285,"./methods/legend.coffee":286,"./methods/links.coffee":287,"./methods/margin.coffee":288,"./methods/messages.coffee":289,"./methods/mouse.coffee":290,"./methods/nodes.coffee":291,"./methods/order.coffee":292,"./methods/resize.coffee":293,"./methods/shape.coffee":294,"./methods/size.coffee":295,"./methods/style.coffee":296,"./methods/temp.coffee":297,"./methods/text.coffee":298,"./methods/time.coffee":299,"./methods/timeline.coffee":300,"./methods/timing.coffee":301,"./methods/title.coffee":302,"./methods/tooltip.coffee":303,"./methods/total.coffee":304,"./methods/type.coffee":305,"./methods/ui.coffee":306,"./methods/width.coffee":307,"./methods/zoom.js":308,"./types/area.coffee":309,"./types/bar.coffee":310,"./types/box.coffee":311,"./types/bubbles.coffee":312,"./types/deprecated/chart.coffee":313,"./types/geo_map.coffee":314,"./types/line.coffee":324,"./types/network.js":325,"./types/paths.coffee":326,"./types/pie.coffee":327,"./types/radar.coffee":328,"./types/rings.js":329,"./types/sankey.coffee":330,"./types/scatter.coffee":332,"./types/table.js":333,"./types/tree_map.coffee":334}]},{},[165,164]);

/*!
 * Chart.js
 * http://chartjs.org/
 * Version: 1.0.2
 *
 * Copyright 2015 Nick Downie
 * Released under the MIT license
 * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md
 */
(function(){"use strict";var t=this,i=t.Chart,e=function(t){this.canvas=t.canvas,this.ctx=t;var i=function(t,i){return t["offset"+i]?t["offset"+i]:document.defaultView.getComputedStyle(t).getPropertyValue(i)},e=this.width=i(t.canvas,"Width"),n=this.height=i(t.canvas,"Height");t.canvas.width=e,t.canvas.height=n;var e=this.width=t.canvas.width,n=this.height=t.canvas.height;return this.aspectRatio=this.width/this.height,s.retinaScale(this),this};e.defaults={global:{animation:!0,animationSteps:60,animationEasing:"easeOutQuart",showScale:!0,scaleOverride:!1,scaleSteps:null,scaleStepWidth:null,scaleStartValue:null,scaleLineColor:"rgba(0,0,0,.1)",scaleLineWidth:1,scaleShowLabels:!0,scaleLabel:"<%=value%>",scaleIntegersOnly:!0,scaleBeginAtZero:!1,scaleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",scaleFontSize:12,scaleFontStyle:"normal",scaleFontColor:"#666",responsive:!1,maintainAspectRatio:!0,showTooltips:!0,customTooltips:!1,tooltipEvents:["mousemove","touchstart","touchmove","mouseout"],tooltipFillColor:"rgba(0,0,0,0.8)",tooltipFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipFontSize:14,tooltipFontStyle:"normal",tooltipFontColor:"#fff",tooltipTitleFontFamily:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",tooltipTitleFontSize:14,tooltipTitleFontStyle:"bold",tooltipTitleFontColor:"#fff",tooltipYPadding:6,tooltipXPadding:6,tooltipCaretSize:8,tooltipCornerRadius:6,tooltipXOffset:10,tooltipTemplate:"<%if (label){%><%=label%>: <%}%><%= value %>",multiTooltipTemplate:"<%= value %>",multiTooltipKeyBackground:"#fff",onAnimationProgress:function(){},onAnimationComplete:function(){}}},e.types={};var s=e.helpers={},n=s.each=function(t,i,e){var s=Array.prototype.slice.call(arguments,3);if(t)if(t.length===+t.length){var n;for(n=0;n<t.length;n++)i.apply(e,[t[n],n].concat(s))}else for(var o in t)i.apply(e,[t[o],o].concat(s))},o=s.clone=function(t){var i={};return n(t,function(e,s){t.hasOwnProperty(s)&&(i[s]=e)}),i},a=s.extend=function(t){return n(Array.prototype.slice.call(arguments,1),function(i){n(i,function(e,s){i.hasOwnProperty(s)&&(t[s]=e)})}),t},h=s.merge=function(){var t=Array.prototype.slice.call(arguments,0);return t.unshift({}),a.apply(null,t)},l=s.indexOf=function(t,i){if(Array.prototype.indexOf)return t.indexOf(i);for(var e=0;e<t.length;e++)if(t[e]===i)return e;return-1},r=(s.where=function(t,i){var e=[];return s.each(t,function(t){i(t)&&e.push(t)}),e},s.findNextWhere=function(t,i,e){e||(e=-1);for(var s=e+1;s<t.length;s++){var n=t[s];if(i(n))return n}},s.findPreviousWhere=function(t,i,e){e||(e=t.length);for(var s=e-1;s>=0;s--){var n=t[s];if(i(n))return n}},s.inherits=function(t){var i=this,e=t&&t.hasOwnProperty("constructor")?t.constructor:function(){return i.apply(this,arguments)},s=function(){this.constructor=e};return s.prototype=i.prototype,e.prototype=new s,e.extend=r,t&&a(e.prototype,t),e.__super__=i.prototype,e}),c=s.noop=function(){},u=s.uid=function(){var t=0;return function(){return"chart-"+t++}}(),d=s.warn=function(t){window.console&&"function"==typeof window.console.warn&&console.warn(t)},p=s.amd="function"==typeof define&&define.amd,f=s.isNumber=function(t){return!isNaN(parseFloat(t))&&isFinite(t)},g=s.max=function(t){return Math.max.apply(Math,t)},m=s.min=function(t){return Math.min.apply(Math,t)},v=(s.cap=function(t,i,e){if(f(i)){if(t>i)return i}else if(f(e)&&e>t)return e;return t},s.getDecimalPlaces=function(t){return t%1!==0&&f(t)?t.toString().split(".")[1].length:0}),S=s.radians=function(t){return t*(Math.PI/180)},x=(s.getAngleFromPoint=function(t,i){var e=i.x-t.x,s=i.y-t.y,n=Math.sqrt(e*e+s*s),o=2*Math.PI+Math.atan2(s,e);return 0>e&&0>s&&(o+=2*Math.PI),{angle:o,distance:n}},s.aliasPixel=function(t){return t%2===0?0:.5}),y=(s.splineCurve=function(t,i,e,s){var n=Math.sqrt(Math.pow(i.x-t.x,2)+Math.pow(i.y-t.y,2)),o=Math.sqrt(Math.pow(e.x-i.x,2)+Math.pow(e.y-i.y,2)),a=s*n/(n+o),h=s*o/(n+o);return{inner:{x:i.x-a*(e.x-t.x),y:i.y-a*(e.y-t.y)},outer:{x:i.x+h*(e.x-t.x),y:i.y+h*(e.y-t.y)}}},s.calculateOrderOfMagnitude=function(t){return Math.floor(Math.log(t)/Math.LN10)}),C=(s.calculateScaleRange=function(t,i,e,s,n){var o=2,a=Math.floor(i/(1.5*e)),h=o>=a,l=g(t),r=m(t);l===r&&(l+=.5,r>=.5&&!s?r-=.5:l+=.5);for(var c=Math.abs(l-r),u=y(c),d=Math.ceil(l/(1*Math.pow(10,u)))*Math.pow(10,u),p=s?0:Math.floor(r/(1*Math.pow(10,u)))*Math.pow(10,u),f=d-p,v=Math.pow(10,u),S=Math.round(f/v);(S>a||a>2*S)&&!h;)if(S>a)v*=2,S=Math.round(f/v),S%1!==0&&(h=!0);else if(n&&u>=0){if(v/2%1!==0)break;v/=2,S=Math.round(f/v)}else v/=2,S=Math.round(f/v);return h&&(S=o,v=f/S),{steps:S,stepValue:v,min:p,max:p+S*v}},s.template=function(t,i){function e(t,i){var e=/\W/.test(t)?new Function("obj","var p=[],print=function(){p.push.apply(p,arguments);};with(obj){p.push('"+t.replace(/[\r\t\n]/g," ").split("<%").join("	").replace(/((^|%>)[^\t]*)'/g,"$1\r").replace(/\t=(.*?)%>/g,"',$1,'").split("	").join("');").split("%>").join("p.push('").split("\r").join("\\'")+"');}return p.join('');"):s[t]=s[t];return i?e(i):e}if(t instanceof Function)return t(i);var s={};return e(t,i)}),w=(s.generateLabels=function(t,i,e,s){var o=new Array(i);return labelTemplateString&&n(o,function(i,n){o[n]=C(t,{value:e+s*(n+1)})}),o},s.easingEffects={linear:function(t){return t},easeInQuad:function(t){return t*t},easeOutQuad:function(t){return-1*t*(t-2)},easeInOutQuad:function(t){return(t/=.5)<1?.5*t*t:-0.5*(--t*(t-2)-1)},easeInCubic:function(t){return t*t*t},easeOutCubic:function(t){return 1*((t=t/1-1)*t*t+1)},easeInOutCubic:function(t){return(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2)},easeInQuart:function(t){return t*t*t*t},easeOutQuart:function(t){return-1*((t=t/1-1)*t*t*t-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*t*t*t*t:-0.5*((t-=2)*t*t*t-2)},easeInQuint:function(t){return 1*(t/=1)*t*t*t*t},easeOutQuint:function(t){return 1*((t=t/1-1)*t*t*t*t+1)},easeInOutQuint:function(t){return(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)},easeInSine:function(t){return-1*Math.cos(t/1*(Math.PI/2))+1},easeOutSine:function(t){return 1*Math.sin(t/1*(Math.PI/2))},easeInOutSine:function(t){return-0.5*(Math.cos(Math.PI*t/1)-1)},easeInExpo:function(t){return 0===t?1:1*Math.pow(2,10*(t/1-1))},easeOutExpo:function(t){return 1===t?1:1*(-Math.pow(2,-10*t/1)+1)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(-Math.pow(2,-10*--t)+2)},easeInCirc:function(t){return t>=1?t:-1*(Math.sqrt(1-(t/=1)*t)-1)},easeOutCirc:function(t){return 1*Math.sqrt(1-(t=t/1-1)*t)},easeInOutCirc:function(t){return(t/=.5)<1?-0.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),-(s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)))},easeOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:1==(t/=1)?1:(e||(e=.3),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),s*Math.pow(2,-10*t)*Math.sin(2*(1*t-i)*Math.PI/e)+1)},easeInOutElastic:function(t){var i=1.70158,e=0,s=1;return 0===t?0:2==(t/=.5)?1:(e||(e=.3*1.5),s<Math.abs(1)?(s=1,i=e/4):i=e/(2*Math.PI)*Math.asin(1/s),1>t?-.5*s*Math.pow(2,10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e):s*Math.pow(2,-10*(t-=1))*Math.sin(2*(1*t-i)*Math.PI/e)*.5+1)},easeInBack:function(t){var i=1.70158;return 1*(t/=1)*t*((i+1)*t-i)},easeOutBack:function(t){var i=1.70158;return 1*((t=t/1-1)*t*((i+1)*t+i)+1)},easeInOutBack:function(t){var i=1.70158;return(t/=.5)<1?.5*t*t*(((i*=1.525)+1)*t-i):.5*((t-=2)*t*(((i*=1.525)+1)*t+i)+2)},easeInBounce:function(t){return 1-w.easeOutBounce(1-t)},easeOutBounce:function(t){return(t/=1)<1/2.75?7.5625*t*t:2/2.75>t?1*(7.5625*(t-=1.5/2.75)*t+.75):2.5/2.75>t?1*(7.5625*(t-=2.25/2.75)*t+.9375):1*(7.5625*(t-=2.625/2.75)*t+.984375)},easeInOutBounce:function(t){return.5>t?.5*w.easeInBounce(2*t):.5*w.easeOutBounce(2*t-1)+.5}}),b=s.requestAnimFrame=function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(t){return window.setTimeout(t,1e3/60)}}(),P=s.cancelAnimFrame=function(){return window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame||function(t){return window.clearTimeout(t,1e3/60)}}(),L=(s.animationLoop=function(t,i,e,s,n,o){var a=0,h=w[e]||w.linear,l=function(){a++;var e=a/i,r=h(e);t.call(o,r,e,a),s.call(o,r,e),i>a?o.animationFrame=b(l):n.apply(o)};b(l)},s.getRelativePosition=function(t){var i,e,s=t.originalEvent||t,n=t.currentTarget||t.srcElement,o=n.getBoundingClientRect();return s.touches?(i=s.touches[0].clientX-o.left,e=s.touches[0].clientY-o.top):(i=s.clientX-o.left,e=s.clientY-o.top),{x:i,y:e}},s.addEvent=function(t,i,e){t.addEventListener?t.addEventListener(i,e):t.attachEvent?t.attachEvent("on"+i,e):t["on"+i]=e}),k=s.removeEvent=function(t,i,e){t.removeEventListener?t.removeEventListener(i,e,!1):t.detachEvent?t.detachEvent("on"+i,e):t["on"+i]=c},F=(s.bindEvents=function(t,i,e){t.events||(t.events={}),n(i,function(i){t.events[i]=function(){e.apply(t,arguments)},L(t.chart.canvas,i,t.events[i])})},s.unbindEvents=function(t,i){n(i,function(i,e){k(t.chart.canvas,e,i)})}),R=s.getMaximumWidth=function(t){var i=t.parentNode;return i.clientWidth},T=s.getMaximumHeight=function(t){var i=t.parentNode;return i.clientHeight},A=(s.getMaximumSize=s.getMaximumWidth,s.retinaScale=function(t){var i=t.ctx,e=t.canvas.width,s=t.canvas.height;window.devicePixelRatio&&(i.canvas.style.width=e+"px",i.canvas.style.height=s+"px",i.canvas.height=s*window.devicePixelRatio,i.canvas.width=e*window.devicePixelRatio,i.scale(window.devicePixelRatio,window.devicePixelRatio))}),M=s.clear=function(t){t.ctx.clearRect(0,0,t.width,t.height)},W=s.fontString=function(t,i,e){return i+" "+t+"px "+e},z=s.longestText=function(t,i,e){t.font=i;var s=0;return n(e,function(i){var e=t.measureText(i).width;s=e>s?e:s}),s},B=s.drawRoundedRectangle=function(t,i,e,s,n,o){t.beginPath(),t.moveTo(i+o,e),t.lineTo(i+s-o,e),t.quadraticCurveTo(i+s,e,i+s,e+o),t.lineTo(i+s,e+n-o),t.quadraticCurveTo(i+s,e+n,i+s-o,e+n),t.lineTo(i+o,e+n),t.quadraticCurveTo(i,e+n,i,e+n-o),t.lineTo(i,e+o),t.quadraticCurveTo(i,e,i+o,e),t.closePath()};e.instances={},e.Type=function(t,i,s){this.options=i,this.chart=s,this.id=u(),e.instances[this.id]=this,i.responsive&&this.resize(),this.initialize.call(this,t)},a(e.Type.prototype,{initialize:function(){return this},clear:function(){return M(this.chart),this},stop:function(){return P(this.animationFrame),this},resize:function(t){this.stop();var i=this.chart.canvas,e=R(this.chart.canvas),s=this.options.maintainAspectRatio?e/this.chart.aspectRatio:T(this.chart.canvas);return i.width=this.chart.width=e,i.height=this.chart.height=s,A(this.chart),"function"==typeof t&&t.apply(this,Array.prototype.slice.call(arguments,1)),this},reflow:c,render:function(t){return t&&this.reflow(),this.options.animation&&!t?s.animationLoop(this.draw,this.options.animationSteps,this.options.animationEasing,this.options.onAnimationProgress,this.options.onAnimationComplete,this):(this.draw(),this.options.onAnimationComplete.call(this)),this},generateLegend:function(){return C(this.options.legendTemplate,this)},destroy:function(){this.clear(),F(this,this.events);var t=this.chart.canvas;t.width=this.chart.width,t.height=this.chart.height,t.style.removeProperty?(t.style.removeProperty("width"),t.style.removeProperty("height")):(t.style.removeAttribute("width"),t.style.removeAttribute("height")),delete e.instances[this.id]},showTooltip:function(t,i){"undefined"==typeof this.activeElements&&(this.activeElements=[]);var o=function(t){var i=!1;return t.length!==this.activeElements.length?i=!0:(n(t,function(t,e){t!==this.activeElements[e]&&(i=!0)},this),i)}.call(this,t);if(o||i){if(this.activeElements=t,this.draw(),this.options.customTooltips&&this.options.customTooltips(!1),t.length>0)if(this.datasets&&this.datasets.length>1){for(var a,h,r=this.datasets.length-1;r>=0&&(a=this.datasets[r].points||this.datasets[r].bars||this.datasets[r].segments,h=l(a,t[0]),-1===h);r--);var c=[],u=[],d=function(){var t,i,e,n,o,a=[],l=[],r=[];return s.each(this.datasets,function(i){t=i.points||i.bars||i.segments,t[h]&&t[h].hasValue()&&a.push(t[h])}),s.each(a,function(t){l.push(t.x),r.push(t.y),c.push(s.template(this.options.multiTooltipTemplate,t)),u.push({fill:t._saved.fillColor||t.fillColor,stroke:t._saved.strokeColor||t.strokeColor})},this),o=m(r),e=g(r),n=m(l),i=g(l),{x:n>this.chart.width/2?n:i,y:(o+e)/2}}.call(this,h);new e.MultiTooltip({x:d.x,y:d.y,xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,xOffset:this.options.tooltipXOffset,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,titleTextColor:this.options.tooltipTitleFontColor,titleFontFamily:this.options.tooltipTitleFontFamily,titleFontStyle:this.options.tooltipTitleFontStyle,titleFontSize:this.options.tooltipTitleFontSize,cornerRadius:this.options.tooltipCornerRadius,labels:c,legendColors:u,legendColorBackground:this.options.multiTooltipKeyBackground,title:t[0].label,chart:this.chart,ctx:this.chart.ctx,custom:this.options.customTooltips}).draw()}else n(t,function(t){var i=t.tooltipPosition();new e.Tooltip({x:Math.round(i.x),y:Math.round(i.y),xPadding:this.options.tooltipXPadding,yPadding:this.options.tooltipYPadding,fillColor:this.options.tooltipFillColor,textColor:this.options.tooltipFontColor,fontFamily:this.options.tooltipFontFamily,fontStyle:this.options.tooltipFontStyle,fontSize:this.options.tooltipFontSize,caretHeight:this.options.tooltipCaretSize,cornerRadius:this.options.tooltipCornerRadius,text:C(this.options.tooltipTemplate,t),chart:this.chart,custom:this.options.customTooltips}).draw()},this);return this}},toBase64Image:function(){return this.chart.canvas.toDataURL.apply(this.chart.canvas,arguments)}}),e.Type.extend=function(t){var i=this,s=function(){return i.apply(this,arguments)};if(s.prototype=o(i.prototype),a(s.prototype,t),s.extend=e.Type.extend,t.name||i.prototype.name){var n=t.name||i.prototype.name,l=e.defaults[i.prototype.name]?o(e.defaults[i.prototype.name]):{};e.defaults[n]=a(l,t.defaults),e.types[n]=s,e.prototype[n]=function(t,i){var o=h(e.defaults.global,e.defaults[n],i||{});return new s(t,o,this)}}else d("Name not provided for this chart, so it hasn't been registered");return i},e.Element=function(t){a(this,t),this.initialize.apply(this,arguments),this.save()},a(e.Element.prototype,{initialize:function(){},restore:function(t){return t?n(t,function(t){this[t]=this._saved[t]},this):a(this,this._saved),this},save:function(){return this._saved=o(this),delete this._saved._saved,this},update:function(t){return n(t,function(t,i){this._saved[i]=this[i],this[i]=t},this),this},transition:function(t,i){return n(t,function(t,e){this[e]=(t-this._saved[e])*i+this._saved[e]},this),this},tooltipPosition:function(){return{x:this.x,y:this.y}},hasValue:function(){return f(this.value)}}),e.Element.extend=r,e.Point=e.Element.extend({display:!0,inRange:function(t,i){var e=this.hitDetectionRadius+this.radius;return Math.pow(t-this.x,2)+Math.pow(i-this.y,2)<Math.pow(e,2)},draw:function(){if(this.display){var t=this.ctx;t.beginPath(),t.arc(this.x,this.y,this.radius,0,2*Math.PI),t.closePath(),t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.fillStyle=this.fillColor,t.fill(),t.stroke()}}}),e.Arc=e.Element.extend({inRange:function(t,i){var e=s.getAngleFromPoint(this,{x:t,y:i}),n=e.angle>=this.startAngle&&e.angle<=this.endAngle,o=e.distance>=this.innerRadius&&e.distance<=this.outerRadius;return n&&o},tooltipPosition:function(){var t=this.startAngle+(this.endAngle-this.startAngle)/2,i=(this.outerRadius-this.innerRadius)/2+this.innerRadius;return{x:this.x+Math.cos(t)*i,y:this.y+Math.sin(t)*i}},draw:function(t){var i=this.ctx;i.beginPath(),i.arc(this.x,this.y,this.outerRadius,this.startAngle,this.endAngle),i.arc(this.x,this.y,this.innerRadius,this.endAngle,this.startAngle,!0),i.closePath(),i.strokeStyle=this.strokeColor,i.lineWidth=this.strokeWidth,i.fillStyle=this.fillColor,i.fill(),i.lineJoin="bevel",this.showStroke&&i.stroke()}}),e.Rectangle=e.Element.extend({draw:function(){var t=this.ctx,i=this.width/2,e=this.x-i,s=this.x+i,n=this.base-(this.base-this.y),o=this.strokeWidth/2;this.showStroke&&(e+=o,s-=o,n+=o),t.beginPath(),t.fillStyle=this.fillColor,t.strokeStyle=this.strokeColor,t.lineWidth=this.strokeWidth,t.moveTo(e,this.base),t.lineTo(e,n),t.lineTo(s,n),t.lineTo(s,this.base),t.fill(),this.showStroke&&t.stroke()},height:function(){return this.base-this.y},inRange:function(t,i){return t>=this.x-this.width/2&&t<=this.x+this.width/2&&i>=this.y&&i<=this.base}}),e.Tooltip=e.Element.extend({draw:function(){var t=this.chart.ctx;t.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.xAlign="center",this.yAlign="above";var i=this.caretPadding=2,e=t.measureText(this.text).width+2*this.xPadding,s=this.fontSize+2*this.yPadding,n=s+this.caretHeight+i;this.x+e/2>this.chart.width?this.xAlign="left":this.x-e/2<0&&(this.xAlign="right"),this.y-n<0&&(this.yAlign="below");var o=this.x-e/2,a=this.y-n;if(t.fillStyle=this.fillColor,this.custom)this.custom(this);else{switch(this.yAlign){case"above":t.beginPath(),t.moveTo(this.x,this.y-i),t.lineTo(this.x+this.caretHeight,this.y-(i+this.caretHeight)),t.lineTo(this.x-this.caretHeight,this.y-(i+this.caretHeight)),t.closePath(),t.fill();break;case"below":a=this.y+i+this.caretHeight,t.beginPath(),t.moveTo(this.x,this.y+i),t.lineTo(this.x+this.caretHeight,this.y+i+this.caretHeight),t.lineTo(this.x-this.caretHeight,this.y+i+this.caretHeight),t.closePath(),t.fill()}switch(this.xAlign){case"left":o=this.x-e+(this.cornerRadius+this.caretHeight);break;case"right":o=this.x-(this.cornerRadius+this.caretHeight)}B(t,o,a,e,s,this.cornerRadius),t.fill(),t.fillStyle=this.textColor,t.textAlign="center",t.textBaseline="middle",t.fillText(this.text,o+e/2,a+s/2)}}}),e.MultiTooltip=e.Element.extend({initialize:function(){this.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.titleFont=W(this.titleFontSize,this.titleFontStyle,this.titleFontFamily),this.height=this.labels.length*this.fontSize+(this.labels.length-1)*(this.fontSize/2)+2*this.yPadding+1.5*this.titleFontSize,this.ctx.font=this.titleFont;var t=this.ctx.measureText(this.title).width,i=z(this.ctx,this.font,this.labels)+this.fontSize+3,e=g([i,t]);this.width=e+2*this.xPadding;var s=this.height/2;this.y-s<0?this.y=s:this.y+s>this.chart.height&&(this.y=this.chart.height-s),this.x>this.chart.width/2?this.x-=this.xOffset+this.width:this.x+=this.xOffset},getLineHeight:function(t){var i=this.y-this.height/2+this.yPadding,e=t-1;return 0===t?i+this.titleFontSize/2:i+(1.5*this.fontSize*e+this.fontSize/2)+1.5*this.titleFontSize},draw:function(){if(this.custom)this.custom(this);else{B(this.ctx,this.x,this.y-this.height/2,this.width,this.height,this.cornerRadius);var t=this.ctx;t.fillStyle=this.fillColor,t.fill(),t.closePath(),t.textAlign="left",t.textBaseline="middle",t.fillStyle=this.titleTextColor,t.font=this.titleFont,t.fillText(this.title,this.x+this.xPadding,this.getLineHeight(0)),t.font=this.font,s.each(this.labels,function(i,e){t.fillStyle=this.textColor,t.fillText(i,this.x+this.xPadding+this.fontSize+3,this.getLineHeight(e+1)),t.fillStyle=this.legendColorBackground,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize),t.fillStyle=this.legendColors[e].fill,t.fillRect(this.x+this.xPadding,this.getLineHeight(e+1)-this.fontSize/2,this.fontSize,this.fontSize)},this)}}}),e.Scale=e.Element.extend({initialize:function(){this.fit()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}));this.yLabelWidth=this.display&&this.showLabels?z(this.ctx,this.font,this.yLabels):0},addXLabel:function(t){this.xLabels.push(t),this.valuesCount++,this.fit()},removeXLabel:function(){this.xLabels.shift(),this.valuesCount--,this.fit()},fit:function(){this.startPoint=this.display?this.fontSize:0,this.endPoint=this.display?this.height-1.5*this.fontSize-5:this.height,this.startPoint+=this.padding,this.endPoint-=this.padding;var t,i=this.endPoint-this.startPoint;for(this.calculateYRange(i),this.buildYLabels(),this.calculateXLabelRotation();i>this.endPoint-this.startPoint;)i=this.endPoint-this.startPoint,t=this.yLabelWidth,this.calculateYRange(i),this.buildYLabels(),t<this.yLabelWidth&&this.calculateXLabelRotation()},calculateXLabelRotation:function(){this.ctx.font=this.font;var t,i,e=this.ctx.measureText(this.xLabels[0]).width,s=this.ctx.measureText(this.xLabels[this.xLabels.length-1]).width;if(this.xScalePaddingRight=s/2+3,this.xScalePaddingLeft=e/2>this.yLabelWidth+10?e/2:this.yLabelWidth+10,this.xLabelRotation=0,this.display){var n,o=z(this.ctx,this.font,this.xLabels);this.xLabelWidth=o;for(var a=Math.floor(this.calculateX(1)-this.calculateX(0))-6;this.xLabelWidth>a&&0===this.xLabelRotation||this.xLabelWidth>a&&this.xLabelRotation<=90&&this.xLabelRotation>0;)n=Math.cos(S(this.xLabelRotation)),t=n*e,i=n*s,t+this.fontSize/2>this.yLabelWidth+8&&(this.xScalePaddingLeft=t+this.fontSize/2),this.xScalePaddingRight=this.fontSize/2,this.xLabelRotation++,this.xLabelWidth=n*o;this.xLabelRotation>0&&(this.endPoint-=Math.sin(S(this.xLabelRotation))*o+3)}else this.xLabelWidth=0,this.xScalePaddingRight=this.padding,this.xScalePaddingLeft=this.padding},calculateYRange:c,drawingArea:function(){return this.startPoint-this.endPoint},calculateY:function(t){var i=this.drawingArea()/(this.min-this.max);return this.endPoint-i*(t-this.min)},calculateX:function(t){var i=(this.xLabelRotation>0,this.width-(this.xScalePaddingLeft+this.xScalePaddingRight)),e=i/Math.max(this.valuesCount-(this.offsetGridLines?0:1),1),s=e*t+this.xScalePaddingLeft;return this.offsetGridLines&&(s+=e/2),Math.round(s)},update:function(t){s.extend(this,t),this.fit()},draw:function(){var t=this.ctx,i=(this.endPoint-this.startPoint)/this.steps,e=Math.round(this.xScalePaddingLeft);this.display&&(t.fillStyle=this.textColor,t.font=this.font,n(this.yLabels,function(n,o){var a=this.endPoint-i*o,h=Math.round(a),l=this.showHorizontalLines;t.textAlign="right",t.textBaseline="middle",this.showLabels&&t.fillText(n,e-10,a),0!==o||l||(l=!0),l&&t.beginPath(),o>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),h+=s.aliasPixel(t.lineWidth),l&&(t.moveTo(e,h),t.lineTo(this.width,h),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(e-5,h),t.lineTo(e,h),t.stroke(),t.closePath()},this),n(this.xLabels,function(i,e){var s=this.calculateX(e)+x(this.lineWidth),n=this.calculateX(e-(this.offsetGridLines?.5:0))+x(this.lineWidth),o=this.xLabelRotation>0,a=this.showVerticalLines;0!==e||a||(a=!0),a&&t.beginPath(),e>0?(t.lineWidth=this.gridLineWidth,t.strokeStyle=this.gridLineColor):(t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor),a&&(t.moveTo(n,this.endPoint),t.lineTo(n,this.startPoint-3),t.stroke(),t.closePath()),t.lineWidth=this.lineWidth,t.strokeStyle=this.lineColor,t.beginPath(),t.moveTo(n,this.endPoint),t.lineTo(n,this.endPoint+5),t.stroke(),t.closePath(),t.save(),t.translate(s,o?this.endPoint+12:this.endPoint+8),t.rotate(-1*S(this.xLabelRotation)),t.font=this.font,t.textAlign=o?"right":"center",t.textBaseline=o?"middle":"top",t.fillText(i,0,0),t.restore()},this))}}),e.RadialScale=e.Element.extend({initialize:function(){this.size=m([this.height,this.width]),this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2},calculateCenterOffset:function(t){var i=this.drawingArea/(this.max-this.min);return(t-this.min)*i},update:function(){this.lineArc?this.drawingArea=this.display?this.size/2-(this.fontSize/2+this.backdropPaddingY):this.size/2:this.setScaleSize(),this.buildYLabels()},buildYLabels:function(){this.yLabels=[];for(var t=v(this.stepValue),i=0;i<=this.steps;i++)this.yLabels.push(C(this.templateString,{value:(this.min+i*this.stepValue).toFixed(t)}))},getCircumference:function(){return 2*Math.PI/this.valuesCount},setScaleSize:function(){var t,i,e,s,n,o,a,h,l,r,c,u,d=m([this.height/2-this.pointLabelFontSize-5,this.width/2]),p=this.width,g=0;for(this.ctx.font=W(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),i=0;i<this.valuesCount;i++)t=this.getPointPosition(i,d),e=this.ctx.measureText(C(this.templateString,{value:this.labels[i]})).width+5,0===i||i===this.valuesCount/2?(s=e/2,t.x+s>p&&(p=t.x+s,n=i),t.x-s<g&&(g=t.x-s,a=i)):i<this.valuesCount/2?t.x+e>p&&(p=t.x+e,n=i):i>this.valuesCount/2&&t.x-e<g&&(g=t.x-e,a=i);l=g,r=Math.ceil(p-this.width),o=this.getIndexAngle(n),h=this.getIndexAngle(a),c=r/Math.sin(o+Math.PI/2),u=l/Math.sin(h+Math.PI/2),c=f(c)?c:0,u=f(u)?u:0,this.drawingArea=d-(u+c)/2,this.setCenterPoint(u,c)},setCenterPoint:function(t,i){var e=this.width-i-this.drawingArea,s=t+this.drawingArea;this.xCenter=(s+e)/2,this.yCenter=this.height/2},getIndexAngle:function(t){var i=2*Math.PI/this.valuesCount;return t*i-Math.PI/2},getPointPosition:function(t,i){var e=this.getIndexAngle(t);return{x:Math.cos(e)*i+this.xCenter,y:Math.sin(e)*i+this.yCenter}},draw:function(){if(this.display){var t=this.ctx;if(n(this.yLabels,function(i,e){if(e>0){var s,n=e*(this.drawingArea/this.steps),o=this.yCenter-n;if(this.lineWidth>0)if(t.strokeStyle=this.lineColor,t.lineWidth=this.lineWidth,this.lineArc)t.beginPath(),t.arc(this.xCenter,this.yCenter,n,0,2*Math.PI),t.closePath(),t.stroke();else{t.beginPath();for(var a=0;a<this.valuesCount;a++)s=this.getPointPosition(a,this.calculateCenterOffset(this.min+e*this.stepValue)),0===a?t.moveTo(s.x,s.y):t.lineTo(s.x,s.y);t.closePath(),t.stroke()}if(this.showLabels){if(t.font=W(this.fontSize,this.fontStyle,this.fontFamily),this.showLabelBackdrop){var h=t.measureText(i).width;t.fillStyle=this.backdropColor,t.fillRect(this.xCenter-h/2-this.backdropPaddingX,o-this.fontSize/2-this.backdropPaddingY,h+2*this.backdropPaddingX,this.fontSize+2*this.backdropPaddingY)}t.textAlign="center",t.textBaseline="middle",t.fillStyle=this.fontColor,t.fillText(i,this.xCenter,o)}}},this),!this.lineArc){t.lineWidth=this.angleLineWidth,t.strokeStyle=this.angleLineColor;for(var i=this.valuesCount-1;i>=0;i--){if(this.angleLineWidth>0){var e=this.getPointPosition(i,this.calculateCenterOffset(this.max));t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(e.x,e.y),t.stroke(),t.closePath()}var s=this.getPointPosition(i,this.calculateCenterOffset(this.max)+5);t.font=W(this.pointLabelFontSize,this.pointLabelFontStyle,this.pointLabelFontFamily),t.fillStyle=this.pointLabelFontColor;var o=this.labels.length,a=this.labels.length/2,h=a/2,l=h>i||i>o-h,r=i===h||i===o-h;t.textAlign=0===i?"center":i===a?"center":a>i?"left":"right",t.textBaseline=r?"middle":l?"bottom":"top",t.fillText(this.labels[i],s.x,s.y)}}}}}),s.addEvent(window,"resize",function(){var t;return function(){clearTimeout(t),t=setTimeout(function(){n(e.instances,function(t){t.options.responsive&&t.resize(t.render,!0)})},50)}}()),p?define(function(){return e}):"object"==typeof module&&module.exports&&(module.exports=e),t.Chart=e,e.noConflict=function(){return t.Chart=i,e}}).call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleBeginAtZero:!0,scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,barShowStroke:!0,barStrokeWidth:2,barValueSpacing:5,barDatasetSpacing:1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].fillColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Bar",defaults:s,initialize:function(t){var s=this.options;this.ScaleClass=i.Scale.extend({offsetGridLines:!0,calculateBarX:function(t,i,e){var n=this.calculateBaseWidth(),o=this.calculateX(e)-n/2,a=this.calculateBarWidth(t);return o+a*i+i*s.barDatasetSpacing+a/2},calculateBaseWidth:function(){return this.calculateX(1)-this.calculateX(0)-2*s.barValueSpacing},calculateBarWidth:function(t){var i=this.calculateBaseWidth()-(t-1)*s.barDatasetSpacing;return i/t}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getBarsAtEvent(t):[];this.eachBars(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),this.BarClass=i.Rectangle.extend({strokeWidth:this.options.barStrokeWidth,showStroke:this.options.barShowStroke,ctx:this.chart.ctx}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,bars:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.bars.push(new this.BarClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.strokeColor,fillColor:i.fillColor,highlightFill:i.highlightFill||i.fillColor,highlightStroke:i.highlightStroke||i.strokeColor}))},this)},this),this.buildScale(t.labels),this.BarClass.prototype.base=this.scale.endPoint,this.eachBars(function(t,i,s){e.extend(t,{width:this.scale.calculateBarWidth(this.datasets.length),x:this.scale.calculateBarX(this.datasets.length,s,i),y:this.scale.endPoint}),t.save()},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachBars(function(t){t.save()}),this.render()},eachBars:function(t){e.each(this.datasets,function(i,s){e.each(i.bars,t,this,s)},this)},getBarsAtEvent:function(t){for(var i,s=[],n=e.getRelativePosition(t),o=function(t){s.push(t.bars[i])},a=0;a<this.datasets.length;a++)for(i=0;i<this.datasets[a].bars.length;i++)if(this.datasets[a].bars[i].inRange(n.x,n.y))return e.each(this.datasets,o),s;return s},buildScale:function(t){var i=this,s=function(){var t=[];return i.eachBars(function(i){t.push(i.value)}),t},n={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(s(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.barShowStroke?this.options.barStrokeWidth:0,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(n,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new this.ScaleClass(n)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].bars.push(new this.BarClass({value:t,label:i,x:this.scale.calculateBarX(this.datasets.length,e,this.scale.valuesCount+1),y:this.scale.endPoint,width:this.scale.calculateBarWidth(this.datasets.length),base:this.scale.endPoint,strokeColor:this.datasets[e].strokeColor,fillColor:this.datasets[e].fillColor}))
},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.bars.shift()},this),this.update()},reflow:function(){e.extend(this.BarClass.prototype,{y:this.scale.endPoint,base:this.scale.endPoint});var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();this.chart.ctx;this.scale.draw(i),e.each(this.datasets,function(t,s){e.each(t.bars,function(t,e){t.hasValue()&&(t.base=this.scale.endPoint,t.transition({x:this.scale.calculateBarX(this.datasets.length,s,e),y:this.scale.calculateY(t.value),width:this.scale.calculateBarWidth(this.datasets.length)},i).draw())},this)},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,percentageInnerCutout:50,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Doughnut",defaults:s,initialize:function(t){this.segments=[],this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,this.SegmentArc=i.Arc.extend({ctx:this.chart.ctx,x:this.chart.width/2,y:this.chart.height/2}),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.calculateTotal(t),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({value:t.value,outerRadius:this.options.animateScale?0:this.outerRadius,innerRadius:this.options.animateScale?0:this.outerRadius/100*this.options.percentageInnerCutout,fillColor:t.color,highlightColor:t.highlight||t.color,showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,startAngle:1.5*Math.PI,circumference:this.options.animateRotate?0:this.calculateCircumference(t.value),label:t.label})),e||(this.reflow(),this.update())},calculateCircumference:function(t){return 2*Math.PI*(Math.abs(t)/this.total)},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=Math.abs(t.value)},this)},update:function(){this.calculateTotal(this.segments),e.each(this.activeElements,function(t){t.restore(["fillColor"])}),e.each(this.segments,function(t){t.save()}),this.render()},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.outerRadius=(e.min([this.chart.width,this.chart.height])-this.options.segmentStrokeWidth/2)/2,e.each(this.segments,function(t){t.update({outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout})},this)},draw:function(t){var i=t?t:1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.calculateCircumference(t.value),outerRadius:this.outerRadius,innerRadius:this.outerRadius/100*this.options.percentageInnerCutout},i),t.endAngle=t.startAngle+t.circumference,t.draw(),0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle)},this)}}),i.types.Doughnut.extend({name:"Pie",defaults:e.merge(s,{percentageInnerCutout:0})})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowGridLines:!0,scaleGridLineColor:"rgba(0,0,0,.05)",scaleGridLineWidth:1,scaleShowHorizontalLines:!0,scaleShowVerticalLines:!0,bezierCurve:!0,bezierCurveTension:.4,pointDot:!0,pointDotRadius:4,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"Line",defaults:s,initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx,inRange:function(t){return Math.pow(t-this.x,2)<Math.pow(this.radius+this.hitDetectionRadius,2)}}),this.datasets=[],this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this),this.buildScale(t.labels),this.eachPoints(function(t,i){e.extend(t,{x:this.scale.calculateX(i),y:this.scale.endPoint}),t.save()},this)},this),this.render()},update:function(){this.scale.update(),e.each(this.activeElements,function(t){t.restore(["fillColor","strokeColor"])}),this.eachPoints(function(t){t.save()}),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.datasets,function(t){e.each(t.points,function(t){t.inRange(s.x,s.y)&&i.push(t)})},this),i},buildScale:function(t){var s=this,n=function(){var t=[];return s.eachPoints(function(i){t.push(i.value)}),t},o={templateString:this.options.scaleLabel,height:this.chart.height,width:this.chart.width,ctx:this.chart.ctx,textColor:this.options.scaleFontColor,fontSize:this.options.scaleFontSize,fontStyle:this.options.scaleFontStyle,fontFamily:this.options.scaleFontFamily,valuesCount:t.length,beginAtZero:this.options.scaleBeginAtZero,integersOnly:this.options.scaleIntegersOnly,calculateYRange:function(t){var i=e.calculateScaleRange(n(),t,this.fontSize,this.beginAtZero,this.integersOnly);e.extend(this,i)},xLabels:t,font:e.fontString(this.options.scaleFontSize,this.options.scaleFontStyle,this.options.scaleFontFamily),lineWidth:this.options.scaleLineWidth,lineColor:this.options.scaleLineColor,showHorizontalLines:this.options.scaleShowHorizontalLines,showVerticalLines:this.options.scaleShowVerticalLines,gridLineWidth:this.options.scaleShowGridLines?this.options.scaleGridLineWidth:0,gridLineColor:this.options.scaleShowGridLines?this.options.scaleGridLineColor:"rgba(0,0,0,0)",padding:this.options.showScale?0:this.options.pointDotRadius+this.options.pointDotStrokeWidth,showLabels:this.options.scaleShowLabels,display:this.options.showScale};this.options.scaleOverride&&e.extend(o,{calculateYRange:e.noop,steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}),this.scale=new i.Scale(o)},addData:function(t,i){e.each(t,function(t,e){this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:this.scale.calculateX(this.scale.valuesCount+1),y:this.scale.endPoint,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.addXLabel(i),this.update()},removeData:function(){this.scale.removeXLabel(),e.each(this.datasets,function(t){t.points.shift()},this),this.update()},reflow:function(){var t=e.extend({height:this.chart.height,width:this.chart.width});this.scale.update(t)},draw:function(t){var i=t||1;this.clear();var s=this.chart.ctx,n=function(t){return null!==t.value},o=function(t,i,s){return e.findNextWhere(i,n,s)||t},a=function(t,i,s){return e.findPreviousWhere(i,n,s)||t};this.scale.draw(i),e.each(this.datasets,function(t){var h=e.where(t.points,n);e.each(t.points,function(t,e){t.hasValue()&&t.transition({y:this.scale.calculateY(t.value),x:this.scale.calculateX(e)},i)},this),this.options.bezierCurve&&e.each(h,function(t,i){var s=i>0&&i<h.length-1?this.options.bezierCurveTension:0;t.controlPoints=e.splineCurve(a(t,h,i),t,o(t,h,i),s),t.controlPoints.outer.y>this.scale.endPoint?t.controlPoints.outer.y=this.scale.endPoint:t.controlPoints.outer.y<this.scale.startPoint&&(t.controlPoints.outer.y=this.scale.startPoint),t.controlPoints.inner.y>this.scale.endPoint?t.controlPoints.inner.y=this.scale.endPoint:t.controlPoints.inner.y<this.scale.startPoint&&(t.controlPoints.inner.y=this.scale.startPoint)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(h,function(t,i){if(0===i)s.moveTo(t.x,t.y);else if(this.options.bezierCurve){var e=a(t,h,i);s.bezierCurveTo(e.controlPoints.outer.x,e.controlPoints.outer.y,t.controlPoints.inner.x,t.controlPoints.inner.y,t.x,t.y)}else s.lineTo(t.x,t.y)},this),s.stroke(),this.options.datasetFill&&h.length>0&&(s.lineTo(h[h.length-1].x,this.scale.endPoint),s.lineTo(h[0].x,this.scale.endPoint),s.fillStyle=t.fillColor,s.closePath(),s.fill()),e.each(h,function(t){t.draw()})},this)}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers,s={scaleShowLabelBackdrop:!0,scaleBackdropColor:"rgba(255,255,255,0.75)",scaleBeginAtZero:!0,scaleBackdropPaddingY:2,scaleBackdropPaddingX:2,scaleShowLine:!0,segmentShowStroke:!0,segmentStrokeColor:"#fff",segmentStrokeWidth:2,animationSteps:100,animationEasing:"easeOutBounce",animateRotate:!0,animateScale:!1,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<segments.length; i++){%><li><span style="background-color:<%=segments[i].fillColor%>"></span><%if(segments[i].label){%><%=segments[i].label%><%}%></li><%}%></ul>'};i.Type.extend({name:"PolarArea",defaults:s,initialize:function(t){this.segments=[],this.SegmentArc=i.Arc.extend({showStroke:this.options.segmentShowStroke,strokeWidth:this.options.segmentStrokeWidth,strokeColor:this.options.segmentStrokeColor,ctx:this.chart.ctx,innerRadius:0,x:this.chart.width/2,y:this.chart.height/2}),this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,lineArc:!0,width:this.chart.width,height:this.chart.height,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,valuesCount:t.length}),this.updateScaleRange(t),this.scale.update(),e.each(t,function(t,i){this.addData(t,i,!0)},this),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getSegmentsAtEvent(t):[];e.each(this.segments,function(t){t.restore(["fillColor"])}),e.each(i,function(t){t.fillColor=t.highlightColor}),this.showTooltip(i)}),this.render()},getSegmentsAtEvent:function(t){var i=[],s=e.getRelativePosition(t);return e.each(this.segments,function(t){t.inRange(s.x,s.y)&&i.push(t)},this),i},addData:function(t,i,e){var s=i||this.segments.length;this.segments.splice(s,0,new this.SegmentArc({fillColor:t.color,highlightColor:t.highlight||t.color,label:t.label,value:t.value,outerRadius:this.options.animateScale?0:this.scale.calculateCenterOffset(t.value),circumference:this.options.animateRotate?0:this.scale.getCircumference(),startAngle:1.5*Math.PI})),e||(this.reflow(),this.update())},removeData:function(t){var i=e.isNumber(t)?t:this.segments.length-1;this.segments.splice(i,1),this.reflow(),this.update()},calculateTotal:function(t){this.total=0,e.each(t,function(t){this.total+=t.value},this),this.scale.valuesCount=this.segments.length},updateScaleRange:function(t){var i=[];e.each(t,function(t){i.push(t.value)});var s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s,{size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2})},update:function(){this.calculateTotal(this.segments),e.each(this.segments,function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.SegmentArc.prototype,{x:this.chart.width/2,y:this.chart.height/2}),this.updateScaleRange(this.segments),this.scale.update(),e.extend(this.scale,{xCenter:this.chart.width/2,yCenter:this.chart.height/2}),e.each(this.segments,function(t){t.update({outerRadius:this.scale.calculateCenterOffset(t.value)})},this)},draw:function(t){var i=t||1;this.clear(),e.each(this.segments,function(t,e){t.transition({circumference:this.scale.getCircumference(),outerRadius:this.scale.calculateCenterOffset(t.value)},i),t.endAngle=t.startAngle+t.circumference,0===e&&(t.startAngle=1.5*Math.PI),e<this.segments.length-1&&(this.segments[e+1].startAngle=t.endAngle),t.draw()},this),this.scale.draw()}})}.call(this),function(){"use strict";var t=this,i=t.Chart,e=i.helpers;i.Type.extend({name:"Radar",defaults:{scaleShowLine:!0,angleShowLineOut:!0,scaleShowLabels:!1,scaleBeginAtZero:!0,angleLineColor:"rgba(0,0,0,.1)",angleLineWidth:1,pointLabelFontFamily:"'Arial'",pointLabelFontStyle:"normal",pointLabelFontSize:10,pointLabelFontColor:"#666",pointDot:!0,pointDotRadius:3,pointDotStrokeWidth:1,pointHitDetectionRadius:20,datasetStroke:!0,datasetStrokeWidth:2,datasetFill:!0,legendTemplate:'<ul class="<%=name.toLowerCase()%>-legend"><% for (var i=0; i<datasets.length; i++){%><li><span style="background-color:<%=datasets[i].strokeColor%>"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>'},initialize:function(t){this.PointClass=i.Point.extend({strokeWidth:this.options.pointDotStrokeWidth,radius:this.options.pointDotRadius,display:this.options.pointDot,hitDetectionRadius:this.options.pointHitDetectionRadius,ctx:this.chart.ctx}),this.datasets=[],this.buildScale(t),this.options.showTooltips&&e.bindEvents(this,this.options.tooltipEvents,function(t){var i="mouseout"!==t.type?this.getPointsAtEvent(t):[];this.eachPoints(function(t){t.restore(["fillColor","strokeColor"])}),e.each(i,function(t){t.fillColor=t.highlightFill,t.strokeColor=t.highlightStroke}),this.showTooltip(i)}),e.each(t.datasets,function(i){var s={label:i.label||null,fillColor:i.fillColor,strokeColor:i.strokeColor,pointColor:i.pointColor,pointStrokeColor:i.pointStrokeColor,points:[]};this.datasets.push(s),e.each(i.data,function(e,n){var o;this.scale.animation||(o=this.scale.getPointPosition(n,this.scale.calculateCenterOffset(e))),s.points.push(new this.PointClass({value:e,label:t.labels[n],datasetLabel:i.label,x:this.options.animation?this.scale.xCenter:o.x,y:this.options.animation?this.scale.yCenter:o.y,strokeColor:i.pointStrokeColor,fillColor:i.pointColor,highlightFill:i.pointHighlightFill||i.pointColor,highlightStroke:i.pointHighlightStroke||i.pointStrokeColor}))},this)},this),this.render()},eachPoints:function(t){e.each(this.datasets,function(i){e.each(i.points,t,this)},this)},getPointsAtEvent:function(t){var i=e.getRelativePosition(t),s=e.getAngleFromPoint({x:this.scale.xCenter,y:this.scale.yCenter},i),n=2*Math.PI/this.scale.valuesCount,o=Math.round((s.angle-1.5*Math.PI)/n),a=[];return(o>=this.scale.valuesCount||0>o)&&(o=0),s.distance<=this.scale.drawingArea&&e.each(this.datasets,function(t){a.push(t.points[o])}),a},buildScale:function(t){this.scale=new i.RadialScale({display:this.options.showScale,fontStyle:this.options.scaleFontStyle,fontSize:this.options.scaleFontSize,fontFamily:this.options.scaleFontFamily,fontColor:this.options.scaleFontColor,showLabels:this.options.scaleShowLabels,showLabelBackdrop:this.options.scaleShowLabelBackdrop,backdropColor:this.options.scaleBackdropColor,backdropPaddingY:this.options.scaleBackdropPaddingY,backdropPaddingX:this.options.scaleBackdropPaddingX,lineWidth:this.options.scaleShowLine?this.options.scaleLineWidth:0,lineColor:this.options.scaleLineColor,angleLineColor:this.options.angleLineColor,angleLineWidth:this.options.angleShowLineOut?this.options.angleLineWidth:0,pointLabelFontColor:this.options.pointLabelFontColor,pointLabelFontSize:this.options.pointLabelFontSize,pointLabelFontFamily:this.options.pointLabelFontFamily,pointLabelFontStyle:this.options.pointLabelFontStyle,height:this.chart.height,width:this.chart.width,xCenter:this.chart.width/2,yCenter:this.chart.height/2,ctx:this.chart.ctx,templateString:this.options.scaleLabel,labels:t.labels,valuesCount:t.datasets[0].data.length}),this.scale.setScaleSize(),this.updateScaleRange(t.datasets),this.scale.buildYLabels()},updateScaleRange:function(t){var i=function(){var i=[];return e.each(t,function(t){t.data?i=i.concat(t.data):e.each(t.points,function(t){i.push(t.value)})}),i}(),s=this.options.scaleOverride?{steps:this.options.scaleSteps,stepValue:this.options.scaleStepWidth,min:this.options.scaleStartValue,max:this.options.scaleStartValue+this.options.scaleSteps*this.options.scaleStepWidth}:e.calculateScaleRange(i,e.min([this.chart.width,this.chart.height])/2,this.options.scaleFontSize,this.options.scaleBeginAtZero,this.options.scaleIntegersOnly);e.extend(this.scale,s)},addData:function(t,i){this.scale.valuesCount++,e.each(t,function(t,e){var s=this.scale.getPointPosition(this.scale.valuesCount,this.scale.calculateCenterOffset(t));this.datasets[e].points.push(new this.PointClass({value:t,label:i,x:s.x,y:s.y,strokeColor:this.datasets[e].pointStrokeColor,fillColor:this.datasets[e].pointColor}))},this),this.scale.labels.push(i),this.reflow(),this.update()},removeData:function(){this.scale.valuesCount--,this.scale.labels.shift(),e.each(this.datasets,function(t){t.points.shift()},this),this.reflow(),this.update()},update:function(){this.eachPoints(function(t){t.save()}),this.reflow(),this.render()},reflow:function(){e.extend(this.scale,{width:this.chart.width,height:this.chart.height,size:e.min([this.chart.width,this.chart.height]),xCenter:this.chart.width/2,yCenter:this.chart.height/2}),this.updateScaleRange(this.datasets),this.scale.setScaleSize(),this.scale.buildYLabels()},draw:function(t){var i=t||1,s=this.chart.ctx;this.clear(),this.scale.draw(),e.each(this.datasets,function(t){e.each(t.points,function(t,e){t.hasValue()&&t.transition(this.scale.getPointPosition(e,this.scale.calculateCenterOffset(t.value)),i)},this),s.lineWidth=this.options.datasetStrokeWidth,s.strokeStyle=t.strokeColor,s.beginPath(),e.each(t.points,function(t,i){0===i?s.moveTo(t.x,t.y):s.lineTo(t.x,t.y)},this),s.closePath(),s.stroke(),s.fillStyle=t.fillColor,s.fill(),e.each(t.points,function(t){t.hasValue()&&t.draw()})},this)}})}.call(this);

!function(t){function i(t,i){this.element=i,this.data=jQuery.extend(!0,e,t),this.init()}var e={size:60,borderSize:10,colorCircle:"gray",background:"white",fontFamily:"sans-serif",fontColor:"#333333",fontSize:16,delayToFadeIn:0,delayToFadeOut:0,reverseLoading:!1,reverseRotation:!1,duration:{hours:0,minutes:0,seconds:10},beforeStart:function(){},end:function(){}};t.fn.circularCountDown=function(e){new i(e,t(this))},i.prototype={init:function(){this.formatData(),this.draw(),this.start()},start:function(){"function"==typeof this.data.beforeStart&&this.data.beforeStart(this),this.show(),this.starDecrementTimeEvent();var t=this.getFormattedTimeByCircle();this.animate(t)},animate:function(t){var i=this;i.data.reverseLoading?i.rotate(i.circlelRight,180,360,t,function(){i.wrapperCircles.css("clip","rect(0px, "+i.data.size/2+"px, "+i.data.size+"px, 0px)"),i.rotate(i.circlelLeft,0,180,t),i.rotate(i.circlelRight,0,180,t)}):(i.wrapperCircles.css("clip","rect(0px, "+i.data.size+"px, "+i.data.size+"px, "+i.data.size/2+"px)"),i.rotate(i.circlelRight,0,180,t,function(){i.wrapperCircles.css("clip","rect(auto, auto, auto, auto)"),i.rotate(i.circlelLeft,180,360,t)}))},formatData:function(){this.time=this.data.duration.seconds+60*this.data.duration.minutes+3600*this.data.duration.hours,this.data.size=parseInt(this.data.size),this.data.borderSize=parseInt(this.data.borderSize),this.data.borderSize%2!=0&&this.data.borderSize++,this.data.size%2!=0&&this.data.size++},draw:function(){this.hide(),this.circlelLeft=this.drawCircle().addClass("coutndown-circle-left"),this.circlelRight=this.drawCircle().addClass("coutndown-circle-right"),this.wrapperCircles=t("<div>").addClass("coutndown-wrapper").css({width:this.data.size+"px",height:this.data.size+"px",position:"absolute"}).append(this.circlelLeft).append(this.circlelRight),this.wrapperTime=this.drawTime(),this.element.css({position:"relative","box-sizing":"content-box"}).append(this.wrapperCircles).append(this.wrapperTime),this.setTime(this.getStringTime(this.time))},drawCircle:function(){var i=this.data.size-2*this.data.borderSize;return i+="px",t("<div>").addClass("coutndown-circle").css({width:i,height:i,border:this.data.borderSize+"px solid "+this.data.colorCircle,"-moz-border-radius":this.data.size+"px","-webkit-border-radius":this.data.size+"px","-o-border-radius":this.data.size+"px","-ms-border-radius":this.data.size+"px","border-radius":this.data.size+"px","box-sizing":"content-box","background-color":this.data.background,position:"absolute",clip:"rect(0px, "+this.data.size/2+"px, "+this.data.size+"px, 0px)"})},rotate:function(i,e,a,s,r){t({deg:e}).animate({deg:a},{duration:s,easing:"linear",step:function(t){i.css({"-moz-transform":"rotate("+t+"deg)","-webkit-transform":"rotate("+t+"deg)","-o-transform":"rotate("+t+"deg)","-ms-transform":"rotate("+t+"deg)",transform:"rotate("+t+"deg)"})},complete:r||t.noop})},hide:function(){this.element.fadeOut(this.data.delayToFadeOut),this.visible=!1},show:function(){this.element.fadeIn(this.data.delayToFadeIn),this.visible=!0},isVisible:function(){return this.visible},getStringTime:function(t){var i=this.secondsToTime(t);return i.h>0?this.addDigit(i.h)+":"+this.addDigit(i.m)+":"+this.addDigit(i.s):i.m>0?this.addDigit(i.m)+":"+this.addDigit(i.s):this.addDigit(i.s)},addDigit:function(t){return("0"+t).slice(-2)},secondsToTime:function(t){var i=Math.floor(t/3600),e=t%3600,a=Math.floor(e/60),s=e%60,r=Math.ceil(s);return{h:i,m:a,s:r}},getFormattedTimeByCircle:function(){var t=this.time/2*1e3;return t%2!=0&&t++,t},starDecrementTimeEvent:function(){var t=this;this.decrementTimeEvent=setInterval(function(){t.time-=1,t.setTime(t.getStringTime(t.time)),t.time<=0&&(t.time=0,t.stopDecrementTimeEvent(),"function"==typeof t.data.end&&t.data.end(t))},1e3)},stopDecrementTimeEvent:function(){clearInterval(this.decrementTimeEvent)},drawTime:function(){return t("<div>").addClass("coutndown-wrapper-time").css({position:"absolute",height:this.data.size+"px",width:this.data.size+"px","line-height":this.data.size+"px","text-align":"center","font-size":this.data.fontSize+"px","font-family":this.data.fontFamily,color:this.data.fontColor})},setTime:function(t){this.wrapperTime.html(t)},destroy:function(){this.hide(),this.element.html("").attr("style",null),this.circlelLeft=null,this.circlelRight=null,this.wrapperCircles=null,this.element=null,this.data=e}}}(jQuery);

/*
Copyright (c) 2008-2011, www.redips.net All rights reserved.
Code licensed under the BSD License: http://www.redips.net/license/
http://www.redips.net/javascript/drag-and-drop-table-content/
Version 5.1.0
Mar 06, 2015.
*/
var REDIPS=REDIPS||{};
REDIPS.drag=function(){var u,F,M,Ea,Qa,Ra,ga,ha,ma,Fa,Ga,Y,na,Ha,T,oa,ba,Ia,G,y,N,pa,qa,ra,Ja,sa,Ka,I,B,La,ia,ja,ta,Sa,Ta,Ma,ua,va,wa,ka,Na,Ua,xa,Va,r=null,J=0,K=0,ya=null,za=null,O=[],w=null,P=0,Q=0,R=0,S=0,U=0,V=0,ca,f=[],da,Aa,t,W=[],q=[],C=null,H=null,Z=0,aa=0,Wa=0,Xa=0,la=!1,Oa=!1,ea=!1,Ba=[],Ca,l=null,x=null,D=null,h=null,z=null,L=null,m=null,E=null,X=null,k=!1,p=!1,v="cell",Da={div:[],cname:"redips-only",other:"deny"},Ya={action:"deny",cname:"redips-mark",exception:[]},n={},Za={keyDiv:!1,keyRow:!1,
sendBack:!1,drop:!1};M=function(){return!1};u=function(a){var b,c,d,e,g;f.length=0;e=void 0===a?C.getElementsByTagName("table"):document.querySelectorAll(a);for(b=a=0;a<e.length;a++)if(!("redips_clone"===e[a].parentNode.id||-1<e[a].className.indexOf("redips-nolayout"))){c=e[a].parentNode;d=0;do"TD"===c.nodeName&&d++,c=c.parentNode;while(c&&c!==C);f[b]=e[a];f[b].redips||(f[b].redips={});f[b].redips.container=C;f[b].redips.nestedLevel=d;f[b].redips.idx=b;Ba[b]=0;d=f[b].getElementsByTagName("td");c=
0;for(g=!1;c<d.length;c++)if(1<d[c].rowSpan){g=!0;break}f[b].redips.rowspan=g;b++}a=0;for(e=da=1;a<f.length;a++)if(0===f[a].redips.nestedLevel){f[a].redips.nestedGroup=e;f[a].redips.sort=100*da;c=f[a].getElementsByTagName("table");for(b=0;b<c.length;b++)-1<c[b].className.indexOf("redips-nolayout")||(c[b].redips.nestedGroup=e,c[b].redips.sort=100*da+c[b].redips.nestedLevel);e++;da++}};Ea=function(a){var b=a||window.event,c,d;if(!0===this.redips.animated)return!0;b.cancelBubble=!0;b.stopPropagation&&
b.stopPropagation();Oa=b.shiftKey;a=b.which?b.which:b.button;if(Ka(b)||!b.touches&&1!==a)return!0;if(window.getSelection)window.getSelection().removeAllRanges();else if(document.selection&&"Text"===document.selection.type)try{document.selection.empty()}catch(e){}b.touches?(a=Z=b.touches[0].clientX,d=aa=b.touches[0].clientY):(a=Z=b.clientX,d=aa=b.clientY);Wa=a;Xa=d;la=!1;REDIPS.drag.objOld=p=k||this;REDIPS.drag.obj=k=this;ea=-1<k.className.indexOf("redips-clone");REDIPS.drag.tableSort&&Ra(k);C!==k.redips.container&&
(C=k.redips.container,u());-1===k.className.indexOf("row")?REDIPS.drag.mode=v="cell":(REDIPS.drag.mode=v="row",REDIPS.drag.obj=k=ka(k));y();ea||"cell"!==v||(k.style.zIndex=999);l=h=m=null;T();D=x=l;L=z=h;X=E=m;REDIPS.drag.td.source=n.source=B("TD",k);REDIPS.drag.td.current=n.current=n.source;REDIPS.drag.td.previous=n.previous=n.source;"cell"===v?REDIPS.drag.event.clicked(n.current):REDIPS.drag.event.rowClicked(n.current);if(null===l||null===h||null===m)if(T(),D=x=l,L=z=h,X=E=m,null===l||null===h||
null===m)return!0;Aa=t=!1;REDIPS.event.add(document,"mousemove",ha);REDIPS.event.add(document,"touchmove",ha);REDIPS.event.add(document,"mouseup",ga);REDIPS.event.add(document,"touchend",ga);k.setCapture&&k.setCapture();null!==l&&null!==h&&null!==m&&(ca=Ia(l,h,m));c=I(f[D],"position");"fixed"!==c&&(c=I(f[D].parentNode,"position"));c=G(k,c);r=[d-c[0],c[1]-a,c[2]-d,a-c[3]];C.onselectstart=function(a){b=a||window.event;if(!Ka(b))return b.shiftKey&&document.selection.clear(),!1};return!1};Qa=function(a){REDIPS.drag.event.dblClicked()};
Ra=function(a){var b;b=B("TABLE",a).redips.nestedGroup;for(a=0;a<f.length;a++)f[a].redips.nestedGroup===b&&(f[a].redips.sort=100*da+f[a].redips.nestedLevel);f.sort(function(a,b){return b.redips.sort-a.redips.sort});da++};ka=function(a,b){var c,d,e,g,f,A;if("DIV"===a.nodeName)return g=a,a=B("TR",a),void 0===a.redips&&(a.redips={}),a.redips.div=g,a;d=a;void 0===d.redips&&(d.redips={});a=B("TABLE",a);ea&&t&&(g=d.redips.div,g.className=xa(g.className.replace("redips-clone","")));c=a.cloneNode(!0);ea&&
t&&(g.className+=" redips-clone");e=c.rows.length-1;g="animated"===b?0===e:!0;for(f=e;0<=f;f--)if(f!==d.rowIndex){if(!0===g&&void 0===b)for(e=c.rows[f],A=0;A<e.cells.length;A++)if(-1<e.cells[A].className.indexOf("redips-rowhandler")){g=!1;break}c.deleteRow(f)}t||(d.redips.emptyRow=g);c.redips={};c.redips.container=a.redips.container;c.redips.sourceRow=d;Ua(d,c.rows[0]);Ja(d,c.rows[0]);document.getElementById("redips_clone").appendChild(c);d=G(d,"fixed");c.style.position="fixed";c.style.top=d[0]+"px";
c.style.left=d[3]+"px";c.style.width=d[1]-d[3]+"px";return c};Na=function(a,b,c){var d=!1,e,g,Pa,A,h,m,fa,q;q=function(a){var b;void 0!==a.redips&&a.redips.emptyRow?wa(a,"empty",REDIPS.drag.style.rowEmptyColor):(b=B("TABLE",a),b.deleteRow(a.rowIndex))};void 0===c?c=k:d=!0;e=c.redips.sourceRow;g=e.rowIndex;Pa=B("TABLE",e);A=e.parentNode;a=f[a];b>a.rows.length-1&&(b=a.rows.length-1);h=a.rows[b];m=b;fa=h.parentNode;b=c.getElementsByTagName("tr")[0];c.parentNode.removeChild(c);!1!==REDIPS.drag.event.rowDroppedBefore(Pa,
g)&&(!d&&-1<n.target.className.indexOf(REDIPS.drag.trash.className)?t?REDIPS.drag.event.rowDeleted():REDIPS.drag.trash.questionRow?confirm(REDIPS.drag.trash.questionRow)?(q(e),REDIPS.drag.event.rowDeleted()):(delete p.redips.emptyRow,REDIPS.drag.event.rowUndeleted()):(q(e),REDIPS.drag.event.rowDeleted()):(m<a.rows.length?l===D?g>m?fa.insertBefore(b,h):fa.insertBefore(b,h.nextSibling):"after"===REDIPS.drag.rowDropMode?fa.insertBefore(b,h.nextSibling):fa.insertBefore(b,h):(fa.appendChild(b),h=a.rows[0]),
h&&h.redips&&h.redips.emptyRow?a.deleteRow(h.rowIndex):"overwrite"===REDIPS.drag.rowDropMode?q(h):"switch"!==REDIPS.drag.rowDropMode||t||(A.insertBefore(h,e),void 0!==e.redips&&delete e.redips.emptyRow),!d&&t||q(e),delete b.redips.emptyRow,d||REDIPS.drag.event.rowDropped(b,Pa,g)),0<b.getElementsByTagName("table").length&&u())};Ua=function(a,b){var c,d,e,g=[],f=[];g[0]=a.getElementsByTagName("input");g[1]=a.getElementsByTagName("textarea");g[2]=a.getElementsByTagName("select");f[0]=b.getElementsByTagName("input");
f[1]=b.getElementsByTagName("textarea");f[2]=b.getElementsByTagName("select");for(c=0;c<g.length;c++)for(d=0;d<g[c].length;d++)switch(e=g[c][d].type,e){case "text":case "textarea":case "password":f[c][d].value=g[c][d].value;break;case "radio":case "checkbox":f[c][d].checked=g[c][d].checked;break;case "select-one":f[c][d].selectedIndex=g[c][d].selectedIndex;break;case "select-multiple":for(e=0;e<g[c][d].options.length;e++)f[c][d].options[e].selected=g[c][d].options[e].selected}};ga=function(a){var b=
a||window.event,c,d,e;a=b.clientX;e=b.clientY;U=V=0;k.releaseCapture&&k.releaseCapture();REDIPS.event.remove(document,"mousemove",ha);REDIPS.event.remove(document,"touchmove",ha);REDIPS.event.remove(document,"mouseup",ga);REDIPS.event.remove(document,"touchend",ga);C.onselectstart=null;Ga(k);ya=document.documentElement.scrollWidth;za=document.documentElement.scrollHeight;U=V=0;if(!t||"cell"!==v||null!==l&&null!==h&&null!==m)if(null===l||null===h||null===m)REDIPS.drag.event.notMoved();else{l<f.length?
(b=f[l],REDIPS.drag.td.target=n.target=b.rows[h].cells[m],ba(l,h,m,ca),c=l,d=h):null===x||null===z||null===E?(b=f[D],REDIPS.drag.td.target=n.target=b.rows[L].cells[X],ba(D,L,X,ca),c=D,d=L):(b=f[x],REDIPS.drag.td.target=n.target=b.rows[z].cells[E],ba(x,z,E,ca),c=x,d=z);if("row"===v)if(Aa)if(D===c&&L===d){b=k.getElementsByTagName("tr")[0];p.style.backgroundColor=b.style.backgroundColor;for(a=0;a<b.cells.length;a++)p.cells[a].style.backgroundColor=b.cells[a].style.backgroundColor;k.parentNode.removeChild(k);
delete p.redips.emptyRow;t?REDIPS.drag.event.rowNotCloned():REDIPS.drag.event.rowDroppedSource(n.target)}else Na(c,d);else REDIPS.drag.event.rowNotMoved();else if(t||la)if(t&&D===l&&L===h&&X===m)k.parentNode.removeChild(k),--W[p.id],REDIPS.drag.event.notCloned();else if(t&&!1===REDIPS.drag.clone.drop&&(a<b.redips.offset[3]||a>b.redips.offset[1]||e<b.redips.offset[0]||e>b.redips.offset[2]))k.parentNode.removeChild(k),--W[p.id],REDIPS.drag.event.notCloned();else if(-1<n.target.className.indexOf(REDIPS.drag.trash.className))k.parentNode.removeChild(k),
REDIPS.drag.trash.question?setTimeout(function(){confirm(REDIPS.drag.trash.question)?Fa():(t||(f[D].rows[L].cells[X].appendChild(k),y()),REDIPS.drag.event.undeleted())},20):Fa();else if("switch"===REDIPS.drag.dropMode)if(a=REDIPS.drag.event.droppedBefore(n.target),!1===a)ma(!1);else{k.parentNode.removeChild(k);b=n.target.getElementsByTagName("div");c=b.length;for(a=0;a<c;a++)void 0!==b[0]&&(REDIPS.drag.objOld=p=b[0],n.source.appendChild(p),Y(p));ma();c&&REDIPS.drag.event.switched()}else"overwrite"===
REDIPS.drag.dropMode?(a=REDIPS.drag.event.droppedBefore(n.target),!1!==a&&ja(n.target)):a=REDIPS.drag.event.droppedBefore(n.target),ma(a);else REDIPS.drag.event.notMoved();"cell"===v&&0<k.getElementsByTagName("table").length&&u();y();REDIPS.drag.event.finish()}else k.parentNode.removeChild(k),--W[p.id],REDIPS.drag.event.notCloned();x=z=E=null};ma=function(a){var b=null,c;if(!1!==a){if(!0===Za.sendBack){a=n.target.getElementsByTagName("DIV");for(c=0;c<a.length;c++)if(k!==a[c]&&0===k.id.indexOf(a[c].id)){b=
a[c];break}if(b){sa(b,1);k.parentNode.removeChild(k);return}}"shift"!==REDIPS.drag.dropMode||!Va(n.target)&&"always"!==REDIPS.drag.shift.after||ta(n.source,n.target);"top"===REDIPS.drag.multipleDrop&&n.target.hasChildNodes()?n.target.insertBefore(k,n.target.firstChild):n.target.appendChild(k);Y(k);REDIPS.drag.event.dropped(n.target);t&&(REDIPS.drag.event.clonedDropped(n.target),sa(p,-1))}else t&&k.parentNode&&k.parentNode.removeChild(k)};Y=function(a,b){!1===b?(a.onmousedown=null,a.ontouchstart=null,
a.ondblclick=null):(a.onmousedown=Ea,a.ontouchstart=Ea,a.ondblclick=Qa)};Ga=function(a){a.style.top="";a.style.left="";a.style.position="";a.style.zIndex=""};Fa=function(){var a;t&&sa(p,-1);if("shift"===REDIPS.drag.dropMode&&("delete"===REDIPS.drag.shift.after||"always"===REDIPS.drag.shift.after)){switch(REDIPS.drag.shift.mode){case "vertical2":a="lastInColumn";break;case "horizontal2":a="lastInRow";break;default:a="last"}ta(n.source,La(a,n.source)[2])}REDIPS.drag.event.deleted(t)};ha=function(a){a=
a||window.event;var b=REDIPS.drag.scroll.bound,c,d,e,g;a.touches?(d=Z=a.touches[0].clientX,e=aa=a.touches[0].clientY):(d=Z=a.clientX,e=aa=a.clientY);c=Math.abs(Wa-d);g=Math.abs(Xa-e);if(!Aa){if("cell"===v&&(ea||!0===REDIPS.drag.clone.keyDiv&&Oa))REDIPS.drag.objOld=p=k,REDIPS.drag.obj=k=ra(k,!0),t=!0,REDIPS.drag.event.cloned();else{if("row"===v){if(ea||!0===REDIPS.drag.clone.keyRow&&Oa)t=!0;REDIPS.drag.objOld=p=k;REDIPS.drag.obj=k=ka(k);k.style.zIndex=999}k.setCapture&&k.setCapture();k.style.position=
"fixed";y();T();"row"===v&&(t?REDIPS.drag.event.rowCloned():REDIPS.drag.event.rowMoved())}oa();d>J-r[1]&&(k.style.left=J-(r[1]+r[3])+"px");e>K-r[2]&&(k.style.top=K-(r[0]+r[2])+"px")}Aa=!0;"cell"===v&&(7<c||7<g)&&!la&&(la=!0,oa(),REDIPS.drag.event.moved(t));d>r[3]&&d<J-r[1]&&(k.style.left=d-r[3]+"px");e>r[0]&&e<K-r[2]&&(k.style.top=e-r[0]+"px");d<H[1]&&d>H[3]&&e<H[2]&&e>H[0]&&0===U&&0===V&&(q.containTable||d<q[3]||d>q[1]||e<q[0]||e>q[2])&&(T(),na());if(REDIPS.drag.scroll.enable)for(P=b-(J/2>d?d-r[3]:
J-d-r[1]),0<P?(P>b&&(P=b),c=N()[0],P*=d<J/2?-1:1,0>P&&0>=c||0<P&&c>=ya-J||0!==U++||(REDIPS.event.remove(window,"scroll",y),pa(window))):P=0,Q=b-(K/2>e?e-r[0]:K-e-r[2]),0<Q?(Q>b&&(Q=b),c=N()[1],Q*=e<K/2?-1:1,0>Q&&0>=c||0<Q&&c>=za-K||0!==V++||(REDIPS.event.remove(window,"scroll",y),qa(window))):Q=0,g=0;g<O.length;g++)if(c=O[g],c.autoscroll&&d<c.offset[1]&&d>c.offset[3]&&e<c.offset[2]&&e>c.offset[0]){R=b-(c.midstX>d?d-r[3]-c.offset[3]:c.offset[1]-d-r[1]);0<R?(R>b&&(R=b),R*=d<c.midstX?-1:1,0===U++&&(REDIPS.event.remove(c.div,
"scroll",y),pa(c.div))):R=0;S=b-(c.midstY>e?e-r[0]-c.offset[0]:c.offset[2]-e-r[2]);0<S?(S>b&&(S=b),S*=e<c.midstY?-1:1,0===V++&&(REDIPS.event.remove(c.div,"scroll",y),qa(c.div))):S=0;break}else R=S=0;a.cancelBubble=!0;a.stopPropagation&&a.stopPropagation()};na=function(){l<f.length&&(l!==x||h!==z||m!==E)&&(null!==x&&null!==z&&null!==E&&(ba(x,z,E,ca),REDIPS.drag.td.previous=n.previous=f[x].rows[z].cells[E],REDIPS.drag.td.current=n.current=f[l].rows[h].cells[m],"switching"===REDIPS.drag.dropMode&&"cell"===
v&&(ia(n.current,n.previous),y(),T()),"cell"===v?REDIPS.drag.event.changed(n.current):"row"!==v||l===x&&h===z||REDIPS.drag.event.rowChanged(n.current)),oa())};Ha=function(){"number"===typeof window.innerWidth?(J=window.innerWidth,K=window.innerHeight):document.documentElement&&(document.documentElement.clientWidth||document.documentElement.clientHeight)?(J=document.documentElement.clientWidth,K=document.documentElement.clientHeight):document.body&&(document.body.clientWidth||document.body.clientHeight)&&
(J=document.body.clientWidth,K=document.body.clientHeight);ya=document.documentElement.scrollWidth;za=document.documentElement.scrollHeight;y()};T=function(){var a,b,c,d,e,g;c=[];a=function(){null!==x&&null!==z&&null!==E&&(l=x,h=z,m=E)};b=Z;g=aa;for(l=0;l<f.length;l++)if(!1!==f[l].redips.enabled&&(c[0]=f[l].redips.offset[0],c[1]=f[l].redips.offset[1],c[2]=f[l].redips.offset[2],c[3]=f[l].redips.offset[3],void 0!==f[l].sca&&(c[0]=c[0]>f[l].sca.offset[0]?c[0]:f[l].sca.offset[0],c[1]=c[1]<f[l].sca.offset[1]?
c[1]:f[l].sca.offset[1],c[2]=c[2]<f[l].sca.offset[2]?c[2]:f[l].sca.offset[2],c[3]=c[3]>f[l].sca.offset[3]?c[3]:f[l].sca.offset[3]),c[3]<b&&b<c[1]&&c[0]<g&&g<c[2])){c=f[l].redips.row_offset;for(h=0;h<c.length-1;h++)if(void 0!==c[h]){q[0]=c[h][0];if(void 0!==c[h+1])q[2]=c[h+1][0];else for(d=h+2;d<c.length;d++)if(void 0!==c[d]){q[2]=c[d][0];break}if(g<=q[2])break}d=h;h===c.length-1&&(q[0]=c[h][0],q[2]=f[l].redips.offset[2]);do for(m=e=f[l].rows[h].cells.length-1;0<=m&&!(q[3]=c[h][3]+f[l].rows[h].cells[m].offsetLeft,
q[1]=q[3]+f[l].rows[h].cells[m].offsetWidth,q[3]<=b&&b<=q[1]);m--);while(f[l].redips.rowspan&&-1===m&&0<h--);0>h||0>m?a():h!==d&&(q[0]=c[h][0],q[2]=q[0]+f[l].rows[h].cells[m].offsetHeight,(g<q[0]||g>q[2])&&a());b=f[l].rows[h].cells[m];q.containTable=0<b.childNodes.length&&0<b.getElementsByTagName("table").length;if(-1===b.className.indexOf(REDIPS.drag.trash.className))if(g=-1<b.className.indexOf(REDIPS.drag.only.cname),!0===g){if(-1===b.className.indexOf(Da.div[k.id])){a();break}}else if(void 0!==
Da.div[k.id]&&"deny"===Da.other){a();break}else if(g=-1<b.className.indexOf(REDIPS.drag.mark.cname),(!0===g&&"deny"===REDIPS.drag.mark.action||!1===g&&"allow"===REDIPS.drag.mark.action)&&-1===b.className.indexOf(Ya.exception[k.id])){a();break}g=-1<b.className.indexOf("redips-single");if("cell"===v){if(("single"===REDIPS.drag.dropMode||g)&&0<b.childNodes.length){if(1===b.childNodes.length&&3===b.firstChild.nodeType)break;g=!0;for(d=b.childNodes.length-1;0<=d;d--)if(b.childNodes[d].className&&-1<b.childNodes[d].className.indexOf("redips-drag")){g=
!1;break}if(!g&&null!==x&&null!==z&&null!==E&&(D!==l||L!==h||X!==m)){a();break}}if(-1<b.className.indexOf("redips-rowhandler")){a();break}if(b.parentNode.redips&&b.parentNode.redips.emptyRow){a();break}}break}};oa=function(){l<f.length&&null!==l&&null!==h&&null!==m&&(ca=Ia(l,h,m),ba(l,h,m),x=l,z=h,E=m)};ba=function(a,b,c,d){if("cell"===v&&la)c=f[a].rows[b].cells[c].style,c.backgroundColor=void 0===d?REDIPS.drag.hover.colorTd:d.color[0].toString(),void 0!==REDIPS.drag.hover.borderTd&&(void 0===d?c.border=
REDIPS.drag.hover.borderTd:(c.borderTopWidth=d.top[0][0],c.borderTopStyle=d.top[0][1],c.borderTopColor=d.top[0][2],c.borderRightWidth=d.right[0][0],c.borderRightStyle=d.right[0][1],c.borderRightColor=d.right[0][2],c.borderBottomWidth=d.bottom[0][0],c.borderBottomStyle=d.bottom[0][1],c.borderBottomColor=d.bottom[0][2],c.borderLeftWidth=d.left[0][0],c.borderLeftStyle=d.left[0][1],c.borderLeftColor=d.left[0][2]));else if("row"===v)for(a=f[a].rows[b],b=0;b<a.cells.length;b++)c=a.cells[b].style,c.backgroundColor=
void 0===d?REDIPS.drag.hover.colorTr:d.color[b].toString(),void 0!==REDIPS.drag.hover.borderTr&&(void 0===d?l===D?h<L?c.borderTop=REDIPS.drag.hover.borderTr:c.borderBottom=REDIPS.drag.hover.borderTr:"before"===REDIPS.drag.rowDropMode?c.borderTop=REDIPS.drag.hover.borderTr:c.borderBottom=REDIPS.drag.hover.borderTr:(c.borderTopWidth=d.top[b][0],c.borderTopStyle=d.top[b][1],c.borderTopColor=d.top[b][2],c.borderBottomWidth=d.bottom[b][0],c.borderBottomStyle=d.bottom[b][1],c.borderBottomColor=d.bottom[b][2]))};
Ia=function(a,b,c){var d={color:[],top:[],right:[],bottom:[],left:[]},e=function(a,b){var c="border"+b+"Style",d="border"+b+"Color";return[I(a,"border"+b+"Width"),I(a,c),I(a,d)]};if("cell"===v)c=f[a].rows[b].cells[c],d.color[0]=c.style.backgroundColor,void 0!==REDIPS.drag.hover.borderTd&&(d.top[0]=e(c,"Top"),d.right[0]=e(c,"Right"),d.bottom[0]=e(c,"Bottom"),d.left[0]=e(c,"Left"));else for(a=f[a].rows[b],b=0;b<a.cells.length;b++)c=a.cells[b],d.color[b]=c.style.backgroundColor,void 0!==REDIPS.drag.hover.borderTr&&
(d.top[b]=e(c,"Top"),d.bottom[b]=e(c,"Bottom"));return d};G=function(a,b,c){var d=0,e=0,g=a;"fixed"!==b&&(d=0-Ca[0],e=0-Ca[1]);if(void 0===c||!0===c){do d+=a.offsetLeft-a.scrollLeft,e+=a.offsetTop-a.scrollTop,a=a.offsetParent;while(a&&"BODY"!==a.nodeName)}else{do d+=a.offsetLeft,e+=a.offsetTop,a=a.offsetParent;while(a&&"BODY"!==a.nodeName)}return[e,d+g.offsetWidth,e+g.offsetHeight,d]};y=function(){var a,b,c,d;Ca=N();for(a=0;a<f.length;a++){c=[];d=I(f[a],"position");"fixed"!==d&&(d=I(f[a].parentNode,
"position"));for(b=f[a].rows.length-1;0<=b;b--)"none"!==f[a].rows[b].style.display&&(c[b]=G(f[a].rows[b],d));f[a].redips.offset=G(f[a],d);f[a].redips.row_offset=c}H=G(C);for(a=0;a<O.length;a++)d=I(O[a].div,"position"),b=G(O[a].div,d,!1),O[a].offset=b,O[a].midstX=(b[1]+b[3])/2,O[a].midstY=(b[0]+b[2])/2};N=function(){var a,b;"number"===typeof window.pageYOffset?(a=window.pageXOffset,b=window.pageYOffset):document.body&&(document.body.scrollLeft||document.body.scrollTop)?(a=document.body.scrollLeft,
b=document.body.scrollTop):document.documentElement&&(document.documentElement.scrollLeft||document.documentElement.scrollTop)?(a=document.documentElement.scrollLeft,b=document.documentElement.scrollTop):a=b=0;return[a,b]};pa=function(a){var b,c;b=Z;c=aa;0<U&&(y(),T(),b<H[1]&&b>H[3]&&c<H[2]&&c>H[0]&&na());"object"===typeof a&&(w=a);w===window?(a=N()[0],b=ya-J,c=P):(a=w.scrollLeft,b=w.scrollWidth-w.clientWidth,c=R);0<U&&(0>c&&0<a||0<c&&a<b)?(w===window?(window.scrollBy(c,0),N(),a=parseInt(k.style.left,
10),isNaN(a)):w.scrollLeft+=c,setTimeout(pa,REDIPS.drag.scroll.speed)):(REDIPS.event.add(w,"scroll",y),U=0,q=[0,0,0,0])};qa=function(a){var b,c;b=Z;c=aa;0<V&&(y(),T(),b<H[1]&&b>H[3]&&c<H[2]&&c>H[0]&&na());"object"===typeof a&&(w=a);w===window?(a=N()[1],b=za-K,c=Q):(a=w.scrollTop,b=w.scrollHeight-w.clientHeight,c=S);0<V&&(0>c&&0<a||0<c&&a<b)?(w===window?(window.scrollBy(0,c),N(),a=parseInt(k.style.top,10),isNaN(a)):w.scrollTop+=c,setTimeout(qa,REDIPS.drag.scroll.speed)):(REDIPS.event.add(w,"scroll",
y),V=0,q=[0,0,0,0])};ra=function(a,b){var c=a.cloneNode(!0),d=c.className,e,g;!0===b&&(document.getElementById("redips_clone").appendChild(c),c.style.zIndex=999,c.style.position="fixed",e=G(a),g=G(c),c.style.top=e[0]-g[0]+"px",c.style.left=e[3]-g[3]+"px");c.setCapture&&c.setCapture();d=d.replace("redips-clone","");d=d.replace(/climit(\d)_(\d+)/,"");c.className=xa(d);void 0===W[a.id]&&(W[a.id]=0);c.id=a.id+"c"+W[a.id];W[a.id]+=1;Ja(a,c);return c};Ja=function(a,b){var c=[],d;c[0]=function(a,b){a.redips&&
(b.redips={},b.redips.enabled=a.redips.enabled,b.redips.container=a.redips.container,a.redips.enabled&&Y(b))};c[1]=function(a,b){a.redips&&(b.redips={},b.redips.emptyRow=a.redips.emptyRow)};d=function(d){var g,f,A;f=["DIV","TR"];g=a.getElementsByTagName(f[d]);f=b.getElementsByTagName(f[d]);for(A=0;A<f.length;A++)c[d](g[A],f[A])};if("DIV"===a.nodeName)c[0](a,b);else if("TR"===a.nodeName)c[1](a,b);d(0);d(1)};sa=function(a,b){var c,d,e;e=a.className;c=e.match(/climit(\d)_(\d+)/);null!==c&&(d=parseInt(c[1],
10),c=parseInt(c[2],10),0===c&&1===b&&(e+=" redips-clone",2===d&&F(!0,a)),c+=b,e=e.replace(/climit\d_\d+/g,"climit"+d+"_"+c),0>=c&&(e=e.replace("redips-clone",""),2===d?(F(!1,a),REDIPS.drag.event.clonedEnd2()):REDIPS.drag.event.clonedEnd1()),a.className=xa(e))};Ka=function(a){var b=!1;a.srcElement?(b=a.srcElement.nodeName,a=a.srcElement.className):(b=a.target.nodeName,a=a.target.className);switch(b){case "A":case "INPUT":case "SELECT":case "OPTION":case "TEXTAREA":b=!0;break;default:b=/\bredips-nodrag\b/i.test(a)}return b};
F=function(a,b){var c,d,e,g=[],f=[],A,k,h,l,n=/\bredips-drag\b/i,m=/\bredips-noautoscroll\b/i;k=REDIPS.drag.style.opacityDisabled;!0===a||"init"===a?(A=REDIPS.drag.style.borderEnabled,h="move",l=!0):(A=REDIPS.drag.style.borderDisabled,h="auto",l=!1);void 0===b?g=C.getElementsByTagName("div"):"string"===typeof b?g=document.querySelectorAll(b):"object"!==typeof b||"DIV"===b.nodeName&&-1!==b.className.indexOf("redips-drag")?g[0]=b:g=b.getElementsByTagName("div");for(d=c=0;c<g.length;c++)if(n.test(g[c].className))"init"===
a||void 0===g[c].redips?(g[c].redips={},g[c].redips.container=C):!0===a&&"number"===typeof k?(g[c].style.opacity="",g[c].style.filter=""):!1===a&&"number"===typeof k&&(g[c].style.opacity=k/100,g[c].style.filter="alpha(opacity="+k+")"),Y(g[c],l),g[c].style.borderStyle=A,g[c].style.cursor=h,g[c].redips.enabled=l;else if("init"===a&&(e=I(g[c],"overflow"),"visible"!==e)){REDIPS.event.add(g[c],"scroll",y);e=I(g[c],"position");f=G(g[c],e,!1);e=!m.test(g[c].className);O[d]={div:g[c],offset:f,midstX:(f[1]+
f[3])/2,midstY:(f[0]+f[2])/2,autoscroll:e};f=g[c].getElementsByTagName("table");for(e=0;e<f.length;e++)f[e].sca=O[d];d++}};I=function(a,b){var c;a&&a.currentStyle?c=a.currentStyle[b]:a&&window.getComputedStyle&&(c=document.defaultView.getComputedStyle(a,null)[b]);return c};B=function(a,b,c){b=b.parentNode;for(void 0===c&&(c=0);b;){if(b.nodeName===a)if(0<c)c--;else break;b=b.parentNode}return b};La=function(a,b){var c=B("TABLE",b),d,e;switch(a){case "firstInColumn":d=0;e=b.cellIndex;break;case "firstInRow":d=
b.parentNode.rowIndex;e=0;break;case "lastInColumn":d=c.rows.length-1;e=b.cellIndex;break;case "lastInRow":d=b.parentNode.rowIndex;e=c.rows[d].cells.length-1;break;case "last":d=c.rows.length-1;e=c.rows[d].cells.length-1;break;default:d=e=0}return[d,e,c.rows[d].cells[e]]};ia=function(a,b,c){var d,e,g;d=function(a,b){REDIPS.drag.event.relocateBefore(a,b);var c=REDIPS.drag.getPosition(b);REDIPS.drag.moveObject({obj:a,target:c,callback:function(a){var c=REDIPS.drag.findParent("TABLE",a),d=c.redips.idx;
REDIPS.drag.event.relocateAfter(a,b);Ba[d]--;0===Ba[d]&&(REDIPS.drag.event.relocateEnd(),REDIPS.drag.enableTable(!0,c))}})};if(a!==b&&"object"===typeof a&&"object"===typeof b)if(g=a.childNodes.length,"animation"===c){if(0<g)for(c=B("TABLE",b),e=c.redips.idx,REDIPS.drag.enableTable(!1,c),c=0;c<g;c++)1===a.childNodes[c].nodeType&&"DIV"===a.childNodes[c].nodeName&&(Ba[e]++,d(a.childNodes[c],b))}else for(d=c=0;c<g;c++)1===a.childNodes[d].nodeType&&"DIV"===a.childNodes[d].nodeName?(e=a.childNodes[d],REDIPS.drag.event.relocateBefore(e,
b),b.appendChild(e),e.redips&&!1!==e.redips.enabled&&Y(e),REDIPS.drag.event.relocateAfter(e)):d++};ja=function(a,b){var c,d=[],e;if("TD"===a.nodeName){c=a.childNodes.length;if("test"===b)return c=n.source===a?void 0:0===a.childNodes.length||1===a.childNodes.length&&3===a.firstChild.nodeType;for(e=0;e<c;e++)d.push(a.childNodes[0]),a.removeChild(a.childNodes[0]);return d}};ta=function(a,b){var c,d,e,g,f,k,h,l,m,q,p,r,t=!1,u,v;u=function(a,b){REDIPS.drag.shift.animation?ia(a,b,"animation"):ia(a,b)};
v=function(a){"delete"===REDIPS.drag.shift.overflow?ja(a):"source"===REDIPS.drag.shift.overflow?u(a,n.source):"object"===typeof REDIPS.drag.shift.overflow&&u(a,REDIPS.drag.shift.overflow);t=!1;REDIPS.drag.event.shiftOverflow(a)};if(a!==b){f=REDIPS.drag.shift.mode;c=B("TABLE",a);d=B("TABLE",b);k=Sa(d);e=c===d?[a.redips.rowIndex,a.redips.cellIndex]:[-1,-1];g=[b.redips.rowIndex,b.redips.cellIndex];p=d.rows.length;r=Ta(d);switch(f){case "vertical2":c=c===d&&a.redips.cellIndex===b.redips.cellIndex?e:[p,
b.redips.cellIndex];break;case "horizontal2":c=c===d&&a.parentNode.rowIndex===b.parentNode.rowIndex?e:[b.redips.rowIndex,r];break;default:c=c===d?e:[p,r]}"vertical1"===f||"vertical2"===f?(f=1E3*c[1]+c[0]<1E3*g[1]+g[0]?1:-1,d=p,p=0,r=1):(f=1E3*c[0]+c[1]<1E3*g[0]+g[1]?1:-1,d=r,p=1,r=0);for(c[0]!==e[0]&&c[1]!==e[1]&&(t=!0);c[0]!==g[0]||c[1]!==g[1];)h=k[c[0]+"-"+c[1]],c[p]+=f,0>c[p]?(c[p]=d,c[r]--):c[p]>d&&(c[p]=0,c[r]++),e=k[c[0]+"-"+c[1]],void 0!==e&&(l=e),void 0!==h&&(m=h),void 0!==e&&void 0!==m||
void 0!==l&&void 0!==h?(e=-1===l.className.indexOf(REDIPS.drag.mark.cname)?0:1,h=-1===m.className.indexOf(REDIPS.drag.mark.cname)?0:1,t&&0===e&&1===h&&v(l),1===e?0===h&&(q=m):(0===e&&1===h&&(m=q),u(l,m))):t&&void 0!==l&&void 0===m&&(e=-1===l.className.indexOf(REDIPS.drag.mark.cname)?0:1,0===e&&v(l))}};Sa=function(a){var b=[],c,d={},e,g,f,k,h,l,m,n;k=a.rows;for(h=0;h<k.length;h++)for(l=0;l<k[h].cells.length;l++){c=k[h].cells[l];a=c.parentNode.rowIndex;e=c.rowSpan||1;g=c.colSpan||1;b[a]=b[a]||[];for(m=
0;m<b[a].length+1;m++)if("undefined"===typeof b[a][m]){f=m;break}d[a+"-"+f]=c;void 0===c.redips&&(c.redips={});c.redips.rowIndex=a;c.redips.cellIndex=f;for(m=a;m<a+e;m++)for(b[m]=b[m]||[],c=b[m],n=f;n<f+g;n++)c[n]="x"}return d};Ta=function(a){"string"===typeof a&&(a=document.getElementById(a));a=a.rows;var b,c=0,d,e;for(d=0;d<a.length;d++){for(e=b=0;e<a[d].cells.length;e++)b+=a[d].cells[e].colSpan||1;b>c&&(c=b)}return c};Ma=function(a,b){var c=(b.k1-b.k2*a)*(b.k1-b.k2*a),d;a+=REDIPS.drag.animation.step*
(4-3*c)*b.direction;d=b.m*a+b.b;"horizontal"===b.type?(b.obj.style.left=a+"px",b.obj.style.top=d+"px"):(b.obj.style.left=d+"px",b.obj.style.top=a+"px");a<b.last&&0<b.direction||a>b.last&&0>b.direction?setTimeout(function(){Ma(a,b)},REDIPS.drag.animation.pause*c):(Ga(b.obj),b.obj.redips&&(b.obj.redips.animated=!1),"cell"===b.mode?(!0===b.overwrite&&ja(b.targetCell),b.targetCell.appendChild(b.obj),b.obj.redips&&!1!==b.obj.redips.enabled&&Y(b.obj)):Na(ua(b.target[0]),b.target[1],b.obj),"function"===
typeof b.callback&&b.callback(b.obj))};va=function(a){var b,c,d;b=[];b=c=d=-1;if(void 0===a)b=l<f.length?f[l].redips.idx:null===x||null===z||null===E?f[D].redips.idx:f[x].redips.idx,c=f[D].redips.idx,b=[b,h,m,c,L,X];else{if(a="string"===typeof a?document.getElementById(a):a)"TD"!==a.nodeName&&(a=B("TD",a)),a&&"TD"===a.nodeName&&(b=a.cellIndex,c=a.parentNode.rowIndex,a=B("TABLE",a),d=a.redips.idx);b=[d,c,b]}return b};ua=function(a){var b;for(b=0;b<f.length&&f[b].redips.idx!==a;b++);return b};xa=function(a){void 0!==
a&&(a=a.replace(/^\s+|\s+$/g,"").replace(/\s{2,}/g," "));return a};Va=function(a){var b;for(b=0;b<a.childNodes.length;b++)if(1===a.childNodes[b].nodeType)return!0;return!1};wa=function(a,b,c){var d,e;"string"===typeof a&&(a=document.getElementById(a),a=B("TABLE",a));if("TR"===a.nodeName)for(a=a.getElementsByTagName("td"),d=0;d<a.length;d++)if(a[d].style.backgroundColor=c?c:"","empty"===b)a[d].innerHTML="";else for(e=0;e<a[d].childNodes.length;e++)1===a[d].childNodes[e].nodeType&&(a[d].childNodes[e].style.opacity=
b/100,a[d].childNodes[e].style.filter="alpha(opacity="+b+")");else a.style.opacity=b/100,a.style.filter="alpha(opacity="+b+")",a.style.backgroundColor=c?c:""};return{obj:k,objOld:p,mode:v,td:n,hover:{colorTd:"#E7AB83",colorTr:"#E7AB83"},scroll:{enable:!0,bound:25,speed:20},only:Da,mark:Ya,style:{borderEnabled:"solid",borderDisabled:"dotted",opacityDisabled:"",rowEmptyColor:"white"},trash:{className:"redips-trash",question:null,questionRow:null},saveParamName:"p",dropMode:"multiple",multipleDrop:"bottom",
clone:Za,animation:{pause:20,step:2,shift:!1},shift:{mode:"horizontal1",after:"default",overflow:"bunch"},rowDropMode:"before",tableSort:!0,init:function(a){var b;if(void 0===a||"string"!==typeof a)a="redips-drag";C=document.getElementById(a);if(null===C)throw"REDIPS.drag - Drag container is not set!";Ca=N();document.getElementById("redips_clone")||(a=document.createElement("div"),a.id="redips_clone",a.style.width=a.style.height="1px",C.appendChild(a));F("init");u();Ha();REDIPS.event.add(window,"resize",
Ha);b=C.getElementsByTagName("img");for(a=0;a<b.length;a++)REDIPS.event.add(b[a],"mousemove",M),REDIPS.event.add(b[a],"touchmove",M);REDIPS.event.add(window,"scroll",y)},initTables:u,enableDrag:F,enableTable:function(a,b){var c;if("object"===typeof b&&"TABLE"===b.nodeName)b.redips.enabled=a;else for(c=0;c<f.length;c++)-1<f[c].className.indexOf(b)&&(f[c].redips.enabled=a)},cloneObject:ra,saveContent:function(a,b){var c="",d,e,f,h,k,l,m,n=[],p=REDIPS.drag.saveParamName;"string"===typeof a&&(a=document.getElementById(a));
if(void 0!==a&&"object"===typeof a&&"TABLE"===a.nodeName){d=a.rows.length;for(k=0;k<d;k++)for(e=a.rows[k].cells.length,l=0;l<e;l++)if(f=a.rows[k].cells[l],0<f.childNodes.length)for(m=0;m<f.childNodes.length;m++)h=f.childNodes[m],"DIV"===h.nodeName&&-1<h.className.indexOf("redips-drag")&&(c+=p+"[]="+h.id+"_"+k+"_"+l+"&",n.push([h.id,k,l]));c="json"===b&&0<n.length?JSON.stringify(n):c.substring(0,c.length-1)}return c},relocate:ia,emptyCell:ja,moveObject:function(a){var b={direction:1},c,d,e,g,k,h;b.callback=
a.callback;b.overwrite=a.overwrite;"string"===typeof a.id?b.obj=b.objOld=document.getElementById(a.id):"object"===typeof a.obj&&"DIV"===a.obj.nodeName&&(b.obj=b.objOld=a.obj);if("row"===a.mode){b.mode="row";h=ua(a.source[0]);k=a.source[1];p=b.objOld=f[h].rows[k];if(p.redips&&!0===p.redips.emptyRow)return!1;b.obj=ka(b.objOld,"animated")}else if(b.obj&&-1<b.obj.className.indexOf("redips-row")){b.mode="row";b.obj=b.objOld=p=B("TR",b.obj);if(p.redips&&!0===p.redips.emptyRow)return!1;b.obj=ka(b.objOld,
"animated")}else b.mode="cell";if("object"===typeof b.obj&&null!==b.obj)return b.obj.style.zIndex=999,b.obj.redips&&C!==b.obj.redips.container&&(C=b.obj.redips.container,u()),h=G(b.obj),e=h[1]-h[3],g=h[2]-h[0],c=h[3],d=h[0],!0===a.clone&&"cell"===b.mode&&(b.obj=ra(b.obj,!0),REDIPS.drag.event.cloned(b.obj)),void 0===a.target?a.target=va():"object"===typeof a.target&&"TD"===a.target.nodeName&&(a.target=va(a.target)),b.target=a.target,h=ua(a.target[0]),k=a.target[1],a=a.target[2],k>f[h].rows.length-
1&&(k=f[h].rows.length-1),b.targetCell=f[h].rows[k].cells[a],"cell"===b.mode?(h=G(b.targetCell),k=h[1]-h[3],a=h[2]-h[0],e=h[3]+(k-e)/2,g=h[0]+(a-g)/2):(h=G(f[h].rows[k]),e=h[3],g=h[0]),h=e-c,a=g-d,b.obj.style.position="fixed",Math.abs(h)>Math.abs(a)?(b.type="horizontal",b.m=a/h,b.b=d-b.m*c,b.k1=(c+e)/(c-e),b.k2=2/(c-e),c>e&&(b.direction=-1),h=c,b.last=e):(b.type="vertical",b.m=h/a,b.b=c-b.m*d,b.k1=(d+g)/(d-g),b.k2=2/(d-g),d>g&&(b.direction=-1),h=d,b.last=g),b.obj.redips&&(b.obj.redips.animated=!0),
Ma(h,b),[b.obj,b.objOld]},shiftCells:ta,deleteObject:function(a){"object"===typeof a&&"DIV"===a.nodeName?a.parentNode.removeChild(a):"string"===typeof a&&(a=document.getElementById(a))&&a.parentNode.removeChild(a)},getPosition:va,rowOpacity:wa,rowEmpty:function(a,b,c){a=document.getElementById(a).rows[b];void 0===c&&(c=REDIPS.drag.style.rowEmptyColor);void 0===a.redips&&(a.redips={});a.redips.emptyRow=!0;wa(a,"empty",c)},getScrollPosition:N,getStyle:I,findParent:B,findCell:La,event:{changed:function(){},
clicked:function(){},cloned:function(){},clonedDropped:function(){},clonedEnd1:function(){},clonedEnd2:function(){},dblClicked:function(){},deleted:function(){},dropped:function(){},droppedBefore:function(){},finish:function(){},moved:function(){},notCloned:function(){},notMoved:function(){},shiftOverflow:function(){},relocateBefore:function(){},relocateAfter:function(){},relocateEnd:function(){},rowChanged:function(){},rowClicked:function(){},rowCloned:function(){},rowDeleted:function(){},rowDropped:function(){},
rowDroppedBefore:function(){},rowDroppedSource:function(){},rowMoved:function(){},rowNotCloned:function(){},rowNotMoved:function(){},rowUndeleted:function(){},switched:function(){},undeleted:function(){}}}}();REDIPS.event||(REDIPS.event=function(){return{add:function(u,F,M){u.addEventListener?u.addEventListener(F,M,!1):u.attachEvent?u.attachEvent("on"+F,M):u["on"+F]=M},remove:function(u,F,M){u.removeEventListener?u.removeEventListener(F,M,!1):u.detachEvent?u.detachEvent("on"+F,M):u["on"+F]=null}}}());
function goSidebar(elem, link){
    $(".main-sidebar1").css('opacity', '1')
    $(".main-sidebar1").css('z-index', 100)

    //Fetch the content of sub-menu
    $.ajax({
        url: 'link',
        data: {name: elem.id},
        type: 'post',
        success: function (response) {
            if (response !== null) {
                $(".main-sidebar1").html(response);

//            $(".main-sidebar1").show();


                $(".main-sidebar").animate({
                        left: "-=230",
                    }
                );
            }
        },
        error: function () {
        },
        complete: function () {
        }
    })
}

function getSidebar(link, url, params, view)
{
    $.ajax({
        url: link,
        data: {'url' : url, 'paramsToSidebar': params, 'view': view},
        type: 'post',
        success: function (response) {
            if (response !== null) {
                $(".main-sidebar").html(response);

            }
        },
        error: function () {
        },
        complete: function () {
        }
    })
}

$('.collapse')
    .on('shown.bs.collapse', function() {
        $(this)
            .parent()
            .find(".fa-chevron-down")
            .removeClass("fa-chevron-down")
            .addClass("fa-chevron-up");
    })
    .on('hidden.bs.collapse', function() {
        $(this)
            .parent()
            .find(".fa-chevron-up")
            .removeClass("fa-chevron-up")
            .addClass("fa-chevron-down");
    });
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":3,"./socket":5,"./url":6,"debug":10,"socket.io-parser":44}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var object = _dereq_('object-component');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":4,"./socket":5,"./url":6,"backo2":7,"component-bind":8,"component-emitter":9,"debug":10,"engine.io-client":11,"indexof":40,"object-component":41,"socket.io-parser":44}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":4,"component-bind":8,"component-emitter":9,"debug":10,"has-binary":36,"socket.io-parser":44,"to-array":48}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":10,"parseuri":42}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":14,"./transports":15,"component-emitter":9,"debug":22,"engine.io-parser":25,"indexof":40,"parsejson":32,"parseqs":33,"parseuri":34}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest":20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-emitter":9,"component-inherit":21,"debug":22,"xmlhttprequest":20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":33,"xmlhttprequest":20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":33,"ws":35}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":38}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":26,"after":27,"arraybuffer.slice":28,"base64-arraybuffer":29,"blob":30,"has-binary":36,"utf8":31}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],32:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],33:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],34:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],35:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],36:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":37}],37:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],38:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":39}],39:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],40:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],41:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],42:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],43:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":45,"isarray":46}],44:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":43,"./is-buffer":45,"component-emitter":9,"debug":10,"isarray":46,"json3":47}],45:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],46:[function(_dereq_,module,exports){
module.exports=_dereq_(37)
},{}],47:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],48:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});

/*!
 * Datepicker for Bootstrap v1.6.4 (https://github.com/eternicode/bootstrap-datepicker)
 *
 * Copyright 2012 Stefan Petre
 * Improvements by Andrew Rowls
 * Licensed under the Apache License v2.0 (http://www.apache.org/licenses/LICENSE-2.0)
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a("object"==typeof exports?require("jquery"):jQuery)}(function(a,b){function c(){return new Date(Date.UTC.apply(Date,arguments))}function d(){var a=new Date;return c(a.getFullYear(),a.getMonth(),a.getDate())}function e(a,b){return a.getUTCFullYear()===b.getUTCFullYear()&&a.getUTCMonth()===b.getUTCMonth()&&a.getUTCDate()===b.getUTCDate()}function f(a){return function(){return this[a].apply(this,arguments)}}function g(a){return a&&!isNaN(a.getTime())}function h(b,c){function d(a,b){return b.toLowerCase()}var e,f=a(b).data(),g={},h=new RegExp("^"+c.toLowerCase()+"([A-Z])");c=new RegExp("^"+c.toLowerCase());for(var i in f)c.test(i)&&(e=i.replace(h,d),g[e]=f[i]);return g}function i(b){var c={};if(q[b]||(b=b.split("-")[0],q[b])){var d=q[b];return a.each(p,function(a,b){b in d&&(c[b]=d[b])}),c}}var j=function(){var b={get:function(a){return this.slice(a)[0]},contains:function(a){for(var b=a&&a.valueOf(),c=0,d=this.length;d>c;c++)if(this[c].valueOf()===b)return c;return-1},remove:function(a){this.splice(a,1)},replace:function(b){b&&(a.isArray(b)||(b=[b]),this.clear(),this.push.apply(this,b))},clear:function(){this.length=0},copy:function(){var a=new j;return a.replace(this),a}};return function(){var c=[];return c.push.apply(c,arguments),a.extend(c,b),c}}(),k=function(b,c){a(b).data("datepicker",this),this._process_options(c),this.dates=new j,this.viewDate=this.o.defaultViewDate,this.focusDate=null,this.element=a(b),this.isInput=this.element.is("input"),this.inputField=this.isInput?this.element:this.element.find("input"),this.component=this.element.hasClass("date")?this.element.find(".add-on, .input-group-addon, .btn"):!1,this.hasInput=this.component&&this.inputField.length,this.component&&0===this.component.length&&(this.component=!1),this.isInline=!this.component&&this.element.is("div"),this.picker=a(r.template),this._check_template(this.o.templates.leftArrow)&&this.picker.find(".prev").html(this.o.templates.leftArrow),this._check_template(this.o.templates.rightArrow)&&this.picker.find(".next").html(this.o.templates.rightArrow),this._buildEvents(),this._attachEvents(),this.isInline?this.picker.addClass("datepicker-inline").appendTo(this.element):this.picker.addClass("datepicker-dropdown dropdown-menu"),this.o.rtl&&this.picker.addClass("datepicker-rtl"),this.viewMode=this.o.startView,this.o.calendarWeeks&&this.picker.find("thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan",function(a,b){return parseInt(b)+1}),this._allow_update=!1,this.setStartDate(this._o.startDate),this.setEndDate(this._o.endDate),this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled),this.setDaysOfWeekHighlighted(this.o.daysOfWeekHighlighted),this.setDatesDisabled(this.o.datesDisabled),this.fillDow(),this.fillMonths(),this._allow_update=!0,this.update(),this.showMode(),this.isInline&&this.show()};k.prototype={constructor:k,_resolveViewName:function(a,c){return 0===a||"days"===a||"month"===a?0:1===a||"months"===a||"year"===a?1:2===a||"years"===a||"decade"===a?2:3===a||"decades"===a||"century"===a?3:4===a||"centuries"===a||"millennium"===a?4:c===b?!1:c},_check_template:function(c){try{if(c===b||""===c)return!1;if((c.match(/[<>]/g)||[]).length<=0)return!0;var d=a(c);return d.length>0}catch(e){return!1}},_process_options:function(b){this._o=a.extend({},this._o,b);var e=this.o=a.extend({},this._o),f=e.language;q[f]||(f=f.split("-")[0],q[f]||(f=o.language)),e.language=f,e.startView=this._resolveViewName(e.startView,0),e.minViewMode=this._resolveViewName(e.minViewMode,0),e.maxViewMode=this._resolveViewName(e.maxViewMode,4),e.startView=Math.min(e.startView,e.maxViewMode),e.startView=Math.max(e.startView,e.minViewMode),e.multidate!==!0&&(e.multidate=Number(e.multidate)||!1,e.multidate!==!1&&(e.multidate=Math.max(0,e.multidate))),e.multidateSeparator=String(e.multidateSeparator),e.weekStart%=7,e.weekEnd=(e.weekStart+6)%7;var g=r.parseFormat(e.format);e.startDate!==-(1/0)&&(e.startDate?e.startDate instanceof Date?e.startDate=this._local_to_utc(this._zero_time(e.startDate)):e.startDate=r.parseDate(e.startDate,g,e.language,e.assumeNearbyYear):e.startDate=-(1/0)),e.endDate!==1/0&&(e.endDate?e.endDate instanceof Date?e.endDate=this._local_to_utc(this._zero_time(e.endDate)):e.endDate=r.parseDate(e.endDate,g,e.language,e.assumeNearbyYear):e.endDate=1/0),e.daysOfWeekDisabled=e.daysOfWeekDisabled||[],a.isArray(e.daysOfWeekDisabled)||(e.daysOfWeekDisabled=e.daysOfWeekDisabled.split(/[,\s]*/)),e.daysOfWeekDisabled=a.map(e.daysOfWeekDisabled,function(a){return parseInt(a,10)}),e.daysOfWeekHighlighted=e.daysOfWeekHighlighted||[],a.isArray(e.daysOfWeekHighlighted)||(e.daysOfWeekHighlighted=e.daysOfWeekHighlighted.split(/[,\s]*/)),e.daysOfWeekHighlighted=a.map(e.daysOfWeekHighlighted,function(a){return parseInt(a,10)}),e.datesDisabled=e.datesDisabled||[],a.isArray(e.datesDisabled)||(e.datesDisabled=[e.datesDisabled]),e.datesDisabled=a.map(e.datesDisabled,function(a){return r.parseDate(a,g,e.language,e.assumeNearbyYear)});var h=String(e.orientation).toLowerCase().split(/\s+/g),i=e.orientation.toLowerCase();if(h=a.grep(h,function(a){return/^auto|left|right|top|bottom$/.test(a)}),e.orientation={x:"auto",y:"auto"},i&&"auto"!==i)if(1===h.length)switch(h[0]){case"top":case"bottom":e.orientation.y=h[0];break;case"left":case"right":e.orientation.x=h[0]}else i=a.grep(h,function(a){return/^left|right$/.test(a)}),e.orientation.x=i[0]||"auto",i=a.grep(h,function(a){return/^top|bottom$/.test(a)}),e.orientation.y=i[0]||"auto";else;if(e.defaultViewDate){var j=e.defaultViewDate.year||(new Date).getFullYear(),k=e.defaultViewDate.month||0,l=e.defaultViewDate.day||1;e.defaultViewDate=c(j,k,l)}else e.defaultViewDate=d()},_events:[],_secondaryEvents:[],_applyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(d=b,e=a[f][1]):3===a[f].length&&(d=a[f][1],e=a[f][2]),c.on(e,d)},_unapplyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(e=b,d=a[f][1]):3===a[f].length&&(e=a[f][1],d=a[f][2]),c.off(d,e)},_buildEvents:function(){var b={keyup:a.proxy(function(b){-1===a.inArray(b.keyCode,[27,37,39,38,40,32,13,9])&&this.update()},this),keydown:a.proxy(this.keydown,this),paste:a.proxy(this.paste,this)};this.o.showOnFocus===!0&&(b.focus=a.proxy(this.show,this)),this.isInput?this._events=[[this.element,b]]:this.component&&this.hasInput?this._events=[[this.inputField,b],[this.component,{click:a.proxy(this.show,this)}]]:this._events=[[this.element,{click:a.proxy(this.show,this),keydown:a.proxy(this.keydown,this)}]],this._events.push([this.element,"*",{blur:a.proxy(function(a){this._focused_from=a.target},this)}],[this.element,{blur:a.proxy(function(a){this._focused_from=a.target},this)}]),this.o.immediateUpdates&&this._events.push([this.element,{"changeYear changeMonth":a.proxy(function(a){this.update(a.date)},this)}]),this._secondaryEvents=[[this.picker,{click:a.proxy(this.click,this)}],[a(window),{resize:a.proxy(this.place,this)}],[a(document),{mousedown:a.proxy(function(a){this.element.is(a.target)||this.element.find(a.target).length||this.picker.is(a.target)||this.picker.find(a.target).length||this.isInline||this.hide()},this)}]]},_attachEvents:function(){this._detachEvents(),this._applyEvents(this._events)},_detachEvents:function(){this._unapplyEvents(this._events)},_attachSecondaryEvents:function(){this._detachSecondaryEvents(),this._applyEvents(this._secondaryEvents)},_detachSecondaryEvents:function(){this._unapplyEvents(this._secondaryEvents)},_trigger:function(b,c){var d=c||this.dates.get(-1),e=this._utc_to_local(d);this.element.trigger({type:b,date:e,dates:a.map(this.dates,this._utc_to_local),format:a.proxy(function(a,b){0===arguments.length?(a=this.dates.length-1,b=this.o.format):"string"==typeof a&&(b=a,a=this.dates.length-1),b=b||this.o.format;var c=this.dates.get(a);return r.formatDate(c,b,this.o.language)},this)})},show:function(){return this.inputField.prop("disabled")||this.inputField.prop("readonly")&&this.o.enableOnReadonly===!1?void 0:(this.isInline||this.picker.appendTo(this.o.container),this.place(),this.picker.show(),this._attachSecondaryEvents(),this._trigger("show"),(window.navigator.msMaxTouchPoints||"ontouchstart"in document)&&this.o.disableTouchKeyboard&&a(this.element).blur(),this)},hide:function(){return this.isInline||!this.picker.is(":visible")?this:(this.focusDate=null,this.picker.hide().detach(),this._detachSecondaryEvents(),this.viewMode=this.o.startView,this.showMode(),this.o.forceParse&&this.inputField.val()&&this.setValue(),this._trigger("hide"),this)},destroy:function(){return this.hide(),this._detachEvents(),this._detachSecondaryEvents(),this.picker.remove(),delete this.element.data().datepicker,this.isInput||delete this.element.data().date,this},paste:function(b){var c;if(b.originalEvent.clipboardData&&b.originalEvent.clipboardData.types&&-1!==a.inArray("text/plain",b.originalEvent.clipboardData.types))c=b.originalEvent.clipboardData.getData("text/plain");else{if(!window.clipboardData)return;c=window.clipboardData.getData("Text")}this.setDate(c),this.update(),b.preventDefault()},_utc_to_local:function(a){return a&&new Date(a.getTime()+6e4*a.getTimezoneOffset())},_local_to_utc:function(a){return a&&new Date(a.getTime()-6e4*a.getTimezoneOffset())},_zero_time:function(a){return a&&new Date(a.getFullYear(),a.getMonth(),a.getDate())},_zero_utc_time:function(a){return a&&new Date(Date.UTC(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate()))},getDates:function(){return a.map(this.dates,this._utc_to_local)},getUTCDates:function(){return a.map(this.dates,function(a){return new Date(a)})},getDate:function(){return this._utc_to_local(this.getUTCDate())},getUTCDate:function(){var a=this.dates.get(-1);return"undefined"!=typeof a?new Date(a):null},clearDates:function(){this.inputField&&this.inputField.val(""),this.update(),this._trigger("changeDate"),this.o.autoclose&&this.hide()},setDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.update.apply(this,b),this._trigger("changeDate"),this.setValue(),this},setUTCDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.update.apply(this,a.map(b,this._utc_to_local)),this._trigger("changeDate"),this.setValue(),this},setDate:f("setDates"),setUTCDate:f("setUTCDates"),remove:f("destroy"),setValue:function(){var a=this.getFormattedDate();return this.inputField.val(a),this},getFormattedDate:function(c){c===b&&(c=this.o.format);var d=this.o.language;return a.map(this.dates,function(a){return r.formatDate(a,c,d)}).join(this.o.multidateSeparator)},getStartDate:function(){return this.o.startDate},setStartDate:function(a){return this._process_options({startDate:a}),this.update(),this.updateNavArrows(),this},getEndDate:function(){return this.o.endDate},setEndDate:function(a){return this._process_options({endDate:a}),this.update(),this.updateNavArrows(),this},setDaysOfWeekDisabled:function(a){return this._process_options({daysOfWeekDisabled:a}),this.update(),this.updateNavArrows(),this},setDaysOfWeekHighlighted:function(a){return this._process_options({daysOfWeekHighlighted:a}),this.update(),this},setDatesDisabled:function(a){this._process_options({datesDisabled:a}),this.update(),this.updateNavArrows()},place:function(){if(this.isInline)return this;var b=this.picker.outerWidth(),c=this.picker.outerHeight(),d=10,e=a(this.o.container),f=e.width(),g="body"===this.o.container?a(document).scrollTop():e.scrollTop(),h=e.offset(),i=[];this.element.parents().each(function(){var b=a(this).css("z-index");"auto"!==b&&0!==b&&i.push(parseInt(b))});var j=Math.max.apply(Math,i)+this.o.zIndexOffset,k=this.component?this.component.parent().offset():this.element.offset(),l=this.component?this.component.outerHeight(!0):this.element.outerHeight(!1),m=this.component?this.component.outerWidth(!0):this.element.outerWidth(!1),n=k.left-h.left,o=k.top-h.top;"body"!==this.o.container&&(o+=g),this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"),"auto"!==this.o.orientation.x?(this.picker.addClass("datepicker-orient-"+this.o.orientation.x),"right"===this.o.orientation.x&&(n-=b-m)):k.left<0?(this.picker.addClass("datepicker-orient-left"),n-=k.left-d):n+b>f?(this.picker.addClass("datepicker-orient-right"),n+=m-b):this.picker.addClass("datepicker-orient-left");var p,q=this.o.orientation.y;if("auto"===q&&(p=-g+o-c,q=0>p?"bottom":"top"),this.picker.addClass("datepicker-orient-"+q),"top"===q?o-=c+parseInt(this.picker.css("padding-top")):o+=l,this.o.rtl){var r=f-(n+m);this.picker.css({top:o,right:r,zIndex:j})}else this.picker.css({top:o,left:n,zIndex:j});return this},_allow_update:!0,update:function(){if(!this._allow_update)return this;var b=this.dates.copy(),c=[],d=!1;return arguments.length?(a.each(arguments,a.proxy(function(a,b){b instanceof Date&&(b=this._local_to_utc(b)),c.push(b)},this)),d=!0):(c=this.isInput?this.element.val():this.element.data("date")||this.inputField.val(),c=c&&this.o.multidate?c.split(this.o.multidateSeparator):[c],delete this.element.data().date),c=a.map(c,a.proxy(function(a){return r.parseDate(a,this.o.format,this.o.language,this.o.assumeNearbyYear)},this)),c=a.grep(c,a.proxy(function(a){return!this.dateWithinRange(a)||!a},this),!0),this.dates.replace(c),this.dates.length?this.viewDate=new Date(this.dates.get(-1)):this.viewDate<this.o.startDate?this.viewDate=new Date(this.o.startDate):this.viewDate>this.o.endDate?this.viewDate=new Date(this.o.endDate):this.viewDate=this.o.defaultViewDate,d?this.setValue():c.length&&String(b)!==String(this.dates)&&this._trigger("changeDate"),!this.dates.length&&b.length&&this._trigger("clearDate"),this.fill(),this.element.change(),this},fillDow:function(){var b=this.o.weekStart,c="<tr>";for(this.o.calendarWeeks&&(this.picker.find(".datepicker-days .datepicker-switch").attr("colspan",function(a,b){return parseInt(b)+1}),c+='<th class="cw">&#160;</th>');b<this.o.weekStart+7;)c+='<th class="dow',a.inArray(b,this.o.daysOfWeekDisabled)>-1&&(c+=" disabled"),c+='">'+q[this.o.language].daysMin[b++%7]+"</th>";c+="</tr>",this.picker.find(".datepicker-days thead").append(c)},fillMonths:function(){for(var a=this._utc_to_local(this.viewDate),b="",c=0;12>c;){var d=a&&a.getMonth()===c?" focused":"";b+='<span class="month'+d+'">'+q[this.o.language].monthsShort[c++]+"</span>"}this.picker.find(".datepicker-months td").html(b)},setRange:function(b){b&&b.length?this.range=a.map(b,function(a){return a.valueOf()}):delete this.range,this.fill()},getClassNames:function(b){var c=[],d=this.viewDate.getUTCFullYear(),e=this.viewDate.getUTCMonth(),f=new Date;return b.getUTCFullYear()<d||b.getUTCFullYear()===d&&b.getUTCMonth()<e?c.push("old"):(b.getUTCFullYear()>d||b.getUTCFullYear()===d&&b.getUTCMonth()>e)&&c.push("new"),this.focusDate&&b.valueOf()===this.focusDate.valueOf()&&c.push("focused"),this.o.todayHighlight&&b.getUTCFullYear()===f.getFullYear()&&b.getUTCMonth()===f.getMonth()&&b.getUTCDate()===f.getDate()&&c.push("today"),-1!==this.dates.contains(b)&&c.push("active"),this.dateWithinRange(b)||c.push("disabled"),this.dateIsDisabled(b)&&c.push("disabled","disabled-date"),-1!==a.inArray(b.getUTCDay(),this.o.daysOfWeekHighlighted)&&c.push("highlighted"),this.range&&(b>this.range[0]&&b<this.range[this.range.length-1]&&c.push("range"),-1!==a.inArray(b.valueOf(),this.range)&&c.push("selected"),b.valueOf()===this.range[0]&&c.push("range-start"),b.valueOf()===this.range[this.range.length-1]&&c.push("range-end")),c},_fill_yearsView:function(c,d,e,f,g,h,i,j){var k,l,m,n,o,p,q,r,s,t,u;for(k="",l=this.picker.find(c),m=parseInt(g/e,10)*e,o=parseInt(h/f,10)*f,p=parseInt(i/f,10)*f,n=a.map(this.dates,function(a){return parseInt(a.getUTCFullYear()/f,10)*f}),l.find(".datepicker-switch").text(m+"-"+(m+9*f)),q=m-f,r=-1;11>r;r+=1)s=[d],t=null,-1===r?s.push("old"):10===r&&s.push("new"),-1!==a.inArray(q,n)&&s.push("active"),(o>q||q>p)&&s.push("disabled"),q===this.viewDate.getFullYear()&&s.push("focused"),j!==a.noop&&(u=j(new Date(q,0,1)),u===b?u={}:"boolean"==typeof u?u={enabled:u}:"string"==typeof u&&(u={classes:u}),u.enabled===!1&&s.push("disabled"),u.classes&&(s=s.concat(u.classes.split(/\s+/))),u.tooltip&&(t=u.tooltip)),k+='<span class="'+s.join(" ")+'"'+(t?' title="'+t+'"':"")+">"+q+"</span>",q+=f;l.find("td").html(k)},fill:function(){var d,e,f=new Date(this.viewDate),g=f.getUTCFullYear(),h=f.getUTCMonth(),i=this.o.startDate!==-(1/0)?this.o.startDate.getUTCFullYear():-(1/0),j=this.o.startDate!==-(1/0)?this.o.startDate.getUTCMonth():-(1/0),k=this.o.endDate!==1/0?this.o.endDate.getUTCFullYear():1/0,l=this.o.endDate!==1/0?this.o.endDate.getUTCMonth():1/0,m=q[this.o.language].today||q.en.today||"",n=q[this.o.language].clear||q.en.clear||"",o=q[this.o.language].titleFormat||q.en.titleFormat;if(!isNaN(g)&&!isNaN(h)){this.picker.find(".datepicker-days .datepicker-switch").text(r.formatDate(f,o,this.o.language)),this.picker.find("tfoot .today").text(m).toggle(this.o.todayBtn!==!1),this.picker.find("tfoot .clear").text(n).toggle(this.o.clearBtn!==!1),this.picker.find("thead .datepicker-title").text(this.o.title).toggle(""!==this.o.title),this.updateNavArrows(),this.fillMonths();var p=c(g,h-1,28),s=r.getDaysInMonth(p.getUTCFullYear(),p.getUTCMonth());p.setUTCDate(s),p.setUTCDate(s-(p.getUTCDay()-this.o.weekStart+7)%7);var t=new Date(p);p.getUTCFullYear()<100&&t.setUTCFullYear(p.getUTCFullYear()),t.setUTCDate(t.getUTCDate()+42),t=t.valueOf();for(var u,v=[];p.valueOf()<t;){if(p.getUTCDay()===this.o.weekStart&&(v.push("<tr>"),this.o.calendarWeeks)){var w=new Date(+p+(this.o.weekStart-p.getUTCDay()-7)%7*864e5),x=new Date(Number(w)+(11-w.getUTCDay())%7*864e5),y=new Date(Number(y=c(x.getUTCFullYear(),0,1))+(11-y.getUTCDay())%7*864e5),z=(x-y)/864e5/7+1;v.push('<td class="cw">'+z+"</td>")}u=this.getClassNames(p),u.push("day"),this.o.beforeShowDay!==a.noop&&(e=this.o.beforeShowDay(this._utc_to_local(p)),e===b?e={}:"boolean"==typeof e?e={enabled:e}:"string"==typeof e&&(e={classes:e}),e.enabled===!1&&u.push("disabled"),e.classes&&(u=u.concat(e.classes.split(/\s+/))),e.tooltip&&(d=e.tooltip)),u=a.isFunction(a.uniqueSort)?a.uniqueSort(u):a.unique(u),v.push('<td class="'+u.join(" ")+'"'+(d?' title="'+d+'"':"")+">"+p.getUTCDate()+"</td>"),d=null,p.getUTCDay()===this.o.weekEnd&&v.push("</tr>"),p.setUTCDate(p.getUTCDate()+1)}this.picker.find(".datepicker-days tbody").empty().append(v.join(""));var A=q[this.o.language].monthsTitle||q.en.monthsTitle||"Months",B=this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode<2?A:g).end().find("span").removeClass("active");if(a.each(this.dates,function(a,b){b.getUTCFullYear()===g&&B.eq(b.getUTCMonth()).addClass("active")}),(i>g||g>k)&&B.addClass("disabled"),g===i&&B.slice(0,j).addClass("disabled"),g===k&&B.slice(l+1).addClass("disabled"),this.o.beforeShowMonth!==a.noop){var C=this;a.each(B,function(c,d){var e=new Date(g,c,1),f=C.o.beforeShowMonth(e);f===b?f={}:"boolean"==typeof f?f={enabled:f}:"string"==typeof f&&(f={classes:f}),f.enabled!==!1||a(d).hasClass("disabled")||a(d).addClass("disabled"),f.classes&&a(d).addClass(f.classes),f.tooltip&&a(d).prop("title",f.tooltip)})}this._fill_yearsView(".datepicker-years","year",10,1,g,i,k,this.o.beforeShowYear),this._fill_yearsView(".datepicker-decades","decade",100,10,g,i,k,this.o.beforeShowDecade),this._fill_yearsView(".datepicker-centuries","century",1e3,100,g,i,k,this.o.beforeShowCentury)}},updateNavArrows:function(){if(this._allow_update){var a=new Date(this.viewDate),b=a.getUTCFullYear(),c=a.getUTCMonth();switch(this.viewMode){case 0:this.o.startDate!==-(1/0)&&b<=this.o.startDate.getUTCFullYear()&&c<=this.o.startDate.getUTCMonth()?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.o.endDate!==1/0&&b>=this.o.endDate.getUTCFullYear()&&c>=this.o.endDate.getUTCMonth()?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"});break;case 1:case 2:case 3:case 4:this.o.startDate!==-(1/0)&&b<=this.o.startDate.getUTCFullYear()||this.o.maxViewMode<2?this.picker.find(".prev").css({visibility:"hidden"}):this.picker.find(".prev").css({visibility:"visible"}),this.o.endDate!==1/0&&b>=this.o.endDate.getUTCFullYear()||this.o.maxViewMode<2?this.picker.find(".next").css({visibility:"hidden"}):this.picker.find(".next").css({visibility:"visible"})}}},click:function(b){b.preventDefault(),b.stopPropagation();var e,f,g,h,i,j,k;e=a(b.target),e.hasClass("datepicker-switch")&&this.showMode(1);var l=e.closest(".prev, .next");l.length>0&&(f=r.modes[this.viewMode].navStep*(l.hasClass("prev")?-1:1),0===this.viewMode?(this.viewDate=this.moveMonth(this.viewDate,f),this._trigger("changeMonth",this.viewDate)):(this.viewDate=this.moveYear(this.viewDate,f),1===this.viewMode&&this._trigger("changeYear",this.viewDate)),this.fill()),e.hasClass("today")&&!e.hasClass("day")&&(this.showMode(-2),this._setDate(d(),"linked"===this.o.todayBtn?null:"view")),e.hasClass("clear")&&this.clearDates(),e.hasClass("disabled")||(e.hasClass("day")&&(g=parseInt(e.text(),10)||1,h=this.viewDate.getUTCFullYear(),i=this.viewDate.getUTCMonth(),e.hasClass("old")&&(0===i?(i=11,h-=1,j=!0,k=!0):(i-=1,j=!0)),e.hasClass("new")&&(11===i?(i=0,h+=1,j=!0,k=!0):(i+=1,j=!0)),this._setDate(c(h,i,g)),k&&this._trigger("changeYear",this.viewDate),j&&this._trigger("changeMonth",this.viewDate)),e.hasClass("month")&&(this.viewDate.setUTCDate(1),g=1,i=e.parent().find("span").index(e),h=this.viewDate.getUTCFullYear(),this.viewDate.setUTCMonth(i),this._trigger("changeMonth",this.viewDate),1===this.o.minViewMode?(this._setDate(c(h,i,g)),this.showMode()):this.showMode(-1),this.fill()),(e.hasClass("year")||e.hasClass("decade")||e.hasClass("century"))&&(this.viewDate.setUTCDate(1),g=1,i=0,h=parseInt(e.text(),10)||0,this.viewDate.setUTCFullYear(h),e.hasClass("year")&&(this._trigger("changeYear",this.viewDate),2===this.o.minViewMode&&this._setDate(c(h,i,g))),e.hasClass("decade")&&(this._trigger("changeDecade",this.viewDate),3===this.o.minViewMode&&this._setDate(c(h,i,g))),e.hasClass("century")&&(this._trigger("changeCentury",this.viewDate),4===this.o.minViewMode&&this._setDate(c(h,i,g))),this.showMode(-1),this.fill())),this.picker.is(":visible")&&this._focused_from&&a(this._focused_from).focus(),delete this._focused_from},_toggle_multidate:function(a){var b=this.dates.contains(a);if(a||this.dates.clear(),-1!==b?(this.o.multidate===!0||this.o.multidate>1||this.o.toggleActive)&&this.dates.remove(b):this.o.multidate===!1?(this.dates.clear(),this.dates.push(a)):this.dates.push(a),"number"==typeof this.o.multidate)for(;this.dates.length>this.o.multidate;)this.dates.remove(0)},_setDate:function(a,b){b&&"date"!==b||this._toggle_multidate(a&&new Date(a)),b&&"view"!==b||(this.viewDate=a&&new Date(a)),this.fill(),this.setValue(),b&&"view"===b||this._trigger("changeDate"),this.inputField&&this.inputField.change(),!this.o.autoclose||b&&"date"!==b||this.hide()},moveDay:function(a,b){var c=new Date(a);return c.setUTCDate(a.getUTCDate()+b),c},moveWeek:function(a,b){return this.moveDay(a,7*b)},moveMonth:function(a,b){if(!g(a))return this.o.defaultViewDate;if(!b)return a;var c,d,e=new Date(a.valueOf()),f=e.getUTCDate(),h=e.getUTCMonth(),i=Math.abs(b);if(b=b>0?1:-1,1===i)d=-1===b?function(){return e.getUTCMonth()===h}:function(){return e.getUTCMonth()!==c},c=h+b,e.setUTCMonth(c),(0>c||c>11)&&(c=(c+12)%12);else{for(var j=0;i>j;j++)e=this.moveMonth(e,b);c=e.getUTCMonth(),e.setUTCDate(f),d=function(){return c!==e.getUTCMonth()}}for(;d();)e.setUTCDate(--f),e.setUTCMonth(c);return e},moveYear:function(a,b){return this.moveMonth(a,12*b)},moveAvailableDate:function(a,b,c){do{if(a=this[c](a,b),!this.dateWithinRange(a))return!1;c="moveDay"}while(this.dateIsDisabled(a));return a},weekOfDateIsDisabled:function(b){return-1!==a.inArray(b.getUTCDay(),this.o.daysOfWeekDisabled)},dateIsDisabled:function(b){return this.weekOfDateIsDisabled(b)||a.grep(this.o.datesDisabled,function(a){return e(b,a)}).length>0},dateWithinRange:function(a){return a>=this.o.startDate&&a<=this.o.endDate},keydown:function(a){if(!this.picker.is(":visible"))return void((40===a.keyCode||27===a.keyCode)&&(this.show(),a.stopPropagation()));var b,c,d=!1,e=this.focusDate||this.viewDate;switch(a.keyCode){case 27:this.focusDate?(this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill()):this.hide(),a.preventDefault(),a.stopPropagation();break;case 37:case 38:case 39:case 40:if(!this.o.keyboardNavigation||7===this.o.daysOfWeekDisabled.length)break;b=37===a.keyCode||38===a.keyCode?-1:1,0===this.viewMode?a.ctrlKey?(c=this.moveAvailableDate(e,b,"moveYear"),c&&this._trigger("changeYear",this.viewDate)):a.shiftKey?(c=this.moveAvailableDate(e,b,"moveMonth"),c&&this._trigger("changeMonth",this.viewDate)):37===a.keyCode||39===a.keyCode?c=this.moveAvailableDate(e,b,"moveDay"):this.weekOfDateIsDisabled(e)||(c=this.moveAvailableDate(e,b,"moveWeek")):1===this.viewMode?((38===a.keyCode||40===a.keyCode)&&(b=4*b),c=this.moveAvailableDate(e,b,"moveMonth")):2===this.viewMode&&((38===a.keyCode||40===a.keyCode)&&(b=4*b),c=this.moveAvailableDate(e,b,"moveYear")),c&&(this.focusDate=this.viewDate=c,this.setValue(),this.fill(),a.preventDefault());break;case 13:if(!this.o.forceParse)break;e=this.focusDate||this.dates.get(-1)||this.viewDate,this.o.keyboardNavigation&&(this._toggle_multidate(e),d=!0),this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.setValue(),this.fill(),this.picker.is(":visible")&&(a.preventDefault(),a.stopPropagation(),this.o.autoclose&&this.hide());break;case 9:this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill(),this.hide()}d&&(this.dates.length?this._trigger("changeDate"):this._trigger("clearDate"),this.inputField&&this.inputField.change())},showMode:function(a){a&&(this.viewMode=Math.max(this.o.minViewMode,Math.min(this.o.maxViewMode,this.viewMode+a))),this.picker.children("div").hide().filter(".datepicker-"+r.modes[this.viewMode].clsName).show(),this.updateNavArrows()}};var l=function(b,c){a(b).data("datepicker",this),this.element=a(b),this.inputs=a.map(c.inputs,function(a){return a.jquery?a[0]:a}),delete c.inputs,n.call(a(this.inputs),c).on("changeDate",a.proxy(this.dateUpdated,this)),this.pickers=a.map(this.inputs,function(b){return a(b).data("datepicker")}),this.updateDates()};l.prototype={updateDates:function(){this.dates=a.map(this.pickers,function(a){return a.getUTCDate()}),this.updateRanges()},updateRanges:function(){var b=a.map(this.dates,function(a){return a.valueOf()});a.each(this.pickers,function(a,c){c.setRange(b)})},dateUpdated:function(b){if(!this.updating){this.updating=!0;var c=a(b.target).data("datepicker");if("undefined"!=typeof c){var d=c.getUTCDate(),e=a.inArray(b.target,this.inputs),f=e-1,g=e+1,h=this.inputs.length;if(-1!==e){if(a.each(this.pickers,function(a,b){b.getUTCDate()||b.setUTCDate(d)}),d<this.dates[f])for(;f>=0&&d<this.dates[f];)this.pickers[f--].setUTCDate(d);else if(d>this.dates[g])for(;h>g&&d>this.dates[g];)this.pickers[g++].setUTCDate(d);this.updateDates(),delete this.updating}}}},remove:function(){a.map(this.pickers,function(a){a.remove()}),delete this.element.data().datepicker}};var m=a.fn.datepicker,n=function(c){var d=Array.apply(null,arguments);d.shift();var e;if(this.each(function(){var b=a(this),f=b.data("datepicker"),g="object"==typeof c&&c;if(!f){var j=h(this,"date"),m=a.extend({},o,j,g),n=i(m.language),p=a.extend({},o,n,j,g);b.hasClass("input-daterange")||p.inputs?(a.extend(p,{inputs:p.inputs||b.find("input").toArray()}),f=new l(this,p)):f=new k(this,p),b.data("datepicker",f)}"string"==typeof c&&"function"==typeof f[c]&&(e=f[c].apply(f,d))}),e===b||e instanceof k||e instanceof l)return this;if(this.length>1)throw new Error("Using only allowed for the collection of a single element ("+c+" function)");return e};a.fn.datepicker=n;var o=a.fn.datepicker.defaults={assumeNearbyYear:!1,autoclose:!1,beforeShowDay:a.noop,beforeShowMonth:a.noop,beforeShowYear:a.noop,beforeShowDecade:a.noop,beforeShowCentury:a.noop,calendarWeeks:!1,clearBtn:!1,toggleActive:!1,daysOfWeekDisabled:[],daysOfWeekHighlighted:[],datesDisabled:[],endDate:1/0,forceParse:!0,format:"mm/dd/yyyy",keyboardNavigation:!0,language:"en",minViewMode:0,maxViewMode:4,multidate:!1,multidateSeparator:",",orientation:"auto",rtl:!1,startDate:-(1/0),startView:0,todayBtn:!1,todayHighlight:!1,weekStart:0,disableTouchKeyboard:!1,enableOnReadonly:!0,showOnFocus:!0,zIndexOffset:10,container:"body",immediateUpdates:!1,title:"",templates:{leftArrow:"&laquo;",rightArrow:"&raquo;"}},p=a.fn.datepicker.locale_opts=["format","rtl","weekStart"];a.fn.datepicker.Constructor=k;var q=a.fn.datepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today",clear:"Clear",titleFormat:"MM yyyy"}},r={modes:[{clsName:"days",navFnc:"Month",navStep:1},{clsName:"months",navFnc:"FullYear",navStep:1},{clsName:"years",navFnc:"FullYear",navStep:10},{clsName:"decades",navFnc:"FullDecade",navStep:100},{clsName:"centuries",navFnc:"FullCentury",navStep:1e3}],isLeapYear:function(a){return a%4===0&&a%100!==0||a%400===0},getDaysInMonth:function(a,b){return[31,r.isLeapYear(a)?29:28,31,30,31,30,31,31,30,31,30,31][b]},validParts:/dd?|DD?|mm?|MM?|yy(?:yy)?/g,nonpunctuation:/[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,parseFormat:function(a){if("function"==typeof a.toValue&&"function"==typeof a.toDisplay)return a;var b=a.replace(this.validParts,"\x00").split("\x00"),c=a.match(this.validParts);if(!b||!b.length||!c||0===c.length)throw new Error("Invalid date format.");return{separators:b,parts:c}},parseDate:function(e,f,g,h){function i(a,b){return b===!0&&(b=10),100>a&&(a+=2e3,a>(new Date).getFullYear()+b&&(a-=100)),a}function j(){var a=this.slice(0,s[n].length),b=s[n].slice(0,a.length);return a.toLowerCase()===b.toLowerCase()}if(!e)return b;if(e instanceof Date)return e;if("string"==typeof f&&(f=r.parseFormat(f)),f.toValue)return f.toValue(e,f,g);var l,m,n,o,p=/([\-+]\d+)([dmwy])/,s=e.match(/([\-+]\d+)([dmwy])/g),t={d:"moveDay",m:"moveMonth",w:"moveWeek",y:"moveYear"},u={yesterday:"-1d",today:"+0d",tomorrow:"+1d"};if(/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(e)){for(e=new Date,n=0;n<s.length;n++)l=p.exec(s[n]),m=parseInt(l[1]),o=t[l[2]],e=k.prototype[o](e,m);return c(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate())}if("undefined"!=typeof u[e]&&(e=u[e],s=e.match(/([\-+]\d+)([dmwy])/g),/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(e))){for(e=new Date,n=0;n<s.length;n++)l=p.exec(s[n]),m=parseInt(l[1]),o=t[l[2]],e=k.prototype[o](e,m);return c(e.getUTCFullYear(),e.getUTCMonth(),e.getUTCDate())}s=e&&e.match(this.nonpunctuation)||[],e=new Date;var v,w,x={},y=["yyyy","yy","M","MM","m","mm","d","dd"],z={yyyy:function(a,b){return a.setUTCFullYear(h?i(b,h):b)},yy:function(a,b){return a.setUTCFullYear(h?i(b,h):b)},m:function(a,b){if(isNaN(a))return a;for(b-=1;0>b;)b+=12;for(b%=12,a.setUTCMonth(b);a.getUTCMonth()!==b;)a.setUTCDate(a.getUTCDate()-1);return a},d:function(a,b){return a.setUTCDate(b)}};z.M=z.MM=z.mm=z.m,z.dd=z.d,e=d();var A=f.parts.slice();if(s.length!==A.length&&(A=a(A).filter(function(b,c){return-1!==a.inArray(c,y)}).toArray()),s.length===A.length){var B;for(n=0,B=A.length;B>n;n++){if(v=parseInt(s[n],10),l=A[n],isNaN(v))switch(l){case"MM":w=a(q[g].months).filter(j),v=a.inArray(w[0],q[g].months)+1;break;case"M":w=a(q[g].monthsShort).filter(j),v=a.inArray(w[0],q[g].monthsShort)+1}x[l]=v}var C,D;for(n=0;n<y.length;n++)D=y[n],D in x&&!isNaN(x[D])&&(C=new Date(e),z[D](C,x[D]),isNaN(C)||(e=C))}return e},formatDate:function(b,c,d){if(!b)return"";if("string"==typeof c&&(c=r.parseFormat(c)),
c.toDisplay)return c.toDisplay(b,c,d);var e={d:b.getUTCDate(),D:q[d].daysShort[b.getUTCDay()],DD:q[d].days[b.getUTCDay()],m:b.getUTCMonth()+1,M:q[d].monthsShort[b.getUTCMonth()],MM:q[d].months[b.getUTCMonth()],yy:b.getUTCFullYear().toString().substring(2),yyyy:b.getUTCFullYear()};e.dd=(e.d<10?"0":"")+e.d,e.mm=(e.m<10?"0":"")+e.m,b=[];for(var f=a.extend([],c.separators),g=0,h=c.parts.length;h>=g;g++)f.length&&b.push(f.shift()),b.push(e[c.parts[g]]);return b.join("")},headTemplate:'<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">&laquo;</th><th colspan="5" class="datepicker-switch"></th><th class="next">&raquo;</th></tr></thead>',contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'};r.template='<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">'+r.headTemplate+"<tbody></tbody>"+r.footTemplate+'</table></div><div class="datepicker-months"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-years"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-decades"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-centuries"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+"</table></div></div>",a.fn.datepicker.DPGlobal=r,a.fn.datepicker.noConflict=function(){return a.fn.datepicker=m,this},a.fn.datepicker.version="1.6.4",a(document).on("focus.datepicker.data-api click.datepicker.data-api",'[data-provide="datepicker"]',function(b){var c=a(this);c.data("datepicker")||(b.preventDefault(),n.call(c,"show"))}),a(function(){n.call(a('[data-provide="datepicker-inline"]'))})});
!function(a){a.fn.datepicker.dates.pt={days:["Domingo","Segunda","Terça","Quarta","Quinta","Sexta","Sábado"],daysShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],daysMin:["Do","Se","Te","Qu","Qu","Se","Sa"],months:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthsShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],today:"Hoje",monthsTitle:"Meses",clear:"Limpar",format:"dd/mm/yyyy"}}(jQuery);
!function(a){a.fn.datepicker.dates["en-GB"]={days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today",monthsTitle:"Months",clear:"Clear",weekStart:1,format:"dd/mm/yyyy"}}(jQuery);
/*!
 * ClockPicker v0.0.7 (http://weareoutman.github.io/clockpicker/)
 * Copyright 2014 Wang Shenwei.
 * Licensed under MIT (https://github.com/weareoutman/clockpicker/blob/gh-pages/LICENSE)
 */
!function(){function t(t){return document.createElementNS(p,t)}function i(t){return(10>t?"0":"")+t}function e(t){var i=++m+"";return t?t+i:i}function s(s,r){function p(t,i){var e=u.offset(),s=/^touch/.test(t.type),o=e.left+b,n=e.top+b,p=(s?t.originalEvent.touches[0]:t).pageX-o,h=(s?t.originalEvent.touches[0]:t).pageY-n,k=Math.sqrt(p*p+h*h),v=!1;if(!i||!(g-y>k||k>g+y)){t.preventDefault();var m=setTimeout(function(){c.addClass("clockpicker-moving")},200);l&&u.append(x.canvas),x.setHand(p,h,!i,!0),a.off(d).on(d,function(t){t.preventDefault();var i=/^touch/.test(t.type),e=(i?t.originalEvent.touches[0]:t).pageX-o,s=(i?t.originalEvent.touches[0]:t).pageY-n;(v||e!==p||s!==h)&&(v=!0,x.setHand(e,s,!1,!0))}),a.off(f).on(f,function(t){a.off(f),t.preventDefault();var e=/^touch/.test(t.type),s=(e?t.originalEvent.changedTouches[0]:t).pageX-o,l=(e?t.originalEvent.changedTouches[0]:t).pageY-n;(i||v)&&s===p&&l===h&&x.setHand(s,l),"hours"===x.currentView?x.toggleView("minutes",A/2):r.autoclose&&(x.minutesView.addClass("clockpicker-dial-out"),setTimeout(function(){x.done()},A/2)),u.prepend(j),clearTimeout(m),c.removeClass("clockpicker-moving"),a.off(d)})}}var h=n(V),u=h.find(".clockpicker-plate"),v=h.find(".clockpicker-hours"),m=h.find(".clockpicker-minutes"),T=h.find(".clockpicker-am-pm-block"),C="INPUT"===s.prop("tagName"),H=C?s:s.find("input"),P=s.find(".input-group-addon"),x=this;if(this.id=e("cp"),this.element=s,this.options=r,this.isAppended=!1,this.isShown=!1,this.currentView="hours",this.isInput=C,this.input=H,this.addon=P,this.popover=h,this.plate=u,this.hoursView=v,this.minutesView=m,this.amPmBlock=T,this.spanHours=h.find(".clockpicker-span-hours"),this.spanMinutes=h.find(".clockpicker-span-minutes"),this.spanAmPm=h.find(".clockpicker-span-am-pm"),this.amOrPm="PM",r.twelvehour){{var S=['<div class="clockpicker-am-pm-block">','<button type="button" class="btn btn-sm btn-default clockpicker-button clockpicker-am-button">',"AM</button>",'<button type="button" class="btn btn-sm btn-default clockpicker-button clockpicker-pm-button">',"PM</button>","</div>"].join("");n(S)}n('<button type="button" class="btn btn-sm btn-default clockpicker-button am-button">AM</button>').on("click",function(){x.amOrPm="AM",n(".clockpicker-span-am-pm").empty().append("AM")}).appendTo(this.amPmBlock),n('<button type="button" class="btn btn-sm btn-default clockpicker-button pm-button">PM</button>').on("click",function(){x.amOrPm="PM",n(".clockpicker-span-am-pm").empty().append("PM")}).appendTo(this.amPmBlock)}r.autoclose||n('<button type="button" class="btn btn-sm btn-default btn-block clockpicker-button">'+r.donetext+"</button>").click(n.proxy(this.done,this)).appendTo(h),"top"!==r.placement&&"bottom"!==r.placement||"top"!==r.align&&"bottom"!==r.align||(r.align="left"),"left"!==r.placement&&"right"!==r.placement||"left"!==r.align&&"right"!==r.align||(r.align="top"),h.addClass(r.placement),h.addClass("clockpicker-align-"+r.align),this.spanHours.click(n.proxy(this.toggleView,this,"hours")),this.spanMinutes.click(n.proxy(this.toggleView,this,"minutes")),H.on("focus.clockpicker click.clockpicker",n.proxy(this.show,this)),P.on("click.clockpicker",n.proxy(this.toggle,this));var E,D,I,B,z=n('<div class="clockpicker-tick"></div>');if(r.twelvehour)for(E=1;13>E;E+=1)D=z.clone(),I=E/6*Math.PI,B=g,D.css("font-size","120%"),D.css({left:b+Math.sin(I)*B-y,top:b-Math.cos(I)*B-y}),D.html(0===E?"00":E),v.append(D),D.on(k,p);else for(E=0;24>E;E+=1){D=z.clone(),I=E/6*Math.PI;var O=E>0&&13>E;B=O?w:g,D.css({left:b+Math.sin(I)*B-y,top:b-Math.cos(I)*B-y}),O&&D.css("font-size","120%"),D.html(0===E?"00":E),v.append(D),D.on(k,p)}for(E=0;60>E;E+=5)D=z.clone(),I=E/30*Math.PI,D.css({left:b+Math.sin(I)*g-y,top:b-Math.cos(I)*g-y}),D.css("font-size","120%"),D.html(i(E)),m.append(D),D.on(k,p);if(u.on(k,function(t){0===n(t.target).closest(".clockpicker-tick").length&&p(t,!0)}),l){var j=h.find(".clockpicker-canvas"),L=t("svg");L.setAttribute("class","clockpicker-svg"),L.setAttribute("width",M),L.setAttribute("height",M);var U=t("g");U.setAttribute("transform","translate("+b+","+b+")");var W=t("circle");W.setAttribute("class","clockpicker-canvas-bearing"),W.setAttribute("cx",0),W.setAttribute("cy",0),W.setAttribute("r",2);var N=t("line");N.setAttribute("x1",0),N.setAttribute("y1",0);var X=t("circle");X.setAttribute("class","clockpicker-canvas-bg"),X.setAttribute("r",y);var Y=t("circle");Y.setAttribute("class","clockpicker-canvas-fg"),Y.setAttribute("r",3.5),U.appendChild(N),U.appendChild(X),U.appendChild(Y),U.appendChild(W),L.appendChild(U),j.append(L),this.hand=N,this.bg=X,this.fg=Y,this.bearing=W,this.g=U,this.canvas=j}o(this.options.init)}function o(t){t&&"function"==typeof t&&t()}var c,n=window.jQuery,r=n(window),a=n(document),p="http://www.w3.org/2000/svg",l="SVGAngle"in window&&function(){var t,i=document.createElement("div");return i.innerHTML="<svg/>",t=(i.firstChild&&i.firstChild.namespaceURI)==p,i.innerHTML="",t}(),h=function(){var t=document.createElement("div").style;return"transition"in t||"WebkitTransition"in t||"MozTransition"in t||"msTransition"in t||"OTransition"in t}(),u="ontouchstart"in window,k="mousedown"+(u?" touchstart":""),d="mousemove.clockpicker"+(u?" touchmove.clockpicker":""),f="mouseup.clockpicker"+(u?" touchend.clockpicker":""),v=navigator.vibrate?"vibrate":navigator.webkitVibrate?"webkitVibrate":null,m=0,b=100,g=80,w=54,y=13,M=2*b,A=h?350:1,V=['<div class="popover clockpicker-popover">','<div class="arrow"></div>','<div class="popover-title">','<span class="clockpicker-span-hours text-primary"></span>'," : ",'<span class="clockpicker-span-minutes"></span>','<span class="clockpicker-span-am-pm"></span>',"</div>",'<div class="popover-content">','<div class="clockpicker-plate">','<div class="clockpicker-canvas"></div>','<div class="clockpicker-dial clockpicker-hours"></div>','<div class="clockpicker-dial clockpicker-minutes clockpicker-dial-out"></div>',"</div>",'<span class="clockpicker-am-pm-block">',"</span>","</div>","</div>"].join("");s.DEFAULTS={"default":"",fromnow:0,placement:"bottom",align:"left",donetext:"完成",autoclose:!1,twelvehour:!1,vibrate:!0},s.prototype.toggle=function(){this[this.isShown?"hide":"show"]()},s.prototype.locate=function(){var t=this.element,i=this.popover,e=t.offset(),s=t.outerWidth(),o=t.outerHeight(),c=this.options.placement,n=this.options.align,r={};switch(i.show(),c){case"bottom":r.top=e.top+o;break;case"right":r.left=e.left+s;break;case"top":r.top=e.top-i.outerHeight();break;case"left":r.left=e.left-i.outerWidth()}switch(n){case"left":r.left=e.left;break;case"right":r.left=e.left+s-i.outerWidth();break;case"top":r.top=e.top;break;case"bottom":r.top=e.top+o-i.outerHeight()}i.css(r)},s.prototype.show=function(){if(!this.isShown){o(this.options.beforeShow);var t=this;this.isAppended||(c=n(document.body).append(this.popover),r.on("resize.clockpicker"+this.id,function(){t.isShown&&t.locate()}),this.isAppended=!0);var e=((this.input.prop("value")||this.options["default"]||"")+"").split(":");if("now"===e[0]){var s=new Date(+new Date+this.options.fromnow);e=[s.getHours(),s.getMinutes()]}this.hours=+e[0]||0,this.minutes=+e[1]||0,this.spanHours.html(i(this.hours)),this.spanMinutes.html(i(this.minutes)),this.toggleView("hours"),this.locate(),this.isShown=!0,a.on("click.clockpicker."+this.id+" focusin.clockpicker."+this.id,function(i){var e=n(i.target);0===e.closest(t.popover).length&&0===e.closest(t.addon).length&&0===e.closest(t.input).length&&t.hide()}),a.on("keyup.clockpicker."+this.id,function(i){27===i.keyCode&&t.hide()}),o(this.options.afterShow)}},s.prototype.hide=function(){o(this.options.beforeHide),this.isShown=!1,a.off("click.clockpicker."+this.id+" focusin.clockpicker."+this.id),a.off("keyup.clockpicker."+this.id),this.popover.hide(),o(this.options.afterHide)},s.prototype.toggleView=function(t,i){var e=!1;"minutes"===t&&"visible"===n(this.hoursView).css("visibility")&&(o(this.options.beforeHourSelect),e=!0);var s="hours"===t,c=s?this.hoursView:this.minutesView,r=s?this.minutesView:this.hoursView;this.currentView=t,this.spanHours.toggleClass("text-primary",s),this.spanMinutes.toggleClass("text-primary",!s),r.addClass("clockpicker-dial-out"),c.css("visibility","visible").removeClass("clockpicker-dial-out"),this.resetClock(i),clearTimeout(this.toggleViewTimer),this.toggleViewTimer=setTimeout(function(){r.css("visibility","hidden")},A),e&&o(this.options.afterHourSelect)},s.prototype.resetClock=function(t){var i=this.currentView,e=this[i],s="hours"===i,o=Math.PI/(s?6:30),c=e*o,n=s&&e>0&&13>e?w:g,r=Math.sin(c)*n,a=-Math.cos(c)*n,p=this;l&&t?(p.canvas.addClass("clockpicker-canvas-out"),setTimeout(function(){p.canvas.removeClass("clockpicker-canvas-out"),p.setHand(r,a)},t)):this.setHand(r,a)},s.prototype.setHand=function(t,e,s,o){var c,r=Math.atan2(t,-e),a="hours"===this.currentView,p=Math.PI/(a||s?6:30),h=Math.sqrt(t*t+e*e),u=this.options,k=a&&(g+w)/2>h,d=k?w:g;if(u.twelvehour&&(d=g),0>r&&(r=2*Math.PI+r),c=Math.round(r/p),r=c*p,u.twelvehour?a?0===c&&(c=12):(s&&(c*=5),60===c&&(c=0)):a?(12===c&&(c=0),c=k?0===c?12:c:0===c?0:c+12):(s&&(c*=5),60===c&&(c=0)),this[this.currentView]!==c&&v&&this.options.vibrate&&(this.vibrateTimer||(navigator[v](10),this.vibrateTimer=setTimeout(n.proxy(function(){this.vibrateTimer=null},this),100))),this[this.currentView]=c,this[a?"spanHours":"spanMinutes"].html(i(c)),!l)return void this[a?"hoursView":"minutesView"].find(".clockpicker-tick").each(function(){var t=n(this);t.toggleClass("active",c===+t.html())});o||!a&&c%5?(this.g.insertBefore(this.hand,this.bearing),this.g.insertBefore(this.bg,this.fg),this.bg.setAttribute("class","clockpicker-canvas-bg clockpicker-canvas-bg-trans")):(this.g.insertBefore(this.hand,this.bg),this.g.insertBefore(this.fg,this.bg),this.bg.setAttribute("class","clockpicker-canvas-bg"));var f=Math.sin(r)*d,m=-Math.cos(r)*d;this.hand.setAttribute("x2",f),this.hand.setAttribute("y2",m),this.bg.setAttribute("cx",f),this.bg.setAttribute("cy",m),this.fg.setAttribute("cx",f),this.fg.setAttribute("cy",m)},s.prototype.done=function(){o(this.options.beforeDone),this.hide();var t=this.input.prop("value"),e=i(this.hours)+":"+i(this.minutes);this.options.twelvehour&&(e+=this.amOrPm),this.input.prop("value",e),e!==t&&(this.input.triggerHandler("change"),this.isInput||this.element.trigger("change")),this.options.autoclose&&this.input.trigger("blur"),o(this.options.afterDone)},s.prototype.remove=function(){this.element.removeData("clockpicker"),this.input.off("focus.clockpicker click.clockpicker"),this.addon.off("click.clockpicker"),this.isShown&&this.hide(),this.isAppended&&(r.off("resize.clockpicker"+this.id),this.popover.remove())},n.fn.clockpicker=function(t){var i=Array.prototype.slice.call(arguments,1);return this.each(function(){var e=n(this),o=e.data("clockpicker");if(o)"function"==typeof o[t]&&o[t].apply(o,i);else{var c=n.extend({},s.DEFAULTS,e.data(),"object"==typeof t&&t);e.data("clockpicker",new s(e,c))}})}}();
/*! Select2 4.0.3 | https://github.com/select2/select2/blob/master/LICENSE.md */!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a("object"==typeof exports?require("jquery"):jQuery)}(function(a){var b=function(){if(a&&a.fn&&a.fn.select2&&a.fn.select2.amd)var b=a.fn.select2.amd;var b;return function(){if(!b||!b.requirejs){b?c=b:b={};var a,c,d;!function(b){function e(a,b){return u.call(a,b)}function f(a,b){var c,d,e,f,g,h,i,j,k,l,m,n=b&&b.split("/"),o=s.map,p=o&&o["*"]||{};if(a&&"."===a.charAt(0))if(b){for(a=a.split("/"),g=a.length-1,s.nodeIdCompat&&w.test(a[g])&&(a[g]=a[g].replace(w,"")),a=n.slice(0,n.length-1).concat(a),k=0;k<a.length;k+=1)if(m=a[k],"."===m)a.splice(k,1),k-=1;else if(".."===m){if(1===k&&(".."===a[2]||".."===a[0]))break;k>0&&(a.splice(k-1,2),k-=2)}a=a.join("/")}else 0===a.indexOf("./")&&(a=a.substring(2));if((n||p)&&o){for(c=a.split("/"),k=c.length;k>0;k-=1){if(d=c.slice(0,k).join("/"),n)for(l=n.length;l>0;l-=1)if(e=o[n.slice(0,l).join("/")],e&&(e=e[d])){f=e,h=k;break}if(f)break;!i&&p&&p[d]&&(i=p[d],j=k)}!f&&i&&(f=i,h=j),f&&(c.splice(0,h,f),a=c.join("/"))}return a}function g(a,c){return function(){var d=v.call(arguments,0);return"string"!=typeof d[0]&&1===d.length&&d.push(null),n.apply(b,d.concat([a,c]))}}function h(a){return function(b){return f(b,a)}}function i(a){return function(b){q[a]=b}}function j(a){if(e(r,a)){var c=r[a];delete r[a],t[a]=!0,m.apply(b,c)}if(!e(q,a)&&!e(t,a))throw new Error("No "+a);return q[a]}function k(a){var b,c=a?a.indexOf("!"):-1;return c>-1&&(b=a.substring(0,c),a=a.substring(c+1,a.length)),[b,a]}function l(a){return function(){return s&&s.config&&s.config[a]||{}}}var m,n,o,p,q={},r={},s={},t={},u=Object.prototype.hasOwnProperty,v=[].slice,w=/\.js$/;o=function(a,b){var c,d=k(a),e=d[0];return a=d[1],e&&(e=f(e,b),c=j(e)),e?a=c&&c.normalize?c.normalize(a,h(b)):f(a,b):(a=f(a,b),d=k(a),e=d[0],a=d[1],e&&(c=j(e))),{f:e?e+"!"+a:a,n:a,pr:e,p:c}},p={require:function(a){return g(a)},exports:function(a){var b=q[a];return"undefined"!=typeof b?b:q[a]={}},module:function(a){return{id:a,uri:"",exports:q[a],config:l(a)}}},m=function(a,c,d,f){var h,k,l,m,n,s,u=[],v=typeof d;if(f=f||a,"undefined"===v||"function"===v){for(c=!c.length&&d.length?["require","exports","module"]:c,n=0;n<c.length;n+=1)if(m=o(c[n],f),k=m.f,"require"===k)u[n]=p.require(a);else if("exports"===k)u[n]=p.exports(a),s=!0;else if("module"===k)h=u[n]=p.module(a);else if(e(q,k)||e(r,k)||e(t,k))u[n]=j(k);else{if(!m.p)throw new Error(a+" missing "+k);m.p.load(m.n,g(f,!0),i(k),{}),u[n]=q[k]}l=d?d.apply(q[a],u):void 0,a&&(h&&h.exports!==b&&h.exports!==q[a]?q[a]=h.exports:l===b&&s||(q[a]=l))}else a&&(q[a]=d)},a=c=n=function(a,c,d,e,f){if("string"==typeof a)return p[a]?p[a](c):j(o(a,c).f);if(!a.splice){if(s=a,s.deps&&n(s.deps,s.callback),!c)return;c.splice?(a=c,c=d,d=null):a=b}return c=c||function(){},"function"==typeof d&&(d=e,e=f),e?m(b,a,c,d):setTimeout(function(){m(b,a,c,d)},4),n},n.config=function(a){return n(a)},a._defined=q,d=function(a,b,c){if("string"!=typeof a)throw new Error("See almond README: incorrect module build, no module name");b.splice||(c=b,b=[]),e(q,a)||e(r,a)||(r[a]=[a,b,c])},d.amd={jQuery:!0}}(),b.requirejs=a,b.require=c,b.define=d}}(),b.define("almond",function(){}),b.define("jquery",[],function(){var b=a||$;return null==b&&console&&console.error&&console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."),b}),b.define("select2/utils",["jquery"],function(a){function b(a){var b=a.prototype,c=[];for(var d in b){var e=b[d];"function"==typeof e&&"constructor"!==d&&c.push(d)}return c}var c={};c.Extend=function(a,b){function c(){this.constructor=a}var d={}.hasOwnProperty;for(var e in b)d.call(b,e)&&(a[e]=b[e]);return c.prototype=b.prototype,a.prototype=new c,a.__super__=b.prototype,a},c.Decorate=function(a,c){function d(){var b=Array.prototype.unshift,d=c.prototype.constructor.length,e=a.prototype.constructor;d>0&&(b.call(arguments,a.prototype.constructor),e=c.prototype.constructor),e.apply(this,arguments)}function e(){this.constructor=d}var f=b(c),g=b(a);c.displayName=a.displayName,d.prototype=new e;for(var h=0;h<g.length;h++){var i=g[h];d.prototype[i]=a.prototype[i]}for(var j=(function(a){var b=function(){};a in d.prototype&&(b=d.prototype[a]);var e=c.prototype[a];return function(){var a=Array.prototype.unshift;return a.call(arguments,b),e.apply(this,arguments)}}),k=0;k<f.length;k++){var l=f[k];d.prototype[l]=j(l)}return d};var d=function(){this.listeners={}};return d.prototype.on=function(a,b){this.listeners=this.listeners||{},a in this.listeners?this.listeners[a].push(b):this.listeners[a]=[b]},d.prototype.trigger=function(a){var b=Array.prototype.slice,c=b.call(arguments,1);this.listeners=this.listeners||{},null==c&&(c=[]),0===c.length&&c.push({}),c[0]._type=a,a in this.listeners&&this.invoke(this.listeners[a],b.call(arguments,1)),"*"in this.listeners&&this.invoke(this.listeners["*"],arguments)},d.prototype.invoke=function(a,b){for(var c=0,d=a.length;d>c;c++)a[c].apply(this,b)},c.Observable=d,c.generateChars=function(a){for(var b="",c=0;a>c;c++){var d=Math.floor(36*Math.random());b+=d.toString(36)}return b},c.bind=function(a,b){return function(){a.apply(b,arguments)}},c._convertData=function(a){for(var b in a){var c=b.split("-"),d=a;if(1!==c.length){for(var e=0;e<c.length;e++){var f=c[e];f=f.substring(0,1).toLowerCase()+f.substring(1),f in d||(d[f]={}),e==c.length-1&&(d[f]=a[b]),d=d[f]}delete a[b]}}return a},c.hasScroll=function(b,c){var d=a(c),e=c.style.overflowX,f=c.style.overflowY;return e!==f||"hidden"!==f&&"visible"!==f?"scroll"===e||"scroll"===f?!0:d.innerHeight()<c.scrollHeight||d.innerWidth()<c.scrollWidth:!1},c.escapeMarkup=function(a){var b={"\\":"&#92;","&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#47;"};return"string"!=typeof a?a:String(a).replace(/[&<>"'\/\\]/g,function(a){return b[a]})},c.appendMany=function(b,c){if("1.7"===a.fn.jquery.substr(0,3)){var d=a();a.map(c,function(a){d=d.add(a)}),c=d}b.append(c)},c}),b.define("select2/results",["jquery","./utils"],function(a,b){function c(a,b,d){this.$element=a,this.data=d,this.options=b,c.__super__.constructor.call(this)}return b.Extend(c,b.Observable),c.prototype.render=function(){var b=a('<ul class="select2-results__options" role="tree"></ul>');return this.options.get("multiple")&&b.attr("aria-multiselectable","true"),this.$results=b,b},c.prototype.clear=function(){this.$results.empty()},c.prototype.displayMessage=function(b){var c=this.options.get("escapeMarkup");this.clear(),this.hideLoading();var d=a('<li role="treeitem" aria-live="assertive" class="select2-results__option"></li>'),e=this.options.get("translations").get(b.message);d.append(c(e(b.args))),d[0].className+=" select2-results__message",this.$results.append(d)},c.prototype.hideMessages=function(){this.$results.find(".select2-results__message").remove()},c.prototype.append=function(a){this.hideLoading();var b=[];if(null==a.results||0===a.results.length)return void(0===this.$results.children().length&&this.trigger("results:message",{message:"noResults"}));a.results=this.sort(a.results);for(var c=0;c<a.results.length;c++){var d=a.results[c],e=this.option(d);b.push(e)}this.$results.append(b)},c.prototype.position=function(a,b){var c=b.find(".select2-results");c.append(a)},c.prototype.sort=function(a){var b=this.options.get("sorter");return b(a)},c.prototype.highlightFirstItem=function(){var a=this.$results.find(".select2-results__option[aria-selected]"),b=a.filter("[aria-selected=true]");b.length>0?b.first().trigger("mouseenter"):a.first().trigger("mouseenter"),this.ensureHighlightVisible()},c.prototype.setClasses=function(){var b=this;this.data.current(function(c){var d=a.map(c,function(a){return a.id.toString()}),e=b.$results.find(".select2-results__option[aria-selected]");e.each(function(){var b=a(this),c=a.data(this,"data"),e=""+c.id;null!=c.element&&c.element.selected||null==c.element&&a.inArray(e,d)>-1?b.attr("aria-selected","true"):b.attr("aria-selected","false")})})},c.prototype.showLoading=function(a){this.hideLoading();var b=this.options.get("translations").get("searching"),c={disabled:!0,loading:!0,text:b(a)},d=this.option(c);d.className+=" loading-results",this.$results.prepend(d)},c.prototype.hideLoading=function(){this.$results.find(".loading-results").remove()},c.prototype.option=function(b){var c=document.createElement("li");c.className="select2-results__option";var d={role:"treeitem","aria-selected":"false"};b.disabled&&(delete d["aria-selected"],d["aria-disabled"]="true"),null==b.id&&delete d["aria-selected"],null!=b._resultId&&(c.id=b._resultId),b.title&&(c.title=b.title),b.children&&(d.role="group",d["aria-label"]=b.text,delete d["aria-selected"]);for(var e in d){var f=d[e];c.setAttribute(e,f)}if(b.children){var g=a(c),h=document.createElement("strong");h.className="select2-results__group";a(h);this.template(b,h);for(var i=[],j=0;j<b.children.length;j++){var k=b.children[j],l=this.option(k);i.push(l)}var m=a("<ul></ul>",{"class":"select2-results__options select2-results__options--nested"});m.append(i),g.append(h),g.append(m)}else this.template(b,c);return a.data(c,"data",b),c},c.prototype.bind=function(b,c){var d=this,e=b.id+"-results";this.$results.attr("id",e),b.on("results:all",function(a){d.clear(),d.append(a.data),b.isOpen()&&(d.setClasses(),d.highlightFirstItem())}),b.on("results:append",function(a){d.append(a.data),b.isOpen()&&d.setClasses()}),b.on("query",function(a){d.hideMessages(),d.showLoading(a)}),b.on("select",function(){b.isOpen()&&(d.setClasses(),d.highlightFirstItem())}),b.on("unselect",function(){b.isOpen()&&(d.setClasses(),d.highlightFirstItem())}),b.on("open",function(){d.$results.attr("aria-expanded","true"),d.$results.attr("aria-hidden","false"),d.setClasses(),d.ensureHighlightVisible()}),b.on("close",function(){d.$results.attr("aria-expanded","false"),d.$results.attr("aria-hidden","true"),d.$results.removeAttr("aria-activedescendant")}),b.on("results:toggle",function(){var a=d.getHighlightedResults();0!==a.length&&a.trigger("mouseup")}),b.on("results:select",function(){var a=d.getHighlightedResults();if(0!==a.length){var b=a.data("data");"true"==a.attr("aria-selected")?d.trigger("close",{}):d.trigger("select",{data:b})}}),b.on("results:previous",function(){var a=d.getHighlightedResults(),b=d.$results.find("[aria-selected]"),c=b.index(a);if(0!==c){var e=c-1;0===a.length&&(e=0);var f=b.eq(e);f.trigger("mouseenter");var g=d.$results.offset().top,h=f.offset().top,i=d.$results.scrollTop()+(h-g);0===e?d.$results.scrollTop(0):0>h-g&&d.$results.scrollTop(i)}}),b.on("results:next",function(){var a=d.getHighlightedResults(),b=d.$results.find("[aria-selected]"),c=b.index(a),e=c+1;if(!(e>=b.length)){var f=b.eq(e);f.trigger("mouseenter");var g=d.$results.offset().top+d.$results.outerHeight(!1),h=f.offset().top+f.outerHeight(!1),i=d.$results.scrollTop()+h-g;0===e?d.$results.scrollTop(0):h>g&&d.$results.scrollTop(i)}}),b.on("results:focus",function(a){a.element.addClass("select2-results__option--highlighted")}),b.on("results:message",function(a){d.displayMessage(a)}),a.fn.mousewheel&&this.$results.on("mousewheel",function(a){var b=d.$results.scrollTop(),c=d.$results.get(0).scrollHeight-b+a.deltaY,e=a.deltaY>0&&b-a.deltaY<=0,f=a.deltaY<0&&c<=d.$results.height();e?(d.$results.scrollTop(0),a.preventDefault(),a.stopPropagation()):f&&(d.$results.scrollTop(d.$results.get(0).scrollHeight-d.$results.height()),a.preventDefault(),a.stopPropagation())}),this.$results.on("mouseup",".select2-results__option[aria-selected]",function(b){var c=a(this),e=c.data("data");return"true"===c.attr("aria-selected")?void(d.options.get("multiple")?d.trigger("unselect",{originalEvent:b,data:e}):d.trigger("close",{})):void d.trigger("select",{originalEvent:b,data:e})}),this.$results.on("mouseenter",".select2-results__option[aria-selected]",function(b){var c=a(this).data("data");d.getHighlightedResults().removeClass("select2-results__option--highlighted"),d.trigger("results:focus",{data:c,element:a(this)})})},c.prototype.getHighlightedResults=function(){var a=this.$results.find(".select2-results__option--highlighted");return a},c.prototype.destroy=function(){this.$results.remove()},c.prototype.ensureHighlightVisible=function(){var a=this.getHighlightedResults();if(0!==a.length){var b=this.$results.find("[aria-selected]"),c=b.index(a),d=this.$results.offset().top,e=a.offset().top,f=this.$results.scrollTop()+(e-d),g=e-d;f-=2*a.outerHeight(!1),2>=c?this.$results.scrollTop(0):(g>this.$results.outerHeight()||0>g)&&this.$results.scrollTop(f)}},c.prototype.template=function(b,c){var d=this.options.get("templateResult"),e=this.options.get("escapeMarkup"),f=d(b,c);null==f?c.style.display="none":"string"==typeof f?c.innerHTML=e(f):a(c).append(f)},c}),b.define("select2/keys",[],function(){var a={BACKSPACE:8,TAB:9,ENTER:13,SHIFT:16,CTRL:17,ALT:18,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46};return a}),b.define("select2/selection/base",["jquery","../utils","../keys"],function(a,b,c){function d(a,b){this.$element=a,this.options=b,d.__super__.constructor.call(this)}return b.Extend(d,b.Observable),d.prototype.render=function(){var b=a('<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>');return this._tabindex=0,null!=this.$element.data("old-tabindex")?this._tabindex=this.$element.data("old-tabindex"):null!=this.$element.attr("tabindex")&&(this._tabindex=this.$element.attr("tabindex")),b.attr("title",this.$element.attr("title")),b.attr("tabindex",this._tabindex),this.$selection=b,b},d.prototype.bind=function(a,b){var d=this,e=(a.id+"-container",a.id+"-results");this.container=a,this.$selection.on("focus",function(a){d.trigger("focus",a)}),this.$selection.on("blur",function(a){d._handleBlur(a)}),this.$selection.on("keydown",function(a){d.trigger("keypress",a),a.which===c.SPACE&&a.preventDefault()}),a.on("results:focus",function(a){d.$selection.attr("aria-activedescendant",a.data._resultId)}),a.on("selection:update",function(a){d.update(a.data)}),a.on("open",function(){d.$selection.attr("aria-expanded","true"),d.$selection.attr("aria-owns",e),d._attachCloseHandler(a)}),a.on("close",function(){d.$selection.attr("aria-expanded","false"),d.$selection.removeAttr("aria-activedescendant"),d.$selection.removeAttr("aria-owns"),d.$selection.focus(),d._detachCloseHandler(a)}),a.on("enable",function(){d.$selection.attr("tabindex",d._tabindex)}),a.on("disable",function(){d.$selection.attr("tabindex","-1")})},d.prototype._handleBlur=function(b){var c=this;window.setTimeout(function(){document.activeElement==c.$selection[0]||a.contains(c.$selection[0],document.activeElement)||c.trigger("blur",b)},1)},d.prototype._attachCloseHandler=function(b){a(document.body).on("mousedown.select2."+b.id,function(b){var c=a(b.target),d=c.closest(".select2"),e=a(".select2.select2-container--open");e.each(function(){var b=a(this);if(this!=d[0]){var c=b.data("element");c.select2("close")}})})},d.prototype._detachCloseHandler=function(b){a(document.body).off("mousedown.select2."+b.id)},d.prototype.position=function(a,b){var c=b.find(".selection");c.append(a)},d.prototype.destroy=function(){this._detachCloseHandler(this.container)},d.prototype.update=function(a){throw new Error("The `update` method must be defined in child classes.")},d}),b.define("select2/selection/single",["jquery","./base","../utils","../keys"],function(a,b,c,d){function e(){e.__super__.constructor.apply(this,arguments)}return c.Extend(e,b),e.prototype.render=function(){var a=e.__super__.render.call(this);return a.addClass("select2-selection--single"),a.html('<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'),a},e.prototype.bind=function(a,b){var c=this;e.__super__.bind.apply(this,arguments);var d=a.id+"-container";this.$selection.find(".select2-selection__rendered").attr("id",d),this.$selection.attr("aria-labelledby",d),this.$selection.on("mousedown",function(a){1===a.which&&c.trigger("toggle",{originalEvent:a})}),this.$selection.on("focus",function(a){}),this.$selection.on("blur",function(a){}),a.on("focus",function(b){a.isOpen()||c.$selection.focus()}),a.on("selection:update",function(a){c.update(a.data)})},e.prototype.clear=function(){this.$selection.find(".select2-selection__rendered").empty()},e.prototype.display=function(a,b){var c=this.options.get("templateSelection"),d=this.options.get("escapeMarkup");return d(c(a,b))},e.prototype.selectionContainer=function(){return a("<span></span>")},e.prototype.update=function(a){if(0===a.length)return void this.clear();var b=a[0],c=this.$selection.find(".select2-selection__rendered"),d=this.display(b,c);c.empty().append(d),c.prop("title",b.title||b.text)},e}),b.define("select2/selection/multiple",["jquery","./base","../utils"],function(a,b,c){function d(a,b){d.__super__.constructor.apply(this,arguments)}return c.Extend(d,b),d.prototype.render=function(){var a=d.__super__.render.call(this);return a.addClass("select2-selection--multiple"),a.html('<ul class="select2-selection__rendered"></ul>'),a},d.prototype.bind=function(b,c){var e=this;d.__super__.bind.apply(this,arguments),this.$selection.on("click",function(a){e.trigger("toggle",{originalEvent:a})}),this.$selection.on("click",".select2-selection__choice__remove",function(b){if(!e.options.get("disabled")){var c=a(this),d=c.parent(),f=d.data("data");e.trigger("unselect",{originalEvent:b,data:f})}})},d.prototype.clear=function(){this.$selection.find(".select2-selection__rendered").empty()},d.prototype.display=function(a,b){var c=this.options.get("templateSelection"),d=this.options.get("escapeMarkup");return d(c(a,b))},d.prototype.selectionContainer=function(){var b=a('<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>');return b},d.prototype.update=function(a){if(this.clear(),0!==a.length){for(var b=[],d=0;d<a.length;d++){var e=a[d],f=this.selectionContainer(),g=this.display(e,f);f.append(g),f.prop("title",e.title||e.text),f.data("data",e),b.push(f)}var h=this.$selection.find(".select2-selection__rendered");c.appendMany(h,b)}},d}),b.define("select2/selection/placeholder",["../utils"],function(a){function b(a,b,c){this.placeholder=this.normalizePlaceholder(c.get("placeholder")),a.call(this,b,c)}return b.prototype.normalizePlaceholder=function(a,b){return"string"==typeof b&&(b={id:"",text:b}),b},b.prototype.createPlaceholder=function(a,b){var c=this.selectionContainer();return c.html(this.display(b)),c.addClass("select2-selection__placeholder").removeClass("select2-selection__choice"),c},b.prototype.update=function(a,b){var c=1==b.length&&b[0].id!=this.placeholder.id,d=b.length>1;if(d||c)return a.call(this,b);this.clear();var e=this.createPlaceholder(this.placeholder);this.$selection.find(".select2-selection__rendered").append(e)},b}),b.define("select2/selection/allowClear",["jquery","../keys"],function(a,b){function c(){}return c.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),null==this.placeholder&&this.options.get("debug")&&window.console&&console.error&&console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."),this.$selection.on("mousedown",".select2-selection__clear",function(a){d._handleClear(a)}),b.on("keypress",function(a){d._handleKeyboardClear(a,b)})},c.prototype._handleClear=function(a,b){if(!this.options.get("disabled")){var c=this.$selection.find(".select2-selection__clear");if(0!==c.length){b.stopPropagation();for(var d=c.data("data"),e=0;e<d.length;e++){var f={data:d[e]};if(this.trigger("unselect",f),f.prevented)return}this.$element.val(this.placeholder.id).trigger("change"),this.trigger("toggle",{})}}},c.prototype._handleKeyboardClear=function(a,c,d){d.isOpen()||(c.which==b.DELETE||c.which==b.BACKSPACE)&&this._handleClear(c)},c.prototype.update=function(b,c){if(b.call(this,c),!(this.$selection.find(".select2-selection__placeholder").length>0||0===c.length)){var d=a('<span class="select2-selection__clear">&times;</span>');d.data("data",c),this.$selection.find(".select2-selection__rendered").prepend(d)}},c}),b.define("select2/selection/search",["jquery","../utils","../keys"],function(a,b,c){function d(a,b,c){a.call(this,b,c)}return d.prototype.render=function(b){var c=a('<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" aria-autocomplete="list" /></li>');this.$searchContainer=c,this.$search=c.find("input");var d=b.call(this);return this._transferTabIndex(),d},d.prototype.bind=function(a,b,d){var e=this;a.call(this,b,d),b.on("open",function(){e.$search.trigger("focus")}),b.on("close",function(){e.$search.val(""),e.$search.removeAttr("aria-activedescendant"),e.$search.trigger("focus")}),b.on("enable",function(){e.$search.prop("disabled",!1),e._transferTabIndex()}),b.on("disable",function(){e.$search.prop("disabled",!0)}),b.on("focus",function(a){e.$search.trigger("focus")}),b.on("results:focus",function(a){e.$search.attr("aria-activedescendant",a.id)}),this.$selection.on("focusin",".select2-search--inline",function(a){e.trigger("focus",a)}),this.$selection.on("focusout",".select2-search--inline",function(a){e._handleBlur(a)}),this.$selection.on("keydown",".select2-search--inline",function(a){a.stopPropagation(),e.trigger("keypress",a),e._keyUpPrevented=a.isDefaultPrevented();var b=a.which;if(b===c.BACKSPACE&&""===e.$search.val()){var d=e.$searchContainer.prev(".select2-selection__choice");if(d.length>0){var f=d.data("data");e.searchRemoveChoice(f),a.preventDefault()}}});var f=document.documentMode,g=f&&11>=f;this.$selection.on("input.searchcheck",".select2-search--inline",function(a){return g?void e.$selection.off("input.search input.searchcheck"):void e.$selection.off("keyup.search")}),this.$selection.on("keyup.search input.search",".select2-search--inline",function(a){if(g&&"input"===a.type)return void e.$selection.off("input.search input.searchcheck");var b=a.which;b!=c.SHIFT&&b!=c.CTRL&&b!=c.ALT&&b!=c.TAB&&e.handleSearch(a)})},d.prototype._transferTabIndex=function(a){this.$search.attr("tabindex",this.$selection.attr("tabindex")),this.$selection.attr("tabindex","-1")},d.prototype.createPlaceholder=function(a,b){this.$search.attr("placeholder",b.text)},d.prototype.update=function(a,b){var c=this.$search[0]==document.activeElement;this.$search.attr("placeholder",""),a.call(this,b),this.$selection.find(".select2-selection__rendered").append(this.$searchContainer),this.resizeSearch(),c&&this.$search.focus()},d.prototype.handleSearch=function(){if(this.resizeSearch(),!this._keyUpPrevented){var a=this.$search.val();this.trigger("query",{term:a})}this._keyUpPrevented=!1},d.prototype.searchRemoveChoice=function(a,b){this.trigger("unselect",{data:b}),this.$search.val(b.text),this.handleSearch()},d.prototype.resizeSearch=function(){this.$search.css("width","25px");var a="";if(""!==this.$search.attr("placeholder"))a=this.$selection.find(".select2-selection__rendered").innerWidth();else{var b=this.$search.val().length+1;a=.75*b+"em"}this.$search.css("width",a)},d}),b.define("select2/selection/eventRelay",["jquery"],function(a){function b(){}return b.prototype.bind=function(b,c,d){var e=this,f=["open","opening","close","closing","select","selecting","unselect","unselecting"],g=["opening","closing","selecting","unselecting"];b.call(this,c,d),c.on("*",function(b,c){if(-1!==a.inArray(b,f)){c=c||{};var d=a.Event("select2:"+b,{params:c});e.$element.trigger(d),-1!==a.inArray(b,g)&&(c.prevented=d.isDefaultPrevented())}})},b}),b.define("select2/translation",["jquery","require"],function(a,b){function c(a){this.dict=a||{}}return c.prototype.all=function(){return this.dict},c.prototype.get=function(a){return this.dict[a]},c.prototype.extend=function(b){this.dict=a.extend({},b.all(),this.dict)},c._cache={},c.loadPath=function(a){if(!(a in c._cache)){var d=b(a);c._cache[a]=d}return new c(c._cache[a])},c}),b.define("select2/diacritics",[],function(){var a={"Ⓐ":"A","Ａ":"A","À":"A","Á":"A","Â":"A","Ầ":"A","Ấ":"A","Ẫ":"A","Ẩ":"A","Ã":"A","Ā":"A","Ă":"A","Ằ":"A","Ắ":"A","Ẵ":"A","Ẳ":"A","Ȧ":"A","Ǡ":"A","Ä":"A","Ǟ":"A","Ả":"A","Å":"A","Ǻ":"A","Ǎ":"A","Ȁ":"A","Ȃ":"A","Ạ":"A","Ậ":"A","Ặ":"A","Ḁ":"A","Ą":"A","Ⱥ":"A","Ɐ":"A","Ꜳ":"AA","Æ":"AE","Ǽ":"AE","Ǣ":"AE","Ꜵ":"AO","Ꜷ":"AU","Ꜹ":"AV","Ꜻ":"AV","Ꜽ":"AY","Ⓑ":"B","Ｂ":"B","Ḃ":"B","Ḅ":"B","Ḇ":"B","Ƀ":"B","Ƃ":"B","Ɓ":"B","Ⓒ":"C","Ｃ":"C","Ć":"C","Ĉ":"C","Ċ":"C","Č":"C","Ç":"C","Ḉ":"C","Ƈ":"C","Ȼ":"C","Ꜿ":"C","Ⓓ":"D","Ｄ":"D","Ḋ":"D","Ď":"D","Ḍ":"D","Ḑ":"D","Ḓ":"D","Ḏ":"D","Đ":"D","Ƌ":"D","Ɗ":"D","Ɖ":"D","Ꝺ":"D","Ǳ":"DZ","Ǆ":"DZ","ǲ":"Dz","ǅ":"Dz","Ⓔ":"E","Ｅ":"E","È":"E","É":"E","Ê":"E","Ề":"E","Ế":"E","Ễ":"E","Ể":"E","Ẽ":"E","Ē":"E","Ḕ":"E","Ḗ":"E","Ĕ":"E","Ė":"E","Ë":"E","Ẻ":"E","Ě":"E","Ȅ":"E","Ȇ":"E","Ẹ":"E","Ệ":"E","Ȩ":"E","Ḝ":"E","Ę":"E","Ḙ":"E","Ḛ":"E","Ɛ":"E","Ǝ":"E","Ⓕ":"F","Ｆ":"F","Ḟ":"F","Ƒ":"F","Ꝼ":"F","Ⓖ":"G","Ｇ":"G","Ǵ":"G","Ĝ":"G","Ḡ":"G","Ğ":"G","Ġ":"G","Ǧ":"G","Ģ":"G","Ǥ":"G","Ɠ":"G","Ꞡ":"G","Ᵹ":"G","Ꝿ":"G","Ⓗ":"H","Ｈ":"H","Ĥ":"H","Ḣ":"H","Ḧ":"H","Ȟ":"H","Ḥ":"H","Ḩ":"H","Ḫ":"H","Ħ":"H","Ⱨ":"H","Ⱶ":"H","Ɥ":"H","Ⓘ":"I","Ｉ":"I","Ì":"I","Í":"I","Î":"I","Ĩ":"I","Ī":"I","Ĭ":"I","İ":"I","Ï":"I","Ḯ":"I","Ỉ":"I","Ǐ":"I","Ȉ":"I","Ȋ":"I","Ị":"I","Į":"I","Ḭ":"I","Ɨ":"I","Ⓙ":"J","Ｊ":"J","Ĵ":"J","Ɉ":"J","Ⓚ":"K","Ｋ":"K","Ḱ":"K","Ǩ":"K","Ḳ":"K","Ķ":"K","Ḵ":"K","Ƙ":"K","Ⱪ":"K","Ꝁ":"K","Ꝃ":"K","Ꝅ":"K","Ꞣ":"K","Ⓛ":"L","Ｌ":"L","Ŀ":"L","Ĺ":"L","Ľ":"L","Ḷ":"L","Ḹ":"L","Ļ":"L","Ḽ":"L","Ḻ":"L","Ł":"L","Ƚ":"L","Ɫ":"L","Ⱡ":"L","Ꝉ":"L","Ꝇ":"L","Ꞁ":"L","Ǉ":"LJ","ǈ":"Lj","Ⓜ":"M","Ｍ":"M","Ḿ":"M","Ṁ":"M","Ṃ":"M","Ɱ":"M","Ɯ":"M","Ⓝ":"N","Ｎ":"N","Ǹ":"N","Ń":"N","Ñ":"N","Ṅ":"N","Ň":"N","Ṇ":"N","Ņ":"N","Ṋ":"N","Ṉ":"N","Ƞ":"N","Ɲ":"N","Ꞑ":"N","Ꞥ":"N","Ǌ":"NJ","ǋ":"Nj","Ⓞ":"O","Ｏ":"O","Ò":"O","Ó":"O","Ô":"O","Ồ":"O","Ố":"O","Ỗ":"O","Ổ":"O","Õ":"O","Ṍ":"O","Ȭ":"O","Ṏ":"O","Ō":"O","Ṑ":"O","Ṓ":"O","Ŏ":"O","Ȯ":"O","Ȱ":"O","Ö":"O","Ȫ":"O","Ỏ":"O","Ő":"O","Ǒ":"O","Ȍ":"O","Ȏ":"O","Ơ":"O","Ờ":"O","Ớ":"O","Ỡ":"O","Ở":"O","Ợ":"O","Ọ":"O","Ộ":"O","Ǫ":"O","Ǭ":"O","Ø":"O","Ǿ":"O","Ɔ":"O","Ɵ":"O","Ꝋ":"O","Ꝍ":"O","Ƣ":"OI","Ꝏ":"OO","Ȣ":"OU","Ⓟ":"P","Ｐ":"P","Ṕ":"P","Ṗ":"P","Ƥ":"P","Ᵽ":"P","Ꝑ":"P","Ꝓ":"P","Ꝕ":"P","Ⓠ":"Q","Ｑ":"Q","Ꝗ":"Q","Ꝙ":"Q","Ɋ":"Q","Ⓡ":"R","Ｒ":"R","Ŕ":"R","Ṙ":"R","Ř":"R","Ȑ":"R","Ȓ":"R","Ṛ":"R","Ṝ":"R","Ŗ":"R","Ṟ":"R","Ɍ":"R","Ɽ":"R","Ꝛ":"R","Ꞧ":"R","Ꞃ":"R","Ⓢ":"S","Ｓ":"S","ẞ":"S","Ś":"S","Ṥ":"S","Ŝ":"S","Ṡ":"S","Š":"S","Ṧ":"S","Ṣ":"S","Ṩ":"S","Ș":"S","Ş":"S","Ȿ":"S","Ꞩ":"S","Ꞅ":"S","Ⓣ":"T","Ｔ":"T","Ṫ":"T","Ť":"T","Ṭ":"T","Ț":"T","Ţ":"T","Ṱ":"T","Ṯ":"T","Ŧ":"T","Ƭ":"T","Ʈ":"T","Ⱦ":"T","Ꞇ":"T","Ꜩ":"TZ","Ⓤ":"U","Ｕ":"U","Ù":"U","Ú":"U","Û":"U","Ũ":"U","Ṹ":"U","Ū":"U","Ṻ":"U","Ŭ":"U","Ü":"U","Ǜ":"U","Ǘ":"U","Ǖ":"U","Ǚ":"U","Ủ":"U","Ů":"U","Ű":"U","Ǔ":"U","Ȕ":"U","Ȗ":"U","Ư":"U","Ừ":"U","Ứ":"U","Ữ":"U","Ử":"U","Ự":"U","Ụ":"U","Ṳ":"U","Ų":"U","Ṷ":"U","Ṵ":"U","Ʉ":"U","Ⓥ":"V","Ｖ":"V","Ṽ":"V","Ṿ":"V","Ʋ":"V","Ꝟ":"V","Ʌ":"V","Ꝡ":"VY","Ⓦ":"W","Ｗ":"W","Ẁ":"W","Ẃ":"W","Ŵ":"W","Ẇ":"W","Ẅ":"W","Ẉ":"W","Ⱳ":"W","Ⓧ":"X","Ｘ":"X","Ẋ":"X","Ẍ":"X","Ⓨ":"Y","Ｙ":"Y","Ỳ":"Y","Ý":"Y","Ŷ":"Y","Ỹ":"Y","Ȳ":"Y","Ẏ":"Y","Ÿ":"Y","Ỷ":"Y","Ỵ":"Y","Ƴ":"Y","Ɏ":"Y","Ỿ":"Y","Ⓩ":"Z","Ｚ":"Z","Ź":"Z","Ẑ":"Z","Ż":"Z","Ž":"Z","Ẓ":"Z","Ẕ":"Z","Ƶ":"Z","Ȥ":"Z","Ɀ":"Z","Ⱬ":"Z","Ꝣ":"Z","ⓐ":"a","ａ":"a","ẚ":"a","à":"a","á":"a","â":"a","ầ":"a","ấ":"a","ẫ":"a","ẩ":"a","ã":"a","ā":"a","ă":"a","ằ":"a","ắ":"a","ẵ":"a","ẳ":"a","ȧ":"a","ǡ":"a","ä":"a","ǟ":"a","ả":"a","å":"a","ǻ":"a","ǎ":"a","ȁ":"a","ȃ":"a","ạ":"a","ậ":"a","ặ":"a","ḁ":"a","ą":"a","ⱥ":"a","ɐ":"a","ꜳ":"aa","æ":"ae","ǽ":"ae","ǣ":"ae","ꜵ":"ao","ꜷ":"au","ꜹ":"av","ꜻ":"av","ꜽ":"ay","ⓑ":"b","ｂ":"b","ḃ":"b","ḅ":"b","ḇ":"b","ƀ":"b","ƃ":"b","ɓ":"b","ⓒ":"c","ｃ":"c","ć":"c","ĉ":"c","ċ":"c","č":"c","ç":"c","ḉ":"c","ƈ":"c","ȼ":"c","ꜿ":"c","ↄ":"c","ⓓ":"d","ｄ":"d","ḋ":"d","ď":"d","ḍ":"d","ḑ":"d","ḓ":"d","ḏ":"d","đ":"d","ƌ":"d","ɖ":"d","ɗ":"d","ꝺ":"d","ǳ":"dz","ǆ":"dz","ⓔ":"e","ｅ":"e","è":"e","é":"e","ê":"e","ề":"e","ế":"e","ễ":"e","ể":"e","ẽ":"e","ē":"e","ḕ":"e","ḗ":"e","ĕ":"e","ė":"e","ë":"e","ẻ":"e","ě":"e","ȅ":"e","ȇ":"e","ẹ":"e","ệ":"e","ȩ":"e","ḝ":"e","ę":"e","ḙ":"e","ḛ":"e","ɇ":"e","ɛ":"e","ǝ":"e","ⓕ":"f","ｆ":"f","ḟ":"f","ƒ":"f","ꝼ":"f","ⓖ":"g","ｇ":"g","ǵ":"g","ĝ":"g","ḡ":"g","ğ":"g","ġ":"g","ǧ":"g","ģ":"g","ǥ":"g","ɠ":"g","ꞡ":"g","ᵹ":"g","ꝿ":"g","ⓗ":"h","ｈ":"h","ĥ":"h","ḣ":"h","ḧ":"h","ȟ":"h","ḥ":"h","ḩ":"h","ḫ":"h","ẖ":"h","ħ":"h","ⱨ":"h","ⱶ":"h","ɥ":"h","ƕ":"hv","ⓘ":"i","ｉ":"i","ì":"i","í":"i","î":"i","ĩ":"i","ī":"i","ĭ":"i","ï":"i","ḯ":"i","ỉ":"i","ǐ":"i","ȉ":"i","ȋ":"i","ị":"i","į":"i","ḭ":"i","ɨ":"i","ı":"i","ⓙ":"j","ｊ":"j","ĵ":"j","ǰ":"j","ɉ":"j","ⓚ":"k","ｋ":"k","ḱ":"k","ǩ":"k","ḳ":"k","ķ":"k","ḵ":"k","ƙ":"k","ⱪ":"k","ꝁ":"k","ꝃ":"k","ꝅ":"k","ꞣ":"k","ⓛ":"l","ｌ":"l","ŀ":"l","ĺ":"l","ľ":"l","ḷ":"l","ḹ":"l","ļ":"l","ḽ":"l","ḻ":"l","ſ":"l","ł":"l","ƚ":"l","ɫ":"l","ⱡ":"l","ꝉ":"l","ꞁ":"l","ꝇ":"l","ǉ":"lj","ⓜ":"m","ｍ":"m","ḿ":"m","ṁ":"m","ṃ":"m","ɱ":"m","ɯ":"m","ⓝ":"n","ｎ":"n","ǹ":"n","ń":"n","ñ":"n","ṅ":"n","ň":"n","ṇ":"n","ņ":"n","ṋ":"n","ṉ":"n","ƞ":"n","ɲ":"n","ŉ":"n","ꞑ":"n","ꞥ":"n","ǌ":"nj","ⓞ":"o","ｏ":"o","ò":"o","ó":"o","ô":"o","ồ":"o","ố":"o","ỗ":"o","ổ":"o","õ":"o","ṍ":"o","ȭ":"o","ṏ":"o","ō":"o","ṑ":"o","ṓ":"o","ŏ":"o","ȯ":"o","ȱ":"o","ö":"o","ȫ":"o","ỏ":"o","ő":"o","ǒ":"o","ȍ":"o","ȏ":"o","ơ":"o","ờ":"o","ớ":"o","ỡ":"o","ở":"o","ợ":"o","ọ":"o","ộ":"o","ǫ":"o","ǭ":"o","ø":"o","ǿ":"o","ɔ":"o","ꝋ":"o","ꝍ":"o","ɵ":"o","ƣ":"oi","ȣ":"ou","ꝏ":"oo","ⓟ":"p","ｐ":"p","ṕ":"p","ṗ":"p","ƥ":"p","ᵽ":"p","ꝑ":"p","ꝓ":"p","ꝕ":"p","ⓠ":"q","ｑ":"q","ɋ":"q","ꝗ":"q","ꝙ":"q","ⓡ":"r","ｒ":"r","ŕ":"r","ṙ":"r","ř":"r","ȑ":"r","ȓ":"r","ṛ":"r","ṝ":"r","ŗ":"r","ṟ":"r","ɍ":"r","ɽ":"r","ꝛ":"r","ꞧ":"r","ꞃ":"r","ⓢ":"s","ｓ":"s","ß":"s","ś":"s","ṥ":"s","ŝ":"s","ṡ":"s","š":"s","ṧ":"s","ṣ":"s","ṩ":"s","ș":"s","ş":"s","ȿ":"s","ꞩ":"s","ꞅ":"s","ẛ":"s","ⓣ":"t","ｔ":"t","ṫ":"t","ẗ":"t","ť":"t","ṭ":"t","ț":"t","ţ":"t","ṱ":"t","ṯ":"t","ŧ":"t","ƭ":"t","ʈ":"t","ⱦ":"t","ꞇ":"t","ꜩ":"tz","ⓤ":"u","ｕ":"u","ù":"u","ú":"u","û":"u","ũ":"u","ṹ":"u","ū":"u","ṻ":"u","ŭ":"u","ü":"u","ǜ":"u","ǘ":"u","ǖ":"u","ǚ":"u","ủ":"u","ů":"u","ű":"u","ǔ":"u","ȕ":"u","ȗ":"u","ư":"u","ừ":"u","ứ":"u","ữ":"u","ử":"u","ự":"u","ụ":"u","ṳ":"u","ų":"u","ṷ":"u","ṵ":"u","ʉ":"u","ⓥ":"v","ｖ":"v","ṽ":"v","ṿ":"v","ʋ":"v","ꝟ":"v","ʌ":"v","ꝡ":"vy","ⓦ":"w","ｗ":"w","ẁ":"w","ẃ":"w","ŵ":"w","ẇ":"w","ẅ":"w","ẘ":"w","ẉ":"w","ⱳ":"w","ⓧ":"x","ｘ":"x","ẋ":"x","ẍ":"x","ⓨ":"y","ｙ":"y","ỳ":"y","ý":"y","ŷ":"y","ỹ":"y","ȳ":"y","ẏ":"y","ÿ":"y","ỷ":"y","ẙ":"y","ỵ":"y","ƴ":"y","ɏ":"y","ỿ":"y","ⓩ":"z","ｚ":"z","ź":"z","ẑ":"z","ż":"z","ž":"z","ẓ":"z","ẕ":"z","ƶ":"z","ȥ":"z","ɀ":"z","ⱬ":"z","ꝣ":"z","Ά":"Α","Έ":"Ε","Ή":"Η","Ί":"Ι","Ϊ":"Ι","Ό":"Ο","Ύ":"Υ","Ϋ":"Υ","Ώ":"Ω","ά":"α","έ":"ε","ή":"η","ί":"ι","ϊ":"ι","ΐ":"ι","ό":"ο","ύ":"υ","ϋ":"υ","ΰ":"υ","ω":"ω","ς":"σ"};return a}),b.define("select2/data/base",["../utils"],function(a){function b(a,c){b.__super__.constructor.call(this)}return a.Extend(b,a.Observable),b.prototype.current=function(a){throw new Error("The `current` method must be defined in child classes.")},b.prototype.query=function(a,b){throw new Error("The `query` method must be defined in child classes.")},b.prototype.bind=function(a,b){},b.prototype.destroy=function(){},b.prototype.generateResultId=function(b,c){var d=b.id+"-result-";return d+=a.generateChars(4),d+=null!=c.id?"-"+c.id.toString():"-"+a.generateChars(4)},b}),b.define("select2/data/select",["./base","../utils","jquery"],function(a,b,c){function d(a,b){this.$element=a,this.options=b,d.__super__.constructor.call(this)}return b.Extend(d,a),d.prototype.current=function(a){var b=[],d=this;this.$element.find(":selected").each(function(){var a=c(this),e=d.item(a);b.push(e)}),a(b)},d.prototype.select=function(a){var b=this;if(a.selected=!0,c(a.element).is("option"))return a.element.selected=!0,void this.$element.trigger("change");
if(this.$element.prop("multiple"))this.current(function(d){var e=[];a=[a],a.push.apply(a,d);for(var f=0;f<a.length;f++){var g=a[f].id;-1===c.inArray(g,e)&&e.push(g)}b.$element.val(e),b.$element.trigger("change")});else{var d=a.id;this.$element.val(d),this.$element.trigger("change")}},d.prototype.unselect=function(a){var b=this;if(this.$element.prop("multiple"))return a.selected=!1,c(a.element).is("option")?(a.element.selected=!1,void this.$element.trigger("change")):void this.current(function(d){for(var e=[],f=0;f<d.length;f++){var g=d[f].id;g!==a.id&&-1===c.inArray(g,e)&&e.push(g)}b.$element.val(e),b.$element.trigger("change")})},d.prototype.bind=function(a,b){var c=this;this.container=a,a.on("select",function(a){c.select(a.data)}),a.on("unselect",function(a){c.unselect(a.data)})},d.prototype.destroy=function(){this.$element.find("*").each(function(){c.removeData(this,"data")})},d.prototype.query=function(a,b){var d=[],e=this,f=this.$element.children();f.each(function(){var b=c(this);if(b.is("option")||b.is("optgroup")){var f=e.item(b),g=e.matches(a,f);null!==g&&d.push(g)}}),b({results:d})},d.prototype.addOptions=function(a){b.appendMany(this.$element,a)},d.prototype.option=function(a){var b;a.children?(b=document.createElement("optgroup"),b.label=a.text):(b=document.createElement("option"),void 0!==b.textContent?b.textContent=a.text:b.innerText=a.text),a.id&&(b.value=a.id),a.disabled&&(b.disabled=!0),a.selected&&(b.selected=!0),a.title&&(b.title=a.title);var d=c(b),e=this._normalizeItem(a);return e.element=b,c.data(b,"data",e),d},d.prototype.item=function(a){var b={};if(b=c.data(a[0],"data"),null!=b)return b;if(a.is("option"))b={id:a.val(),text:a.text(),disabled:a.prop("disabled"),selected:a.prop("selected"),title:a.prop("title")};else if(a.is("optgroup")){b={text:a.prop("label"),children:[],title:a.prop("title")};for(var d=a.children("option"),e=[],f=0;f<d.length;f++){var g=c(d[f]),h=this.item(g);e.push(h)}b.children=e}return b=this._normalizeItem(b),b.element=a[0],c.data(a[0],"data",b),b},d.prototype._normalizeItem=function(a){c.isPlainObject(a)||(a={id:a,text:a}),a=c.extend({},{text:""},a);var b={selected:!1,disabled:!1};return null!=a.id&&(a.id=a.id.toString()),null!=a.text&&(a.text=a.text.toString()),null==a._resultId&&a.id&&null!=this.container&&(a._resultId=this.generateResultId(this.container,a)),c.extend({},b,a)},d.prototype.matches=function(a,b){var c=this.options.get("matcher");return c(a,b)},d}),b.define("select2/data/array",["./select","../utils","jquery"],function(a,b,c){function d(a,b){var c=b.get("data")||[];d.__super__.constructor.call(this,a,b),this.addOptions(this.convertToOptions(c))}return b.Extend(d,a),d.prototype.select=function(a){var b=this.$element.find("option").filter(function(b,c){return c.value==a.id.toString()});0===b.length&&(b=this.option(a),this.addOptions(b)),d.__super__.select.call(this,a)},d.prototype.convertToOptions=function(a){function d(a){return function(){return c(this).val()==a.id}}for(var e=this,f=this.$element.find("option"),g=f.map(function(){return e.item(c(this)).id}).get(),h=[],i=0;i<a.length;i++){var j=this._normalizeItem(a[i]);if(c.inArray(j.id,g)>=0){var k=f.filter(d(j)),l=this.item(k),m=c.extend(!0,{},j,l),n=this.option(m);k.replaceWith(n)}else{var o=this.option(j);if(j.children){var p=this.convertToOptions(j.children);b.appendMany(o,p)}h.push(o)}}return h},d}),b.define("select2/data/ajax",["./array","../utils","jquery"],function(a,b,c){function d(a,b){this.ajaxOptions=this._applyDefaults(b.get("ajax")),null!=this.ajaxOptions.processResults&&(this.processResults=this.ajaxOptions.processResults),d.__super__.constructor.call(this,a,b)}return b.Extend(d,a),d.prototype._applyDefaults=function(a){var b={data:function(a){return c.extend({},a,{q:a.term})},transport:function(a,b,d){var e=c.ajax(a);return e.then(b),e.fail(d),e}};return c.extend({},b,a,!0)},d.prototype.processResults=function(a){return a},d.prototype.query=function(a,b){function d(){var d=f.transport(f,function(d){var f=e.processResults(d,a);e.options.get("debug")&&window.console&&console.error&&(f&&f.results&&c.isArray(f.results)||console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")),b(f)},function(){d.status&&"0"===d.status||e.trigger("results:message",{message:"errorLoading"})});e._request=d}var e=this;null!=this._request&&(c.isFunction(this._request.abort)&&this._request.abort(),this._request=null);var f=c.extend({type:"GET"},this.ajaxOptions);"function"==typeof f.url&&(f.url=f.url.call(this.$element,a)),"function"==typeof f.data&&(f.data=f.data.call(this.$element,a)),this.ajaxOptions.delay&&null!=a.term?(this._queryTimeout&&window.clearTimeout(this._queryTimeout),this._queryTimeout=window.setTimeout(d,this.ajaxOptions.delay)):d()},d}),b.define("select2/data/tags",["jquery"],function(a){function b(b,c,d){var e=d.get("tags"),f=d.get("createTag");void 0!==f&&(this.createTag=f);var g=d.get("insertTag");if(void 0!==g&&(this.insertTag=g),b.call(this,c,d),a.isArray(e))for(var h=0;h<e.length;h++){var i=e[h],j=this._normalizeItem(i),k=this.option(j);this.$element.append(k)}}return b.prototype.query=function(a,b,c){function d(a,f){for(var g=a.results,h=0;h<g.length;h++){var i=g[h],j=null!=i.children&&!d({results:i.children},!0),k=i.text===b.term;if(k||j)return f?!1:(a.data=g,void c(a))}if(f)return!0;var l=e.createTag(b);if(null!=l){var m=e.option(l);m.attr("data-select2-tag",!0),e.addOptions([m]),e.insertTag(g,l)}a.results=g,c(a)}var e=this;return this._removeOldTags(),null==b.term||null!=b.page?void a.call(this,b,c):void a.call(this,b,d)},b.prototype.createTag=function(b,c){var d=a.trim(c.term);return""===d?null:{id:d,text:d}},b.prototype.insertTag=function(a,b,c){b.unshift(c)},b.prototype._removeOldTags=function(b){var c=(this._lastTag,this.$element.find("option[data-select2-tag]"));c.each(function(){this.selected||a(this).remove()})},b}),b.define("select2/data/tokenizer",["jquery"],function(a){function b(a,b,c){var d=c.get("tokenizer");void 0!==d&&(this.tokenizer=d),a.call(this,b,c)}return b.prototype.bind=function(a,b,c){a.call(this,b,c),this.$search=b.dropdown.$search||b.selection.$search||c.find(".select2-search__field")},b.prototype.query=function(b,c,d){function e(b){var c=g._normalizeItem(b),d=g.$element.find("option").filter(function(){return a(this).val()===c.id});if(!d.length){var e=g.option(c);e.attr("data-select2-tag",!0),g._removeOldTags(),g.addOptions([e])}f(c)}function f(a){g.trigger("select",{data:a})}var g=this;c.term=c.term||"";var h=this.tokenizer(c,this.options,e);h.term!==c.term&&(this.$search.length&&(this.$search.val(h.term),this.$search.focus()),c.term=h.term),b.call(this,c,d)},b.prototype.tokenizer=function(b,c,d,e){for(var f=d.get("tokenSeparators")||[],g=c.term,h=0,i=this.createTag||function(a){return{id:a.term,text:a.term}};h<g.length;){var j=g[h];if(-1!==a.inArray(j,f)){var k=g.substr(0,h),l=a.extend({},c,{term:k}),m=i(l);null!=m?(e(m),g=g.substr(h+1)||"",h=0):h++}else h++}return{term:g}},b}),b.define("select2/data/minimumInputLength",[],function(){function a(a,b,c){this.minimumInputLength=c.get("minimumInputLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){return b.term=b.term||"",b.term.length<this.minimumInputLength?void this.trigger("results:message",{message:"inputTooShort",args:{minimum:this.minimumInputLength,input:b.term,params:b}}):void a.call(this,b,c)},a}),b.define("select2/data/maximumInputLength",[],function(){function a(a,b,c){this.maximumInputLength=c.get("maximumInputLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){return b.term=b.term||"",this.maximumInputLength>0&&b.term.length>this.maximumInputLength?void this.trigger("results:message",{message:"inputTooLong",args:{maximum:this.maximumInputLength,input:b.term,params:b}}):void a.call(this,b,c)},a}),b.define("select2/data/maximumSelectionLength",[],function(){function a(a,b,c){this.maximumSelectionLength=c.get("maximumSelectionLength"),a.call(this,b,c)}return a.prototype.query=function(a,b,c){var d=this;this.current(function(e){var f=null!=e?e.length:0;return d.maximumSelectionLength>0&&f>=d.maximumSelectionLength?void d.trigger("results:message",{message:"maximumSelected",args:{maximum:d.maximumSelectionLength}}):void a.call(d,b,c)})},a}),b.define("select2/dropdown",["jquery","./utils"],function(a,b){function c(a,b){this.$element=a,this.options=b,c.__super__.constructor.call(this)}return b.Extend(c,b.Observable),c.prototype.render=function(){var b=a('<span class="select2-dropdown"><span class="select2-results"></span></span>');return b.attr("dir",this.options.get("dir")),this.$dropdown=b,b},c.prototype.bind=function(){},c.prototype.position=function(a,b){},c.prototype.destroy=function(){this.$dropdown.remove()},c}),b.define("select2/dropdown/search",["jquery","../utils"],function(a,b){function c(){}return c.prototype.render=function(b){var c=b.call(this),d=a('<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></span>');return this.$searchContainer=d,this.$search=d.find("input"),c.prepend(d),c},c.prototype.bind=function(b,c,d){var e=this;b.call(this,c,d),this.$search.on("keydown",function(a){e.trigger("keypress",a),e._keyUpPrevented=a.isDefaultPrevented()}),this.$search.on("input",function(b){a(this).off("keyup")}),this.$search.on("keyup input",function(a){e.handleSearch(a)}),c.on("open",function(){e.$search.attr("tabindex",0),e.$search.focus(),window.setTimeout(function(){e.$search.focus()},0)}),c.on("close",function(){e.$search.attr("tabindex",-1),e.$search.val("")}),c.on("focus",function(){c.isOpen()&&e.$search.focus()}),c.on("results:all",function(a){if(null==a.query.term||""===a.query.term){var b=e.showSearch(a);b?e.$searchContainer.removeClass("select2-search--hide"):e.$searchContainer.addClass("select2-search--hide")}})},c.prototype.handleSearch=function(a){if(!this._keyUpPrevented){var b=this.$search.val();this.trigger("query",{term:b})}this._keyUpPrevented=!1},c.prototype.showSearch=function(a,b){return!0},c}),b.define("select2/dropdown/hidePlaceholder",[],function(){function a(a,b,c,d){this.placeholder=this.normalizePlaceholder(c.get("placeholder")),a.call(this,b,c,d)}return a.prototype.append=function(a,b){b.results=this.removePlaceholder(b.results),a.call(this,b)},a.prototype.normalizePlaceholder=function(a,b){return"string"==typeof b&&(b={id:"",text:b}),b},a.prototype.removePlaceholder=function(a,b){for(var c=b.slice(0),d=b.length-1;d>=0;d--){var e=b[d];this.placeholder.id===e.id&&c.splice(d,1)}return c},a}),b.define("select2/dropdown/infiniteScroll",["jquery"],function(a){function b(a,b,c,d){this.lastParams={},a.call(this,b,c,d),this.$loadingMore=this.createLoadingMore(),this.loading=!1}return b.prototype.append=function(a,b){this.$loadingMore.remove(),this.loading=!1,a.call(this,b),this.showLoadingMore(b)&&this.$results.append(this.$loadingMore)},b.prototype.bind=function(b,c,d){var e=this;b.call(this,c,d),c.on("query",function(a){e.lastParams=a,e.loading=!0}),c.on("query:append",function(a){e.lastParams=a,e.loading=!0}),this.$results.on("scroll",function(){var b=a.contains(document.documentElement,e.$loadingMore[0]);if(!e.loading&&b){var c=e.$results.offset().top+e.$results.outerHeight(!1),d=e.$loadingMore.offset().top+e.$loadingMore.outerHeight(!1);c+50>=d&&e.loadMore()}})},b.prototype.loadMore=function(){this.loading=!0;var b=a.extend({},{page:1},this.lastParams);b.page++,this.trigger("query:append",b)},b.prototype.showLoadingMore=function(a,b){return b.pagination&&b.pagination.more},b.prototype.createLoadingMore=function(){var b=a('<li class="select2-results__option select2-results__option--load-more"role="treeitem" aria-disabled="true"></li>'),c=this.options.get("translations").get("loadingMore");return b.html(c(this.lastParams)),b},b}),b.define("select2/dropdown/attachBody",["jquery","../utils"],function(a,b){function c(b,c,d){this.$dropdownParent=d.get("dropdownParent")||a(document.body),b.call(this,c,d)}return c.prototype.bind=function(a,b,c){var d=this,e=!1;a.call(this,b,c),b.on("open",function(){d._showDropdown(),d._attachPositioningHandler(b),e||(e=!0,b.on("results:all",function(){d._positionDropdown(),d._resizeDropdown()}),b.on("results:append",function(){d._positionDropdown(),d._resizeDropdown()}))}),b.on("close",function(){d._hideDropdown(),d._detachPositioningHandler(b)}),this.$dropdownContainer.on("mousedown",function(a){a.stopPropagation()})},c.prototype.destroy=function(a){a.call(this),this.$dropdownContainer.remove()},c.prototype.position=function(a,b,c){b.attr("class",c.attr("class")),b.removeClass("select2"),b.addClass("select2-container--open"),b.css({position:"absolute",top:-999999}),this.$container=c},c.prototype.render=function(b){var c=a("<span></span>"),d=b.call(this);return c.append(d),this.$dropdownContainer=c,c},c.prototype._hideDropdown=function(a){this.$dropdownContainer.detach()},c.prototype._attachPositioningHandler=function(c,d){var e=this,f="scroll.select2."+d.id,g="resize.select2."+d.id,h="orientationchange.select2."+d.id,i=this.$container.parents().filter(b.hasScroll);i.each(function(){a(this).data("select2-scroll-position",{x:a(this).scrollLeft(),y:a(this).scrollTop()})}),i.on(f,function(b){var c=a(this).data("select2-scroll-position");a(this).scrollTop(c.y)}),a(window).on(f+" "+g+" "+h,function(a){e._positionDropdown(),e._resizeDropdown()})},c.prototype._detachPositioningHandler=function(c,d){var e="scroll.select2."+d.id,f="resize.select2."+d.id,g="orientationchange.select2."+d.id,h=this.$container.parents().filter(b.hasScroll);h.off(e),a(window).off(e+" "+f+" "+g)},c.prototype._positionDropdown=function(){var b=a(window),c=this.$dropdown.hasClass("select2-dropdown--above"),d=this.$dropdown.hasClass("select2-dropdown--below"),e=null,f=this.$container.offset();f.bottom=f.top+this.$container.outerHeight(!1);var g={height:this.$container.outerHeight(!1)};g.top=f.top,g.bottom=f.top+g.height;var h={height:this.$dropdown.outerHeight(!1)},i={top:b.scrollTop(),bottom:b.scrollTop()+b.height()},j=i.top<f.top-h.height,k=i.bottom>f.bottom+h.height,l={left:f.left,top:g.bottom},m=this.$dropdownParent;"static"===m.css("position")&&(m=m.offsetParent());var n=m.offset();l.top-=n.top,l.left-=n.left,c||d||(e="below"),k||!j||c?!j&&k&&c&&(e="below"):e="above",("above"==e||c&&"below"!==e)&&(l.top=g.top-n.top-h.height),null!=e&&(this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--"+e),this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--"+e)),this.$dropdownContainer.css(l)},c.prototype._resizeDropdown=function(){var a={width:this.$container.outerWidth(!1)+"px"};this.options.get("dropdownAutoWidth")&&(a.minWidth=a.width,a.position="relative",a.width="auto"),this.$dropdown.css(a)},c.prototype._showDropdown=function(a){this.$dropdownContainer.appendTo(this.$dropdownParent),this._positionDropdown(),this._resizeDropdown()},c}),b.define("select2/dropdown/minimumResultsForSearch",[],function(){function a(b){for(var c=0,d=0;d<b.length;d++){var e=b[d];e.children?c+=a(e.children):c++}return c}function b(a,b,c,d){this.minimumResultsForSearch=c.get("minimumResultsForSearch"),this.minimumResultsForSearch<0&&(this.minimumResultsForSearch=1/0),a.call(this,b,c,d)}return b.prototype.showSearch=function(b,c){return a(c.data.results)<this.minimumResultsForSearch?!1:b.call(this,c)},b}),b.define("select2/dropdown/selectOnClose",[],function(){function a(){}return a.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),b.on("close",function(a){d._handleSelectOnClose(a)})},a.prototype._handleSelectOnClose=function(a,b){if(b&&null!=b.originalSelect2Event){var c=b.originalSelect2Event;if("select"===c._type||"unselect"===c._type)return}var d=this.getHighlightedResults();if(!(d.length<1)){var e=d.data("data");null!=e.element&&e.element.selected||null==e.element&&e.selected||this.trigger("select",{data:e})}},a}),b.define("select2/dropdown/closeOnSelect",[],function(){function a(){}return a.prototype.bind=function(a,b,c){var d=this;a.call(this,b,c),b.on("select",function(a){d._selectTriggered(a)}),b.on("unselect",function(a){d._selectTriggered(a)})},a.prototype._selectTriggered=function(a,b){var c=b.originalEvent;c&&c.ctrlKey||this.trigger("close",{originalEvent:c,originalSelect2Event:b})},a}),b.define("select2/i18n/en",[],function(){return{errorLoading:function(){return"The results could not be loaded."},inputTooLong:function(a){var b=a.input.length-a.maximum,c="Please delete "+b+" character";return 1!=b&&(c+="s"),c},inputTooShort:function(a){var b=a.minimum-a.input.length,c="Please enter "+b+" or more characters";return c},loadingMore:function(){return"Loading more results…"},maximumSelected:function(a){var b="You can only select "+a.maximum+" item";return 1!=a.maximum&&(b+="s"),b},noResults:function(){return"No results found"},searching:function(){return"Searching…"}}}),b.define("select2/defaults",["jquery","require","./results","./selection/single","./selection/multiple","./selection/placeholder","./selection/allowClear","./selection/search","./selection/eventRelay","./utils","./translation","./diacritics","./data/select","./data/array","./data/ajax","./data/tags","./data/tokenizer","./data/minimumInputLength","./data/maximumInputLength","./data/maximumSelectionLength","./dropdown","./dropdown/search","./dropdown/hidePlaceholder","./dropdown/infiniteScroll","./dropdown/attachBody","./dropdown/minimumResultsForSearch","./dropdown/selectOnClose","./dropdown/closeOnSelect","./i18n/en"],function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){function D(){this.reset()}D.prototype.apply=function(l){if(l=a.extend(!0,{},this.defaults,l),null==l.dataAdapter){if(null!=l.ajax?l.dataAdapter=o:null!=l.data?l.dataAdapter=n:l.dataAdapter=m,l.minimumInputLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,r)),l.maximumInputLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,s)),l.maximumSelectionLength>0&&(l.dataAdapter=j.Decorate(l.dataAdapter,t)),l.tags&&(l.dataAdapter=j.Decorate(l.dataAdapter,p)),(null!=l.tokenSeparators||null!=l.tokenizer)&&(l.dataAdapter=j.Decorate(l.dataAdapter,q)),null!=l.query){var C=b(l.amdBase+"compat/query");l.dataAdapter=j.Decorate(l.dataAdapter,C)}if(null!=l.initSelection){var D=b(l.amdBase+"compat/initSelection");l.dataAdapter=j.Decorate(l.dataAdapter,D)}}if(null==l.resultsAdapter&&(l.resultsAdapter=c,null!=l.ajax&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,x)),null!=l.placeholder&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,w)),l.selectOnClose&&(l.resultsAdapter=j.Decorate(l.resultsAdapter,A))),null==l.dropdownAdapter){if(l.multiple)l.dropdownAdapter=u;else{var E=j.Decorate(u,v);l.dropdownAdapter=E}if(0!==l.minimumResultsForSearch&&(l.dropdownAdapter=j.Decorate(l.dropdownAdapter,z)),l.closeOnSelect&&(l.dropdownAdapter=j.Decorate(l.dropdownAdapter,B)),null!=l.dropdownCssClass||null!=l.dropdownCss||null!=l.adaptDropdownCssClass){var F=b(l.amdBase+"compat/dropdownCss");l.dropdownAdapter=j.Decorate(l.dropdownAdapter,F)}l.dropdownAdapter=j.Decorate(l.dropdownAdapter,y)}if(null==l.selectionAdapter){if(l.multiple?l.selectionAdapter=e:l.selectionAdapter=d,null!=l.placeholder&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,f)),l.allowClear&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,g)),l.multiple&&(l.selectionAdapter=j.Decorate(l.selectionAdapter,h)),null!=l.containerCssClass||null!=l.containerCss||null!=l.adaptContainerCssClass){var G=b(l.amdBase+"compat/containerCss");l.selectionAdapter=j.Decorate(l.selectionAdapter,G)}l.selectionAdapter=j.Decorate(l.selectionAdapter,i)}if("string"==typeof l.language)if(l.language.indexOf("-")>0){var H=l.language.split("-"),I=H[0];l.language=[l.language,I]}else l.language=[l.language];if(a.isArray(l.language)){var J=new k;l.language.push("en");for(var K=l.language,L=0;L<K.length;L++){var M=K[L],N={};try{N=k.loadPath(M)}catch(O){try{M=this.defaults.amdLanguageBase+M,N=k.loadPath(M)}catch(P){l.debug&&window.console&&console.warn&&console.warn('Select2: The language file for "'+M+'" could not be automatically loaded. A fallback will be used instead.');continue}}J.extend(N)}l.translations=J}else{var Q=k.loadPath(this.defaults.amdLanguageBase+"en"),R=new k(l.language);R.extend(Q),l.translations=R}return l},D.prototype.reset=function(){function b(a){function b(a){return l[a]||a}return a.replace(/[^\u0000-\u007E]/g,b)}function c(d,e){if(""===a.trim(d.term))return e;if(e.children&&e.children.length>0){for(var f=a.extend(!0,{},e),g=e.children.length-1;g>=0;g--){var h=e.children[g],i=c(d,h);null==i&&f.children.splice(g,1)}return f.children.length>0?f:c(d,f)}var j=b(e.text).toUpperCase(),k=b(d.term).toUpperCase();return j.indexOf(k)>-1?e:null}this.defaults={amdBase:"./",amdLanguageBase:"./i18n/",closeOnSelect:!0,debug:!1,dropdownAutoWidth:!1,escapeMarkup:j.escapeMarkup,language:C,matcher:c,minimumInputLength:0,maximumInputLength:0,maximumSelectionLength:0,minimumResultsForSearch:0,selectOnClose:!1,sorter:function(a){return a},templateResult:function(a){return a.text},templateSelection:function(a){return a.text},theme:"default",width:"resolve"}},D.prototype.set=function(b,c){var d=a.camelCase(b),e={};e[d]=c;var f=j._convertData(e);a.extend(this.defaults,f)};var E=new D;return E}),b.define("select2/options",["require","jquery","./defaults","./utils"],function(a,b,c,d){function e(b,e){if(this.options=b,null!=e&&this.fromElement(e),this.options=c.apply(this.options),e&&e.is("input")){var f=a(this.get("amdBase")+"compat/inputData");this.options.dataAdapter=d.Decorate(this.options.dataAdapter,f)}}return e.prototype.fromElement=function(a){var c=["select2"];null==this.options.multiple&&(this.options.multiple=a.prop("multiple")),null==this.options.disabled&&(this.options.disabled=a.prop("disabled")),null==this.options.language&&(a.prop("lang")?this.options.language=a.prop("lang").toLowerCase():a.closest("[lang]").prop("lang")&&(this.options.language=a.closest("[lang]").prop("lang"))),null==this.options.dir&&(a.prop("dir")?this.options.dir=a.prop("dir"):a.closest("[dir]").prop("dir")?this.options.dir=a.closest("[dir]").prop("dir"):this.options.dir="ltr"),a.prop("disabled",this.options.disabled),a.prop("multiple",this.options.multiple),a.data("select2Tags")&&(this.options.debug&&window.console&&console.warn&&console.warn('Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'),a.data("data",a.data("select2Tags")),a.data("tags",!0)),a.data("ajaxUrl")&&(this.options.debug&&window.console&&console.warn&&console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."),a.attr("ajax--url",a.data("ajaxUrl")),a.data("ajax--url",a.data("ajaxUrl")));var e={};e=b.fn.jquery&&"1."==b.fn.jquery.substr(0,2)&&a[0].dataset?b.extend(!0,{},a[0].dataset,a.data()):a.data();var f=b.extend(!0,{},e);f=d._convertData(f);for(var g in f)b.inArray(g,c)>-1||(b.isPlainObject(this.options[g])?b.extend(this.options[g],f[g]):this.options[g]=f[g]);return this},e.prototype.get=function(a){return this.options[a]},e.prototype.set=function(a,b){this.options[a]=b},e}),b.define("select2/core",["jquery","./options","./utils","./keys"],function(a,b,c,d){var e=function(a,c){null!=a.data("select2")&&a.data("select2").destroy(),this.$element=a,this.id=this._generateId(a),c=c||{},this.options=new b(c,a),e.__super__.constructor.call(this);var d=a.attr("tabindex")||0;a.data("old-tabindex",d),a.attr("tabindex","-1");var f=this.options.get("dataAdapter");this.dataAdapter=new f(a,this.options);var g=this.render();this._placeContainer(g);var h=this.options.get("selectionAdapter");this.selection=new h(a,this.options),this.$selection=this.selection.render(),this.selection.position(this.$selection,g);var i=this.options.get("dropdownAdapter");this.dropdown=new i(a,this.options),this.$dropdown=this.dropdown.render(),this.dropdown.position(this.$dropdown,g);var j=this.options.get("resultsAdapter");this.results=new j(a,this.options,this.dataAdapter),this.$results=this.results.render(),this.results.position(this.$results,this.$dropdown);var k=this;this._bindAdapters(),this._registerDomEvents(),this._registerDataEvents(),this._registerSelectionEvents(),this._registerDropdownEvents(),this._registerResultsEvents(),this._registerEvents(),this.dataAdapter.current(function(a){k.trigger("selection:update",{data:a})}),a.addClass("select2-hidden-accessible"),a.attr("aria-hidden","true"),this._syncAttributes(),a.data("select2",this)};return c.Extend(e,c.Observable),e.prototype._generateId=function(a){var b="";return b=null!=a.attr("id")?a.attr("id"):null!=a.attr("name")?a.attr("name")+"-"+c.generateChars(2):c.generateChars(4),b=b.replace(/(:|\.|\[|\]|,)/g,""),b="select2-"+b},e.prototype._placeContainer=function(a){a.insertAfter(this.$element);var b=this._resolveWidth(this.$element,this.options.get("width"));null!=b&&a.css("width",b)},e.prototype._resolveWidth=function(a,b){var c=/^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;if("resolve"==b){var d=this._resolveWidth(a,"style");return null!=d?d:this._resolveWidth(a,"element")}if("element"==b){var e=a.outerWidth(!1);return 0>=e?"auto":e+"px"}if("style"==b){var f=a.attr("style");if("string"!=typeof f)return null;for(var g=f.split(";"),h=0,i=g.length;i>h;h+=1){var j=g[h].replace(/\s/g,""),k=j.match(c);if(null!==k&&k.length>=1)return k[1]}return null}return b},e.prototype._bindAdapters=function(){this.dataAdapter.bind(this,this.$container),this.selection.bind(this,this.$container),this.dropdown.bind(this,this.$container),this.results.bind(this,this.$container)},e.prototype._registerDomEvents=function(){var b=this;this.$element.on("change.select2",function(){b.dataAdapter.current(function(a){b.trigger("selection:update",{data:a})})}),this.$element.on("focus.select2",function(a){b.trigger("focus",a)}),this._syncA=c.bind(this._syncAttributes,this),this._syncS=c.bind(this._syncSubtree,this),this.$element[0].attachEvent&&this.$element[0].attachEvent("onpropertychange",this._syncA);var d=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver;null!=d?(this._observer=new d(function(c){a.each(c,b._syncA),a.each(c,b._syncS)}),this._observer.observe(this.$element[0],{attributes:!0,childList:!0,subtree:!1})):this.$element[0].addEventListener&&(this.$element[0].addEventListener("DOMAttrModified",b._syncA,!1),this.$element[0].addEventListener("DOMNodeInserted",b._syncS,!1),this.$element[0].addEventListener("DOMNodeRemoved",b._syncS,!1))},e.prototype._registerDataEvents=function(){var a=this;this.dataAdapter.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerSelectionEvents=function(){var b=this,c=["toggle","focus"];this.selection.on("toggle",function(){b.toggleDropdown()}),this.selection.on("focus",function(a){b.focus(a)}),this.selection.on("*",function(d,e){-1===a.inArray(d,c)&&b.trigger(d,e)})},e.prototype._registerDropdownEvents=function(){var a=this;this.dropdown.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerResultsEvents=function(){var a=this;this.results.on("*",function(b,c){a.trigger(b,c)})},e.prototype._registerEvents=function(){var a=this;this.on("open",function(){a.$container.addClass("select2-container--open")}),this.on("close",function(){a.$container.removeClass("select2-container--open")}),this.on("enable",function(){a.$container.removeClass("select2-container--disabled")}),this.on("disable",function(){a.$container.addClass("select2-container--disabled")}),this.on("blur",function(){a.$container.removeClass("select2-container--focus")}),this.on("query",function(b){a.isOpen()||a.trigger("open",{}),this.dataAdapter.query(b,function(c){a.trigger("results:all",{data:c,query:b})})}),this.on("query:append",function(b){this.dataAdapter.query(b,function(c){a.trigger("results:append",{data:c,query:b})})}),this.on("keypress",function(b){var c=b.which;a.isOpen()?c===d.ESC||c===d.TAB||c===d.UP&&b.altKey?(a.close(),b.preventDefault()):c===d.ENTER?(a.trigger("results:select",{}),b.preventDefault()):c===d.SPACE&&b.ctrlKey?(a.trigger("results:toggle",{}),b.preventDefault()):c===d.UP?(a.trigger("results:previous",{}),b.preventDefault()):c===d.DOWN&&(a.trigger("results:next",{}),b.preventDefault()):(c===d.ENTER||c===d.SPACE||c===d.DOWN&&b.altKey)&&(a.open(),b.preventDefault())})},e.prototype._syncAttributes=function(){this.options.set("disabled",this.$element.prop("disabled")),this.options.get("disabled")?(this.isOpen()&&this.close(),this.trigger("disable",{})):this.trigger("enable",{})},e.prototype._syncSubtree=function(a,b){var c=!1,d=this;if(!a||!a.target||"OPTION"===a.target.nodeName||"OPTGROUP"===a.target.nodeName){if(b)if(b.addedNodes&&b.addedNodes.length>0)for(var e=0;e<b.addedNodes.length;e++){var f=b.addedNodes[e];f.selected&&(c=!0)}else b.removedNodes&&b.removedNodes.length>0&&(c=!0);else c=!0;c&&this.dataAdapter.current(function(a){d.trigger("selection:update",{data:a})})}},e.prototype.trigger=function(a,b){var c=e.__super__.trigger,d={open:"opening",close:"closing",select:"selecting",unselect:"unselecting"};if(void 0===b&&(b={}),a in d){var f=d[a],g={prevented:!1,name:a,args:b};if(c.call(this,f,g),g.prevented)return void(b.prevented=!0)}c.call(this,a,b)},e.prototype.toggleDropdown=function(){this.options.get("disabled")||(this.isOpen()?this.close():this.open())},e.prototype.open=function(){this.isOpen()||this.trigger("query",{})},e.prototype.close=function(){this.isOpen()&&this.trigger("close",{})},e.prototype.isOpen=function(){return this.$container.hasClass("select2-container--open")},e.prototype.hasFocus=function(){return this.$container.hasClass("select2-container--focus")},e.prototype.focus=function(a){this.hasFocus()||(this.$container.addClass("select2-container--focus"),this.trigger("focus",{}))},e.prototype.enable=function(a){this.options.get("debug")&&window.console&&console.warn&&console.warn('Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'),(null==a||0===a.length)&&(a=[!0]);var b=!a[0];this.$element.prop("disabled",b)},e.prototype.data=function(){this.options.get("debug")&&arguments.length>0&&window.console&&console.warn&&console.warn('Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.');var a=[];return this.dataAdapter.current(function(b){a=b}),a},e.prototype.val=function(b){if(this.options.get("debug")&&window.console&&console.warn&&console.warn('Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'),null==b||0===b.length)return this.$element.val();var c=b[0];a.isArray(c)&&(c=a.map(c,function(a){return a.toString()})),this.$element.val(c).trigger("change")},e.prototype.destroy=function(){this.$container.remove(),this.$element[0].detachEvent&&this.$element[0].detachEvent("onpropertychange",this._syncA),null!=this._observer?(this._observer.disconnect(),this._observer=null):this.$element[0].removeEventListener&&(this.$element[0].removeEventListener("DOMAttrModified",this._syncA,!1),this.$element[0].removeEventListener("DOMNodeInserted",this._syncS,!1),this.$element[0].removeEventListener("DOMNodeRemoved",this._syncS,!1)),this._syncA=null,this._syncS=null,this.$element.off(".select2"),this.$element.attr("tabindex",this.$element.data("old-tabindex")),this.$element.removeClass("select2-hidden-accessible"),this.$element.attr("aria-hidden","false"),this.$element.removeData("select2"),this.dataAdapter.destroy(),this.selection.destroy(),this.dropdown.destroy(),this.results.destroy(),this.dataAdapter=null,this.selection=null,this.dropdown=null,this.results=null;
},e.prototype.render=function(){var b=a('<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>');return b.attr("dir",this.options.get("dir")),this.$container=b,this.$container.addClass("select2-container--"+this.options.get("theme")),b.data("element",this.$element),b},e}),b.define("select2/compat/utils",["jquery"],function(a){function b(b,c,d){var e,f,g=[];e=a.trim(b.attr("class")),e&&(e=""+e,a(e.split(/\s+/)).each(function(){0===this.indexOf("select2-")&&g.push(this)})),e=a.trim(c.attr("class")),e&&(e=""+e,a(e.split(/\s+/)).each(function(){0!==this.indexOf("select2-")&&(f=d(this),null!=f&&g.push(f))})),b.attr("class",g.join(" "))}return{syncCssClasses:b}}),b.define("select2/compat/containerCss",["jquery","./utils"],function(a,b){function c(a){return null}function d(){}return d.prototype.render=function(d){var e=d.call(this),f=this.options.get("containerCssClass")||"";a.isFunction(f)&&(f=f(this.$element));var g=this.options.get("adaptContainerCssClass");if(g=g||c,-1!==f.indexOf(":all:")){f=f.replace(":all:","");var h=g;g=function(a){var b=h(a);return null!=b?b+" "+a:a}}var i=this.options.get("containerCss")||{};return a.isFunction(i)&&(i=i(this.$element)),b.syncCssClasses(e,this.$element,g),e.css(i),e.addClass(f),e},d}),b.define("select2/compat/dropdownCss",["jquery","./utils"],function(a,b){function c(a){return null}function d(){}return d.prototype.render=function(d){var e=d.call(this),f=this.options.get("dropdownCssClass")||"";a.isFunction(f)&&(f=f(this.$element));var g=this.options.get("adaptDropdownCssClass");if(g=g||c,-1!==f.indexOf(":all:")){f=f.replace(":all:","");var h=g;g=function(a){var b=h(a);return null!=b?b+" "+a:a}}var i=this.options.get("dropdownCss")||{};return a.isFunction(i)&&(i=i(this.$element)),b.syncCssClasses(e,this.$element,g),e.css(i),e.addClass(f),e},d}),b.define("select2/compat/initSelection",["jquery"],function(a){function b(a,b,c){c.get("debug")&&window.console&&console.warn&&console.warn("Select2: The `initSelection` option has been deprecated in favor of a custom data adapter that overrides the `current` method. This method is now called multiple times instead of a single time when the instance is initialized. Support will be removed for the `initSelection` option in future versions of Select2"),this.initSelection=c.get("initSelection"),this._isInitialized=!1,a.call(this,b,c)}return b.prototype.current=function(b,c){var d=this;return this._isInitialized?void b.call(this,c):void this.initSelection.call(null,this.$element,function(b){d._isInitialized=!0,a.isArray(b)||(b=[b]),c(b)})},b}),b.define("select2/compat/inputData",["jquery"],function(a){function b(a,b,c){this._currentData=[],this._valueSeparator=c.get("valueSeparator")||",","hidden"===b.prop("type")&&c.get("debug")&&console&&console.warn&&console.warn("Select2: Using a hidden input with Select2 is no longer supported and may stop working in the future. It is recommended to use a `<select>` element instead."),a.call(this,b,c)}return b.prototype.current=function(b,c){function d(b,c){var e=[];return b.selected||-1!==a.inArray(b.id,c)?(b.selected=!0,e.push(b)):b.selected=!1,b.children&&e.push.apply(e,d(b.children,c)),e}for(var e=[],f=0;f<this._currentData.length;f++){var g=this._currentData[f];e.push.apply(e,d(g,this.$element.val().split(this._valueSeparator)))}c(e)},b.prototype.select=function(b,c){if(this.options.get("multiple")){var d=this.$element.val();d+=this._valueSeparator+c.id,this.$element.val(d),this.$element.trigger("change")}else this.current(function(b){a.map(b,function(a){a.selected=!1})}),this.$element.val(c.id),this.$element.trigger("change")},b.prototype.unselect=function(a,b){var c=this;b.selected=!1,this.current(function(a){for(var d=[],e=0;e<a.length;e++){var f=a[e];b.id!=f.id&&d.push(f.id)}c.$element.val(d.join(c._valueSeparator)),c.$element.trigger("change")})},b.prototype.query=function(a,b,c){for(var d=[],e=0;e<this._currentData.length;e++){var f=this._currentData[e],g=this.matches(b,f);null!==g&&d.push(g)}c({results:d})},b.prototype.addOptions=function(b,c){var d=a.map(c,function(b){return a.data(b[0],"data")});this._currentData.push.apply(this._currentData,d)},b}),b.define("select2/compat/matcher",["jquery"],function(a){function b(b){function c(c,d){var e=a.extend(!0,{},d);if(null==c.term||""===a.trim(c.term))return e;if(d.children){for(var f=d.children.length-1;f>=0;f--){var g=d.children[f],h=b(c.term,g.text,g);h||e.children.splice(f,1)}if(e.children.length>0)return e}return b(c.term,d.text,d)?e:null}return c}return b}),b.define("select2/compat/query",[],function(){function a(a,b,c){c.get("debug")&&window.console&&console.warn&&console.warn("Select2: The `query` option has been deprecated in favor of a custom data adapter that overrides the `query` method. Support will be removed for the `query` option in future versions of Select2."),a.call(this,b,c)}return a.prototype.query=function(a,b,c){b.callback=c;var d=this.options.get("query");d.call(null,b)},a}),b.define("select2/dropdown/attachContainer",[],function(){function a(a,b,c){a.call(this,b,c)}return a.prototype.position=function(a,b,c){var d=c.find(".dropdown-wrapper");d.append(b),b.addClass("select2-dropdown--below"),c.addClass("select2-container--below")},a}),b.define("select2/dropdown/stopPropagation",[],function(){function a(){}return a.prototype.bind=function(a,b,c){a.call(this,b,c);var d=["blur","change","click","dblclick","focus","focusin","focusout","input","keydown","keyup","keypress","mousedown","mouseenter","mouseleave","mousemove","mouseover","mouseup","search","touchend","touchstart"];this.$dropdown.on(d.join(" "),function(a){a.stopPropagation()})},a}),b.define("select2/selection/stopPropagation",[],function(){function a(){}return a.prototype.bind=function(a,b,c){a.call(this,b,c);var d=["blur","change","click","dblclick","focus","focusin","focusout","input","keydown","keyup","keypress","mousedown","mouseenter","mouseleave","mousemove","mouseover","mouseup","search","touchend","touchstart"];this.$selection.on(d.join(" "),function(a){a.stopPropagation()})},a}),function(c){"function"==typeof b.define&&b.define.amd?b.define("jquery-mousewheel",["jquery"],c):"object"==typeof exports?module.exports=c:c(a)}(function(a){function b(b){var g=b||window.event,h=i.call(arguments,1),j=0,l=0,m=0,n=0,o=0,p=0;if(b=a.event.fix(g),b.type="mousewheel","detail"in g&&(m=-1*g.detail),"wheelDelta"in g&&(m=g.wheelDelta),"wheelDeltaY"in g&&(m=g.wheelDeltaY),"wheelDeltaX"in g&&(l=-1*g.wheelDeltaX),"axis"in g&&g.axis===g.HORIZONTAL_AXIS&&(l=-1*m,m=0),j=0===m?l:m,"deltaY"in g&&(m=-1*g.deltaY,j=m),"deltaX"in g&&(l=g.deltaX,0===m&&(j=-1*l)),0!==m||0!==l){if(1===g.deltaMode){var q=a.data(this,"mousewheel-line-height");j*=q,m*=q,l*=q}else if(2===g.deltaMode){var r=a.data(this,"mousewheel-page-height");j*=r,m*=r,l*=r}if(n=Math.max(Math.abs(m),Math.abs(l)),(!f||f>n)&&(f=n,d(g,n)&&(f/=40)),d(g,n)&&(j/=40,l/=40,m/=40),j=Math[j>=1?"floor":"ceil"](j/f),l=Math[l>=1?"floor":"ceil"](l/f),m=Math[m>=1?"floor":"ceil"](m/f),k.settings.normalizeOffset&&this.getBoundingClientRect){var s=this.getBoundingClientRect();o=b.clientX-s.left,p=b.clientY-s.top}return b.deltaX=l,b.deltaY=m,b.deltaFactor=f,b.offsetX=o,b.offsetY=p,b.deltaMode=0,h.unshift(b,j,l,m),e&&clearTimeout(e),e=setTimeout(c,200),(a.event.dispatch||a.event.handle).apply(this,h)}}function c(){f=null}function d(a,b){return k.settings.adjustOldDeltas&&"mousewheel"===a.type&&b%120===0}var e,f,g=["wheel","mousewheel","DOMMouseScroll","MozMousePixelScroll"],h="onwheel"in document||document.documentMode>=9?["wheel"]:["mousewheel","DomMouseScroll","MozMousePixelScroll"],i=Array.prototype.slice;if(a.event.fixHooks)for(var j=g.length;j;)a.event.fixHooks[g[--j]]=a.event.mouseHooks;var k=a.event.special.mousewheel={version:"3.1.12",setup:function(){if(this.addEventListener)for(var c=h.length;c;)this.addEventListener(h[--c],b,!1);else this.onmousewheel=b;a.data(this,"mousewheel-line-height",k.getLineHeight(this)),a.data(this,"mousewheel-page-height",k.getPageHeight(this))},teardown:function(){if(this.removeEventListener)for(var c=h.length;c;)this.removeEventListener(h[--c],b,!1);else this.onmousewheel=null;a.removeData(this,"mousewheel-line-height"),a.removeData(this,"mousewheel-page-height")},getLineHeight:function(b){var c=a(b),d=c["offsetParent"in a.fn?"offsetParent":"parent"]();return d.length||(d=a("body")),parseInt(d.css("fontSize"),10)||parseInt(c.css("fontSize"),10)||16},getPageHeight:function(b){return a(b).height()},settings:{adjustOldDeltas:!0,normalizeOffset:!0}};a.fn.extend({mousewheel:function(a){return a?this.bind("mousewheel",a):this.trigger("mousewheel")},unmousewheel:function(a){return this.unbind("mousewheel",a)}})}),b.define("jquery.select2",["jquery","jquery-mousewheel","./select2/core","./select2/defaults"],function(a,b,c,d){if(null==a.fn.select2){var e=["open","close","destroy"];a.fn.select2=function(b){if(b=b||{},"object"==typeof b)return this.each(function(){var d=a.extend(!0,{},b);new c(a(this),d)}),this;if("string"==typeof b){var d,f=Array.prototype.slice.call(arguments,1);return this.each(function(){var c=a(this).data("select2");null==c&&window.console&&console.error&&console.error("The select2('"+b+"') method was called on an element that is not using Select2."),d=c[b].apply(c,f)}),a.inArray(b,e)>-1?this:d}throw new Error("Invalid arguments for Select2: "+b)}}return null==a.fn.select2.defaults&&(a.fn.select2.defaults=d),c}),{define:b.define,require:b.require}}(),c=b.require("jquery.select2");return a.fn.select2.amd=b,c});
/*!
 * Nestable jQuery Plugin - Copyright (c) 2012 David Bushell - http://dbushell.com/
 * Dual-licensed under the BSD or MIT licenses
 */
;(function($, window, document, undefined)
{
    var hasTouch = 'ontouchstart' in window;

    /**
     * Detect CSS pointer-events property
     * events are normally disabled on the dragging element to avoid conflicts
     * https://github.com/ausi/Feature-detection-technique-for-pointer-events/blob/master/modernizr-pointerevents.js
     */
    var hasPointerEvents = (function()
    {
        var el    = document.createElement('div'),
            docEl = document.documentElement;
        if (!('pointerEvents' in el.style)) {
            return false;
        }
        el.style.pointerEvents = 'auto';
        el.style.pointerEvents = 'x';
        docEl.appendChild(el);
        var supports = window.getComputedStyle && window.getComputedStyle(el, '').pointerEvents === 'auto';
        docEl.removeChild(el);
        return !!supports;
    })();

    var eStart  = hasTouch ? 'touchstart'  : 'mousedown',
        eMove   = hasTouch ? 'touchmove'   : 'mousemove',
        eEnd    = hasTouch ? 'touchend'    : 'mouseup';
        eCancel = hasTouch ? 'touchcancel' : 'mouseup';

    var defaults = {
            listNodeName    : 'ol',
            itemNodeName    : 'li',
            rootClass       : 'dd',
            listClass       : 'dd-list',
            itemClass       : 'dd-item',
            dragClass       : 'dd-dragel',
            handleClass     : 'dd-handle',
            collapsedClass  : 'dd-collapsed',
            placeClass      : 'dd-placeholder',
            noDragClass     : 'dd-nodrag',
            emptyClass      : 'dd-empty',
            expandBtnHTML   : '<button data-action="expand" type="button">Expand</button>',
            collapseBtnHTML : '<button data-action="collapse" type="button">Collapse</button>',
            group           : 0,
            maxDepth        : 5,
            threshold       : 20,

            //method for call when an item has been successfully dropped
            //method has 1 argument in which sends an object containing all
            //necessary details
            dropCallback    : null
        };

    function Plugin(element, options)
    {
        this.w  = $(window);
        this.el = $(element);
        this.options = $.extend({}, defaults, options);
        this.init();
    }

    Plugin.prototype = {

        init: function()
        {
            var list = this;

            list.reset();

            list.el.data('nestable-group', this.options.group);

            list.placeEl = $('<div class="' + list.options.placeClass + '"/>');

            $.each(this.el.find(list.options.itemNodeName), function(k, el) {
                list.setParent($(el));
            });

            list.el.on('click', 'button', function(e) {
                if (list.dragEl || (!hasTouch && e.button !== 0)) {
                    return;
                }
                var target = $(e.currentTarget),
                    action = target.data('action'),
                    item   = target.parent(list.options.itemNodeName);
                if (action === 'collapse') {
                    list.collapseItem(item);
                }
                if (action === 'expand') {
                    list.expandItem(item);
                }
            });

            var onStartEvent = function(e)
            {
                var handle = $(e.target);
                if (!handle.hasClass(list.options.handleClass)) {
                    if (handle.closest('.' + list.options.noDragClass).length) {
                        return;
                    }
                    handle = handle.closest('.' + list.options.handleClass);
                }
                if (!handle.length || list.dragEl || (!hasTouch && e.button !== 0) || (hasTouch && e.touches.length !== 1)) {
                    return;
                }
                e.preventDefault();
                list.dragStart(hasTouch ? e.touches[0] : e);
            };

            var onMoveEvent = function(e)
            {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragMove(hasTouch ? e.touches[0] : e);
                }
            };

            var onEndEvent = function(e)
            {
                if (list.dragEl) {
                    e.preventDefault();
                    list.dragStop(hasTouch ? e.touches[0] : e);
                }
            };

            if (hasTouch) {
                list.el[0].addEventListener(eStart, onStartEvent, false);
                window.addEventListener(eMove, onMoveEvent, false);
                window.addEventListener(eEnd, onEndEvent, false);
                window.addEventListener(eCancel, onEndEvent, false);
            } else {
                list.el.on(eStart, onStartEvent);
                list.w.on(eMove, onMoveEvent);
                list.w.on(eEnd, onEndEvent);
            }

        },

        serialize: function()
        {
            var data,
                depth = 0,
                list  = this;
                step  = function(level, depth)
                {
                    var array = [ ],
                        items = level.children(list.options.itemNodeName);
                    items.each(function()
                    {
                        var li   = $(this),
                            item = $.extend({}, li.data()),
                            sub  = li.children(list.options.listNodeName);
                        if (sub.length) {
                            item.children = step(sub, depth + 1);
                        }
                        array.push(item);
                    });
                    return array;
                };
            data = step(list.el.find(list.options.listNodeName).first(), depth);
            return data;
        },

        serialise: function()
        {
            return this.serialize();
        },

        reset: function()
        {
            this.mouse = {
                offsetX   : 0,
                offsetY   : 0,
                startX    : 0,
                startY    : 0,
                lastX     : 0,
                lastY     : 0,
                nowX      : 0,
                nowY      : 0,
                distX     : 0,
                distY     : 0,
                dirAx     : 0,
                dirX      : 0,
                dirY      : 0,
                lastDirX  : 0,
                lastDirY  : 0,
                distAxX   : 0,
                distAxY   : 0
            };
            this.moving     = false;
            this.dragEl     = null;
            this.dragRootEl = null;
            this.dragDepth  = 0;
            this.hasNewRoot = false;
            this.pointEl    = null;
            this.sourceRoot = null;
        },

        expandItem: function(li)
        {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action="expand"]').hide();
            li.children('[data-action="collapse"]').show();
            li.children(this.options.listNodeName).show();
        },

        collapseItem: function(li)
        {
            var lists = li.children(this.options.listNodeName);
            if (lists.length) {
                li.addClass(this.options.collapsedClass);
                li.children('[data-action="collapse"]').hide();
                li.children('[data-action="expand"]').show();
                li.children(this.options.listNodeName).hide();
            }
        },

        expandAll: function()
        {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function() {
                list.expandItem($(this));
            });
        },

        collapseAll: function()
        {
            var list = this;
            list.el.find(list.options.itemNodeName).each(function() {
                list.collapseItem($(this));
            });
        },

        setParent: function(li)
        {
            if (li.children(this.options.listNodeName).length) {
                li.prepend($(this.options.expandBtnHTML));
                li.prepend($(this.options.collapseBtnHTML));
            }
            li.children('[data-action="expand"]').hide();
        },

        unsetParent: function(li)
        {
            li.removeClass(this.options.collapsedClass);
            li.children('[data-action]').remove();
            li.children(this.options.listNodeName).remove();
        },

        dragStart: function(e)
        {
            var mouse    = this.mouse,
                target   = $(e.target),
                dragItem = target.closest(this.options.itemNodeName);

            this.sourceRoot = target.closest('.' + this.options.rootClass);
            this.placeEl.css('height', dragItem.height());

            mouse.offsetX = e.offsetX !== undefined ? e.offsetX : e.pageX - target.offset().left;
            mouse.offsetY = e.offsetY !== undefined ? e.offsetY : e.pageY - target.offset().top;
            mouse.startX = mouse.lastX = e.pageX;
            mouse.startY = mouse.lastY = e.pageY;

            this.dragRootEl = this.el;

            this.dragEl = $(document.createElement(this.options.listNodeName)).addClass(this.options.listClass + ' ' + this.options.dragClass);
            this.dragEl.css('width', dragItem.width());

            // fix for zepto.js
            //dragItem.after(this.placeEl).detach().appendTo(this.dragEl);
            dragItem.after(this.placeEl);
            dragItem[0].parentNode.removeChild(dragItem[0]);
            dragItem.appendTo(this.dragEl);

            $(document.body).append(this.dragEl);
            this.dragEl.css({
                'left' : e.pageX - mouse.offsetX,
                'top'  : e.pageY - mouse.offsetY
            });
            // total depth of dragging item
            var i, depth,
                items = this.dragEl.find(this.options.itemNodeName);
            for (i = 0; i < items.length; i++) {
                depth = $(items[i]).parents(this.options.listNodeName).length;
                if (depth > this.dragDepth) {
                    this.dragDepth = depth;
                }
            }
        },

        dragStop: function(e)
        {
            // fix for zepto.js
            //this.placeEl.replaceWith(this.dragEl.children(this.options.itemNodeName + ':first').detach());
            var el = this.dragEl.children(this.options.itemNodeName).first();
            el[0].parentNode.removeChild(el[0]);
            this.placeEl.replaceWith(el);

            this.dragEl.remove();
            this.el.trigger('change');

            //Let's find out new parent id
            var parentItem = el.parent().parent();
            var parentId = null;
            if(parentItem !== null && !parentItem.is('.' + this.options.rootClass))
                parentId = parentItem.data('id');

            if($.isFunction(this.options.dropCallback)) {
              var details = {
                sourceId   : el.data('id'),
                destId     : parentId,
                sourceEl   : el,
                destParent : parentItem,
                destRoot   : el.closest('.' + this.options.rootClass),
                sourceRoot : this.sourceRoot
              };
              this.options.dropCallback.call(this, details);
            }

            if (this.hasNewRoot) {
                this.dragRootEl.trigger('change');
            }
            this.reset();
        },

        dragMove: function(e)
        {
            var list, parent, prev, next, depth,
                opt   = this.options,
                mouse = this.mouse;

            this.dragEl.css({
                'left' : e.pageX - mouse.offsetX,
                'top'  : e.pageY - mouse.offsetY
            });

            // mouse position last events
            mouse.lastX = mouse.nowX;
            mouse.lastY = mouse.nowY;
            // mouse position this events
            mouse.nowX  = e.pageX;
            mouse.nowY  = e.pageY;
            // distance mouse moved between events
            mouse.distX = mouse.nowX - mouse.lastX;
            mouse.distY = mouse.nowY - mouse.lastY;
            // direction mouse was moving
            mouse.lastDirX = mouse.dirX;
            mouse.lastDirY = mouse.dirY;
            // direction mouse is now moving (on both axis)
            mouse.dirX = mouse.distX === 0 ? 0 : mouse.distX > 0 ? 1 : -1;
            mouse.dirY = mouse.distY === 0 ? 0 : mouse.distY > 0 ? 1 : -1;
            // axis mouse is now moving on
            var newAx   = Math.abs(mouse.distX) > Math.abs(mouse.distY) ? 1 : 0;

            // do nothing on first move
            if (!mouse.moving) {
                mouse.dirAx  = newAx;
                mouse.moving = true;
                return;
            }

            // calc distance moved on this axis (and direction)
            if (mouse.dirAx !== newAx) {
                mouse.distAxX = 0;
                mouse.distAxY = 0;
            } else {
                mouse.distAxX += Math.abs(mouse.distX);
                if (mouse.dirX !== 0 && mouse.dirX !== mouse.lastDirX) {
                    mouse.distAxX = 0;
                }
                mouse.distAxY += Math.abs(mouse.distY);
                if (mouse.dirY !== 0 && mouse.dirY !== mouse.lastDirY) {
                    mouse.distAxY = 0;
                }
            }
            mouse.dirAx = newAx;

            /**
             * move horizontal
             */
            if (mouse.dirAx && mouse.distAxX >= opt.threshold) {
                // reset move distance on x-axis for new phase
                mouse.distAxX = 0;
                prev = this.placeEl.prev(opt.itemNodeName);
                // increase horizontal level if previous sibling exists and is not collapsed
                if (mouse.distX > 0 && prev.length && !prev.hasClass(opt.collapsedClass)) {
                    // cannot increase level when item above is collapsed
                    list = prev.find(opt.listNodeName).last();
                    // check if depth limit has reached
                    depth = this.placeEl.parents(opt.listNodeName).length;
                    if (depth + this.dragDepth <= opt.maxDepth) {
                        // create new sub-level if one doesn't exist
                        if (!list.length) {
                            list = $('<' + opt.listNodeName + '/>').addClass(opt.listClass);
                            list.append(this.placeEl);
                            prev.append(list);
                            this.setParent(prev);
                        } else {
                            // else append to next level up
                            list = prev.children(opt.listNodeName).last();
                            list.append(this.placeEl);
                        }
                    }
                }
                // decrease horizontal level
                if (mouse.distX < 0) {
                    // we can't decrease a level if an item preceeds the current one
                    next = this.placeEl.next(opt.itemNodeName);
                    if (!next.length) {
                        parent = this.placeEl.parent();
                        this.placeEl.closest(opt.itemNodeName).after(this.placeEl);
                        if (!parent.children().length) {
                            this.unsetParent(parent.parent());
                        }
                    }
                }
            }

            var isEmpty = false;

            // find list item under cursor
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'hidden';
            }
            this.pointEl = $(document.elementFromPoint(e.pageX - document.body.scrollLeft, e.pageY - (window.pageYOffset || document.documentElement.scrollTop)));
            if (!hasPointerEvents) {
                this.dragEl[0].style.visibility = 'visible';
            }
            if (this.pointEl.hasClass(opt.handleClass)) {
                this.pointEl = this.pointEl.parent(opt.itemNodeName);
            }
            if (this.pointEl.hasClass(opt.emptyClass)) {
                isEmpty = true;
            }
            else if (!this.pointEl.length || !this.pointEl.hasClass(opt.itemClass)) {
                return;
            }

            // find parent list of item under cursor
            var pointElRoot = this.pointEl.closest('.' + opt.rootClass),
                isNewRoot   = this.dragRootEl.data('nestable-id') !== pointElRoot.data('nestable-id');

            /**
             * move vertical
             */
            if (!mouse.dirAx || isNewRoot || isEmpty) {
                // check if groups match if dragging over new root
                if (isNewRoot && opt.group !== pointElRoot.data('nestable-group')) {
                    return;
                }
                // check depth limit
                depth = this.dragDepth - 1 + this.pointEl.parents(opt.listNodeName).length;
                if (depth > opt.maxDepth) {
                    return;
                }
                var before = e.pageY < (this.pointEl.offset().top + this.pointEl.height() / 2);
                    parent = this.placeEl.parent();
                // if empty create new list to replace empty placeholder
                if (isEmpty) {
                    list = $(document.createElement(opt.listNodeName)).addClass(opt.listClass);
                    list.append(this.placeEl);
                    this.pointEl.replaceWith(list);
                }
                else if (before) {
                    this.pointEl.before(this.placeEl);
                }
                else {
                    this.pointEl.after(this.placeEl);
                }
                if (!parent.children().length) {
                    this.unsetParent(parent.parent());
                }
                if (!this.dragRootEl.find(opt.itemNodeName).length) {
                    this.dragRootEl.append('<div class="' + opt.emptyClass + '"/>');
                }
                // parent root list has changed
                if (isNewRoot) {
                    this.dragRootEl = pointElRoot;
                    this.hasNewRoot = this.el[0] !== this.dragRootEl[0];
                }
            }
        }

    };

    $.fn.nestable = function(params)
    {
        var lists  = this,
            retval = this;

        lists.each(function()
        {
            var plugin = $(this).data("nestable");

            if (!plugin) {
                $(this).data("nestable", new Plugin(this, params));
                $(this).data("nestable-id", new Date().getTime());
            } else {
                if (typeof params === 'string' && typeof plugin[params] === 'function') {
                    retval = plugin[params]();
                }
            }
        });

        return retval || lists;
    };

})(window.jQuery || window.Zepto, window, document);
!function(e){e(["jquery"],function(e){return function(){function t(e,t,n){return g({type:O.error,iconClass:m().iconClasses.error,message:e,optionsOverride:n,title:t})}function n(t,n){return t||(t=m()),v=e("#"+t.containerId),v.length?v:(n&&(v=u(t)),v)}function i(e,t,n){return g({type:O.info,iconClass:m().iconClasses.info,message:e,optionsOverride:n,title:t})}function o(e){w=e}function s(e,t,n){return g({type:O.success,iconClass:m().iconClasses.success,message:e,optionsOverride:n,title:t})}function a(e,t,n){return g({type:O.warning,iconClass:m().iconClasses.warning,message:e,optionsOverride:n,title:t})}function r(e,t){var i=m();v||n(i),l(e,i,t)||d(i)}function c(t){var i=m();return v||n(i),t&&0===e(":focus",t).length?void h(t):void(v.children().length&&v.remove())}function d(t){for(var n=v.children(),i=n.length-1;i>=0;i--)l(e(n[i]),t)}function l(t,n,i){var o=i&&i.force?i.force:!1;return t&&(o||0===e(":focus",t).length)?(t[n.hideMethod]({duration:n.hideDuration,easing:n.hideEasing,complete:function(){h(t)}}),!0):!1}function u(t){return v=e("<div/>").attr("id",t.containerId).addClass(t.positionClass).attr("aria-live","polite").attr("role","alert"),v.appendTo(e(t.target)),v}function p(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",showDuration:300,showEasing:"swing",onShown:void 0,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:void 0,closeMethod:!1,closeDuration:!1,closeEasing:!1,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-right",timeOut:5e3,titleClass:"toast-title",messageClass:"toast-message",escapeHtml:!1,target:"body",closeHtml:'<button type="button">&times;</button>',newestOnTop:!0,preventDuplicates:!1,progressBar:!1}}function f(e){w&&w(e)}function g(t){function i(e){return null==e&&(e=""),new String(e).replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function o(){r(),d(),l(),u(),p(),c()}function s(){y.hover(b,O),!x.onclick&&x.tapToDismiss&&y.click(w),x.closeButton&&k&&k.click(function(e){e.stopPropagation?e.stopPropagation():void 0!==e.cancelBubble&&e.cancelBubble!==!0&&(e.cancelBubble=!0),w(!0)}),x.onclick&&y.click(function(e){x.onclick(e),w()})}function a(){y.hide(),y[x.showMethod]({duration:x.showDuration,easing:x.showEasing,complete:x.onShown}),x.timeOut>0&&(H=setTimeout(w,x.timeOut),q.maxHideTime=parseFloat(x.timeOut),q.hideEta=(new Date).getTime()+q.maxHideTime,x.progressBar&&(q.intervalId=setInterval(D,10)))}function r(){t.iconClass&&y.addClass(x.toastClass).addClass(E)}function c(){x.newestOnTop?v.prepend(y):v.append(y)}function d(){t.title&&(I.append(x.escapeHtml?i(t.title):t.title).addClass(x.titleClass),y.append(I))}function l(){t.message&&(M.append(x.escapeHtml?i(t.message):t.message).addClass(x.messageClass),y.append(M))}function u(){x.closeButton&&(k.addClass("toast-close-button").attr("role","button"),y.prepend(k))}function p(){x.progressBar&&(B.addClass("toast-progress"),y.prepend(B))}function g(e,t){if(e.preventDuplicates){if(t.message===C)return!0;C=t.message}return!1}function w(t){var n=t&&x.closeMethod!==!1?x.closeMethod:x.hideMethod,i=t&&x.closeDuration!==!1?x.closeDuration:x.hideDuration,o=t&&x.closeEasing!==!1?x.closeEasing:x.hideEasing;return!e(":focus",y).length||t?(clearTimeout(q.intervalId),y[n]({duration:i,easing:o,complete:function(){h(y),x.onHidden&&"hidden"!==j.state&&x.onHidden(),j.state="hidden",j.endTime=new Date,f(j)}})):void 0}function O(){(x.timeOut>0||x.extendedTimeOut>0)&&(H=setTimeout(w,x.extendedTimeOut),q.maxHideTime=parseFloat(x.extendedTimeOut),q.hideEta=(new Date).getTime()+q.maxHideTime)}function b(){clearTimeout(H),q.hideEta=0,y.stop(!0,!0)[x.showMethod]({duration:x.showDuration,easing:x.showEasing})}function D(){var e=(q.hideEta-(new Date).getTime())/q.maxHideTime*100;B.width(e+"%")}var x=m(),E=t.iconClass||x.iconClass;if("undefined"!=typeof t.optionsOverride&&(x=e.extend(x,t.optionsOverride),E=t.optionsOverride.iconClass||E),!g(x,t)){T++,v=n(x,!0);var H=null,y=e("<div/>"),I=e("<div/>"),M=e("<div/>"),B=e("<div/>"),k=e(x.closeHtml),q={intervalId:null,hideEta:null,maxHideTime:null},j={toastId:T,state:"visible",startTime:new Date,options:x,map:t};return o(),a(),s(),f(j),x.debug&&console&&console.log(j),y}}function m(){return e.extend({},p(),b.options)}function h(e){v||(v=n()),e.is(":visible")||(e.remove(),e=null,0===v.children().length&&(v.remove(),C=void 0))}var v,w,C,T=0,O={error:"error",info:"info",success:"success",warning:"warning"},b={clear:r,remove:c,error:t,getContainer:n,info:i,options:{},subscribe:o,success:s,version:"2.1.2",warning:a};return b}()})}("function"==typeof define&&define.amd?define:function(e,t){"undefined"!=typeof module&&module.exports?module.exports=t(require("jquery")):window.toastr=t(window.jQuery)});
//# sourceMappingURL=toastr.js.map
/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.8
 *
 */
(function($) {

  $.fn.extend({
    slimScroll: function(options) {

      var defaults = {

        // width in pixels of the visible scroll area
        width : 'auto',

        // height in pixels of the visible scroll area
        height : '250px',

        // width in pixels of the scrollbar and rail
        size : '7px',

        // scrollbar color, accepts any hex/color value
        color: '#000',

        // scrollbar position - left/right
        position : 'right',

        // distance in pixels between the side edge and the scrollbar
        distance : '1px',

        // default scroll position on load - top / bottom / $('selector')
        start : 'top',

        // sets scrollbar opacity
        opacity : .4,

        // enables always-on mode for the scrollbar
        alwaysVisible : false,

        // check if we should hide the scrollbar when user is hovering over
        disableFadeOut : false,

        // sets visibility of the rail
        railVisible : false,

        // sets rail color
        railColor : '#333',

        // sets rail opacity
        railOpacity : .2,

        // whether  we should use jQuery UI Draggable to enable bar dragging
        railDraggable : true,

        // defautlt CSS class of the slimscroll rail
        railClass : 'slimScrollRail',

        // defautlt CSS class of the slimscroll bar
        barClass : 'slimScrollBar',

        // defautlt CSS class of the slimscroll wrapper
        wrapperClass : 'slimScrollDiv',

        // check if mousewheel should scroll the window if we reach top/bottom
        allowPageScroll : false,

        // scroll amount applied to each mouse wheel step
        wheelStep : 20,

        // scroll amount applied when user is using gestures
        touchScrollStep : 200,

        // sets border radius
        borderRadius: '7px',

        // sets border radius of the rail
        railBorderRadius : '7px'
      };

      var o = $.extend(defaults, options);

      // do it for every element that matches selector
      this.each(function(){

      var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
        barHeight, percentScroll, lastScroll,
        divS = '<div></div>',
        minBarHeight = 30,
        releaseScroll = false;

        // used in event handlers and for better minification
        var me = $(this);

        // ensure we are not binding it again
        if (me.parent().hasClass(o.wrapperClass))
        {
            // start from last bar position
            var offset = me.scrollTop();

            // find bar and rail
            bar = me.siblings('.' + o.barClass);
            rail = me.siblings('.' + o.railClass);

            getBarHeight();

            // check if we should scroll existing instance
            if ($.isPlainObject(options))
            {
              // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
              if ( 'height' in options && options.height == 'auto' ) {
                me.parent().css('height', 'auto');
                me.css('height', 'auto');
                var height = me.parent().parent().height();
                me.parent().css('height', height);
                me.css('height', height);
              } else if ('height' in options) {
                var h = options.height;
                me.parent().css('height', h);
                me.css('height', h);
              }

              if ('scrollTo' in options)
              {
                // jump to a static point
                offset = parseInt(o.scrollTo);
              }
              else if ('scrollBy' in options)
              {
                // jump by value pixels
                offset += parseInt(o.scrollBy);
              }
              else if ('destroy' in options)
              {
                // remove slimscroll elements
                bar.remove();
                rail.remove();
                me.unwrap();
                return;
              }

              // scroll content by the given offset
              scrollContent(offset, false, true);
            }

            return;
        }
        else if ($.isPlainObject(options))
        {
            if ('destroy' in options)
            {
            	return;
            }
        }

        // optionally set height to the parent's height
        o.height = (o.height == 'auto') ? me.parent().height() : o.height;

        // wrap content
        var wrapper = $(divS)
          .addClass(o.wrapperClass)
          .css({
            position: 'relative',
            overflow: 'hidden',
            width: o.width,
            height: o.height
          });

        // update style for the div
        me.css({
          overflow: 'hidden',
          width: o.width,
          height: o.height
        });

        // create scrollbar rail
        var rail = $(divS)
          .addClass(o.railClass)
          .css({
            width: o.size,
            height: '100%',
            position: 'absolute',
            top: 0,
            display: (o.alwaysVisible && o.railVisible) ? 'block' : 'none',
            'border-radius': o.railBorderRadius,
            background: o.railColor,
            opacity: o.railOpacity,
            zIndex: 90
          });

        // create scrollbar
        var bar = $(divS)
          .addClass(o.barClass)
          .css({
            background: o.color,
            width: o.size,
            position: 'absolute',
            top: 0,
            opacity: o.opacity,
            display: o.alwaysVisible ? 'block' : 'none',
            'border-radius' : o.borderRadius,
            BorderRadius: o.borderRadius,
            MozBorderRadius: o.borderRadius,
            WebkitBorderRadius: o.borderRadius,
            zIndex: 99
          });

        // set position
        var posCss = (o.position == 'right') ? { right: o.distance } : { left: o.distance };
        rail.css(posCss);
        bar.css(posCss);

        // wrap it
        me.wrap(wrapper);

        // append to parent div
        me.parent().append(bar);
        me.parent().append(rail);

        // make it draggable and no longer dependent on the jqueryUI
        if (o.railDraggable){
          bar.bind("mousedown", function(e) {
            var $doc = $(document);
            isDragg = true;
            t = parseFloat(bar.css('top'));
            pageY = e.pageY;

            $doc.bind("mousemove.slimscroll", function(e){
              currTop = t + e.pageY - pageY;
              bar.css('top', currTop);
              scrollContent(0, bar.position().top, false);// scroll content
            });

            $doc.bind("mouseup.slimscroll", function(e) {
              isDragg = false;hideBar();
              $doc.unbind('.slimscroll');
            });
            return false;
          }).bind("selectstart.slimscroll", function(e){
            e.stopPropagation();
            e.preventDefault();
            return false;
          });
        }

        // on rail over
        rail.hover(function(){
          showBar();
        }, function(){
          hideBar();
        });

        // on bar over
        bar.hover(function(){
          isOverBar = true;
        }, function(){
          isOverBar = false;
        });

        // show on parent mouseover
        me.hover(function(){
          isOverPanel = true;
          showBar();
          hideBar();
        }, function(){
          isOverPanel = false;
          hideBar();
        });

        // support for mobile
        me.bind('touchstart', function(e,b){
          if (e.originalEvent.touches.length)
          {
            // record where touch started
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });

        me.bind('touchmove', function(e){
          // prevent scrolling the page if necessary
          if(!releaseScroll)
          {
  		      e.originalEvent.preventDefault();
		      }
          if (e.originalEvent.touches.length)
          {
            // see how far user swiped
            var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
            // scroll content
            scrollContent(diff, true);
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });

        // set up initial height
        getBarHeight();

        // check start position
        if (o.start === 'bottom')
        {
          // scroll content to bottom
          bar.css({ top: me.outerHeight() - bar.outerHeight() });
          scrollContent(0, true);
        }
        else if (o.start !== 'top')
        {
          // assume jQuery selector
          scrollContent($(o.start).position().top, null, true);

          // make sure bar stays hidden
          if (!o.alwaysVisible) { bar.hide(); }
        }

        // attach scroll events
        attachWheel(this);

        function _onWheel(e)
        {
          // use mouse wheel only when mouse is over
          if (!isOverPanel) { return; }

          var e = e || window.event;

          var delta = 0;
          if (e.wheelDelta) { delta = -e.wheelDelta/120; }
          if (e.detail) { delta = e.detail / 3; }

          var target = e.target || e.srcTarget || e.srcElement;
          if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
            // scroll content
            scrollContent(delta, true);
          }

          // stop window scroll
          if (e.preventDefault && !releaseScroll) { e.preventDefault(); }
          if (!releaseScroll) { e.returnValue = false; }
        }

        function scrollContent(y, isWheel, isJump)
        {
          releaseScroll = false;
          var delta = y;
          var maxTop = me.outerHeight() - bar.outerHeight();

          if (isWheel)
          {
            // move bar with mouse wheel
            delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

            // move bar, make sure it doesn't go out
            delta = Math.min(Math.max(delta, 0), maxTop);

            // if scrolling down, make sure a fractional change to the
            // scroll position isn't rounded away when the scrollbar's CSS is set
            // this flooring of delta would happened automatically when
            // bar.css is set below, but we floor here for clarity
            delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);

            // scroll the scrollbar
            bar.css({ top: delta + 'px' });
          }

          // calculate actual scroll amount
          percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
          delta = percentScroll * (me[0].scrollHeight - me.outerHeight());

          if (isJump)
          {
            delta = y;
            var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
            offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
            bar.css({ top: offsetTop + 'px' });
          }

          // scroll content
          me.scrollTop(delta);

          // fire scrolling event
          me.trigger('slimscrolling', ~~delta);

          // ensure bar is visible
          showBar();

          // trigger hide when scroll is stopped
          hideBar();
        }

        function attachWheel(target)
        {
          if (window.addEventListener)
          {
            target.addEventListener('DOMMouseScroll', _onWheel, false );
            target.addEventListener('mousewheel', _onWheel, false );
          }
          else
          {
            document.attachEvent("onmousewheel", _onWheel)
          }
        }

        function getBarHeight()
        {
          // calculate scrollbar height and make sure it is not too small
          barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
          bar.css({ height: barHeight + 'px' });

          // hide scrollbar if content is not long enough
          var display = barHeight == me.outerHeight() ? 'none' : 'block';
          bar.css({ display: display });
        }

        function showBar()
        {
          // recalculate bar height
          getBarHeight();
          clearTimeout(queueHide);

          // when bar reached top or bottom
          if (percentScroll == ~~percentScroll)
          {
            //release wheel
            releaseScroll = o.allowPageScroll;

            // publish approporiate event
            if (lastScroll != percentScroll)
            {
                var msg = (~~percentScroll == 0) ? 'top' : 'bottom';
                me.trigger('slimscroll', msg);
            }
          }
          else
          {
            releaseScroll = false;
          }
          lastScroll = percentScroll;

          // show only when required
          if(barHeight >= me.outerHeight()) {
            //allow window scroll
            releaseScroll = true;
            return;
          }
          bar.stop(true,true).fadeIn('fast');
          if (o.railVisible) { rail.stop(true,true).fadeIn('fast'); }
        }

        function hideBar()
        {
          // only hide when options allow it
          if (!o.alwaysVisible)
          {
            queueHide = setTimeout(function(){
              if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg)
              {
                bar.fadeOut('slow');
                rail.fadeOut('slow');
              }
            }, 1000);
          }
        }

      });

      // maintain chainability
      return this;
    }
  });

  $.fn.extend({
    slimscroll: $.fn.slimScroll
  });

})(jQuery);

/**
 * Created by OneSource on 16/05/2017.
 */

//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
    throw new Error("EmpatiaLayout requires jQuery");
}

/* EmpatiaLayout
 *
 * @type Object
 * @description $.EmpatiaLayout is the main object for the template's app.
 *              It's used for implementing functions and options related
 *              to the template. Keeping everything wrapped in an object
 *              prevents conflict with other plugins and is a better
 *              way to organize our code.
 */
$.EmpatiaLayout = {};

/* --------------------
 * - EmpatiaLayout Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.EmpatiaLayout.options = {
    //Add slimscroll to navbar menus
    //This requires you to load the slimscroll plugin
    //in every page before app.js
    navbarMenuSlimscroll: true,
    navbarMenuSlimscrollWidth: "3px", //The width of the scroll bar
    navbarMenuHeight: "200px", //The height of the inner menu
    //General animation speed for JS animated elements such as box collapse/expand and
    //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
    //'fast', 'normal', or 'slow'
    animationSpeed: 500,
    //Sidebar push menu toggle button selector
    sidebarToggleSelector: "[data-toggle='offcanvas']",
    //Activate sidebar push menu
    sidebarPushMenu: true,
    //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
    sidebarSlimScroll: true,
    //Enable sidebar expand on hover effect for sidebar mini
    //This option is forced to true if both the fixed layout and sidebar mini
    //are used together
    sidebarExpandOnHover: false,
    //BoxRefresh Plugin
    enableBoxRefresh: true,
    //Bootstrap.js tooltip
    enableBSToppltip: true,
    BSTooltipSelector: "[data-toggle='tooltip']",
    //Enable Fast Click. Fastclick.js creates a more
    //native touch experience with touch devices. If you
    //choose to enable the plugin, make sure you load the script
    //before EmpatiaLayout's app.js
    enableFastclick: true,
    //Control Sidebar Options
    enableControlSidebar: true,
    controlSidebarOptions: {
        //Which button should trigger the open/close event
        toggleBtnSelector: "[data-toggle='control-sidebar']",
        //The sidebar selector
        selector: ".control-sidebar",
        //Enable slide over content
        slide: true
    },
    //Box Widget Plugin. Enable this plugin
    //to allow boxes to be collapsed and/or removed
    enableBoxWidget: true,
    //Box Widget plugin options
    boxWidgetOptions: {
        boxWidgetIcons: {
            //Collapse icon
            collapse: 'fa-minus',
            //Open icon
            open: 'fa-plus',
            //Remove icon
            remove: 'fa-times'
        },
        boxWidgetSelectors: {
            //Remove button selector
            remove: '[data-widget="remove"]',
            //Collapse button selector
            collapse: '[data-widget="collapse"]'
        }
    },
    //Direct Chat plugin options
    directChat: {
        //Enable direct chat by default
        enable: true,
        //The button to open and close the chat contacts pane
        contactToggleSelector: '[data-widget="chat-pane-toggle"]'
    },
    //Define the set of colors to use globally around the website
    colors: {
        lightBlue: "#3c8dbc",
        red: "#f56954",
        green: "#00a65a",
        aqua: "#00c0ef",
        yellow: "#f39c12",
        blue: "#0073b7",
        navy: "#001F3F",
        teal: "#39CCCC",
        olive: "#3D9970",
        lime: "#01FF70",
        orange: "#FF851B",
        fuchsia: "#F012BE",
        purple: "#8E24AA",
        maroon: "#D81B60",
        black: "#222222",
        gray: "#d2d6de"
    },
    //The standard screen sizes that bootstrap uses.
    //If you change these in the variables.less file, change
    //them here too.
    screenSizes: {
        xs: 480,
        sm: 768,
        md: 992,
        lg: 1200
    }
};

/* ------------------
 * - Implementation -
 * ------------------
 * The next block of code implements EmpatiaLayout's
 * functions and plugins as specified by the
 * options above.
 */
$(function () {
    "use strict";

    //Fix for IE page transitions
    $("body").removeClass("hold-transition");

    //Extend options if external options exist
    if (typeof EmpatiaLayoutOptions !== "undefined") {
        $.extend(true,
            $.EmpatiaLayout.options,
            EmpatiaLayoutOptions);
    }

    //Easy access to options
    var o = $.EmpatiaLayout.options;

    //Set up the object
    _init();

    //Activate the layout maker
    $.EmpatiaLayout.layout.activate();

    //Enable sidebar tree view controls
    $.EmpatiaLayout.tree('.sidebar');

    //Enable control sidebar
    if (o.enableControlSidebar) {
        $.EmpatiaLayout.controlSidebar.activate();
    }

    //Add slimscroll to navbar dropdown
    if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
        $(".navbar .menu").slimscroll({
            height: o.navbarMenuHeight,
            alwaysVisible: false,
            size: o.navbarMenuSlimscrollWidth
        }).css("width", "100%");
    }

    //Activate sidebar push menu
    if (o.sidebarPushMenu) {
        $.EmpatiaLayout.pushMenu.activate(o.sidebarToggleSelector);
    }

    //Activate Bootstrap tooltip
    if (o.enableBSToppltip) {
        $('body').tooltip({
            selector: o.BSTooltipSelector
        });
    }

    //Activate box widget
    if (o.enableBoxWidget) {
        $.EmpatiaLayout.boxWidget.activate();
    }

    //Activate fast click
    if (o.enableFastclick && typeof FastClick != 'undefined') {
        FastClick.attach(document.body);
    }

    //Activate direct chat widget
    if (o.directChat.enable) {
        $(document).on('click', o.directChat.contactToggleSelector, function () {
            var box = $(this).parents('.direct-chat').first();
            box.toggleClass('direct-chat-contacts-open');
        });
    }

    /*
     * INITIALIZE BUTTON TOGGLE
     * ------------------------
     */
    $('.btn-group[data-toggle="btn-toggle"]').each(function () {
        var group = $(this);
        $(this).find(".btn").on('click', function (e) {
            group.find(".btn.active").removeClass("active");
            $(this).addClass("active");
            e.preventDefault();
        });

    });
});

/* ----------------------------------
 * - Initialize the EmpatiaLayout Object -
 * ----------------------------------
 * All EmpatiaLayout functions are implemented below.
 */
function _init() {
    'use strict';
    /* Layout
     * ======
     * Fixes the layout height in case min-height fails.
     *
     * @type Object
     * @usage $.EmpatiaLayout.layout.activate()
     *        $.EmpatiaLayout.layout.fix()
     *        $.EmpatiaLayout.layout.fixSidebar()
     */
    $.EmpatiaLayout.layout = {
        activate: function () {
            var _this = this;
            _this.fix();
            _this.fixSidebar();
            $(window, ".wrapper").resize(function () {
                _this.fix();
                _this.fixSidebar();
            });
        },
        fix: function () {
            //Get window height and the wrapper height
            var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
            var window_height = $(window).height();
            var sidebar_height = $(".sidebar").height();
            //Set the min-height of the content and sidebar based on the
            //the height of the document.
            if ($("body").hasClass("fixed")) {
                $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
            } else {
                var postSetWidth;
                if (window_height >= sidebar_height) {
                    $(".content-wrapper, .right-side").css('min-height', window_height - neg);
                    postSetWidth = window_height - neg;
                } else {
                    $(".content-wrapper, .right-side").css('min-height', sidebar_height);
                    postSetWidth = sidebar_height;
                }

                //Fix for the control sidebar height
                var controlSidebar = $($.EmpatiaLayout.options.controlSidebarOptions.selector);
                if (typeof controlSidebar !== "undefined") {
                    if (controlSidebar.height() > postSetWidth)
                        $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
                }

            }
        },
        fixSidebar: function () {
            //Make sure the body tag has the .fixed class
            if (!$("body").hasClass("fixed")) {
                if (typeof $.fn.slimScroll != 'undefined') {
                    $(".sidebar").slimScroll({destroy: true}).height("auto");
                }
                return;
            } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
                window.console.error("Error: the fixed layout requires the slimscroll plugin!");
            }
            //Enable slimscroll for fixed layout
            if ($.EmpatiaLayout.options.sidebarSlimScroll) {
                if (typeof $.fn.slimScroll != 'undefined') {
                    //Destroy if it exists
                    $(".sidebar").slimScroll({destroy: true}).height("auto");
                    //Add slimscroll
                    $(".sidebar").slimscroll({
                        height: ($(window).height() - $(".main-header").height()) + "px",
                        color: "rgba(0,0,0,0.2)",
                        size: "3px"
                    });
                }
            }
        }
    };

    /* PushMenu()
     * ==========
     * Adds the push menu functionality to the sidebar.
     *
     * @type Function
     * @usage: $.EmpatiaLayout.pushMenu("[data-toggle='offcanvas']")
     */
    $.EmpatiaLayout.pushMenu = {
        activate: function (toggleBtn) {
            //Get the screen sizes
            var screenSizes = $.EmpatiaLayout.options.screenSizes;

            //Enable sidebar toggle
            $(toggleBtn).on('click', function (e) {
                e.preventDefault();

                //Enable sidebar push menu
                if ($(window).width() > (screenSizes.sm - 1)) {
                    if ($("body").hasClass('sidebar-collapse')) {
                        $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
                    } else {
                        $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
                    }
                }
                //Handle sidebar push menu for small screens
                else {
                    if ($("body").hasClass('sidebar-open')) {
                        $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
                    } else {
                        $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
                    }
                }
            });

            $(".content-wrapper").click(function () {
                //Enable hide menu when clicking on the content-wrapper on small screens
                if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
                    $("body").removeClass('sidebar-open');
                }
            });

            //Enable expand on hover for sidebar mini
            if ($.EmpatiaLayout.options.sidebarExpandOnHover
                || ($('body').hasClass('fixed')
                && $('body').hasClass('sidebar-mini'))) {
                this.expandOnHover();
            }
        },
        expandOnHover: function () {
            var _this = this;
            var screenWidth = $.EmpatiaLayout.options.screenSizes.sm - 1;
            //Expand sidebar on hover
            $('.main-sidebar').hover(function () {
                if ($('body').hasClass('sidebar-mini')
                    && $("body").hasClass('sidebar-collapse')
                    && $(window).width() > screenWidth) {
                    _this.expand();
                }
            }, function () {
                if ($('body').hasClass('sidebar-mini')
                    && $('body').hasClass('sidebar-expanded-on-hover')
                    && $(window).width() > screenWidth) {
                    _this.collapse();
                }
            });
        },
        expand: function () {
            $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
        },
        collapse: function () {
            if ($('body').hasClass('sidebar-expanded-on-hover')) {
                $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
            }
        }
    };

    /* Tree()
     * ======
     * Converts the sidebar into a multilevel
     * tree view menu.
     *
     * @type Function
     * @Usage: $.EmpatiaLayout.tree('.sidebar')
     */
    $.EmpatiaLayout.tree = function (menu) {
        var _this = this;
        var animationSpeed = $.EmpatiaLayout.options.animationSpeed;
        $(document).on('click', menu + ' li a', function (e) {
            //Get the clicked link and the next element
            var $this = $(this);
            var checkElement = $this.next();

            //Check if the next element is a menu and is visible
            if ((checkElement.is('.treeview-menu')) && (checkElement.is(':visible'))) {
                //Close the menu
                checkElement.slideUp(animationSpeed, function () {
                    checkElement.removeClass('menu-open');
                    //Fix the layout in case the sidebar stretches over the height of the window
                    //_this.layout.fix();
                });
                checkElement.parent("li").removeClass("active");
            }
            //If the menu is not visible
            else if ((checkElement.is('.treeview-menu')) && (!checkElement.is(':visible'))) {
                //Get the parent menu
                var parent = $this.parents('ul').first();
                //Close all open menus within the parent
                var ul = parent.find('ul:visible').slideUp(animationSpeed);
                //Remove the menu-open class from the parent
                ul.removeClass('menu-open');
                //Get the parent li
                var parent_li = $this.parent("li");

                //Open the target menu and add the menu-open class
                checkElement.slideDown(animationSpeed, function () {
                    //Add the class active to the parent li
                    checkElement.addClass('menu-open');
                    parent.find('li.active').removeClass('active');
                    parent_li.addClass('active');
                    //Fix the layout in case the sidebar stretches over the height of the window
                    _this.layout.fix();
                });
            }
            //if this isn't a link, prevent the page from being redirected
            if (checkElement.is('.treeview-menu')) {
                e.preventDefault();
            }
        });
    };

    /* ControlSidebar
     * ==============
     * Adds functionality to the right sidebar
     *
     * @type Object
     * @usage $.EmpatiaLayout.controlSidebar.activate(options)
     */
    $.EmpatiaLayout.controlSidebar = {
        //instantiate the object
        activate: function () {
            //Get the object
            var _this = this;
            //Update options
            var o = $.EmpatiaLayout.options.controlSidebarOptions;
            //Get the sidebar
            var sidebar = $(o.selector);
            //The toggle button
            var btn = $(o.toggleBtnSelector);

            //Listen to the click event
            btn.on('click', function (e) {
                e.preventDefault();
                //If the sidebar is not open
                if (!sidebar.hasClass('control-sidebar-open')
                    && !$('body').hasClass('control-sidebar-open')) {
                    //Open the sidebar
                    _this.open(sidebar, o.slide);
                } else {
                    _this.close(sidebar, o.slide);
                }
            });

            //If the body has a boxed layout, fix the sidebar bg position
            var bg = $(".control-sidebar-bg");
            _this._fix(bg);

            //If the body has a fixed layout, make the control sidebar fixed
            if ($('body').hasClass('fixed')) {
                _this._fixForFixed(sidebar);
            } else {
                //If the content height is less than the sidebar's height, force max height
                if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
                    _this._fixForContent(sidebar);
                }
            }
        },
        //Open the control sidebar
        open: function (sidebar, slide) {
            //Slide over content
            if (slide) {
                sidebar.addClass('control-sidebar-open');
            } else {
                //Push the content by adding the open class to the body instead
                //of the sidebar itself
                $('body').addClass('control-sidebar-open');
            }
        },
        //Close the control sidebar
        close: function (sidebar, slide) {
            if (slide) {
                sidebar.removeClass('control-sidebar-open');
            } else {
                $('body').removeClass('control-sidebar-open');
            }
        },
        _fix: function (sidebar) {
            var _this = this;
            if ($("body").hasClass('layout-boxed')) {
                sidebar.css('position', 'absolute');
                sidebar.height($(".wrapper").height());
                $(window).resize(function () {
                    _this._fix(sidebar);
                });
            } else {
                sidebar.css({
                    'position': 'fixed',
                    'height': 'auto'
                });
            }
        },
        _fixForFixed: function (sidebar) {
            sidebar.css({
                'position': 'fixed',
                'max-height': '100%',
                'overflow': 'auto',
                'padding-bottom': '50px'
            });
        },
        _fixForContent: function (sidebar) {
            $(".content-wrapper, .right-side").css('min-height', sidebar.height());
        }
    };

    /* BoxWidget
     * =========
     * BoxWidget is a plugin to handle collapsing and
     * removing boxes from the screen.
     *
     * @type Object
     * @usage $.EmpatiaLayout.boxWidget.activate()
     *        Set all your options in the main $.EmpatiaLayout.options object
     */
    $.EmpatiaLayout.boxWidget = {
        selectors: $.EmpatiaLayout.options.boxWidgetOptions.boxWidgetSelectors,
        icons: $.EmpatiaLayout.options.boxWidgetOptions.boxWidgetIcons,
        animationSpeed: $.EmpatiaLayout.options.animationSpeed,
        activate: function (_box) {
            var _this = this;
            if (!_box) {
                _box = document; // activate all boxes per default
            }
            //Listen for collapse event triggers
            $(_box).on('click', _this.selectors.collapse, function (e) {
                e.preventDefault();
                _this.collapse($(this));
            });

            //Listen for remove event triggers
            $(_box).on('click', _this.selectors.remove, function (e) {
                e.preventDefault();
                _this.remove($(this));
            });
        },
        collapse: function (element) {
            var _this = this;
            //Find the box parent
            var box = element.parents(".box").first();
            //Find the body and the footer
            var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
            if (!box.hasClass("collapsed-box")) {
                //Convert minus into plus
                element.children(":first")
                    .removeClass(_this.icons.collapse)
                    .addClass(_this.icons.open);
                //Hide the content
                box_content.slideUp(_this.animationSpeed, function () {
                    box.addClass("collapsed-box");
                });
            } else {
                //Convert plus into minus
                element.children(":first")
                    .removeClass(_this.icons.open)
                    .addClass(_this.icons.collapse);
                //Show the content
                box_content.slideDown(_this.animationSpeed, function () {
                    box.removeClass("collapsed-box");
                });
            }
        },
        remove: function (element) {
            //Find the box parent
            var box = element.parents(".box").first();
            box.slideUp(this.animationSpeed);
        }
    };
}

// Set select2 defaults
$( document ).ready(function() {
    $(".select2-default").select2({
        minimumResultsForSearch: Infinity
    });
    $(".select2-searchable").select2();
});
function convertArrayOfObjectsToCSV(args) {
    var result, ctr, keys, columnDelimiter, lineDelimiter, data;

    data = args.data || null;
    if (data == null || !data.length) {
        return null;
    }

    columnDelimiter = args.columnDelimiter || ',';
    lineDelimiter = args.lineDelimiter || '\n';

    keys = Object.keys(data[0]);

    result = '';
    result += keys.join(columnDelimiter);
    result += lineDelimiter;

    data.forEach(function(item) {
        ctr = 0;
        keys.forEach(function(key) {
            if (ctr > 0) result += columnDelimiter;
            result += '"'+item[key]+'"';
            ctr++;
        });
        result += lineDelimiter;
    });

    return result;
}


function downloadCSV(data_array, filename) {
    //Default Values
    filename = typeof(filename) != 'undefined' ? filename : 'data.csv';

    var data, link;

    var csv = convertArrayOfObjectsToCSV({
        data: data_array
    });
    if (csv == null)
        return;

    var blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});

    if (navigator.msSaveBlob)
    { // IE 10+
        navigator.msSaveBlob(blob, filename)
    }
    else
    {
        var link = document.createElement("a");
        if (link.download !== undefined)
        {
            // feature detection, Browsers that support HTML5 download attribute
            var url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style = "visibility:hidden";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
//# sourceMappingURL=private.js.map
